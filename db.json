{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/smackdown/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/smackdown/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/coderwall.png","path":"img/coderwall.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/delicious.png","path":"img/delicious.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/douban.png","path":"img/douban.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/facebook.png","path":"img/facebook.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/github.png","path":"img/github.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/google.png","path":"img/google.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/img-err.png","path":"img/img-err.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/img-loading.png","path":"img/img-loading.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/linkedin.png","path":"img/linkedin.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/mail.png","path":"img/mail.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/pinboard.png","path":"img/pinboard.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/pinterest.png","path":"img/pinterest.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/qq.png","path":"img/qq.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/rss.png","path":"img/rss.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/search.png","path":"img/search.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/twitter.png","path":"img/twitter.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/weibo.png","path":"img/weibo.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/img/zhihu.png","path":"img/zhihu.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/js/Counter.js","path":"js/Counter.js","modified":0,"renderable":1},{"_id":"themes/smackdown/source/js/instagram.js","path":"js/instagram.js","modified":0,"renderable":1},{"_id":"themes/smackdown/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/smackdown/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/smackdown/source/js/mobile.js","path":"js/mobile.js","modified":0,"renderable":1},{"_id":"themes/smackdown/source/js/particles.js","path":"js/particles.js","modified":0,"renderable":1},{"_id":"themes/smackdown/source/js/pc.js","path":"js/pc.js","modified":0,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":0,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"868b644b3ca1492192bbc01ee344ad96da15e2f0","modified":1481521294384},{"_id":"themes/smackdown/.gitignore","hash":"eaa3d84cb77d92a21b111fd1e37f53edc1ff9de0","modified":1480239017133},{"_id":"themes/smackdown/README.md","hash":"58b067379f496aad99bd7ab1b4366fdc846a2711","modified":1480239017133},{"_id":"themes/smackdown/READMEzh.md","hash":"3ab646ee453087063a58e993a7c3928945dd5ceb","modified":1480239017135},{"_id":"themes/smackdown/_config.yml","hash":"971e25b546518c3e6034b25b53ec639597a1bb0f","modified":1483156474704},{"_id":"themes/smackdown/package.json","hash":"0199dfb3d44cf520b67464817d13c44a7766b8d6","modified":1480239017163},{"_id":"source/about/index.md","hash":"570e3f4cfa1adb409ede4305067b6d4012df383d","modified":1483158466830},{"_id":"source/_posts/2016zongjie.md","hash":"a20fdc00de5a19cc40977162487891ec9bdd7a5d","modified":1484036030366},{"_id":"source/_posts/6jicheng.md","hash":"0d24e4d982f404094b4f08455f71642fbb39871c","modified":1481532813535},{"_id":"source/_posts/ES6-promise.md","hash":"f4a71bf2da20c110e5da526716e7bdaf3e483196","modified":1482371255984},{"_id":"source/_posts/Jenkins-CI.md","hash":"f5684ed2531df8c54fd3fb2966fbeaca539de19d","modified":1482386059234},{"_id":"source/_posts/Object.create.md","hash":"524929edad83bd9c2eefd29c4cd8bbbbe906eec2","modified":1482370580480},{"_id":"source/_posts/angualr-19-Karma.md","hash":"1f806adb57f676784c0ee72848382877423dfdc5","modified":1482371255937},{"_id":"source/_posts/aboutme.md","hash":"b978fed40164e2b33949267cefe19bdca2e0cd6a","modified":1481536304752},{"_id":"source/_posts/angular-decorator.md","hash":"ac8bbdbfddd0a83d959c7c505343994a16e7f7c5","modified":1482739309894},{"_id":"source/_posts/angular-fiveservice.md","hash":"8559aa0185632fd0257b360bdade0e92dbf310de","modified":1482739012359},{"_id":"source/_posts/angular-guide1-5章.md","hash":"ad63f4268df822a360d1027c70767fe273afb270","modified":1482728442778},{"_id":"source/_posts/angular-guide16-xhr实践.md","hash":"5b11865af84c6d96dd6dce89a1af4315e2e2bcfb","modified":1482371255969},{"_id":"source/_posts/angular-guide17-angular中的promise.md","hash":"b62c2419ea1e04ac942247e9bad0456b64ce4a8d","modified":1482477767666},{"_id":"source/_posts/angular-guide6-7.md","hash":"069a6c0c247873d93cf6d07081a07b23c1e3e6f0","modified":1482729130203},{"_id":"source/_posts/angular-guide8-9章.md","hash":"3625dcb5e84104deff66bd9e46b73989b2ae71ae","modified":1482729429898},{"_id":"source/_posts/angular-html5.md","hash":"308b759b81234cab8e9c7c8837515fb25e51971d","modified":1481608179799},{"_id":"source/_posts/angular-promise-two.md","hash":"7b30f75641d2975f78504b22a137143c423541c6","modified":1482480116379},{"_id":"source/_posts/angular-q-promise-http.md","hash":"9a6df0d73b4f29688a7f20f4695baebbe3543424","modified":1482481359187},{"_id":"source/_posts/angular-router.md","hash":"0683891ebf469ff05b468edf1209676941b6889a","modified":1481871626934},{"_id":"source/_posts/angular-study.md","hash":"efa1c949306696fabc14968f2d796f72d735ac4d","modified":1481611135644},{"_id":"source/_posts/angular-ui-router.md","hash":"d098fd9ffe008002b5aa33886931d6b6f0778286","modified":1482371255937},{"_id":"source/_posts/arraydeapply.md","hash":"3ffc01e9f08eb958d5293a5270d34b22465544f9","modified":1481621222705},{"_id":"source/_posts/biantaiti.md","hash":"8d3467bba85b83524e3636e7e0cdbc78f99fcd37","modified":1481553231779},{"_id":"source/_posts/blockchain.md","hash":"600d484d4895e56b24af0c973d20f1694a6bb160","modified":1482390460531},{"_id":"source/_posts/bubaoyuan.md","hash":"d5323b1ebddea24e993c58c0cb177e15ed15fe33","modified":1484036606850},{"_id":"source/_posts/cross-app.md","hash":"565efbdd71d7bf7502fb60b7f88de151dc0740eb","modified":1481611562563},{"_id":"source/_posts/curryfunction.md","hash":"e4511bf49ad3f66ed5be74892b1817673f3563f7","modified":1483421061042},{"_id":"source/_posts/dajianjiaoshoujia.md","hash":"ba4c1e702ba4b0ec99b507b4b40dd552dd92836e","modified":1481727532856},{"_id":"source/_posts/data-compare.md","hash":"6f9f34277740cf0c7f94302a3d1c700a9afaf941","modified":1481526835848},{"_id":"source/_posts/debugwechat.md","hash":"d75db063f86103c2f821d496f495bd0599806e30","modified":1484041862447},{"_id":"source/_posts/defined-filter.md","hash":"edcb1511d5a0cab15dd4f2b468ff4a4e4708b3f3","modified":1482740644216},{"_id":"source/_posts/docker.md","hash":"fb15bc355ac0821efe553a4bc599362e661bf525","modified":1481533474810},{"_id":"source/_posts/document-domain.md","hash":"4d27e0749cc5acbf81d511e9286bb12a82b30a25","modified":1481595510068},{"_id":"source/_posts/filternull.md","hash":"a10ee9873cf2e54eac0c25afb762e2d983a077f2","modified":1483584008508},{"_id":"source/_posts/gaojiefunction.md","hash":"2ed398c5a362be310f47ba172c0c2840ebf4cee5","modified":1483422526490},{"_id":"source/_posts/gitsinglefile.md","hash":"a104d3760bd9f02150cdefb37a869dbe323f69d5","modified":1481527432023},{"_id":"source/_posts/guanchazhemoshi.md","hash":"c74c8d2a4b6cea3cdab4288ca81c06a65efec2c9","modified":1482371255984},{"_id":"source/_posts/h5api-router.md","hash":"8397d56cfd827e3770f200139573d4927b27955e","modified":1481872361636},{"_id":"source/_posts/h5bug.md","hash":"37d569790bda003b423445a6b9fe14fa7e02c6e2","modified":1482396519780},{"_id":"source/_posts/iframe-video.md","hash":"453661c15a92602bedb14a5d24c0f46757ba1d6b","modified":1483082915579},{"_id":"source/_posts/iscroll.md","hash":"f13ccb6afd809edf25516a3a73da64fe67ca66ee","modified":1481533474839},{"_id":"source/_posts/jigou.md","hash":"a6fda28ccff9e24b06c35fdbd3820478fe215006","modified":1481533474823},{"_id":"source/_posts/jquery-gaoxiao.md","hash":"17f446ffc9fe3c2a4428d4ef23b150ca9faa1944","modified":1483082134269},{"_id":"source/_posts/js-modules-compare.md","hash":"7ac3dbeb0305fe0d5552318441ef7aac2fdacb5a","modified":1481619413838},{"_id":"source/_posts/js-seajs.md","hash":"fabafca5aee850e72c5e0e19cb91e6925be66212","modified":1481528312721},{"_id":"source/_posts/life-yinian.md","hash":"9d176138d391dd17d759f1efc278de0781ffa8a4","modified":1481727786365},{"_id":"source/_posts/mvp.md","hash":"0855b72301f6e855e627eca44b85afd495c11587","modified":1484036458824},{"_id":"source/_posts/node-debug.md","hash":"72ef85fba8646c89b725ac9d4ecc25f473c4abd7","modified":1483585445360},{"_id":"source/_posts/node-tips.md","hash":"99391fc87d2b0674a0d8892f95c5009f5318189a","modified":1482371255953},{"_id":"source/_posts/nodekeng.md","hash":"a479acf0e277b8056963a319ccc62d16c0388cc9","modified":1481532285640},{"_id":"source/_posts/postMessage.md","hash":"2226a65dfcad3b4cfa7da34d0eebea79116efea2","modified":1484036846592},{"_id":"source/_posts/object-oriented-js.md","hash":"21bc99896265356319f5cc0afb94442fa25e86f3","modified":1482370580496},{"_id":"source/_posts/pure-function.md","hash":"2479072b2f3d48102d269387c69b3519ff743b34","modified":1484036255310},{"_id":"source/_posts/qianhouduanfenli.md","hash":"c064e66319032f0092ab82806e88909fc7d6fe82","modified":1481552486469},{"_id":"source/_posts/rap-loverujia.md","hash":"5c25169856aee5b5b31207e9c572101a52c86964","modified":1483089451356},{"_id":"source/_posts/rap-strong.md","hash":"5cd1e8cf4e10e053ad7a7bee3d50886fb67ef04e","modified":1483157164811},{"_id":"source/_posts/raps.md","hash":"f7297139be33df7a205ccc2dd1d7011f492ff262","modified":1483152656835},{"_id":"source/_posts/react-ant-design.md","hash":"64ba4b591b58755b70769857d6cb7b6daf3f6483","modified":1482387959501},{"_id":"source/_posts/react1.md","hash":"e44a6a306a7cd8a98d278c88e274432edbbeb8d4","modified":1483264813278},{"_id":"source/_posts/shejimoshi.md","hash":"e168429c00a0aa0210330f1529d412ef0d35aafc","modified":1481535816437},{"_id":"source/_posts/test-makrdown.md","hash":"c575fd2303cf86b99fedf12e805de542613120d7","modified":1482733481768},{"_id":"source/_posts/thanks-real.md","hash":"fa738453997a5eb544b7a0f4fab67c924e878b0d","modified":1483265160763},{"_id":"source/_posts/web-resource.md","hash":"514835ebfec1b06baba12af8c0e707f857493538","modified":1481614682078},{"_id":"source/_posts/web-xingnengyouhua.md","hash":"bae1e222e697a8795efbacec0ac84ff581eb9315","modified":1482377201869},{"_id":"source/_posts/wechat1-1.md","hash":"8d99aba4c7bb935312df612e819ec6ec561cb6ad","modified":1484037431219},{"_id":"source/_posts/wechat1-2.md","hash":"edda9ce55ffb7908c2552c63c65e5b78ff37a465","modified":1484037748070},{"_id":"source/_posts/wechat1-4.md","hash":"5cf483002c8b16c778e5a543254ecfe10b517be2","modified":1484038831309},{"_id":"source/_posts/wechat1-5.md","hash":"0acc2e9e1915cc8c8e83b9c35cfdfd7d035ab244","modified":1484039173471},{"_id":"source/_posts/wechat1-6.md","hash":"f0b78f05f483a591fac6177bb2a761057e78756d","modified":1484039736351},{"_id":"source/_posts/win10-ubuntu.md","hash":"bed55b1eb03fe06f0ffbf7f892117d6527a8ba1b","modified":1481855608666},{"_id":"source/_posts/window-back-disabled.md","hash":"b0183438bde3cd28b841e8a80b68b4596ae90c3b","modified":1481860459790},{"_id":"source/_posts/zaqiluanba.md","hash":"3535e012db0d705c661a09b0152f160873047183","modified":1483415445719},{"_id":"source/_posts/zhaoji-life.md","hash":"ba59ddca3db4ac0928d505ce923dec2902ce94dc","modified":1482801990050},{"_id":"source/_posts/wumai.md","hash":"5080ac975d902d50525b1d9d073dc0eae2a72c77","modified":1482457725061},{"_id":"themes/smackdown/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1480239017112},{"_id":"themes/smackdown/.git/config","hash":"28555d95e1c8c56476ae8e8a83f682272fa72c07","modified":1480239017121},{"_id":"themes/smackdown/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1480239013148},{"_id":"themes/smackdown/.git/index","hash":"30a9838e4fc9e906ea21d1d931835e00433f214c","modified":1480239017230},{"_id":"themes/smackdown/.git/packed-refs","hash":"a64284ecdfab00f039ec81e4178259522fd0e22a","modified":1480239017102},{"_id":"themes/smackdown/layout/.DS_Store","hash":"693e513b44d5241ea897cc90cc71aeba091283b9","modified":1480239017136},{"_id":"themes/smackdown/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1480239017157},{"_id":"themes/smackdown/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1480239017158},{"_id":"themes/smackdown/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1480239017159},{"_id":"themes/smackdown/layout/layout.ejs","hash":"acbcab84260ffe7168b898ccc86dab99da2e44cb","modified":1480239017160},{"_id":"themes/smackdown/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1480239017161},{"_id":"themes/smackdown/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1480239017162},{"_id":"themes/smackdown/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1480239017162},{"_id":"themes/smackdown/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1480239013152},{"_id":"themes/smackdown/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1480239013151},{"_id":"themes/smackdown/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1480239013149},{"_id":"themes/smackdown/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1480239013153},{"_id":"themes/smackdown/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1480239013154},{"_id":"themes/smackdown/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1480239013154},{"_id":"themes/smackdown/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1480239013155},{"_id":"themes/smackdown/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1480239013156},{"_id":"themes/smackdown/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1480239013156},{"_id":"themes/smackdown/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1480239013158},{"_id":"themes/smackdown/.git/logs/HEAD","hash":"67c0cb3129ac4c72da4a7bfe761ecce9c21e6841","modified":1480239017117},{"_id":"themes/smackdown/layout/_partial/.DS_Store","hash":"e32979f5a18bff84e197c13b48f4c54e03796e4a","modified":1480239017138},{"_id":"themes/smackdown/layout/_partial/archive-post.ejs","hash":"5ad682a62264a8b35dc621f00aa123984d6f1cf2","modified":1480239017140},{"_id":"themes/smackdown/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1480239017141},{"_id":"themes/smackdown/layout/_partial/article.ejs","hash":"c9f6c3609608f78d43546bdf66506692febe36fe","modified":1480239017142},{"_id":"themes/smackdown/layout/_partial/baidu_tongji.ejs","hash":"df67dae10b3d5390ca5ff329bf36ff60082bf664","modified":1480239017143},{"_id":"themes/smackdown/layout/_partial/footer.ejs","hash":"130258cdd52da5acee226c34cc1174fede3585b8","modified":1482732944705},{"_id":"themes/smackdown/layout/_partial/google_analytics.ejs","hash":"0bd77fcbe30c5bc323222c1cfee592300abfd42f","modified":1480239017144},{"_id":"themes/smackdown/layout/_partial/head.ejs","hash":"bcfa5b67ca4f02f40e9ca898a3d2e85f5fa1a523","modified":1480239017145},{"_id":"themes/smackdown/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1480239017146},{"_id":"themes/smackdown/layout/_partial/left-col.ejs","hash":"a01a4f9d738236a5340926e4c33cd333e34d548a","modified":1480239017147},{"_id":"themes/smackdown/layout/_partial/mathjax.ejs","hash":"09f982c283160324de40cc6ae4267b2075edeed1","modified":1480239017147},{"_id":"themes/smackdown/layout/_partial/mobile-nav.ejs","hash":"998e065e0ea49852281684fa6e2629780053abec","modified":1480239017148},{"_id":"themes/smackdown/layout/_partial/after-footer.ejs","hash":"15bcb523e600f55e8f6cc288cac1e043c8c2ba02","modified":1480239017139},{"_id":"themes/smackdown/layout/_partial/search.ejs","hash":"6250423092d8c69d63e14d390fb3df30c6f77f1c","modified":1480239017156},{"_id":"themes/smackdown/layout/_widget/Counter.ejs","hash":"472ca8ac00a7143904689b6ce9ea6defd03f0cfc","modified":1480239017157},{"_id":"themes/smackdown/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1480239017166},{"_id":"themes/smackdown/source/css/.DS_Store","hash":"fc5a428fe40854a0ba66b4cea196c6700a57cae7","modified":1480239017165},{"_id":"themes/smackdown/source/css/_variables.styl","hash":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1480239017181},{"_id":"themes/smackdown/source/css/style.styl","hash":"860a75a024d261f2fb8349dc0dfe01a6b2f6bfa7","modified":1480239017190},{"_id":"themes/smackdown/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1480239017191},{"_id":"themes/smackdown/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1480239017192},{"_id":"themes/smackdown/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1480239017194},{"_id":"themes/smackdown/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1480239017193},{"_id":"themes/smackdown/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1480239017195},{"_id":"themes/smackdown/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1480239017195},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.css","hash":"96138eaddfbd305160ddcb98a5f08555ca6cb4ee","modified":1480239017202},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.js","hash":"004bb0812414554ab48067792f09e978603253b6","modified":1480239017204},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1480239017205},{"_id":"themes/smackdown/source/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1480239017206},{"_id":"themes/smackdown/source/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1480239017207},{"_id":"themes/smackdown/source/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1480239017208},{"_id":"themes/smackdown/source/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1480239017209},{"_id":"themes/smackdown/source/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1480239017210},{"_id":"themes/smackdown/source/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1480239017210},{"_id":"themes/smackdown/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1480239017211},{"_id":"themes/smackdown/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1480239017212},{"_id":"themes/smackdown/source/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1480239017213},{"_id":"themes/smackdown/source/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1480239017214},{"_id":"themes/smackdown/source/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1480239017214},{"_id":"themes/smackdown/source/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1480239017215},{"_id":"themes/smackdown/source/img/qq.png","hash":"93e6e87ec8cef56573a08c8f8fbb0bb53313354a","modified":1480239017216},{"_id":"themes/smackdown/source/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1480239017217},{"_id":"themes/smackdown/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1480239017218},{"_id":"themes/smackdown/source/img/search.png","hash":"1ab76b03297ae2ce61ec59dd9bf8727f1fbbcedd","modified":1480239017218},{"_id":"themes/smackdown/source/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1480239017219},{"_id":"themes/smackdown/source/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1480239017220},{"_id":"themes/smackdown/source/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1480239017221},{"_id":"themes/smackdown/source/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1480239017222},{"_id":"themes/smackdown/source/js/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1480239017223},{"_id":"themes/smackdown/source/js/Counter.js","hash":"ef766189974c8a6bdd5de586e8bd7daf304f617d","modified":1480239017224},{"_id":"themes/smackdown/source/js/instagram.js","hash":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1480239017225},{"_id":"themes/smackdown/source/js/jquery.lazyload.js","hash":"9c34c37b4dca82386648d364da913153d1db902e","modified":1480239017226},{"_id":"themes/smackdown/source/js/main.js","hash":"ea1f1ebb19ba56a005cfcf91be1475c9be388a7d","modified":1480239017226},{"_id":"themes/smackdown/source/js/mobile.js","hash":"387c047e661f04fbb5f5bfc4b2db617023e836ce","modified":1480239017227},{"_id":"themes/smackdown/source/js/particles.js","hash":"4ea9bd5501eeb6ee79ed57b3608423cfbc399338","modified":1480239017228},{"_id":"themes/smackdown/source/js/pc.js","hash":"a5397d34a04084ee089b4b1e26457ab46ecea63e","modified":1480239017229},{"_id":"themes/smackdown/.git/objects/pack/pack-e2afc97877bffa7bda4c7fd8c436ee4a872b8fc2.idx","hash":"a25956a31e32cf5dd182fab15e924c760a3abf86","modified":1480239017026},{"_id":"themes/smackdown/.git/refs/heads/master","hash":"e25905b554595fb667d75bed9da0201336e5ed58","modified":1480239017115},{"_id":"themes/smackdown/layout/_partial/post/category.ejs","hash":"27fab3e6ccc41c075dc4c5ba3ca9e7f3b6247945","modified":1480239017149},{"_id":"themes/smackdown/layout/_partial/post/date.ejs","hash":"06d8914b5aef73b5ec2cabb0105e275ff821b321","modified":1480239017150},{"_id":"themes/smackdown/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1480239017151},{"_id":"themes/smackdown/layout/_partial/post/nav.ejs","hash":"e1fd94b1e4655b20018be6c90fa1f9c523274a50","modified":1480239017152},{"_id":"themes/smackdown/layout/_partial/post/tag.ejs","hash":"acf1b9d79ccec172881f9f0080e96667f4178885","modified":1480239017153},{"_id":"themes/smackdown/layout/_partial/post/share.ejs","hash":"e032a0417c931de2a626cd06c797206a823014a6","modified":1480239017152},{"_id":"themes/smackdown/layout/_partial/post/title.ejs","hash":"8fc5f697aed67921327caa275e2787122845f2b7","modified":1480239017154},{"_id":"themes/smackdown/layout/_partial/post/viewCounter.ejs","hash":"f23d808e13dfcd1d637c07cc02dc8cf9d371192c","modified":1480239017155},{"_id":"themes/smackdown/source/css/_partial/archive.styl","hash":"7c164321fd2b5bc7e81f758076e4d7d353ea81f2","modified":1480239017167},{"_id":"themes/smackdown/source/css/_partial/article.styl","hash":"759f4fd37694ce421a5822fc8aa1c52ff222eeb9","modified":1480239017168},{"_id":"themes/smackdown/source/css/_partial/footer.styl","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1480239017169},{"_id":"themes/smackdown/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1480239017170},{"_id":"themes/smackdown/source/css/_partial/instagram.styl","hash":"8a7b07bf5ea2d3588c0019f722c245bb1a8696af","modified":1480239017172},{"_id":"themes/smackdown/source/css/_partial/highlight.styl","hash":"8987b455f11a141d8507d722ad48241add1b0bf0","modified":1480239017171},{"_id":"themes/smackdown/source/css/_partial/main.styl","hash":"e3b55e7af02fe96629e549e921771c6cd8e6ce2c","modified":1480239017172},{"_id":"themes/smackdown/source/css/_partial/mobile-slider.styl","hash":"e19c7fae6968ad3ea6cfc110900a991f9b5fce31","modified":1480239017173},{"_id":"themes/smackdown/source/css/_partial/mobile.styl","hash":"931f3abd229e84b04d66169299fbb086cfc63acf","modified":1480239017174},{"_id":"themes/smackdown/source/css/_partial/page.styl","hash":"720b5b169bc28ccba3794efce9b7cd39f243dec7","modified":1480239017175},{"_id":"themes/smackdown/source/css/_partial/scroll.styl","hash":"5539a38f9acd603d453a0ea0d8ce10893cf83d22","modified":1480239017175},{"_id":"themes/smackdown/source/css/_partial/share.styl","hash":"22697b9a9877ab9f018364feb57aeea4a8313c9a","modified":1480239017176},{"_id":"themes/smackdown/source/css/_partial/tagcloud.styl","hash":"255e1ce6480050b5901ee69a2ac1178241f06d2c","modified":1480239017177},{"_id":"themes/smackdown/source/css/_partial/wheelmenu.styl","hash":"9e57421eab562ea13d0ed2b2e1415eee79fa23d0","modified":1480239017178},{"_id":"themes/smackdown/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1480239017179},{"_id":"themes/smackdown/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1480239017180},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.eot","hash":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1480239017184},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.svgz","hash":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1480239017186},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.ttf","hash":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1480239017188},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.woff","hash":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1480239017189},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1480239017198},{"_id":"themes/smackdown/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1480239017197},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1480239017199},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1480239017200},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1480239017201},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1480239017201},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.svg","hash":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1480239017185},{"_id":"themes/smackdown/.git/logs/refs/heads/master","hash":"67c0cb3129ac4c72da4a7bfe761ecce9c21e6841","modified":1480239017116},{"_id":"themes/smackdown/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1480239017105},{"_id":"themes/smackdown/.git/logs/refs/remotes/origin/HEAD","hash":"67c0cb3129ac4c72da4a7bfe761ecce9c21e6841","modified":1480239017111},{"_id":"themes/smackdown/.git/objects/pack/pack-e2afc97877bffa7bda4c7fd8c436ee4a872b8fc2.pack","hash":"346d7bf4c16d81bac1fb08236741958e0bc47885","modified":1480239017031},{"_id":"public/about/index.html","hash":"55ceb91b76feb3a1631113e904b42961d510c825","modified":1488275561184},{"_id":"public/2016/12/31/thanks-real/index.html","hash":"0138c4e50698f939392c7a275499a17c637b99b0","modified":1488275562703},{"_id":"public/2016/12/16/mvp/index.html","hash":"396e5302bbcaab639c91265608f670b3605a3f0e","modified":1488275562775},{"_id":"public/2016/12/12/angular-html5/index.html","hash":"5d555aff3f6680eac8fb6037e74cbd7c17aafccb","modified":1488275562776},{"_id":"public/2016/12/10/data-compare/index.html","hash":"241322718945f4ee3f219fe329950196b4fe39fa","modified":1488275562776},{"_id":"public/2016/12/04/docker/index.html","hash":"570ea4a4ea5ab467a0832b9e0acdbda00d0b9fbd","modified":1488275562761},{"_id":"public/2016/11/10/react-ant-design/index.html","hash":"855ef70f162726e27176aca95fe0aa15e7a98f43","modified":1488275562777},{"_id":"public/2016/09/30/iframe-video/index.html","hash":"034ed855776aec3796fa6a1c04f58ca67929adfe","modified":1488275562777},{"_id":"public/2016/08/15/node-tips/index.html","hash":"411ac2d7d9aa3426475d77cf2afb05e9e4d566a5","modified":1488275562777},{"_id":"public/2015/12/26/rap-loverujia/index.html","hash":"8dc521897d3d9c4137f6781d6728077cbad368ae","modified":1488275562765},{"_id":"public/2015/10/25/aboutme/index.html","hash":"eba699bb4bdefa51bc7bf83910162d3ba884ad33","modified":1488275562765},{"_id":"public/archives/page/8/index.html","hash":"070712db783b5c39281352bfe0efcec881812ed0","modified":1488275562782},{"_id":"public/archives/2014/index.html","hash":"b590f38e1e40ea420d024757cedbe4e36946b758","modified":1488275562766},{"_id":"public/archives/2014/12/index.html","hash":"bfe052cd8972a4fa8df9dd4cb1c278800e42c378","modified":1488275562766},{"_id":"public/archives/2015/page/2/index.html","hash":"3d5d1a147c6f8bd245f04b34472fb662e4b7553c","modified":1488275562782},{"_id":"public/archives/2015/02/index.html","hash":"7685bc29e2f778ba15f59087460cd8f4d47da67f","modified":1488275562767},{"_id":"public/archives/2015/03/index.html","hash":"2536654746d7ac8bd78ef6de5b5a1872386e93c9","modified":1488275562767},{"_id":"public/archives/2015/06/index.html","hash":"d67b9200e6201815877c06f3b4e746875d371c3d","modified":1488275562767},{"_id":"public/archives/2015/10/index.html","hash":"97c28fe48a2ba3cb310b1ab4c8806f942c13ce64","modified":1488275562767},{"_id":"public/archives/2015/11/index.html","hash":"bab6b55c10518853a82f01765a394f5938034612","modified":1488275562767},{"_id":"public/archives/2016/01/index.html","hash":"4c142dc9a3685078955c0eea45ab11c874269de7","modified":1488275562783},{"_id":"public/archives/2016/02/index.html","hash":"5a18a2827e815a656533866245c9f10e2d84e9e0","modified":1488275562767},{"_id":"public/archives/2016/03/index.html","hash":"d0526d00cbefdd218f9e36c5e2bf3ef826ff6a12","modified":1488275562767},{"_id":"public/archives/2016/05/index.html","hash":"e48dde7104c1a3d5627ef5ca5dc8125e3fdb282d","modified":1488275562783},{"_id":"public/archives/2016/06/index.html","hash":"d384be28e5bce922095e01393988d3902f683946","modified":1488275562783},{"_id":"public/archives/2016/07/index.html","hash":"6816895dfab94fabdb1fc4caeb66c09b929c3a32","modified":1488275562783},{"_id":"public/archives/2016/08/index.html","hash":"3f954da0d04718b3d3215f4cdd77b4d9373521d4","modified":1488275562783},{"_id":"public/archives/2016/09/index.html","hash":"fcf659d4913f7abed4409f4a0cb2472e8733ba3b","modified":1488275562767},{"_id":"public/archives/2016/10/index.html","hash":"b5f9a84112125c4f3c08715c58c92267ab9e07cb","modified":1488275562783},{"_id":"public/archives/2016/11/index.html","hash":"9f5bae39510e7159efe4db234e9786e9277e255b","modified":1488275562783},{"_id":"public/tags/生活/index.html","hash":"26b08a30709bfae633bc78eeed3e94536e95558d","modified":1488275562784},{"_id":"public/tags/js继承/index.html","hash":"19477b7d8dc1f2fb46c8c0e105b4abd785e64ec5","modified":1488275562767},{"_id":"public/tags/ES6、promise/index.html","hash":"eb6df2da37b012975fa238234a42b45a7635162c","modified":1488275562767},{"_id":"public/tags/es5-js/index.html","hash":"2d8ceee0fb542afd69490fa922530bdbc75f8433","modified":1488275562767},{"_id":"public/tags/Jenkins-CI/index.html","hash":"3242a14c8bdea08bea5f26c9ed353075b2c51ab9","modified":1488275562767},{"_id":"public/tags/angular、Karma/index.html","hash":"9c5f9f195a65b281237757767d46ee036b8f994f","modified":1488275562768},{"_id":"public/tags/angular-decorator/index.html","hash":"37ed0b14d6af91145f15142aff23c996c9b655fc","modified":1488275562767},{"_id":"public/tags/angular-服务/index.html","hash":"e26f2196b7f109b01c6535ed9ef2683f9db8c817","modified":1488275562767},{"_id":"public/tags/angular、module、controller/index.html","hash":"2397f19024841d9838174839402c21e2ffc000e7","modified":1488275562767},{"_id":"public/tags/angular、-http/index.html","hash":"27c82eab80a8adef70eb66ed04a7c4877e58a7f5","modified":1488275562767},{"_id":"public/tags/angular、promise、-q、deferred/index.html","hash":"874ad1217973570c846a7cc5c1b14e8f60f62d18","modified":1488275562770},{"_id":"public/tags/angular、表达式、filter/index.html","hash":"8c02b644d83681f441bcf6d9e68ee589243e657f","modified":1488275562768},{"_id":"public/tags/angular、directive/index.html","hash":"cfefa3f33811989db82128eabe81aeeb8ffe333b","modified":1488275562770},{"_id":"public/tags/angular、html5/index.html","hash":"6e97647a169db9eb56e6e3e803d2c22603381493","modified":1488275562770},{"_id":"public/tags/angular-q-promise/index.html","hash":"1f86107df31930d0c1927b850619e165b2fd0e04","modified":1488275562770},{"_id":"public/tags/angular-http-q-promise/index.html","hash":"a9c0fc31e6c72cd01f818fe77f60dcc7e5e901ee","modified":1488275562770},{"_id":"public/tags/angular、router/index.html","hash":"c39349fdf935a7aee77aac3c4a348065691ad90f","modified":1488275562770},{"_id":"public/tags/angular/index.html","hash":"3ad34022f89bfd05a01c4da0423e447dc1e719bc","modified":1488275562770},{"_id":"public/tags/angular、ui-router/index.html","hash":"fccb7c9de362bf950ef01adb7785dad2514c5ff0","modified":1488275562770},{"_id":"public/tags/js-Array/index.html","hash":"15ebb3624e4a87920435a3534b978a535c1f784f","modified":1488275562771},{"_id":"public/tags/js、变态题/index.html","hash":"28e3b8f035e269948e74bad7216bba8a48633578","modified":1488275562771},{"_id":"public/tags/blockchain/index.html","hash":"24a82075976ade3015fb3068edfbdde0bb8ff554","modified":1488275562771},{"_id":"public/tags/app-跨平台/index.html","hash":"deda77a2a75750625f4b173b140e8c41209c7c1e","modified":1488275562771},{"_id":"public/tags/js-柯里化/index.html","hash":"59311ca6b791042965e70c61c411566f9237754b","modified":1488275562771},{"_id":"public/tags/前端脚手架/index.html","hash":"ef25ced5e5461775d02a844adfe8221a363874ff","modified":1488275562771},{"_id":"public/tags/mongoDB-数据库/index.html","hash":"320294dcfa54baf350a8ce38e260fe8c7c731343","modified":1488275562771},{"_id":"public/tags/angular-filter/index.html","hash":"6cdf555524414cf619623aaccc6b1e604685ae47","modified":1488275562771},{"_id":"public/tags/js、跨域、document-domain/index.html","hash":"108f146345287a414224c591428428a486600596","modified":1488275562771},{"_id":"public/tags/js-Higher-order-function/index.html","hash":"f4acfb485bc4349fb26a75117d67a81ba8268291","modified":1488275562771},{"_id":"public/tags/git-github/index.html","hash":"61d0af634b9235d1161e0bfa730ab24bcc84a09d","modified":1488275562771},{"_id":"public/tags/angularjs/index.html","hash":"66b9ca378bf84d8dfc83b5212253290158b5a8f3","modified":1488275562771},{"_id":"public/tags/路由-html5/index.html","hash":"ee1eecd72b13b4368c1bcbf01304d1e33462a6e3","modified":1488275562771},{"_id":"public/tags/js、设计模式/index.html","hash":"6761cff640302be0bf16ee1d1b373a5591f69d91","modified":1488275562771},{"_id":"public/tags/H5、bug/index.html","hash":"38596acc3cf7bb5d160f1f43a1acb43430f1320c","modified":1488275562772},{"_id":"public/tags/iframe/index.html","hash":"ce3252f50ae660388b6dd2d602c3eeede6031a5f","modified":1488275562772},{"_id":"public/tags/移动端、fixed/index.html","hash":"64888998cf73fac944e761ecc48b158005e31361","modified":1488275562771},{"_id":"public/tags/解构赋值-es6/index.html","hash":"18b7e3a867af73ea78650b63f67c24d4f8a53760","modified":1488275562771},{"_id":"public/tags/jquery/index.html","hash":"c4091a0525e90d7c9ad40fa54a84aae9ed5a1078","modified":1488275562772},{"_id":"public/tags/js模块化、AMD、CMD、CommonJs/index.html","hash":"985623ba570bf4399860bec77e91976728ebb191","modified":1488275562772},{"_id":"public/tags/js-sea-js-模块化/index.html","hash":"caaf8cb0baef9d8dbff94dc9e6ebde66670889fb","modified":1488275562772},{"_id":"public/tags/life、意念/index.html","hash":"7d077017ad38fa144ebaedb49b07cc0dc419bb0a","modified":1488275562772},{"_id":"public/tags/mvp/index.html","hash":"b51dfa14be95438bb9559c6914c5eccfd844f8f5","modified":1488275562772},{"_id":"public/tags/node-debug/index.html","hash":"cee0ab2b01d571ffc33c3520b8f9895964e37171","modified":1488275562772},{"_id":"public/tags/node/index.html","hash":"2db4dcf576f8ba01fc639674bb60ff26a8871b67","modified":1488275562772},{"_id":"public/tags/跨域、postMessage、html5/index.html","hash":"160c0f98df817f8b0ad2665ff4d09ebec123a280","modified":1488275562772},{"_id":"public/tags/javascript、object-oriented、继承/index.html","hash":"4da014a8213e9303b4b6c81f4da4b4a849528e16","modified":1488275562772},{"_id":"public/tags/js-纯函数/index.html","hash":"1b1a4df4249ac9fef4fda784ad0b46d34afd3b46","modified":1488275562772},{"_id":"public/tags/前后端分享/index.html","hash":"5d3b8b8780560d1b923a5a5e5da162ae2714f4b1","modified":1488275562772},{"_id":"public/tags/rap/index.html","hash":"bdfa5218bb11d76f11b0251daf20efc7c6fd8aef","modified":1488275562784},{"_id":"public/tags/react-ant-design/index.html","hash":"1f68f997698a589c4462b2dccf1b4b4aabb5011d","modified":1488275562772},{"_id":"public/tags/react/index.html","hash":"bd519c13db29056cf72fd06a5acb731e952bd00f","modified":1488275562772},{"_id":"public/tags/JS设计模式-设计模式/index.html","hash":"0c6603a26948047e0631a68d0fd90076b765cb59","modified":1488275562772},{"_id":"public/tags/markdown/index.html","hash":"f401c312fc2175c22fafa606afda6e6644e0da44","modified":1488275562772},{"_id":"public/tags/web、前端/index.html","hash":"1fef57a285c33d0d42c7ec2ba40b7b90e44c6c2d","modified":1488275562772},{"_id":"public/tags/web、性能优化/index.html","hash":"278290b3df36861aeddceb6ab075d855e305348d","modified":1488275562772},{"_id":"public/tags/node-wechat/index.html","hash":"96d0837440a57a903e211948de5c2461b292c98e","modified":1488275562784},{"_id":"public/tags/win10、linux/index.html","hash":"d23d10bd3f7f71991f6899d84d530fdec66a9bfa","modified":1488275562773},{"_id":"public/tags/window-history-html5/index.html","hash":"5a89fde6f36c5d5198f6b73b8701bf1d9af2150a","modified":1488275562773},{"_id":"public/tags/人生/index.html","hash":"8f4f93aeb9d41a0992f0281e02c6714b7c3c7ace","modified":1488275562773},{"_id":"public/2017/01/10/wechat1-6/index.html","hash":"d31b46a8928ef885a5015047e18d42988aa2a92c","modified":1488275562584},{"_id":"public/2017/01/10/wechat1-5/index.html","hash":"3037c8dfba176ea7f86d135419e756468637cffb","modified":1488275562584},{"_id":"public/2017/01/10/wechat1-4/index.html","hash":"ae78c7edd1d8bd57466a7596ad8c61b0ee48b8e3","modified":1488275562584},{"_id":"public/2017/01/10/wechat1-2/index.html","hash":"5cc84766e08b0ece5eed7eeedb0c31655817314b","modified":1488275562584},{"_id":"public/2017/01/10/wechat1-1/index.html","hash":"db07f9054f9a00ba86cbc2b7760ef8004a986c0b","modified":1488275562584},{"_id":"public/2017/01/05/node-debug/index.html","hash":"e447c195427b541ba5b0d7a5b89869b45b206ed0","modified":1488275562584},{"_id":"public/2017/01/03/gaojiefunction/index.html","hash":"bfcd2f31b7fc0f1ee35de0f3479b65fe3be8ef26","modified":1488275562584},{"_id":"public/2017/01/03/curryfunction/index.html","hash":"32b271b5b2baff940d412ad2643049e7d322c03d","modified":1488275562584},{"_id":"public/2017/01/03/pure-function/index.html","hash":"8644a8a178b83ce8cf95d7fce808404dc4d40cde","modified":1488275562584},{"_id":"public/2016/12/31/2016zongjie/index.html","hash":"d863f4df52573ab65d37aafbac1b07064b970a94","modified":1488275562774},{"_id":"public/2016/12/22/wumai/index.html","hash":"bac30cf83ce8b401ba0948794c70837d855dbbf5","modified":1488275562774},{"_id":"public/2016/12/16/angular-router/index.html","hash":"e99ff3463b35c7d00447b04a690561cb1a3e071a","modified":1488275562775},{"_id":"public/2016/12/16/win10-ubuntu/index.html","hash":"b4c08bdb5982abf6a7e458e5b79029fadea40cab","modified":1488275562775},{"_id":"public/2016/12/16/bubaoyuan/index.html","hash":"d6a824fd2c6a1c0f97f931e5c008e3d1467255f4","modified":1488275562775},{"_id":"public/2016/12/13/js-modules-compare/index.html","hash":"b64e1160dd796df5f6dbd71d243b6db27210ac8d","modified":1488275562775},{"_id":"public/2016/12/13/cross-app/index.html","hash":"01b82a475e403ffedca4900984be9c999fe4e65b","modified":1488275562775},{"_id":"public/2016/12/13/postMessage/index.html","hash":"ad5da750e79b5200015b353b77ea89ee60748398","modified":1488275562775},{"_id":"public/2016/12/13/document-domain/index.html","hash":"6b004d1e6aa0ecc49d1d801cd519072829130c6b","modified":1488275562776},{"_id":"public/2016/12/12/biantaiti/index.html","hash":"7fd76389afcc226660445e95c063bd46cf876b44","modified":1488275562775},{"_id":"public/2016/12/02/Jenkins-CI/index.html","hash":"efc84dfbcd8e6ecd3f4dee861af4a6b87bd485fe","modified":1488275562776},{"_id":"public/2016/12/01/blockchain/index.html","hash":"efceef82ede1f3c3fe159e7c7da9fafe440a3ecb","modified":1488275562777},{"_id":"public/2016/12/01/angular-promise-two/index.html","hash":"9b263ba9b2ac07c666ef3070abb616d5e7e609f7","modified":1488275562777},{"_id":"public/2016/11/22/h5bug/index.html","hash":"6106d47e4f2d24001637206fcb92d0444291f2e5","modified":1488275562776},{"_id":"public/2016/11/13/window-back-disabled/index.html","hash":"ea2fc191703c17f54b8ba58f6f60adb7526be39e","modified":1488275562777},{"_id":"public/2016/11/13/arraydeapply/index.html","hash":"2dfbdaed8d647b430f724918d7b537444fd91112","modified":1488275562776},{"_id":"public/2016/10/23/nodekeng/index.html","hash":"6d6b75692150a64ce1c65b76f60dceb5eb988735","modified":1488275562777},{"_id":"public/2016/10/23/shejimoshi/index.html","hash":"34296aaab22998f0710bf4a6d683fcd9a11a6184","modified":1488275562777},{"_id":"public/2016/10/23/angular-q-promise-http/index.html","hash":"88fd1dfdf991c8ec09cd8249442d71d8b2566b20","modified":1488275562777},{"_id":"public/2016/10/14/life-yinian/index.html","hash":"8862165919673c1091c9933cffb5dd685325a4c2","modified":1488275562777},{"_id":"public/2016/08/16/h5api-router/index.html","hash":"0170cb98108b63cb8327621f11a29682f7a23d8d","modified":1488275562777},{"_id":"public/2016/08/12/guanchazhemoshi/index.html","hash":"29defe07502e0c12908a8bdabb9cab7760b4b9a8","modified":1488275562777},{"_id":"public/2016/08/12/react1/index.html","hash":"a2351fe496552f748fa81b7da395f13ecf785bd8","modified":1488275562777},{"_id":"public/2016/08/12/angualr-19-Karma/index.html","hash":"dc8a1e5b2972f66aadd4f6c12be3760303cb39c3","modified":1488275562777},{"_id":"public/2016/07/20/angular-decorator/index.html","hash":"fadd0a061378333f2d0eee963243404256055799","modified":1488275562779},{"_id":"public/2016/07/20/angular-guide16-xhr实践/index.html","hash":"e3471c6b678736f1cb13870aa7d77df9798241ea","modified":1488275562777},{"_id":"public/2016/07/16/qianhouduanfenli/index.html","hash":"606f89f9e0d232dde5b97eed4c520259d921c40a","modified":1488275562779},{"_id":"public/2016/07/13/angular-study/index.html","hash":"eb96d6459391605ddd3ddd2647227833b9c88131","modified":1488275562778},{"_id":"public/2016/06/29/angular-guide17-angular中的promise/index.html","hash":"c8d5b652b5c0282620df3c4b28be7dce85a46f1d","modified":1488275562778},{"_id":"public/2016/06/13/dajianjiaoshoujia/index.html","hash":"e41554ce099f87ea1d0efd55c6807bcf433def5c","modified":1488275562778},{"_id":"public/2016/06/05/filternull/index.html","hash":"d0b737c0564db0c282284e3b8ef36b0ea16838ca","modified":1488275562778},{"_id":"public/2016/06/01/angular-fiveservice/index.html","hash":"ac92ffeb157503b16bc5a93de948cde8637647f2","modified":1488275562778},{"_id":"public/2016/05/30/raps/index.html","hash":"7c3a40f1711bc0e7584d439b86c0225370b2e1e8","modified":1488275562778},{"_id":"public/2016/05/26/defined-filter/index.html","hash":"7d7f7494826b18464226c889986685f0cfd35557","modified":1488275562778},{"_id":"public/2016/05/13/angular-guide8-9章/index.html","hash":"f0f91ec23c204cc63288cab0644e6e3fc18c612b","modified":1488275562778},{"_id":"public/2016/05/10/angular-guide6-7/index.html","hash":"c02b7c5ea4ca752357e086ddaaaf5c149d68fb03","modified":1488275562778},{"_id":"public/2016/05/04/angular-guide1-5章/index.html","hash":"8039f4aa3a37c95c466ac0fdb4b750d9b0473c5c","modified":1488275562778},{"_id":"public/2016/03/12/gitsinglefile/index.html","hash":"2b44bff02c102ccc1ba5032dd03fa440300ec85b","modified":1488275562778},{"_id":"public/2016/02/10/jigou/index.html","hash":"08a51c73e4cc524a13645c00ad5edafacb5e5176","modified":1488275562778},{"_id":"public/2016/01/22/web-xingnengyouhua/index.html","hash":"b263f24b374435de02059e43d7e154a6cddc4c91","modified":1488275562779},{"_id":"public/2016/01/05/ES6-promise/index.html","hash":"2b8f8b2b1d4b18fbe6e4b3495ec8be4183714a09","modified":1488275562778},{"_id":"public/2015/12/30/rap-strong/index.html","hash":"52f8b2480a02e25c70fed6bd062daf26deb4db99","modified":1488275562779},{"_id":"public/2015/12/16/iscroll/index.html","hash":"53517821e6a5d01426bec59f9299e439566a1bce","modified":1488275562779},{"_id":"public/2015/12/13/web-resource/index.html","hash":"f17d40f7f93e82235d23ca8fbdfb00ffd25822e0","modified":1488275562779},{"_id":"public/2015/12/12/js-seajs/index.html","hash":"3020fecd13d6dc2ea1288d6fcf37188f7ab5b949","modified":1488275562779},{"_id":"public/2015/12/05/angular-ui-router/index.html","hash":"29ff5ddd626c81423cc0fe4dafa12d8d528e97b2","modified":1488275562779},{"_id":"public/2015/11/13/zaqiluanba/index.html","hash":"4d262e71435b1f43d445159e3fbb7d4a1231f56e","modified":1488275562779},{"_id":"public/2015/10/23/Object.create/index.html","hash":"595d8f293a12ab9077696a5866d9a51885faa451","modified":1488275562784},{"_id":"public/2015/10/15/6jicheng/index.html","hash":"86bcac598ddedc3d617b27ff498b5c3baafbeb4d","modified":1488275562784},{"_id":"public/2015/06/23/object-oriented-js/index.html","hash":"d19ee6138eeb9571d997355b3131bcb4ed617b32","modified":1488275562779},{"_id":"public/2015/03/27/zhaoji-life/index.html","hash":"3f6770258912fc7a71ccb84ba3b06ae75b570202","modified":1488275562780},{"_id":"public/2015/02/02/test-makrdown/index.html","hash":"fc870991023785c76fb8518759c8d1818e85ed65","modified":1488275562780},{"_id":"public/2014/12/30/jquery-gaoxiao/index.html","hash":"c4f542705abda57ec982cc12ae2bd20170d5d752","modified":1488275562780},{"_id":"public/archives/index.html","hash":"e65a449f141ae24caa4738c37d2ebc74a1f7cf8c","modified":1488275562781},{"_id":"public/archives/page/2/index.html","hash":"476ba4ae86a46c45566528e9590152535b969ea3","modified":1488275562782},{"_id":"public/archives/page/3/index.html","hash":"021c5a983a1d4a6d4f17992062fe4c8df4edf931","modified":1488275562782},{"_id":"public/archives/page/4/index.html","hash":"4273024d457e48f548a417dee92177b81554f8d3","modified":1488275562782},{"_id":"public/archives/page/5/index.html","hash":"19fd13a4f007206647785fa5843d8c142c7a8872","modified":1488275562782},{"_id":"public/archives/page/6/index.html","hash":"6a6fd05ad4552eda1a221137ee143f234fad3ce2","modified":1488275562782},{"_id":"public/archives/page/7/index.html","hash":"1c0a2b07122ad63eec7fa86f9ebc165444adf8f9","modified":1488275562782},{"_id":"public/archives/2015/index.html","hash":"24af1e26ea8f4974174dd603d0d07614e2e87f76","modified":1488275562782},{"_id":"public/archives/2015/12/index.html","hash":"f693266cfb54b4797fcf7e854ad836f647df081d","modified":1488275562782},{"_id":"public/archives/2016/index.html","hash":"7d204760bca4e0d8540d35a85b17ac36e49bcb63","modified":1488275562782},{"_id":"public/archives/2016/page/2/index.html","hash":"33e80f8cf3c262aa68f3b9298b2869d218e5cd63","modified":1488275562782},{"_id":"public/archives/2016/page/3/index.html","hash":"d021fa5d0b359a2973ddbdceb6ee97e553b300aa","modified":1488275562782},{"_id":"public/archives/2016/page/4/index.html","hash":"bb550127d900423ed3d8150152a85b639808ed9b","modified":1488275562783},{"_id":"public/archives/2016/page/5/index.html","hash":"b95ed0585d881eff9391a24ca5cd6d4f62017afe","modified":1488275562783},{"_id":"public/archives/2016/12/index.html","hash":"b1f6c1b9fb94db9387a86c7b1b0ee6ec712dae70","modified":1488275562783},{"_id":"public/archives/2016/12/page/2/index.html","hash":"d71b2de326deaeb26ad8c0e1c6ea0f72d38949bf","modified":1488275562783},{"_id":"public/archives/2017/index.html","hash":"3743a39d519ea8ebe0eaf1d82dac8917b24bb55e","modified":1488275562783},{"_id":"public/archives/2017/01/index.html","hash":"37b8c40ee96963ef8dc1c52ee31e88f4bdb2a42b","modified":1488275562784},{"_id":"public/index.html","hash":"513f85e1d890926909deeb5e1d5a6c562f132b51","modified":1488331063100},{"_id":"public/page/2/index.html","hash":"c752662745297779b3e4746a4dbfaa90d4db803a","modified":1488275562780},{"_id":"public/page/3/index.html","hash":"0d35806d72e25ec87e0dfd93dbb111cbb1f7739d","modified":1488275562780},{"_id":"public/page/4/index.html","hash":"c6dabd623a788d3ff8c9ab35865205c2e7574221","modified":1488275562781},{"_id":"public/page/5/index.html","hash":"89f5360dfe231bc1f93ce343784b5184ed5f25fc","modified":1488275562781},{"_id":"public/page/6/index.html","hash":"270448d97aa9c898a07f54ebc9acfef5631fdaa7","modified":1488275562781},{"_id":"public/page/7/index.html","hash":"1d5cd683dae74f8f64bf5a163940a9981f64a53c","modified":1488275562781},{"_id":"public/page/8/index.html","hash":"51c51b41648dcde56b6b2adc3b3ef064f5e45075","modified":1488275562781},{"_id":"public/tags/wechat/index.html","hash":"79a11c2642516aa2005c933bd83c70999f321142","modified":1488275562771},{"_id":"public/2017/01/10/debugwechat/index.html","hash":"ad53fff7ef67ff3be4f3bed60b978d9fb04565ca","modified":1488275562584},{"_id":"public/CNAME","hash":"868b644b3ca1492192bbc01ee344ad96da15e2f0","modified":1484042164497},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1484042164497},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1484042164497},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1484042164497},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1484042164497},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1484042164497},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1484042164497},{"_id":"public/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1484042164497},{"_id":"public/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1484042164497},{"_id":"public/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1484042164498},{"_id":"public/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1484042164498},{"_id":"public/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1484042164498},{"_id":"public/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1484042164498},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1484042164498},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1484042164498},{"_id":"public/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1484042164498},{"_id":"public/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1484042164498},{"_id":"public/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1484042164498},{"_id":"public/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1484042164498},{"_id":"public/img/qq.png","hash":"93e6e87ec8cef56573a08c8f8fbb0bb53313354a","modified":1484042164498},{"_id":"public/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1484042164498},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1484042164498},{"_id":"public/img/search.png","hash":"1ab76b03297ae2ce61ec59dd9bf8727f1fbbcedd","modified":1484042164498},{"_id":"public/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1484042164498},{"_id":"public/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1484042164498},{"_id":"public/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1484042164498},{"_id":"public/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1484042164498},{"_id":"public/css/fonts/fontawesome-webfont.svgz","hash":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1484042164498},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1484042164498},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1484042164498},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1484042164499},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1484042164499},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1484042165736},{"_id":"public/fancybox/jquery.fancybox.css","hash":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1484042165748},{"_id":"public/js/Counter.js","hash":"6697d5dfba2700c059722b62d856d4c86c73031a","modified":1484042165748},{"_id":"public/js/instagram.js","hash":"f19adbcc0dac33536bc6660598059048ec901882","modified":1484042165748},{"_id":"public/js/jquery.lazyload.js","hash":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1484042165748},{"_id":"public/js/mobile.js","hash":"b68cc01d24e80973c48205f551da87f3f3427644","modified":1484042165748},{"_id":"public/js/main.js","hash":"1d599d598cc4d90bc7f1aaf1acfb5e0841a2f97f","modified":1484042165748},{"_id":"public/js/pc.js","hash":"fdbc039fc9ffa70815b5fc4daaa587ae29693f10","modified":1484042165748},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1484042165748},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1484042165748},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1484042165748},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1484042165749},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1484042165749},{"_id":"public/css/style.css","hash":"0154043a6bc1838fcf882edf31c1eb252f76f278","modified":1484042165749},{"_id":"public/fancybox/jquery.fancybox.js","hash":"a82597493d75ea989ca586e09173cff332efe41e","modified":1484042165749},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1484042165749},{"_id":"public/js/particles.js","hash":"c4286268c2071a624bf3c8565f6328eccecacf30","modified":1484042165749},{"_id":"source/_posts/lodash-api.md","hash":"aed56cdc3bc3c533e4503464d4ef8d92b782794f","modified":1484126285901},{"_id":"source/_posts/lodash-chain.md","hash":"673e7209aed5bff2301af9cd6410ef2324397ec2","modified":1484106876861},{"_id":"source/_posts/lodashjieshao.md","hash":"afccbcd6633b0ca7152b7f38e52919c3f295d384","modified":1484112877271},{"_id":"source/_posts/node-interview.md","hash":"4311ed100298e42d1965b863912e6c84712973f2","modified":1484189411777},{"_id":"source/_posts/yarn-introduction.md","hash":"fde64f956898b9086a069af76af2e32b629c4975","modified":1484190718793},{"_id":"public/2017/01/12/yarn-introduction/index.html","hash":"20de88c0edd0e1f38c2e8ba4bb7da4cc8f0536e3","modified":1488275562583},{"_id":"public/2017/01/11/lodashjieshao/index.html","hash":"916f73d326604e51e5473e1e18e9502e372d4ff0","modified":1488275562584},{"_id":"public/2017/01/11/node-interview/index.html","hash":"6498ef1be51f70ee50bf1db712ca4d29f2c89a1e","modified":1488275562583},{"_id":"public/2017/01/11/lodash-chain/index.html","hash":"030952aaa67df0d4f198a7e2161b1156ffb18013","modified":1488275562583},{"_id":"public/2017/01/11/lodash-api/index.html","hash":"e25d62ca27eea8f73dc3219a369590104ae7cb28","modified":1488275562583},{"_id":"public/tags/js-lodash/index.html","hash":"7b92d51eddbbf1af23983823553dcc80fe7be424","modified":1488275562773},{"_id":"public/tags/Lodash/index.html","hash":"4cd3b5d6d5017f34c92c64d5066122ecc2684721","modified":1488275562773},{"_id":"public/tags/lodash-chain/index.html","hash":"f3e98ac1bc8f69cd58446f4e5c028480fa41d83d","modified":1488275562773},{"_id":"public/tags/nodejs/index.html","hash":"126e6fffce70c6c169429e120abb5d005ec2a435","modified":1488275562773},{"_id":"public/tags/yarn-npm/index.html","hash":"2b55ed986c1ddc89ca4dc09270ea4f79855d019d","modified":1488275562773},{"_id":"public/archives/2017/page/2/index.html","hash":"3e8af4f3f2a20f9b56930d8fe849a81d2563a55b","modified":1488275562783},{"_id":"public/archives/2017/01/page/2/index.html","hash":"bb0d21de26e0d6b34ea5bdd11719a38f77690b0c","modified":1488275562784},{"_id":"source/_posts/aso.md","hash":"d231d7aa8ebe0ed7c02c4e27ea5204d14f23b766","modified":1484534728154},{"_id":"source/_posts/newsyuanseo.md","hash":"49174745ad81050545bc8c8009e293b55ac2f140","modified":1484534209864},{"_id":"source/_posts/qianduanxijie.md","hash":"1ac089afc57904361bf4141c37fa29de63e06543","modified":1484537560902},{"_id":"source/_posts/siteseo1.md","hash":"bec73271b56405d8409dc8dd4c67c6a5d565026f","modified":1484532240589},{"_id":"source/_posts/sitepeise.md","hash":"759129448cf1357a238b3d63d2620b6ba0f36d10","modified":1484531694091},{"_id":"source/_posts/siteseo3.md","hash":"682ca772fb7a5e1292735dd91a70cbdc73df7d3d","modified":1484533346994},{"_id":"source/_posts/siteseo2.md","hash":"28265802745bcf7c1dab10db3fd46b1522b01256","modified":1484532448961},{"_id":"source/_posts/siteseo4.md","hash":"1ffd45ba4521fbf03c87eadd945be5e13b0d65ce","modified":1484533347004},{"_id":"source/_posts/siteseo5.md","hash":"9529b53a6c73bbedf3cb4613df4fb0659d5e520b","modified":1484533346983},{"_id":"source/_posts/webjiaohuxijie.md","hash":"48eef30562837fc4392c664b212df8a84d62ae4e","modified":1484536039771},{"_id":"public/archives/2014/07/index.html","hash":"270094f8db2535d484ccf4071266cef9262d1a2e","modified":1488275562767},{"_id":"public/archives/2015/page/3/index.html","hash":"8956a92c58bc897ac97117890d8d804fc3ed6f28","modified":1488275562766},{"_id":"public/archives/2015/09/index.html","hash":"e83e1cd19fbe1ea39d48b823ca396dacc71df737","modified":1488275562767},{"_id":"public/tags/aso/index.html","hash":"525b5fcde7345eb5fb47dbd588214c07956549d3","modified":1488275562773},{"_id":"public/tags/seo-新闻源/index.html","hash":"3e1f474e1390a9c5e0b765206ee57167e1ca8921","modified":1488275562773},{"_id":"public/tags/web/index.html","hash":"b837873ed4968e7cc3aa3c12f4f78ceb20801271","modified":1488275562773},{"_id":"public/tags/web-交互/index.html","hash":"ed65daf326f0d04c8a49e1e7683c68a8049385ff","modified":1488275562773},{"_id":"public/tags/建站-seo/index.html","hash":"f3160311c1dc1c5d7eb28772443c3a01b9f2863b","modified":1488275562773},{"_id":"public/2015/12/16/webjiaohuxijie/index.html","hash":"eb4e9dba59d1eafc21f0cb4ec16105da650e7153","modified":1488275562779},{"_id":"public/2015/09/29/qianduanxijie/index.html","hash":"a23b9f4b0a8716886e2ebb8713003342013a3f32","modified":1488275562779},{"_id":"public/2015/06/16/aso/index.html","hash":"c1919b0a421fbcefce1270f6431698fe7e6387f5","modified":1488275562779},{"_id":"public/2015/01/18/siteseo4/index.html","hash":"53dc5b24b80d3cbd9190b7c3dcc0df1415c5905e","modified":1488275562780},{"_id":"public/2015/01/20/siteseo5/index.html","hash":"f1d7ac68a4f371ac7cc44050b41fd03fee5baa1d","modified":1488275562780},{"_id":"public/2015/01/18/siteseo3/index.html","hash":"89e8bd39364e967f8656fd53a9ea1d9cdda251d2","modified":1488275562780},{"_id":"public/2015/01/17/siteseo2/index.html","hash":"2edb3661ad5945b426f7515743ce34ba52573dc8","modified":1488275562780},{"_id":"public/2015/01/16/siteseo1/index.html","hash":"66ede6a0050c5befee1c321023a364cf9345ca79","modified":1488275562780},{"_id":"public/2014/12/16/sitepeise/index.html","hash":"8fcb8040af5daea828018b7d1af87050f24f27a1","modified":1488275562780},{"_id":"public/2014/07/16/newsyuanseo/index.html","hash":"50e0f074f08ec06b955ffff310ad06bb9b565646","modified":1488275562780},{"_id":"public/archives/page/9/index.html","hash":"88c1632317b26523975195576839770419432b8a","modified":1488275562782},{"_id":"public/archives/2015/01/index.html","hash":"49cf98a9e1391663b3d2b01c8f85395910d8ca3b","modified":1488275562782},{"_id":"public/page/9/index.html","hash":"ef8daee16875e2d239fffc22e5ea2c2fb31698a2","modified":1488275562781},{"_id":"public/tags/seo/index.html","hash":"0ae1caa5f87e9638c9e58157187f37e80aca3d0b","modified":1488275562784},{"_id":"source/_posts/chrome-debugger.md","hash":"c21e606dbb9d4de4322eda286ed7d6a8f8ada597","modified":1485333567991},{"_id":"source/_posts/h5optimization.md","hash":"7ecf02e6ffdd686b5c474159575cb68aa89d9625","modified":1486195878698},{"_id":"source/_posts/jianfei21.md","hash":"fdcbf175bf03f63c08b984116f0aeb7a274c69c9","modified":1485250859298},{"_id":"source/_posts/wsdevwechat.md","hash":"691b7abcab9cdda9fbf57f5a0d3e9d10c6dd9676","modified":1486200979216},{"_id":"source/_posts/yahuyouhua.md","hash":"527157b78c2bdac0e98ba37849663a50eabd46db","modified":1486192436559},{"_id":"public/2017/02/04/wsdevwechat/index.html","hash":"62fcf493480dce1c93d48ac2f0ae0bf81da9b94c","modified":1488275562583},{"_id":"public/2016/12/29/h5optimization/index.html","hash":"aca3ace099bcc1c9d2bbe6415ab5422821cc0f5a","modified":1488275562774},{"_id":"public/tags/debugger/index.html","hash":"2bda774af88dc4769b832fcb2e622f6342cef7f2","modified":1488275562773},{"_id":"public/tags/H5-移动端优化/index.html","hash":"8ef05b36c03de5598af5bff3259fc7fcae8b9a22","modified":1488275562774},{"_id":"public/tags/fit/index.html","hash":"37a46768173d609dce9b26520377cb540c24905f","modified":1488275562773},{"_id":"public/tags/wechat-webstorm/index.html","hash":"8fd6614e91c7f8439535adeb90675ac7a56f069f","modified":1488275562774},{"_id":"public/tags/性能优化/index.html","hash":"ccd7c8b09301fac67239ffa3d9d4b195380effe8","modified":1488275562774},{"_id":"public/archives/page/10/index.html","hash":"ae7c928948f7376dd11162baade3a73986e3161f","modified":1488275562782},{"_id":"public/archives/2016/page/6/index.html","hash":"a98b151843e3b13b158f478f932a2bf2f50b2558","modified":1488275562783},{"_id":"public/archives/2017/02/index.html","hash":"98f086c6149c173d8f97274b3eba4870a7f0d1ef","modified":1488275562784},{"_id":"public/2016/07/04/yahuyouhua/index.html","hash":"d7e8d9e6ce4d287cd8f92b6bae1516d78ed6c637","modified":1488275562778},{"_id":"public/2016/01/25/chrome-debugger/index.html","hash":"d92f58d76053b6e59ed45d3f46d2efe7e6195fca","modified":1488275562778},{"_id":"public/2016/01/24/jianfei21/index.html","hash":"f3aa00d5518084c1916e0026b23f61fbd2e2580c","modified":1488275562778},{"_id":"public/page/10/index.html","hash":"732a34b83c0df8fa70f274e2120efa79c49199ed","modified":1488275562781},{"_id":"source/_posts/deepclosure.md","hash":"02fd0e81a1ebae0cdc63aa946661db64f16543e8","modified":1486549014428},{"_id":"source/_posts/deepthis.md","hash":"1eb299ddd9a3d92e7d5021c5dd80fb4cf47833e2","modified":1486610864627},{"_id":"source/_posts/flexintroduction.md","hash":"ca138a696b431cfe59692b8d3bde51148446c398","modified":1486437370830},{"_id":"source/_posts/scope.md","hash":"e6ac1b0d06f9f28bc6ff24068a18e8179ef54b7b","modified":1486540327764},{"_id":"source/_posts/wxapp1.md","hash":"192e666bfdae341d0bd1c4fdc6891f66ce3d986e","modified":1486368233948},{"_id":"source/_posts/wxappintroduction.md","hash":"7e3d327be2d49b2318ee071405a2c4c5e1be4d45","modified":1486367052612},{"_id":"source/_posts/wxapp-online.md","hash":"8d6d32732d309d4c1777d6fa686d19a46e8f562f","modified":1486435273054},{"_id":"public/2017/02/09/deepthis/index.html","hash":"982caac44ab45ffdb6cfb18f96b26a4a7f458aa2","modified":1488275562583},{"_id":"public/2017/02/07/flexintroduction/index.html","hash":"5de9ac682cf60c165aa14e5f07e31761b3ae2dc8","modified":1488275562513},{"_id":"public/2017/02/06/deepclosure/index.html","hash":"d804e998f3444b11be055a11fa051bbae21cb550","modified":1488275562583},{"_id":"public/2017/02/06/wxapp1/index.html","hash":"1470c86027894d8319d5ea5782a5de7c881e9246","modified":1488275562583},{"_id":"public/2017/02/06/wxapp-online/index.html","hash":"b93b972e113e2018e73dbabf8dbf179e08a9878b","modified":1488275562583},{"_id":"public/2017/02/06/wxappintroduction/index.html","hash":"493e0d772dd8c4daca64515489d2323b5848f542","modified":1488275562583},{"_id":"public/archives/2017/page/3/index.html","hash":"b52f5e62b1fa17e723024ec9df8fe2945a8b6e12","modified":1488275562784},{"_id":"public/tags/js-this/index.html","hash":"a90d99aedf2070b06b7c6e25ed01560dd342a9a6","modified":1488275562774},{"_id":"public/tags/js-closure/index.html","hash":"1a1c4ba3d952a7f4c3540a6d07601a774b49524b","modified":1488275562774},{"_id":"public/tags/flex-css/index.html","hash":"3c40a99fac4bce61aad647771c236b4c9e6f11f5","modified":1488275562774},{"_id":"public/tags/js-scope/index.html","hash":"ddae42b1ff1c62e27dbce7ae0c42be39cbf3d5d4","modified":1488275562774},{"_id":"public/tags/wxapp/index.html","hash":"59919e3809d130b09c1d5a64a2f8aee09271d884","modified":1488275562774},{"_id":"public/2015/02/08/scope/index.html","hash":"ae42e3741fea8b690ef2fce3d445171a2e76d2f1","modified":1488275562780},{"_id":"source/_posts/codetest.md","hash":"c585dab84a0a4a8dacf51f9f461403a25da96de4","modified":1486696201370},{"_id":"source/_posts/jstype.md","hash":"c97223ae576175f6af12762ecea5a345de3ef97e","modified":1486632801918},{"_id":"source/_posts/jsobject.md","hash":"9325f5a52233d67beab3f907a38d09ac1825410e","modified":1486624280070},{"_id":"source/_posts/lovestart.md","hash":"18d25acb726a2206ec1315bf2edf83c40b82358a","modified":1488330948661},{"_id":"source/_posts/performancetest.md","hash":"4a43656c955dde3c3ec3a5c4148fbc66b112d1a3","modified":1486693690011},{"_id":"source/_posts/rengemianju.md","hash":"58563ebea82574bdf1d06e6852c4639d5aa371a4","modified":1488275281350},{"_id":"source/_posts/web-workers.md","hash":"066aa4e17cbdcc852a1eade5b0f569b4e21a635e","modified":1486708487957},{"_id":"public/2017/02/14/lovestart/index.html","hash":"16bfb228bb1eea1315205cec097a6faff8b9cbce","modified":1488331063100},{"_id":"public/2017/02/19/rengemianju/index.html","hash":"50eb331ba1ef66b3ed47f01e181ec7ec5a3b878f","modified":1488275562774},{"_id":"public/2017/02/10/web-workers/index.html","hash":"472723331cc7d6efd6493f412f3ac74d7fa1f87d","modified":1488275562774},{"_id":"public/2017/02/10/codetest/index.html","hash":"9aa4c761e2fa7c8404cc0db7c2338be12797f27d","modified":1488275562774},{"_id":"public/2017/02/05/performancetest/index.html","hash":"9fc597d19803ffe7d6bf70c97401fa391edd712b","modified":1488275562774},{"_id":"public/archives/2017/02/page/2/index.html","hash":"411f3e51040e5cf294df32714356a47391a23f9a","modified":1488275562797},{"_id":"public/tags/js/index.html","hash":"9074fab10c767cc145bff0a14d4cbcff4f313b05","modified":1488275562797},{"_id":"public/tags/Benchmark-jsPerf/index.html","hash":"88d4f94dd68da26ebaff7c0fd7d24b915df3f36e","modified":1488275562797},{"_id":"public/tags/js-object/index.html","hash":"b7b0a9e1aebae706e600050c05d66810d6163287","modified":1488275562798},{"_id":"public/tags/js-性能调试/index.html","hash":"681bbae467b66b619b85aa8aeb43f7440ce16d4d","modified":1488275562798},{"_id":"public/tags/h5-webworkers/index.html","hash":"7b40d89967f0664a54ba001e2042cf29a6208498","modified":1488275562798},{"_id":"public/2016/02/09/jsobject/index.html","hash":"d97c806500ffe9d0ce975cb7c9c476e3445672f1","modified":1488275562799},{"_id":"public/2015/02/09/jstype/index.html","hash":"55c188a87c5bfb32e2328bf8628f9f1309f5e1be","modified":1488275562799},{"_id":"public/page/11/index.html","hash":"9a7c60c4ce96ceb48d809bf68bec31cb41f02947","modified":1488275562799},{"_id":"public/archives/page/11/index.html","hash":"7b9b956aedb9c6519b84ea4cb3ba9b37981b2675","modified":1488275562799}],"Category":[],"Data":[],"Page":[{"title":"我就是我，不一样的花朵","date":"2015-01-15T10:43:39.000Z","_content":"## keep real，be myself\n<iframe style=\"display:block; margin:0 auto;\" height=20% width=80% src='http://player.youku.com/embed/XMTg5MTYwMDEyMA==' frameborder=0 ''></iframe>\n我是英俊潇洒、玉树临风、天下无敌、人见人爱、花见花开、气死潘安、羞死宋玉、号称一朵梨花压海棠、宇宙第一高手,人送绰号玉面小鲜肉、山崩地裂水倒流鬼见愁、美貌与智慧结合、英雄与侠义化身——Scorpio~~~~哈哈哈！","source":"about/index.md","raw":"---\ntitle: 我就是我，不一样的花朵\ndate: 2015-1-15 18:43:39\n---\n## keep real，be myself\n<iframe style=\"display:block; margin:0 auto;\" height=20% width=80% src='http://player.youku.com/embed/XMTg5MTYwMDEyMA==' frameborder=0 ''></iframe>\n我是英俊潇洒、玉树临风、天下无敌、人见人爱、花见花开、气死潘安、羞死宋玉、号称一朵梨花压海棠、宇宙第一高手,人送绰号玉面小鲜肉、山崩地裂水倒流鬼见愁、美貌与智慧结合、英雄与侠义化身——Scorpio~~~~哈哈哈！","updated":"2016-12-31T04:27:46.830Z","path":"about/index.html","comments":1,"layout":"page","_id":"cixrcdv4x0000jgtukgcx5k60","content":"<h2 id=\"keep-real，be-myself\"><a href=\"#keep-real，be-myself\" class=\"headerlink\" title=\"keep real，be myself\"></a>keep real，be myself</h2><p><iframe style=\"display:block; margin:0 auto;\" height=\"20%\" width=\"80%\" src=\"http://player.youku.com/embed/XMTg5MTYwMDEyMA==\" frameborder=\"0\" ''=\"\"></iframe><br>我是英俊潇洒、玉树临风、天下无敌、人见人爱、花见花开、气死潘安、羞死宋玉、号称一朵梨花压海棠、宇宙第一高手,人送绰号玉面小鲜肉、山崩地裂水倒流鬼见愁、美貌与智慧结合、英雄与侠义化身——Scorpio~~~~哈哈哈！</p>\n","excerpt":"","more":"<h2 id=\"keep-real，be-myself\"><a href=\"#keep-real，be-myself\" class=\"headerlink\" title=\"keep real，be myself\"></a>keep real，be myself</h2><p><iframe style=\"display:block; margin:0 auto;\" height=20% width=80% src='http://player.youku.com/embed/XMTg5MTYwMDEyMA==' frameborder=0 ''></iframe><br>我是英俊潇洒、玉树临风、天下无敌、人见人爱、花见花开、气死潘安、羞死宋玉、号称一朵梨花压海棠、宇宙第一高手,人送绰号玉面小鲜肉、山崩地裂水倒流鬼见愁、美貌与智慧结合、英雄与侠义化身——Scorpio~~~~哈哈哈！</p>\n"}],"Post":[{"title":"我的2016个人总结","date":"2016-12-31T05:28:45.000Z","_content":"<iframe style=\"display:block; margin:0 auto;\" frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=29371332&auto=0&height=66\"></iframe>\n\n2016年过去了，首先感恩遇到的人，碰到的事。不管好和坏，小弟在此真诚地说声谢谢！！！一年不知不觉又过去了，猛然一回头发现2016年1月1日许的愿望全TM的实现了，比如我要攒10万钱，我要搞个对象，等到17年元旦睡醒发现还差12万，还是一个单身狗。。。。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/daxia.jpg-public)\n </div>\n今年元旦还不错，比我想像中的要好，我以为也就两个撸铁单身狗一块过了，没想到七八个人一块吃了顿饭，打了会牌。开始说还要包饺子热闹，最后他们都不会包就我自己会（此时对方向我抛出一个异常-不要face），所以改成火锅了。最赞的是羊肉，纯后腿肉，买了让人家现切的，我也没有多吃，自己也就吃了二斤，哈哈，比海底捞一点也不次。对了还有二鹏做的油焖大虾也是一个抢手货，除了皮和虾线，二斤大虾（买的时候还是去头的）做出来最后就这一点肉，怪不得外面吃的都带着头和皮。这里要重点透露下虾线和皮都是我自己的弄的！！！饭尽，扯着蛋炸了会金花，对于我这专业又低调的老司机来说赢了一百多。。。珍惜这种机会吧，以后在一起浪的机会会越来越少\n <div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/zha.jpg-public)\n </div>\n \n 先谈谈2016思维的转变，就拿智商来说吧。之前我也没有多么佩服那些上名牌大学的，感觉智商这玩意人与人也没有太大区别，你要非说你智商低，很有可能说明你没有努力。2016年认识到了有些人确实是特么的怪才，逻辑思维就是牛比，智商还是有差距的，好大学出来的人总体比所谓的坏大学要强，那些人接受新事物是比较快，当然你也不用羡慕，我认为上好大学的人有两种，一种是智商高，一种是拼命努力的人。我更佩服智商高的人考上好大学，当然那些努力奋斗考上的也得为之点赞，说实话，我不是很佩服，因为我要努力我一样能。比如接受一个知识有的人一小时，有的人要花一天，而我比较笨我花二天也能掌握了，我感觉那样没多大意义。我为什么上不了好大学，就是智商也不高，也没有那么努力而已，为什么用了而已一词，就是因为努力是一个可控的因素，这个因素就掌握在你自己的手中，你想努力你就能努力，但是对于智商来说不是你想提高就能提高的。所以说也回不到过去了，也上不了好大学了，以后的路就脚踏实地走吧！\n \n  <div align=center>\n     ![](http://oi28tswuq.bkt.clouddn.com/images/baidu2.jpg-public)\n  </div>\n其次谈谈工作，我认为工作就是生活的一种途径，就是通过自己的劳动来获得价值，再说得高尚点就是为中国的进步贡献一份自己的力量。现在我也没那么高尚的情操，我就是挣点钱而已。说到钱用一个比喻来体现会更加简单：钱就像水，多了会淹死，少了会渴死。工作中，我更喜欢比较随意的领导，我认为这样的领导更加智慧，上班到现在，就现在公司的这个领导是我见过最随意的，他说他就是讨厌那种分领导级别的人所以就出来创业了，每回开会TB时，都会来句各位爷或者各位老板辛苦了，让你听到之后你都不会不好好工作的。我不喜欢那种感觉自己就是领导的人，每天摆个比脸，跟每个员工都欠你八百万是的，当然员工没资格鄙视你，你确实比员工牛比，最起码是个领导，但是老子一点也不佩服你，最起码人与人之间的那点尊重你比我一点也不强。刚毕业第一家公司老板喜欢打感情战，也经常抱怨合作方不按时回款，不讲诚信，教育我们员工要讲诚信怎么怎么地，其实通过他干的那点事，他也不诚信，我辞职的时候就反问他你做的事诚信体现在哪，说给的奖金也哪？你有什么资格来教育我要讲诚信，最后他无话可说。记得有一次我去面试，谈到工资，他说我要多了，要我给他说说我哪里值这么多钱，我当时要不是出于礼貌，我直接就骂他了，还给我说之前他在三星总部上班，今年被挖来的以后我要来上班可以教我很多东西，他就是想要你来上班还不想给你这么多钱，这套路玩的我特么也是醉了。。。对了，今年我还去百度面试了，我就是去装把比而已，留个图纪念下。\n <div align=center>\n     ![](http://oi28tswuq.bkt.clouddn.com/images/baidu1.jpg-public)\n  </div>\n\n\n最后谈谈生活与对象，生不易，活也不易，生活中用心去体会就会发现美好的一面，之前我应该不算用心生活，我是用急性子来度过的。今年做过好多好事，体会到了不一样的快乐，以至于我出门捡钱都是捡一百的，不管你信不信反正我捡了。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/haoxin.jpg)\n </div>\n今年去健身房跟我饼哥混了半年多了，感受到了不一样的乐趣，之前我一直以为那是一个奢华的地，其实不是，一年1000块还是很值得的，虽然是一个虚比，但是你打不过我，来啊，互相伤害，截图为证，今年虽然进步了一点点，明年分要上去。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/rentifenxi.jpg-public)\n </div>\n在健身房里，一位资深老司机告诉年轻人，不论你是干什么的时刻不忘学习，不然会被社会淘汰。其实做一件事情也没有想像的那么难，也不要畏惧，明白了最核心的原理后很容易得到解决，比如减肥，你连肝糖元，肌糖元都不知道，你减个毛线肥。虽然话说得很难听，但是特别有道理。乞讨也是有区别的，有的人一天能要来100块，有的能要来1000块，难道你不想想自己的问题出在哪？\n\n最后的最后，谈谈对象，我为什么没有对象，因为人丑嘴不甜长得磕碜还没钱。期待2017你的到来。\n心怀善念，能利人；心怀感恩，能利己。学会换位，人生才有和谐；知道感恩，岁月才有温暖。活着，就是一场修行，真正的修行不在一张能言的嘴上，而在一颗向善的心里。人生之光，是一颗宽容的心；岁月之好，是一份随缘的爱。\n这段话送给自己，也送给你，与君共勉，吃了这瓶玛珈，你会发现一个不一样的自己。祝大家2017安好！\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/shuai2.jpg)\n </div>\n","source":"_posts/2016zongjie.md","raw":"---\ntitle: 我的2016个人总结\ndate: 2016-12-31 13:28:45\ntags: 生活\n---\n<iframe style=\"display:block; margin:0 auto;\" frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=29371332&auto=0&height=66\"></iframe>\n\n2016年过去了，首先感恩遇到的人，碰到的事。不管好和坏，小弟在此真诚地说声谢谢！！！一年不知不觉又过去了，猛然一回头发现2016年1月1日许的愿望全TM的实现了，比如我要攒10万钱，我要搞个对象，等到17年元旦睡醒发现还差12万，还是一个单身狗。。。。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/daxia.jpg-public)\n </div>\n今年元旦还不错，比我想像中的要好，我以为也就两个撸铁单身狗一块过了，没想到七八个人一块吃了顿饭，打了会牌。开始说还要包饺子热闹，最后他们都不会包就我自己会（此时对方向我抛出一个异常-不要face），所以改成火锅了。最赞的是羊肉，纯后腿肉，买了让人家现切的，我也没有多吃，自己也就吃了二斤，哈哈，比海底捞一点也不次。对了还有二鹏做的油焖大虾也是一个抢手货，除了皮和虾线，二斤大虾（买的时候还是去头的）做出来最后就这一点肉，怪不得外面吃的都带着头和皮。这里要重点透露下虾线和皮都是我自己的弄的！！！饭尽，扯着蛋炸了会金花，对于我这专业又低调的老司机来说赢了一百多。。。珍惜这种机会吧，以后在一起浪的机会会越来越少\n <div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/zha.jpg-public)\n </div>\n \n 先谈谈2016思维的转变，就拿智商来说吧。之前我也没有多么佩服那些上名牌大学的，感觉智商这玩意人与人也没有太大区别，你要非说你智商低，很有可能说明你没有努力。2016年认识到了有些人确实是特么的怪才，逻辑思维就是牛比，智商还是有差距的，好大学出来的人总体比所谓的坏大学要强，那些人接受新事物是比较快，当然你也不用羡慕，我认为上好大学的人有两种，一种是智商高，一种是拼命努力的人。我更佩服智商高的人考上好大学，当然那些努力奋斗考上的也得为之点赞，说实话，我不是很佩服，因为我要努力我一样能。比如接受一个知识有的人一小时，有的人要花一天，而我比较笨我花二天也能掌握了，我感觉那样没多大意义。我为什么上不了好大学，就是智商也不高，也没有那么努力而已，为什么用了而已一词，就是因为努力是一个可控的因素，这个因素就掌握在你自己的手中，你想努力你就能努力，但是对于智商来说不是你想提高就能提高的。所以说也回不到过去了，也上不了好大学了，以后的路就脚踏实地走吧！\n \n  <div align=center>\n     ![](http://oi28tswuq.bkt.clouddn.com/images/baidu2.jpg-public)\n  </div>\n其次谈谈工作，我认为工作就是生活的一种途径，就是通过自己的劳动来获得价值，再说得高尚点就是为中国的进步贡献一份自己的力量。现在我也没那么高尚的情操，我就是挣点钱而已。说到钱用一个比喻来体现会更加简单：钱就像水，多了会淹死，少了会渴死。工作中，我更喜欢比较随意的领导，我认为这样的领导更加智慧，上班到现在，就现在公司的这个领导是我见过最随意的，他说他就是讨厌那种分领导级别的人所以就出来创业了，每回开会TB时，都会来句各位爷或者各位老板辛苦了，让你听到之后你都不会不好好工作的。我不喜欢那种感觉自己就是领导的人，每天摆个比脸，跟每个员工都欠你八百万是的，当然员工没资格鄙视你，你确实比员工牛比，最起码是个领导，但是老子一点也不佩服你，最起码人与人之间的那点尊重你比我一点也不强。刚毕业第一家公司老板喜欢打感情战，也经常抱怨合作方不按时回款，不讲诚信，教育我们员工要讲诚信怎么怎么地，其实通过他干的那点事，他也不诚信，我辞职的时候就反问他你做的事诚信体现在哪，说给的奖金也哪？你有什么资格来教育我要讲诚信，最后他无话可说。记得有一次我去面试，谈到工资，他说我要多了，要我给他说说我哪里值这么多钱，我当时要不是出于礼貌，我直接就骂他了，还给我说之前他在三星总部上班，今年被挖来的以后我要来上班可以教我很多东西，他就是想要你来上班还不想给你这么多钱，这套路玩的我特么也是醉了。。。对了，今年我还去百度面试了，我就是去装把比而已，留个图纪念下。\n <div align=center>\n     ![](http://oi28tswuq.bkt.clouddn.com/images/baidu1.jpg-public)\n  </div>\n\n\n最后谈谈生活与对象，生不易，活也不易，生活中用心去体会就会发现美好的一面，之前我应该不算用心生活，我是用急性子来度过的。今年做过好多好事，体会到了不一样的快乐，以至于我出门捡钱都是捡一百的，不管你信不信反正我捡了。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/haoxin.jpg)\n </div>\n今年去健身房跟我饼哥混了半年多了，感受到了不一样的乐趣，之前我一直以为那是一个奢华的地，其实不是，一年1000块还是很值得的，虽然是一个虚比，但是你打不过我，来啊，互相伤害，截图为证，今年虽然进步了一点点，明年分要上去。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/rentifenxi.jpg-public)\n </div>\n在健身房里，一位资深老司机告诉年轻人，不论你是干什么的时刻不忘学习，不然会被社会淘汰。其实做一件事情也没有想像的那么难，也不要畏惧，明白了最核心的原理后很容易得到解决，比如减肥，你连肝糖元，肌糖元都不知道，你减个毛线肥。虽然话说得很难听，但是特别有道理。乞讨也是有区别的，有的人一天能要来100块，有的能要来1000块，难道你不想想自己的问题出在哪？\n\n最后的最后，谈谈对象，我为什么没有对象，因为人丑嘴不甜长得磕碜还没钱。期待2017你的到来。\n心怀善念，能利人；心怀感恩，能利己。学会换位，人生才有和谐；知道感恩，岁月才有温暖。活着，就是一场修行，真正的修行不在一张能言的嘴上，而在一颗向善的心里。人生之光，是一颗宽容的心；岁月之好，是一份随缘的爱。\n这段话送给自己，也送给你，与君共勉，吃了这瓶玛珈，你会发现一个不一样的自己。祝大家2017安好！\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/shuai2.jpg)\n </div>\n","slug":"2016zongjie","published":1,"updated":"2017-01-10T08:13:50.366Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv4z0001jgtuj035a8dg","content":"<iframe style=\"display:block; margin:0 auto;\" frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=29371332&auto=0&height=66\"></iframe>\n\n<p>2016年过去了，首先感恩遇到的人，碰到的事。不管好和坏，小弟在此真诚地说声谢谢！！！一年不知不觉又过去了，猛然一回头发现2016年1月1日许的愿望全TM的实现了，比如我要攒10万钱，我要搞个对象，等到17年元旦睡醒发现还差12万，还是一个单身狗。。。。</p>\n<div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/daxia.jpg-public\" alt=\"\"><br> </div><br>今年元旦还不错，比我想像中的要好，我以为也就两个撸铁单身狗一块过了，没想到七八个人一块吃了顿饭，打了会牌。开始说还要包饺子热闹，最后他们都不会包就我自己会（此时对方向我抛出一个异常-不要face），所以改成火锅了。最赞的是羊肉，纯后腿肉，买了让人家现切的，我也没有多吃，自己也就吃了二斤，哈哈，比海底捞一点也不次。对了还有二鹏做的油焖大虾也是一个抢手货，除了皮和虾线，二斤大虾（买的时候还是去头的）做出来最后就这一点肉，怪不得外面吃的都带着头和皮。这里要重点透露下虾线和皮都是我自己的弄的！！！饭尽，扯着蛋炸了会金花，对于我这专业又低调的老司机来说赢了一百多。。。珍惜这种机会吧，以后在一起浪的机会会越来越少<br> <div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/zha.jpg-public\" alt=\"\"><br> </div>\n\n<p> 先谈谈2016思维的转变，就拿智商来说吧。之前我也没有多么佩服那些上名牌大学的，感觉智商这玩意人与人也没有太大区别，你要非说你智商低，很有可能说明你没有努力。2016年认识到了有些人确实是特么的怪才，逻辑思维就是牛比，智商还是有差距的，好大学出来的人总体比所谓的坏大学要强，那些人接受新事物是比较快，当然你也不用羡慕，我认为上好大学的人有两种，一种是智商高，一种是拼命努力的人。我更佩服智商高的人考上好大学，当然那些努力奋斗考上的也得为之点赞，说实话，我不是很佩服，因为我要努力我一样能。比如接受一个知识有的人一小时，有的人要花一天，而我比较笨我花二天也能掌握了，我感觉那样没多大意义。我为什么上不了好大学，就是智商也不高，也没有那么努力而已，为什么用了而已一词，就是因为努力是一个可控的因素，这个因素就掌握在你自己的手中，你想努力你就能努力，但是对于智商来说不是你想提高就能提高的。所以说也回不到过去了，也上不了好大学了，以后的路就脚踏实地走吧！</p>\n  <div align=\"center\"><br>     <img src=\"http://oi28tswuq.bkt.clouddn.com/images/baidu2.jpg-public\" alt=\"\"><br>  </div><br>其次谈谈工作，我认为工作就是生活的一种途径，就是通过自己的劳动来获得价值，再说得高尚点就是为中国的进步贡献一份自己的力量。现在我也没那么高尚的情操，我就是挣点钱而已。说到钱用一个比喻来体现会更加简单：钱就像水，多了会淹死，少了会渴死。工作中，我更喜欢比较随意的领导，我认为这样的领导更加智慧，上班到现在，就现在公司的这个领导是我见过最随意的，他说他就是讨厌那种分领导级别的人所以就出来创业了，每回开会TB时，都会来句各位爷或者各位老板辛苦了，让你听到之后你都不会不好好工作的。我不喜欢那种感觉自己就是领导的人，每天摆个比脸，跟每个员工都欠你八百万是的，当然员工没资格鄙视你，你确实比员工牛比，最起码是个领导，但是老子一点也不佩服你，最起码人与人之间的那点尊重你比我一点也不强。刚毕业第一家公司老板喜欢打感情战，也经常抱怨合作方不按时回款，不讲诚信，教育我们员工要讲诚信怎么怎么地，其实通过他干的那点事，他也不诚信，我辞职的时候就反问他你做的事诚信体现在哪，说给的奖金也哪？你有什么资格来教育我要讲诚信，最后他无话可说。记得有一次我去面试，谈到工资，他说我要多了，要我给他说说我哪里值这么多钱，我当时要不是出于礼貌，我直接就骂他了，还给我说之前他在三星总部上班，今年被挖来的以后我要来上班可以教我很多东西，他就是想要你来上班还不想给你这么多钱，这套路玩的我特么也是醉了。。。对了，今年我还去百度面试了，我就是去装把比而已，留个图纪念下。<br> <div align=\"center\"><br>     <img src=\"http://oi28tswuq.bkt.clouddn.com/images/baidu1.jpg-public\" alt=\"\"><br>  </div>\n\n\n<p>最后谈谈生活与对象，生不易，活也不易，生活中用心去体会就会发现美好的一面，之前我应该不算用心生活，我是用急性子来度过的。今年做过好多好事，体会到了不一样的快乐，以至于我出门捡钱都是捡一百的，不管你信不信反正我捡了。</p>\n<div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/haoxin.jpg\" alt=\"\"><br> </div><br>今年去健身房跟我饼哥混了半年多了，感受到了不一样的乐趣，之前我一直以为那是一个奢华的地，其实不是，一年1000块还是很值得的，虽然是一个虚比，但是你打不过我，来啊，互相伤害，截图为证，今年虽然进步了一点点，明年分要上去。<br><div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/rentifenxi.jpg-public\" alt=\"\"><br> </div><br>在健身房里，一位资深老司机告诉年轻人，不论你是干什么的时刻不忘学习，不然会被社会淘汰。其实做一件事情也没有想像的那么难，也不要畏惧，明白了最核心的原理后很容易得到解决，比如减肥，你连肝糖元，肌糖元都不知道，你减个毛线肥。虽然话说得很难听，但是特别有道理。乞讨也是有区别的，有的人一天能要来100块，有的能要来1000块，难道你不想想自己的问题出在哪？<br><br>最后的最后，谈谈对象，我为什么没有对象，因为人丑嘴不甜长得磕碜还没钱。期待2017你的到来。<br>心怀善念，能利人；心怀感恩，能利己。学会换位，人生才有和谐；知道感恩，岁月才有温暖。活着，就是一场修行，真正的修行不在一张能言的嘴上，而在一颗向善的心里。人生之光，是一颗宽容的心；岁月之好，是一份随缘的爱。<br>这段话送给自己，也送给你，与君共勉，吃了这瓶玛珈，你会发现一个不一样的自己。祝大家2017安好！<br><div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/shuai2.jpg\" alt=\"\"><br> </div>\n","excerpt":"","more":"<iframe style=\"display:block; margin:0 auto;\" frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=29371332&auto=0&height=66\"></iframe>\n\n<p>2016年过去了，首先感恩遇到的人，碰到的事。不管好和坏，小弟在此真诚地说声谢谢！！！一年不知不觉又过去了，猛然一回头发现2016年1月1日许的愿望全TM的实现了，比如我要攒10万钱，我要搞个对象，等到17年元旦睡醒发现还差12万，还是一个单身狗。。。。</p>\n<div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/daxia.jpg-public\" alt=\"\"><br> </div><br>今年元旦还不错，比我想像中的要好，我以为也就两个撸铁单身狗一块过了，没想到七八个人一块吃了顿饭，打了会牌。开始说还要包饺子热闹，最后他们都不会包就我自己会（此时对方向我抛出一个异常-不要face），所以改成火锅了。最赞的是羊肉，纯后腿肉，买了让人家现切的，我也没有多吃，自己也就吃了二斤，哈哈，比海底捞一点也不次。对了还有二鹏做的油焖大虾也是一个抢手货，除了皮和虾线，二斤大虾（买的时候还是去头的）做出来最后就这一点肉，怪不得外面吃的都带着头和皮。这里要重点透露下虾线和皮都是我自己的弄的！！！饭尽，扯着蛋炸了会金花，对于我这专业又低调的老司机来说赢了一百多。。。珍惜这种机会吧，以后在一起浪的机会会越来越少<br> <div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/zha.jpg-public\" alt=\"\"><br> </div>\n\n<p> 先谈谈2016思维的转变，就拿智商来说吧。之前我也没有多么佩服那些上名牌大学的，感觉智商这玩意人与人也没有太大区别，你要非说你智商低，很有可能说明你没有努力。2016年认识到了有些人确实是特么的怪才，逻辑思维就是牛比，智商还是有差距的，好大学出来的人总体比所谓的坏大学要强，那些人接受新事物是比较快，当然你也不用羡慕，我认为上好大学的人有两种，一种是智商高，一种是拼命努力的人。我更佩服智商高的人考上好大学，当然那些努力奋斗考上的也得为之点赞，说实话，我不是很佩服，因为我要努力我一样能。比如接受一个知识有的人一小时，有的人要花一天，而我比较笨我花二天也能掌握了，我感觉那样没多大意义。我为什么上不了好大学，就是智商也不高，也没有那么努力而已，为什么用了而已一词，就是因为努力是一个可控的因素，这个因素就掌握在你自己的手中，你想努力你就能努力，但是对于智商来说不是你想提高就能提高的。所以说也回不到过去了，也上不了好大学了，以后的路就脚踏实地走吧！</p>\n  <div align=center><br>     <img src=\"http://oi28tswuq.bkt.clouddn.com/images/baidu2.jpg-public\" alt=\"\"><br>  </div><br>其次谈谈工作，我认为工作就是生活的一种途径，就是通过自己的劳动来获得价值，再说得高尚点就是为中国的进步贡献一份自己的力量。现在我也没那么高尚的情操，我就是挣点钱而已。说到钱用一个比喻来体现会更加简单：钱就像水，多了会淹死，少了会渴死。工作中，我更喜欢比较随意的领导，我认为这样的领导更加智慧，上班到现在，就现在公司的这个领导是我见过最随意的，他说他就是讨厌那种分领导级别的人所以就出来创业了，每回开会TB时，都会来句各位爷或者各位老板辛苦了，让你听到之后你都不会不好好工作的。我不喜欢那种感觉自己就是领导的人，每天摆个比脸，跟每个员工都欠你八百万是的，当然员工没资格鄙视你，你确实比员工牛比，最起码是个领导，但是老子一点也不佩服你，最起码人与人之间的那点尊重你比我一点也不强。刚毕业第一家公司老板喜欢打感情战，也经常抱怨合作方不按时回款，不讲诚信，教育我们员工要讲诚信怎么怎么地，其实通过他干的那点事，他也不诚信，我辞职的时候就反问他你做的事诚信体现在哪，说给的奖金也哪？你有什么资格来教育我要讲诚信，最后他无话可说。记得有一次我去面试，谈到工资，他说我要多了，要我给他说说我哪里值这么多钱，我当时要不是出于礼貌，我直接就骂他了，还给我说之前他在三星总部上班，今年被挖来的以后我要来上班可以教我很多东西，他就是想要你来上班还不想给你这么多钱，这套路玩的我特么也是醉了。。。对了，今年我还去百度面试了，我就是去装把比而已，留个图纪念下。<br> <div align=center><br>     <img src=\"http://oi28tswuq.bkt.clouddn.com/images/baidu1.jpg-public\" alt=\"\"><br>  </div>\n\n\n<p>最后谈谈生活与对象，生不易，活也不易，生活中用心去体会就会发现美好的一面，之前我应该不算用心生活，我是用急性子来度过的。今年做过好多好事，体会到了不一样的快乐，以至于我出门捡钱都是捡一百的，不管你信不信反正我捡了。</p>\n<div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/haoxin.jpg\" alt=\"\"><br> </div><br>今年去健身房跟我饼哥混了半年多了，感受到了不一样的乐趣，之前我一直以为那是一个奢华的地，其实不是，一年1000块还是很值得的，虽然是一个虚比，但是你打不过我，来啊，互相伤害，截图为证，今年虽然进步了一点点，明年分要上去。<br><div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/rentifenxi.jpg-public\" alt=\"\"><br> </div><br>在健身房里，一位资深老司机告诉年轻人，不论你是干什么的时刻不忘学习，不然会被社会淘汰。其实做一件事情也没有想像的那么难，也不要畏惧，明白了最核心的原理后很容易得到解决，比如减肥，你连肝糖元，肌糖元都不知道，你减个毛线肥。虽然话说得很难听，但是特别有道理。乞讨也是有区别的，有的人一天能要来100块，有的能要来1000块，难道你不想想自己的问题出在哪？<br><br>最后的最后，谈谈对象，我为什么没有对象，因为人丑嘴不甜长得磕碜还没钱。期待2017你的到来。<br>心怀善念，能利人；心怀感恩，能利己。学会换位，人生才有和谐；知道感恩，岁月才有温暖。活着，就是一场修行，真正的修行不在一张能言的嘴上，而在一颗向善的心里。人生之光，是一颗宽容的心；岁月之好，是一份随缘的爱。<br>这段话送给自己，也送给你，与君共勉，吃了这瓶玛珈，你会发现一个不一样的自己。祝大家2017安好！<br><div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/shuai2.jpg\" alt=\"\"><br> </div>\n"},{"title":"js学习--6种继承方式","date":"2015-10-15T06:12:39.000Z","_content":"js中常用的继承方式: 子类继承父类的方法：\n### 1、原型继承  \n子类的原型指向父类的一个实例  父类的私有和公有方法都是子类的公有方法\n```\nfunction A(){\n    this.x = 100;\n    this.y = 100;\n}\nA.prototype.getX = function (){}\n\nfunction B(){\n    this.x = 100;\n}\nB.prototype = new A(); //B的原型重新赋值A的实例==>每个b实例都能通过自己的__proto__找到a上的所有的私有方法，并且还可以通过a.__proto__继续找到A.prototype上的所有属性 ==> A这个类上的方法相对于B都是公有方法\nB.prototype.constructor = B; //由于重新修改了B的原型导致默认原型上的constructor丢失，我们需要自己添加上\n```\n### 2、call继承  \n在子类构造函数中 父类.call(this)  父类的私有变成子类的私有\n```\nfunction C(){\n    this.x = 100; //d.x = 100\n}\nC.prototype.getX = function (){};\nfunction D(){\n    C.call(this); //构造函数中的this就是当前实例  this ==> d     C.call(d);  ==> 把C中的this修改成d\n}\n```\n### 3、冒充对象继承 \n循环遍历父类实例，然后父类实例的私有方法全部拿过来添加给子类实，如果不做hasOwnProperty判断那么就是把父类的公有的和私有的都拿过来当私有的\n```\nfunction E(){\n    this.x = 100;\n    this.y = 200;\n}\nE.prototype.getX = function (){}\nfunction F(){\n    var e = new E(); //e.x = 100;\n    for(var attr in e){ //for in可以遍历到原型上的公有自定义属性\n        //attr = x\n        if(e.hasOwnProperty(attr)){ //如果这个判断不加，那么无论是公有的还是私有的都拿过来当私有的\n            this[attr] = e[attr];\n            //f['x'] = e['x'] ==> f.x = 100;\n        }\n        // e.propertyIsEnumerable() //可枚举属性  ==> 简单理解：可以拿出来一一列举的属性\n    }\n}\n```\n### 4 混合继承  \n原型+call  ==> 无论是私有的还是公有的都拿过来了 ==> 子类的原型上的多了一套父类私有属但是不会产生问题。因为子类的私有属性也有一套相同的通过call继承拿过来的\n```\nfunction G(){\n    this.x = 100;\n}\nG.prototype.getX = function(){};\nfunction H(){\n    G.call(this);\n}\nH.prototype = new G();\nH.prototype.constructor = H;\n```\n###  5 中间件继承  \nM.prototype.__proto__ = K.prototype;  把父类的公有的当作子类的公有的\n```\nfunction K(){\n    this.x = 100;\n}\nk.prototype.getX = function (){};\nfunction M(){\n\n}\nM.prototype.__proto__ = K.prototype; //本来应该是直接指向Object.prototype。从K的原型上的__proto__也可以到Object.prototype==> 在K.prototype上停留了下，K.prototype就是一个中间件  父类的公有当作子类的公有\n```\n### 6 寄生组合式继承 \n Object.create(xx.prototype)方法  ==> 是把xx.prototype当作别人家的原型  不兼容，只能找到父类原型的方法。父类的私有属性访问不到。\n ```\nfunction Parent() {\n    this.name = \"ywx\";\n}\nParent.prototype.eat = function () {\n    console.log(123);\n};\nfunction Child() {}\n//寄生组合式继承实现方式如下：\nChild.prototype = Object.create(Parent.prototype);\nvar child=new Child();\nconsole.log(child.eat());//只有找到父类原型上的方法\n```\n","source":"_posts/6jicheng.md","raw":"---\ntitle: js学习--6种继承方式\ndate: 2015-10-15 14:12:39\ntags: js继承\n---\njs中常用的继承方式: 子类继承父类的方法：\n### 1、原型继承  \n子类的原型指向父类的一个实例  父类的私有和公有方法都是子类的公有方法\n```\nfunction A(){\n    this.x = 100;\n    this.y = 100;\n}\nA.prototype.getX = function (){}\n\nfunction B(){\n    this.x = 100;\n}\nB.prototype = new A(); //B的原型重新赋值A的实例==>每个b实例都能通过自己的__proto__找到a上的所有的私有方法，并且还可以通过a.__proto__继续找到A.prototype上的所有属性 ==> A这个类上的方法相对于B都是公有方法\nB.prototype.constructor = B; //由于重新修改了B的原型导致默认原型上的constructor丢失，我们需要自己添加上\n```\n### 2、call继承  \n在子类构造函数中 父类.call(this)  父类的私有变成子类的私有\n```\nfunction C(){\n    this.x = 100; //d.x = 100\n}\nC.prototype.getX = function (){};\nfunction D(){\n    C.call(this); //构造函数中的this就是当前实例  this ==> d     C.call(d);  ==> 把C中的this修改成d\n}\n```\n### 3、冒充对象继承 \n循环遍历父类实例，然后父类实例的私有方法全部拿过来添加给子类实，如果不做hasOwnProperty判断那么就是把父类的公有的和私有的都拿过来当私有的\n```\nfunction E(){\n    this.x = 100;\n    this.y = 200;\n}\nE.prototype.getX = function (){}\nfunction F(){\n    var e = new E(); //e.x = 100;\n    for(var attr in e){ //for in可以遍历到原型上的公有自定义属性\n        //attr = x\n        if(e.hasOwnProperty(attr)){ //如果这个判断不加，那么无论是公有的还是私有的都拿过来当私有的\n            this[attr] = e[attr];\n            //f['x'] = e['x'] ==> f.x = 100;\n        }\n        // e.propertyIsEnumerable() //可枚举属性  ==> 简单理解：可以拿出来一一列举的属性\n    }\n}\n```\n### 4 混合继承  \n原型+call  ==> 无论是私有的还是公有的都拿过来了 ==> 子类的原型上的多了一套父类私有属但是不会产生问题。因为子类的私有属性也有一套相同的通过call继承拿过来的\n```\nfunction G(){\n    this.x = 100;\n}\nG.prototype.getX = function(){};\nfunction H(){\n    G.call(this);\n}\nH.prototype = new G();\nH.prototype.constructor = H;\n```\n###  5 中间件继承  \nM.prototype.__proto__ = K.prototype;  把父类的公有的当作子类的公有的\n```\nfunction K(){\n    this.x = 100;\n}\nk.prototype.getX = function (){};\nfunction M(){\n\n}\nM.prototype.__proto__ = K.prototype; //本来应该是直接指向Object.prototype。从K的原型上的__proto__也可以到Object.prototype==> 在K.prototype上停留了下，K.prototype就是一个中间件  父类的公有当作子类的公有\n```\n### 6 寄生组合式继承 \n Object.create(xx.prototype)方法  ==> 是把xx.prototype当作别人家的原型  不兼容，只能找到父类原型的方法。父类的私有属性访问不到。\n ```\nfunction Parent() {\n    this.name = \"ywx\";\n}\nParent.prototype.eat = function () {\n    console.log(123);\n};\nfunction Child() {}\n//寄生组合式继承实现方式如下：\nChild.prototype = Object.create(Parent.prototype);\nvar child=new Child();\nconsole.log(child.eat());//只有找到父类原型上的方法\n```\n","slug":"6jicheng","published":1,"updated":"2016-12-12T08:53:33.535Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv530002jgtu16a84re9","content":"<p>js中常用的继承方式: 子类继承父类的方法：</p>\n<h3 id=\"1、原型继承\"><a href=\"#1、原型继承\" class=\"headerlink\" title=\"1、原型继承\"></a>1、原型继承</h3><p>子类的原型指向父类的一个实例  父类的私有和公有方法都是子类的公有方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function A()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">    this.y = 100;</div><div class=\"line\">&#125;</div><div class=\"line\">A.prototype.getX = function ()&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">function B()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">&#125;</div><div class=\"line\">B.prototype = new A(); //B的原型重新赋值A的实例==&gt;每个b实例都能通过自己的__proto__找到a上的所有的私有方法，并且还可以通过a.__proto__继续找到A.prototype上的所有属性 ==&gt; A这个类上的方法相对于B都是公有方法</div><div class=\"line\">B.prototype.constructor = B; //由于重新修改了B的原型导致默认原型上的constructor丢失，我们需要自己添加上</div></pre></td></tr></table></figure></p>\n<h3 id=\"2、call继承\"><a href=\"#2、call继承\" class=\"headerlink\" title=\"2、call继承\"></a>2、call继承</h3><p>在子类构造函数中 父类.call(this)  父类的私有变成子类的私有<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function C()&#123;</div><div class=\"line\">    this.x = 100; //d.x = 100</div><div class=\"line\">&#125;</div><div class=\"line\">C.prototype.getX = function ()&#123;&#125;;</div><div class=\"line\">function D()&#123;</div><div class=\"line\">    C.call(this); //构造函数中的this就是当前实例  this ==&gt; d     C.call(d);  ==&gt; 把C中的this修改成d</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"3、冒充对象继承\"><a href=\"#3、冒充对象继承\" class=\"headerlink\" title=\"3、冒充对象继承\"></a>3、冒充对象继承</h3><p>循环遍历父类实例，然后父类实例的私有方法全部拿过来添加给子类实，如果不做hasOwnProperty判断那么就是把父类的公有的和私有的都拿过来当私有的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">function E()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">    this.y = 200;</div><div class=\"line\">&#125;</div><div class=\"line\">E.prototype.getX = function ()&#123;&#125;</div><div class=\"line\">function F()&#123;</div><div class=\"line\">    var e = new E(); //e.x = 100;</div><div class=\"line\">    for(var attr in e)&#123; //for in可以遍历到原型上的公有自定义属性</div><div class=\"line\">        //attr = x</div><div class=\"line\">        if(e.hasOwnProperty(attr))&#123; //如果这个判断不加，那么无论是公有的还是私有的都拿过来当私有的</div><div class=\"line\">            this[attr] = e[attr];</div><div class=\"line\">            //f[&apos;x&apos;] = e[&apos;x&apos;] ==&gt; f.x = 100;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // e.propertyIsEnumerable() //可枚举属性  ==&gt; 简单理解：可以拿出来一一列举的属性</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-混合继承\"><a href=\"#4-混合继承\" class=\"headerlink\" title=\"4 混合继承\"></a>4 混合继承</h3><p>原型+call  ==&gt; 无论是私有的还是公有的都拿过来了 ==&gt; 子类的原型上的多了一套父类私有属但是不会产生问题。因为子类的私有属性也有一套相同的通过call继承拿过来的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function G()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">&#125;</div><div class=\"line\">G.prototype.getX = function()&#123;&#125;;</div><div class=\"line\">function H()&#123;</div><div class=\"line\">    G.call(this);</div><div class=\"line\">&#125;</div><div class=\"line\">H.prototype = new G();</div><div class=\"line\">H.prototype.constructor = H;</div></pre></td></tr></table></figure></p>\n<h3 id=\"5-中间件继承\"><a href=\"#5-中间件继承\" class=\"headerlink\" title=\"5 中间件继承\"></a>5 中间件继承</h3><p>M.prototype.<strong>proto</strong> = K.prototype;  把父类的公有的当作子类的公有的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function K()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">&#125;</div><div class=\"line\">k.prototype.getX = function ()&#123;&#125;;</div><div class=\"line\">function M()&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">M.prototype.__proto__ = K.prototype; //本来应该是直接指向Object.prototype。从K的原型上的__proto__也可以到Object.prototype==&gt; 在K.prototype上停留了下，K.prototype就是一个中间件  父类的公有当作子类的公有</div></pre></td></tr></table></figure></p>\n<h3 id=\"6-寄生组合式继承\"><a href=\"#6-寄生组合式继承\" class=\"headerlink\" title=\"6 寄生组合式继承\"></a>6 寄生组合式继承</h3><p> Object.create(xx.prototype)方法  ==&gt; 是把xx.prototype当作别人家的原型  不兼容，只能找到父类原型的方法。父类的私有属性访问不到。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Parent() &#123;</div><div class=\"line\">    this.name = &quot;ywx&quot;;</div><div class=\"line\">&#125;</div><div class=\"line\">Parent.prototype.eat = function () &#123;</div><div class=\"line\">    console.log(123);</div><div class=\"line\">&#125;;</div><div class=\"line\">function Child() &#123;&#125;</div><div class=\"line\">//寄生组合式继承实现方式如下：</div><div class=\"line\">Child.prototype = Object.create(Parent.prototype);</div><div class=\"line\">var child=new Child();</div><div class=\"line\">console.log(child.eat());//只有找到父类原型上的方法</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>js中常用的继承方式: 子类继承父类的方法：</p>\n<h3 id=\"1、原型继承\"><a href=\"#1、原型继承\" class=\"headerlink\" title=\"1、原型继承\"></a>1、原型继承</h3><p>子类的原型指向父类的一个实例  父类的私有和公有方法都是子类的公有方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function A()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">    this.y = 100;</div><div class=\"line\">&#125;</div><div class=\"line\">A.prototype.getX = function ()&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">function B()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">&#125;</div><div class=\"line\">B.prototype = new A(); //B的原型重新赋值A的实例==&gt;每个b实例都能通过自己的__proto__找到a上的所有的私有方法，并且还可以通过a.__proto__继续找到A.prototype上的所有属性 ==&gt; A这个类上的方法相对于B都是公有方法</div><div class=\"line\">B.prototype.constructor = B; //由于重新修改了B的原型导致默认原型上的constructor丢失，我们需要自己添加上</div></pre></td></tr></table></figure></p>\n<h3 id=\"2、call继承\"><a href=\"#2、call继承\" class=\"headerlink\" title=\"2、call继承\"></a>2、call继承</h3><p>在子类构造函数中 父类.call(this)  父类的私有变成子类的私有<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function C()&#123;</div><div class=\"line\">    this.x = 100; //d.x = 100</div><div class=\"line\">&#125;</div><div class=\"line\">C.prototype.getX = function ()&#123;&#125;;</div><div class=\"line\">function D()&#123;</div><div class=\"line\">    C.call(this); //构造函数中的this就是当前实例  this ==&gt; d     C.call(d);  ==&gt; 把C中的this修改成d</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"3、冒充对象继承\"><a href=\"#3、冒充对象继承\" class=\"headerlink\" title=\"3、冒充对象继承\"></a>3、冒充对象继承</h3><p>循环遍历父类实例，然后父类实例的私有方法全部拿过来添加给子类实，如果不做hasOwnProperty判断那么就是把父类的公有的和私有的都拿过来当私有的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">function E()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">    this.y = 200;</div><div class=\"line\">&#125;</div><div class=\"line\">E.prototype.getX = function ()&#123;&#125;</div><div class=\"line\">function F()&#123;</div><div class=\"line\">    var e = new E(); //e.x = 100;</div><div class=\"line\">    for(var attr in e)&#123; //for in可以遍历到原型上的公有自定义属性</div><div class=\"line\">        //attr = x</div><div class=\"line\">        if(e.hasOwnProperty(attr))&#123; //如果这个判断不加，那么无论是公有的还是私有的都拿过来当私有的</div><div class=\"line\">            this[attr] = e[attr];</div><div class=\"line\">            //f[&apos;x&apos;] = e[&apos;x&apos;] ==&gt; f.x = 100;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // e.propertyIsEnumerable() //可枚举属性  ==&gt; 简单理解：可以拿出来一一列举的属性</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-混合继承\"><a href=\"#4-混合继承\" class=\"headerlink\" title=\"4 混合继承\"></a>4 混合继承</h3><p>原型+call  ==&gt; 无论是私有的还是公有的都拿过来了 ==&gt; 子类的原型上的多了一套父类私有属但是不会产生问题。因为子类的私有属性也有一套相同的通过call继承拿过来的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function G()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">&#125;</div><div class=\"line\">G.prototype.getX = function()&#123;&#125;;</div><div class=\"line\">function H()&#123;</div><div class=\"line\">    G.call(this);</div><div class=\"line\">&#125;</div><div class=\"line\">H.prototype = new G();</div><div class=\"line\">H.prototype.constructor = H;</div></pre></td></tr></table></figure></p>\n<h3 id=\"5-中间件继承\"><a href=\"#5-中间件继承\" class=\"headerlink\" title=\"5 中间件继承\"></a>5 中间件继承</h3><p>M.prototype.<strong>proto</strong> = K.prototype;  把父类的公有的当作子类的公有的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function K()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">&#125;</div><div class=\"line\">k.prototype.getX = function ()&#123;&#125;;</div><div class=\"line\">function M()&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">M.prototype.__proto__ = K.prototype; //本来应该是直接指向Object.prototype。从K的原型上的__proto__也可以到Object.prototype==&gt; 在K.prototype上停留了下，K.prototype就是一个中间件  父类的公有当作子类的公有</div></pre></td></tr></table></figure></p>\n<h3 id=\"6-寄生组合式继承\"><a href=\"#6-寄生组合式继承\" class=\"headerlink\" title=\"6 寄生组合式继承\"></a>6 寄生组合式继承</h3><p> Object.create(xx.prototype)方法  ==&gt; 是把xx.prototype当作别人家的原型  不兼容，只能找到父类原型的方法。父类的私有属性访问不到。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Parent() &#123;</div><div class=\"line\">    this.name = &quot;ywx&quot;;</div><div class=\"line\">&#125;</div><div class=\"line\">Parent.prototype.eat = function () &#123;</div><div class=\"line\">    console.log(123);</div><div class=\"line\">&#125;;</div><div class=\"line\">function Child() &#123;&#125;</div><div class=\"line\">//寄生组合式继承实现方式如下：</div><div class=\"line\">Child.prototype = Object.create(Parent.prototype);</div><div class=\"line\">var child=new Child();</div><div class=\"line\">console.log(child.eat());//只有找到父类原型上的方法</div></pre></td></tr></table></figure></p>\n"},{"title":"ES6-promise学习","date":"2016-01-05T14:10:58.000Z","_content":"#### Promise的含义\n所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。\n#### Promise对象有以下两个特点\n   1. 对象的状态不受外界影响。\n   Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。\n   2. 一旦状态改变，就不会再变，任何时候都可以得到这个结果。\n   Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。\n#### promise优缺点：\n有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。\n\nPromise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n#### 基本用法：\nES6规定，Promise对象是一个构造函数，用来生成Promise实例。\n```\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。\nPromise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。\n```\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure  失败的回调函数可以省略不写，是可选的。\n});\n```\n#### Promise.prototype.then()\nthen方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。\nthen方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\n#### Promise.prototype.catch()\nPromise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。\n#### Promise.all()\n Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。\n ```\n var p = Promise.all([p1, p2, p3]);\n ```\n####  Promise.race()\n Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。\n ```\n var p = Promise.race([p1, p2, p3]);\n ```\n 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise实例的返回值，就传递给p的回调函数。\n#### Promise.resolve()\n 有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。\n ```\n var jsPromise = Promise.resolve($.ajax('/whatever.json'));\n 上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。\n \n Promise.resolve等价于下面的写法。\n Promise.resolve('foo')\n // 等价于\n new Promise(resolve => resolve('foo'))\n ```\n#### Promise.reject()\nPromise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。它的参数用法与Promise.resolve方法完全一致。\n```\nvar p = Promise.reject('出错了');\n// 等同于\nvar p = new Promise((resolve, reject) => reject('出错了'))\n\np.then(null, function (s){\n  console.log(s)\n});\n// 出错了\n```\n上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。\n#### 两个有用的附加方法\n   1. done()\n     Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。\n   2. finally()\n     finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。\n","source":"_posts/ES6-promise.md","raw":"---\ntitle: ES6-promise学习\ndate: 2016-1-05 22:10:58\ntags: ES6、promise\n---\n#### Promise的含义\n所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。\n#### Promise对象有以下两个特点\n   1. 对象的状态不受外界影响。\n   Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。\n   2. 一旦状态改变，就不会再变，任何时候都可以得到这个结果。\n   Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。\n#### promise优缺点：\n有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。\n\nPromise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n#### 基本用法：\nES6规定，Promise对象是一个构造函数，用来生成Promise实例。\n```\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。\nPromise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。\n```\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure  失败的回调函数可以省略不写，是可选的。\n});\n```\n#### Promise.prototype.then()\nthen方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。\nthen方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\n#### Promise.prototype.catch()\nPromise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。\n#### Promise.all()\n Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。\n ```\n var p = Promise.all([p1, p2, p3]);\n ```\n####  Promise.race()\n Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。\n ```\n var p = Promise.race([p1, p2, p3]);\n ```\n 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise实例的返回值，就传递给p的回调函数。\n#### Promise.resolve()\n 有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。\n ```\n var jsPromise = Promise.resolve($.ajax('/whatever.json'));\n 上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。\n \n Promise.resolve等价于下面的写法。\n Promise.resolve('foo')\n // 等价于\n new Promise(resolve => resolve('foo'))\n ```\n#### Promise.reject()\nPromise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。它的参数用法与Promise.resolve方法完全一致。\n```\nvar p = Promise.reject('出错了');\n// 等同于\nvar p = new Promise((resolve, reject) => reject('出错了'))\n\np.then(null, function (s){\n  console.log(s)\n});\n// 出错了\n```\n上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。\n#### 两个有用的附加方法\n   1. done()\n     Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。\n   2. finally()\n     finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。\n","slug":"ES6-promise","published":1,"updated":"2016-12-22T01:47:35.984Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv590004jgtukk23z3mi","content":"<h4 id=\"Promise的含义\"><a href=\"#Promise的含义\" class=\"headerlink\" title=\"Promise的含义\"></a>Promise的含义</h4><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。</p>\n<h4 id=\"Promise对象有以下两个特点\"><a href=\"#Promise对象有以下两个特点\" class=\"headerlink\" title=\"Promise对象有以下两个特点\"></a>Promise对象有以下两个特点</h4><ol>\n<li>对象的状态不受外界影响。<br>Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。</li>\n<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<br>Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。<h4 id=\"promise优缺点：\"><a href=\"#promise优缺点：\" class=\"headerlink\" title=\"promise优缺点：\"></a>promise优缺点：</h4>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</li>\n</ol>\n<p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>\n<h4 id=\"基本用法：\"><a href=\"#基本用法：\" class=\"headerlink\" title=\"基本用法：\"></a>基本用法：</h4><p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promise = new Promise(function(resolve, reject) &#123;</div><div class=\"line\">  // ... some code</div><div class=\"line\"></div><div class=\"line\">  if (/* 异步操作成功 */)&#123;</div><div class=\"line\">    resolve(value);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    reject(error);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。<br>Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">promise.then(function(value) &#123;</div><div class=\"line\">  // success</div><div class=\"line\">&#125;, function(error) &#123;</div><div class=\"line\">  // failure  失败的回调函数可以省略不写，是可选的。</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Promise-prototype-then\"><a href=\"#Promise-prototype-then\" class=\"headerlink\" title=\"Promise.prototype.then()\"></a>Promise.prototype.then()</h4><p>then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。<br>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>\n<h4 id=\"Promise-prototype-catch\"><a href=\"#Promise-prototype-catch\" class=\"headerlink\" title=\"Promise.prototype.catch()\"></a>Promise.prototype.catch()</h4><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>\n<h4 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h4><p> Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p = Promise.all([p1, p2, p3]);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h4><p> Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p = Promise.race([p1, p2, p3]);</div></pre></td></tr></table></figure></p>\n<p> 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise实例的返回值，就传递给p的回调函数。</p>\n<h4 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h4><p> 有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var jsPromise = Promise.resolve($.ajax(&apos;/whatever.json&apos;));</div><div class=\"line\">上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。</div><div class=\"line\"></div><div class=\"line\">Promise.resolve等价于下面的写法。</div><div class=\"line\">Promise.resolve(&apos;foo&apos;)</div><div class=\"line\">// 等价于</div><div class=\"line\">new Promise(resolve =&gt; resolve(&apos;foo&apos;))</div></pre></td></tr></table></figure></p>\n<h4 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h4><p>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。它的参数用法与Promise.resolve方法完全一致。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p = Promise.reject(&apos;出错了&apos;);</div><div class=\"line\">// 等同于</div><div class=\"line\">var p = new Promise((resolve, reject) =&gt; reject(&apos;出错了&apos;))</div><div class=\"line\"></div><div class=\"line\">p.then(null, function (s)&#123;</div><div class=\"line\">  console.log(s)</div><div class=\"line\">&#125;);</div><div class=\"line\">// 出错了</div></pre></td></tr></table></figure></p>\n<p>上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。</p>\n<h4 id=\"两个有用的附加方法\"><a href=\"#两个有用的附加方法\" class=\"headerlink\" title=\"两个有用的附加方法\"></a>两个有用的附加方法</h4><ol>\n<li>done()<br>Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</li>\n<li>finally()<br>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。</li>\n</ol>\n","excerpt":"","more":"<h4 id=\"Promise的含义\"><a href=\"#Promise的含义\" class=\"headerlink\" title=\"Promise的含义\"></a>Promise的含义</h4><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。</p>\n<h4 id=\"Promise对象有以下两个特点\"><a href=\"#Promise对象有以下两个特点\" class=\"headerlink\" title=\"Promise对象有以下两个特点\"></a>Promise对象有以下两个特点</h4><ol>\n<li>对象的状态不受外界影响。<br>Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。</li>\n<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<br>Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。<h4 id=\"promise优缺点：\"><a href=\"#promise优缺点：\" class=\"headerlink\" title=\"promise优缺点：\"></a>promise优缺点：</h4>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</li>\n</ol>\n<p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>\n<h4 id=\"基本用法：\"><a href=\"#基本用法：\" class=\"headerlink\" title=\"基本用法：\"></a>基本用法：</h4><p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promise = new Promise(function(resolve, reject) &#123;</div><div class=\"line\">  // ... some code</div><div class=\"line\"></div><div class=\"line\">  if (/* 异步操作成功 */)&#123;</div><div class=\"line\">    resolve(value);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    reject(error);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。<br>Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">promise.then(function(value) &#123;</div><div class=\"line\">  // success</div><div class=\"line\">&#125;, function(error) &#123;</div><div class=\"line\">  // failure  失败的回调函数可以省略不写，是可选的。</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Promise-prototype-then\"><a href=\"#Promise-prototype-then\" class=\"headerlink\" title=\"Promise.prototype.then()\"></a>Promise.prototype.then()</h4><p>then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。<br>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>\n<h4 id=\"Promise-prototype-catch\"><a href=\"#Promise-prototype-catch\" class=\"headerlink\" title=\"Promise.prototype.catch()\"></a>Promise.prototype.catch()</h4><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>\n<h4 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h4><p> Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p = Promise.all([p1, p2, p3]);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h4><p> Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p = Promise.race([p1, p2, p3]);</div></pre></td></tr></table></figure></p>\n<p> 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise实例的返回值，就传递给p的回调函数。</p>\n<h4 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h4><p> 有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var jsPromise = Promise.resolve($.ajax(&apos;/whatever.json&apos;));</div><div class=\"line\">上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。</div><div class=\"line\"></div><div class=\"line\">Promise.resolve等价于下面的写法。</div><div class=\"line\">Promise.resolve(&apos;foo&apos;)</div><div class=\"line\">// 等价于</div><div class=\"line\">new Promise(resolve =&gt; resolve(&apos;foo&apos;))</div></pre></td></tr></table></figure></p>\n<h4 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h4><p>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。它的参数用法与Promise.resolve方法完全一致。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p = Promise.reject(&apos;出错了&apos;);</div><div class=\"line\">// 等同于</div><div class=\"line\">var p = new Promise((resolve, reject) =&gt; reject(&apos;出错了&apos;))</div><div class=\"line\"></div><div class=\"line\">p.then(null, function (s)&#123;</div><div class=\"line\">  console.log(s)</div><div class=\"line\">&#125;);</div><div class=\"line\">// 出错了</div></pre></td></tr></table></figure></p>\n<p>上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。</p>\n<h4 id=\"两个有用的附加方法\"><a href=\"#两个有用的附加方法\" class=\"headerlink\" title=\"两个有用的附加方法\"></a>两个有用的附加方法</h4><ol>\n<li>done()<br>Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</li>\n<li>finally()<br>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。</li>\n</ol>\n"},{"title":"一种新的对象创建方式——Object.create()","date":"2015-10-23T15:06:26.000Z","_content":"Object.create() 方法创建一个拥有指定原型和若干个指定属性的对象。\n1. 语法\n```\nObject.create(proto, [ propertiesObject ])\n```\n参数proto：一个对象，作为新创建对象的原型。如果 proto 参数不是 null 或一个对象值，则抛出一个 TypeError 异常。\npropertiesObject：可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符。注意：该参数对象不能是 undefined，另外只有该对象中自身拥有的可枚举的属性才有效，也就是说该对象的原型链上属性是无效的。\n#### 使用Object.create实现类式继承\n```\n//Shape - superclass\nfunction Shape() {\n  this.x = 0;\n  this.y = 0;\n}\n\nShape.prototype.move = function(x, y) {\n    this.x += x;\n    this.y += y;\n    console.info(\"Shape moved.\");\n};\n\n// Rectangle - subclass\nfunction Rectangle() {\n  Shape.call(this); //call super constructor.\n}\n\nRectangle.prototype = Object.create(Shape.prototype);\n\nvar rect = new Rectangle();\n\nrect instanceof Rectangle //true.\nrect instanceof Shape //true.\n\nrect.move(1, 1); //Outputs, \"Shape moved.\"\n```\n#### 使用Object.create 的 propertyObject 参数\n```\nvar o;\n\n// 创建一个原型为null的空对象\no = Object.create(null);\n\n\no = {};\n// 以字面量方式创建的空对象就相当于:\no = Object.create(Object.prototype);\n\n\no = Object.create(Object.prototype, {\n  // foo会成为所创建对象的数据属性\n  foo: { writable:true, configurable:true, value: \"hello\" },\n  // bar会成为所创建对象的访问器属性\n  bar: {\n    configurable: false,\n    get: function() { return 10 },\n    set: function(value) { console.log(\"Setting `o.bar` to\", value) }\n}})\n\n\nfunction Constructor(){}\no = new Constructor();\n// 上面的一句就相当于:\no = Object.create(Constructor.prototype);\n// 当然,如果在Constructor函数中有一些初始化代码,Object.create不能执行那些代码\n\n\n// 创建一个以另一个空对象为原型,且拥有一个属性p的对象\no = Object.create({}, { p: { value: 42 } })\n\n// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:\no.p = 24\no.p\n//42\n\no.q = 12\nfor (var prop in o) {\n   console.log(prop)\n}\n//\"q\"\n\ndelete o.p\n//false\n\n//创建一个可写的,可枚举的,可配置的属性p\no2 = Object.create({}, { p: { value: 42, writable: true, enumerable: true, configurable: true } });\n```\n\n \n","source":"_posts/Object.create.md","raw":"---\ntitle: 一种新的对象创建方式——Object.create()\ndate: 2015-10-23 23:06:26\ntags: es5 js\n---\nObject.create() 方法创建一个拥有指定原型和若干个指定属性的对象。\n1. 语法\n```\nObject.create(proto, [ propertiesObject ])\n```\n参数proto：一个对象，作为新创建对象的原型。如果 proto 参数不是 null 或一个对象值，则抛出一个 TypeError 异常。\npropertiesObject：可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符。注意：该参数对象不能是 undefined，另外只有该对象中自身拥有的可枚举的属性才有效，也就是说该对象的原型链上属性是无效的。\n#### 使用Object.create实现类式继承\n```\n//Shape - superclass\nfunction Shape() {\n  this.x = 0;\n  this.y = 0;\n}\n\nShape.prototype.move = function(x, y) {\n    this.x += x;\n    this.y += y;\n    console.info(\"Shape moved.\");\n};\n\n// Rectangle - subclass\nfunction Rectangle() {\n  Shape.call(this); //call super constructor.\n}\n\nRectangle.prototype = Object.create(Shape.prototype);\n\nvar rect = new Rectangle();\n\nrect instanceof Rectangle //true.\nrect instanceof Shape //true.\n\nrect.move(1, 1); //Outputs, \"Shape moved.\"\n```\n#### 使用Object.create 的 propertyObject 参数\n```\nvar o;\n\n// 创建一个原型为null的空对象\no = Object.create(null);\n\n\no = {};\n// 以字面量方式创建的空对象就相当于:\no = Object.create(Object.prototype);\n\n\no = Object.create(Object.prototype, {\n  // foo会成为所创建对象的数据属性\n  foo: { writable:true, configurable:true, value: \"hello\" },\n  // bar会成为所创建对象的访问器属性\n  bar: {\n    configurable: false,\n    get: function() { return 10 },\n    set: function(value) { console.log(\"Setting `o.bar` to\", value) }\n}})\n\n\nfunction Constructor(){}\no = new Constructor();\n// 上面的一句就相当于:\no = Object.create(Constructor.prototype);\n// 当然,如果在Constructor函数中有一些初始化代码,Object.create不能执行那些代码\n\n\n// 创建一个以另一个空对象为原型,且拥有一个属性p的对象\no = Object.create({}, { p: { value: 42 } })\n\n// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:\no.p = 24\no.p\n//42\n\no.q = 12\nfor (var prop in o) {\n   console.log(prop)\n}\n//\"q\"\n\ndelete o.p\n//false\n\n//创建一个可写的,可枚举的,可配置的属性p\no2 = Object.create({}, { p: { value: 42, writable: true, enumerable: true, configurable: true } });\n```\n\n \n","slug":"Object.create","published":1,"updated":"2016-12-22T01:36:20.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv5d0005jgtuxldx8k7n","content":"<p>Object.create() 方法创建一个拥有指定原型和若干个指定属性的对象。</p>\n<ol>\n<li>语法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object.create(proto, [ propertiesObject ])</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>参数proto：一个对象，作为新创建对象的原型。如果 proto 参数不是 null 或一个对象值，则抛出一个 TypeError 异常。<br>propertiesObject：可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符。注意：该参数对象不能是 undefined，另外只有该对象中自身拥有的可枚举的属性才有效，也就是说该对象的原型链上属性是无效的。</p>\n<h4 id=\"使用Object-create实现类式继承\"><a href=\"#使用Object-create实现类式继承\" class=\"headerlink\" title=\"使用Object.create实现类式继承\"></a>使用Object.create实现类式继承</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">//Shape - superclass</div><div class=\"line\">function Shape() &#123;</div><div class=\"line\">  this.x = 0;</div><div class=\"line\">  this.y = 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Shape.prototype.move = function(x, y) &#123;</div><div class=\"line\">    this.x += x;</div><div class=\"line\">    this.y += y;</div><div class=\"line\">    console.info(&quot;Shape moved.&quot;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// Rectangle - subclass</div><div class=\"line\">function Rectangle() &#123;</div><div class=\"line\">  Shape.call(this); //call super constructor.</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Rectangle.prototype = Object.create(Shape.prototype);</div><div class=\"line\"></div><div class=\"line\">var rect = new Rectangle();</div><div class=\"line\"></div><div class=\"line\">rect instanceof Rectangle //true.</div><div class=\"line\">rect instanceof Shape //true.</div><div class=\"line\"></div><div class=\"line\">rect.move(1, 1); //Outputs, &quot;Shape moved.&quot;</div></pre></td></tr></table></figure>\n<h4 id=\"使用Object-create-的-propertyObject-参数\"><a href=\"#使用Object-create-的-propertyObject-参数\" class=\"headerlink\" title=\"使用Object.create 的 propertyObject 参数\"></a>使用Object.create 的 propertyObject 参数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o;</div><div class=\"line\"></div><div class=\"line\">// 创建一个原型为null的空对象</div><div class=\"line\">o = Object.create(null);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">o = &#123;&#125;;</div><div class=\"line\">// 以字面量方式创建的空对象就相当于:</div><div class=\"line\">o = Object.create(Object.prototype);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">o = Object.create(Object.prototype, &#123;</div><div class=\"line\">  // foo会成为所创建对象的数据属性</div><div class=\"line\">  foo: &#123; writable:true, configurable:true, value: &quot;hello&quot; &#125;,</div><div class=\"line\">  // bar会成为所创建对象的访问器属性</div><div class=\"line\">  bar: &#123;</div><div class=\"line\">    configurable: false,</div><div class=\"line\">    get: function() &#123; return 10 &#125;,</div><div class=\"line\">    set: function(value) &#123; console.log(&quot;Setting `o.bar` to&quot;, value) &#125;</div><div class=\"line\">&#125;&#125;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">function Constructor()&#123;&#125;</div><div class=\"line\">o = new Constructor();</div><div class=\"line\">// 上面的一句就相当于:</div><div class=\"line\">o = Object.create(Constructor.prototype);</div><div class=\"line\">// 当然,如果在Constructor函数中有一些初始化代码,Object.create不能执行那些代码</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 创建一个以另一个空对象为原型,且拥有一个属性p的对象</div><div class=\"line\">o = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;)</div><div class=\"line\"></div><div class=\"line\">// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:</div><div class=\"line\">o.p = 24</div><div class=\"line\">o.p</div><div class=\"line\">//42</div><div class=\"line\"></div><div class=\"line\">o.q = 12</div><div class=\"line\">for (var prop in o) &#123;</div><div class=\"line\">   console.log(prop)</div><div class=\"line\">&#125;</div><div class=\"line\">//&quot;q&quot;</div><div class=\"line\"></div><div class=\"line\">delete o.p</div><div class=\"line\">//false</div><div class=\"line\"></div><div class=\"line\">//创建一个可写的,可枚举的,可配置的属性p</div><div class=\"line\">o2 = Object.create(&#123;&#125;, &#123; p: &#123; value: 42, writable: true, enumerable: true, configurable: true &#125; &#125;);</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>Object.create() 方法创建一个拥有指定原型和若干个指定属性的对象。</p>\n<ol>\n<li>语法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object.create(proto, [ propertiesObject ])</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>参数proto：一个对象，作为新创建对象的原型。如果 proto 参数不是 null 或一个对象值，则抛出一个 TypeError 异常。<br>propertiesObject：可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符。注意：该参数对象不能是 undefined，另外只有该对象中自身拥有的可枚举的属性才有效，也就是说该对象的原型链上属性是无效的。</p>\n<h4 id=\"使用Object-create实现类式继承\"><a href=\"#使用Object-create实现类式继承\" class=\"headerlink\" title=\"使用Object.create实现类式继承\"></a>使用Object.create实现类式继承</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">//Shape - superclass</div><div class=\"line\">function Shape() &#123;</div><div class=\"line\">  this.x = 0;</div><div class=\"line\">  this.y = 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Shape.prototype.move = function(x, y) &#123;</div><div class=\"line\">    this.x += x;</div><div class=\"line\">    this.y += y;</div><div class=\"line\">    console.info(&quot;Shape moved.&quot;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// Rectangle - subclass</div><div class=\"line\">function Rectangle() &#123;</div><div class=\"line\">  Shape.call(this); //call super constructor.</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Rectangle.prototype = Object.create(Shape.prototype);</div><div class=\"line\"></div><div class=\"line\">var rect = new Rectangle();</div><div class=\"line\"></div><div class=\"line\">rect instanceof Rectangle //true.</div><div class=\"line\">rect instanceof Shape //true.</div><div class=\"line\"></div><div class=\"line\">rect.move(1, 1); //Outputs, &quot;Shape moved.&quot;</div></pre></td></tr></table></figure>\n<h4 id=\"使用Object-create-的-propertyObject-参数\"><a href=\"#使用Object-create-的-propertyObject-参数\" class=\"headerlink\" title=\"使用Object.create 的 propertyObject 参数\"></a>使用Object.create 的 propertyObject 参数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o;</div><div class=\"line\"></div><div class=\"line\">// 创建一个原型为null的空对象</div><div class=\"line\">o = Object.create(null);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">o = &#123;&#125;;</div><div class=\"line\">// 以字面量方式创建的空对象就相当于:</div><div class=\"line\">o = Object.create(Object.prototype);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">o = Object.create(Object.prototype, &#123;</div><div class=\"line\">  // foo会成为所创建对象的数据属性</div><div class=\"line\">  foo: &#123; writable:true, configurable:true, value: &quot;hello&quot; &#125;,</div><div class=\"line\">  // bar会成为所创建对象的访问器属性</div><div class=\"line\">  bar: &#123;</div><div class=\"line\">    configurable: false,</div><div class=\"line\">    get: function() &#123; return 10 &#125;,</div><div class=\"line\">    set: function(value) &#123; console.log(&quot;Setting `o.bar` to&quot;, value) &#125;</div><div class=\"line\">&#125;&#125;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">function Constructor()&#123;&#125;</div><div class=\"line\">o = new Constructor();</div><div class=\"line\">// 上面的一句就相当于:</div><div class=\"line\">o = Object.create(Constructor.prototype);</div><div class=\"line\">// 当然,如果在Constructor函数中有一些初始化代码,Object.create不能执行那些代码</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 创建一个以另一个空对象为原型,且拥有一个属性p的对象</div><div class=\"line\">o = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;)</div><div class=\"line\"></div><div class=\"line\">// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:</div><div class=\"line\">o.p = 24</div><div class=\"line\">o.p</div><div class=\"line\">//42</div><div class=\"line\"></div><div class=\"line\">o.q = 12</div><div class=\"line\">for (var prop in o) &#123;</div><div class=\"line\">   console.log(prop)</div><div class=\"line\">&#125;</div><div class=\"line\">//&quot;q&quot;</div><div class=\"line\"></div><div class=\"line\">delete o.p</div><div class=\"line\">//false</div><div class=\"line\"></div><div class=\"line\">//创建一个可写的,可枚举的,可配置的属性p</div><div class=\"line\">o2 = Object.create(&#123;&#125;, &#123; p: &#123; value: 42, writable: true, enumerable: true, configurable: true &#125; &#125;);</div></pre></td></tr></table></figure>\n"},{"title":"基于Jenkins的持续集成CI","date":"2016-12-02T05:29:54.000Z","_content":"#### CI（continuous integration）持续集成\n持续集成指的是，频繁地（一天多次）将代码集成到主干。持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。\n一次构建：可能包含编译，测试，审查和部署，以及其他一些事情，一次构建就是将源代码放在一起，并验证软件是否可以作为一个一致的单元运行的过程。可以理解为频繁的在多个团队的工作中集成，并且给与反馈的过程。团队开发成员经常集成它们的工作，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。\n#### CI场景如下：\n（1）开发人员向版本控制库提交代码，同时，集成构建计算机上的CI服务器正在轮询检查版本控制库中的变更\n（2）在提交发生之后，CI服务器检测到版本控制库中发生了变更，所以CI服务器会从库中取得最新的代码副本，执行构建脚本，该脚本将对软件进行集成\n（3）CI服务器向指定的项目成员发成电子邮件，提供构建结果的反馈信息。\n（4）CI服务器继续轮询版本控制库中的变更。\n#### CI持续集成周期\n一个典型的持续集成周期包括以下几个步骤：\n（1）持续集成服务器不断从版本控制服务器上检查代码状态，看代码是否有更新。\n（2）如果发现代码有最新的提交，那么就从版本控制服务器下载最新的代码。\n（3）等代码完全更新以后，调用自动化编译脚本，进行代码编译。\n（4）运行所有的自动化测试。\n（5）进行代码分析。\n（6）产生可执行的软件，能够提供给测试人员进行测试。\n#### CI系统\n在CI中您需要一个版本控制库，比如（GIT或者SVN）来执行CI。版本控制库，大家都知道git，可以方便的管理源代码，可以沿着时间轴取得不同同版本的代码。CI服务器在变更提交到版本库后执行的集成构建，他会每个一段时间去检查版本库中的变更，所以我们需要对CI服务器进行配置。CI服务器还需要提供一个方便的显示板来显示构建的结果。但是CI服务器并不是必须的，也**可以通过执行构建脚本来执行构建**。\n\n从上面我们知道CI的4个基本特征：与版本控制库链接，构建脚本，某种类型的反馈机制，集成源代码变更的过程。这也是CI系统的4个基本功能。一个好的CI系统的关键特征就是速度，这个系统的本质就及时向开发者和项目风险承担者提供反馈信息。\n\n既然CI这么好，但还是有些团队并没有选择使用，其实这是一个综合考虑的结果。使用CI会增加一些成本的，比如增加了维护CI系统的开销，变化太多尤其是对于老项目需要改变很多才能实现CI。失败的构建太多，如果在提交代码之前没有私有构建一次，就会造成在使用ci的时候变更变得频繁。存在额外的硬件和软件成本，使用ci就需要一台独立的集成服务器。\n#### CI工具\n持续集成工具：jenkins、CruiseControl、Hudson、gauntlet\n构建工具：Maven、Ant、groovy\nCDBI：持续数据库集成，即每次项目的版本控制库中发生变更时，重建数据库和测试数据。\n\n#### 建议使用Jenkins\nJenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。Jenkins 还提供了非常丰富的插件支持，这使得 Jenkins 变得越来越强大。我们可以方便的安装各种第三方插件，从而方便快捷的集成第三方的应用。\n#### 基于Jenkins快速搭建CI环境\n首先要知道一个持续集成环境需要包括三个方面要素：代码存储库、构建过程和持续集成服务器。\n​代码存储库一般使用GITlab;\n1、开始新建一个 Jenkins 项目， 由于我们需要连接gitlab的代码仓库， 我们选择 Build a free-style software project。\n\n2、然后配置这个 JenkinsTest 项目了，根据实际的 gitlab服务器信息配置 Source Code Management，这能让 Jenkins 知道如何从哪里获取最新的代码。\n\n3、根据开发需要，隔一段时间需要重新构建一次。选择 Build periodically，在 Schedule 中填写 0 * * * *对应的构建时间。\n\n4、添加 build 的步骤了。Jenkins 提供了四个选项供我们选择，可以根据需要执行或调用外部命令和脚本，例如ant、shell、maven等等。这些脚本都是根据需要自己配置的。\n\n5、可以在 Jenkins 中观察构建的进度和最终的状态——成功或者失败。太阳代表之前的构建没有任何失败，蓝色的小球代表构建成功。也可以在JenkinsTest 查看单次构建的 Console 的输出结果。从中能看到构建的第一步是从 gitlab服务器上 check out 代码，然后在build。\n\n声明：文章部分内容参考来源于网络。","source":"_posts/Jenkins-CI.md","raw":"---\ntitle: 基于Jenkins的持续集成CI\ndate: 2016-12-02 13:29:54\ntags: Jenkins CI\n---\n#### CI（continuous integration）持续集成\n持续集成指的是，频繁地（一天多次）将代码集成到主干。持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。\n一次构建：可能包含编译，测试，审查和部署，以及其他一些事情，一次构建就是将源代码放在一起，并验证软件是否可以作为一个一致的单元运行的过程。可以理解为频繁的在多个团队的工作中集成，并且给与反馈的过程。团队开发成员经常集成它们的工作，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。\n#### CI场景如下：\n（1）开发人员向版本控制库提交代码，同时，集成构建计算机上的CI服务器正在轮询检查版本控制库中的变更\n（2）在提交发生之后，CI服务器检测到版本控制库中发生了变更，所以CI服务器会从库中取得最新的代码副本，执行构建脚本，该脚本将对软件进行集成\n（3）CI服务器向指定的项目成员发成电子邮件，提供构建结果的反馈信息。\n（4）CI服务器继续轮询版本控制库中的变更。\n#### CI持续集成周期\n一个典型的持续集成周期包括以下几个步骤：\n（1）持续集成服务器不断从版本控制服务器上检查代码状态，看代码是否有更新。\n（2）如果发现代码有最新的提交，那么就从版本控制服务器下载最新的代码。\n（3）等代码完全更新以后，调用自动化编译脚本，进行代码编译。\n（4）运行所有的自动化测试。\n（5）进行代码分析。\n（6）产生可执行的软件，能够提供给测试人员进行测试。\n#### CI系统\n在CI中您需要一个版本控制库，比如（GIT或者SVN）来执行CI。版本控制库，大家都知道git，可以方便的管理源代码，可以沿着时间轴取得不同同版本的代码。CI服务器在变更提交到版本库后执行的集成构建，他会每个一段时间去检查版本库中的变更，所以我们需要对CI服务器进行配置。CI服务器还需要提供一个方便的显示板来显示构建的结果。但是CI服务器并不是必须的，也**可以通过执行构建脚本来执行构建**。\n\n从上面我们知道CI的4个基本特征：与版本控制库链接，构建脚本，某种类型的反馈机制，集成源代码变更的过程。这也是CI系统的4个基本功能。一个好的CI系统的关键特征就是速度，这个系统的本质就及时向开发者和项目风险承担者提供反馈信息。\n\n既然CI这么好，但还是有些团队并没有选择使用，其实这是一个综合考虑的结果。使用CI会增加一些成本的，比如增加了维护CI系统的开销，变化太多尤其是对于老项目需要改变很多才能实现CI。失败的构建太多，如果在提交代码之前没有私有构建一次，就会造成在使用ci的时候变更变得频繁。存在额外的硬件和软件成本，使用ci就需要一台独立的集成服务器。\n#### CI工具\n持续集成工具：jenkins、CruiseControl、Hudson、gauntlet\n构建工具：Maven、Ant、groovy\nCDBI：持续数据库集成，即每次项目的版本控制库中发生变更时，重建数据库和测试数据。\n\n#### 建议使用Jenkins\nJenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。Jenkins 还提供了非常丰富的插件支持，这使得 Jenkins 变得越来越强大。我们可以方便的安装各种第三方插件，从而方便快捷的集成第三方的应用。\n#### 基于Jenkins快速搭建CI环境\n首先要知道一个持续集成环境需要包括三个方面要素：代码存储库、构建过程和持续集成服务器。\n​代码存储库一般使用GITlab;\n1、开始新建一个 Jenkins 项目， 由于我们需要连接gitlab的代码仓库， 我们选择 Build a free-style software project。\n\n2、然后配置这个 JenkinsTest 项目了，根据实际的 gitlab服务器信息配置 Source Code Management，这能让 Jenkins 知道如何从哪里获取最新的代码。\n\n3、根据开发需要，隔一段时间需要重新构建一次。选择 Build periodically，在 Schedule 中填写 0 * * * *对应的构建时间。\n\n4、添加 build 的步骤了。Jenkins 提供了四个选项供我们选择，可以根据需要执行或调用外部命令和脚本，例如ant、shell、maven等等。这些脚本都是根据需要自己配置的。\n\n5、可以在 Jenkins 中观察构建的进度和最终的状态——成功或者失败。太阳代表之前的构建没有任何失败，蓝色的小球代表构建成功。也可以在JenkinsTest 查看单次构建的 Console 的输出结果。从中能看到构建的第一步是从 gitlab服务器上 check out 代码，然后在build。\n\n声明：文章部分内容参考来源于网络。","slug":"Jenkins-CI","published":1,"updated":"2016-12-22T05:54:19.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv5e0006jgtuch22xz0x","content":"<h4 id=\"CI（continuous-integration）持续集成\"><a href=\"#CI（continuous-integration）持续集成\" class=\"headerlink\" title=\"CI（continuous integration）持续集成\"></a>CI（continuous integration）持续集成</h4><p>持续集成指的是，频繁地（一天多次）将代码集成到主干。持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。<br>一次构建：可能包含编译，测试，审查和部署，以及其他一些事情，一次构建就是将源代码放在一起，并验证软件是否可以作为一个一致的单元运行的过程。可以理解为频繁的在多个团队的工作中集成，并且给与反馈的过程。团队开发成员经常集成它们的工作，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p>\n<h4 id=\"CI场景如下：\"><a href=\"#CI场景如下：\" class=\"headerlink\" title=\"CI场景如下：\"></a>CI场景如下：</h4><p>（1）开发人员向版本控制库提交代码，同时，集成构建计算机上的CI服务器正在轮询检查版本控制库中的变更<br>（2）在提交发生之后，CI服务器检测到版本控制库中发生了变更，所以CI服务器会从库中取得最新的代码副本，执行构建脚本，该脚本将对软件进行集成<br>（3）CI服务器向指定的项目成员发成电子邮件，提供构建结果的反馈信息。<br>（4）CI服务器继续轮询版本控制库中的变更。</p>\n<h4 id=\"CI持续集成周期\"><a href=\"#CI持续集成周期\" class=\"headerlink\" title=\"CI持续集成周期\"></a>CI持续集成周期</h4><p>一个典型的持续集成周期包括以下几个步骤：<br>（1）持续集成服务器不断从版本控制服务器上检查代码状态，看代码是否有更新。<br>（2）如果发现代码有最新的提交，那么就从版本控制服务器下载最新的代码。<br>（3）等代码完全更新以后，调用自动化编译脚本，进行代码编译。<br>（4）运行所有的自动化测试。<br>（5）进行代码分析。<br>（6）产生可执行的软件，能够提供给测试人员进行测试。</p>\n<h4 id=\"CI系统\"><a href=\"#CI系统\" class=\"headerlink\" title=\"CI系统\"></a>CI系统</h4><p>在CI中您需要一个版本控制库，比如（GIT或者SVN）来执行CI。版本控制库，大家都知道git，可以方便的管理源代码，可以沿着时间轴取得不同同版本的代码。CI服务器在变更提交到版本库后执行的集成构建，他会每个一段时间去检查版本库中的变更，所以我们需要对CI服务器进行配置。CI服务器还需要提供一个方便的显示板来显示构建的结果。但是CI服务器并不是必须的，也<strong>可以通过执行构建脚本来执行构建</strong>。</p>\n<p>从上面我们知道CI的4个基本特征：与版本控制库链接，构建脚本，某种类型的反馈机制，集成源代码变更的过程。这也是CI系统的4个基本功能。一个好的CI系统的关键特征就是速度，这个系统的本质就及时向开发者和项目风险承担者提供反馈信息。</p>\n<p>既然CI这么好，但还是有些团队并没有选择使用，其实这是一个综合考虑的结果。使用CI会增加一些成本的，比如增加了维护CI系统的开销，变化太多尤其是对于老项目需要改变很多才能实现CI。失败的构建太多，如果在提交代码之前没有私有构建一次，就会造成在使用ci的时候变更变得频繁。存在额外的硬件和软件成本，使用ci就需要一台独立的集成服务器。</p>\n<h4 id=\"CI工具\"><a href=\"#CI工具\" class=\"headerlink\" title=\"CI工具\"></a>CI工具</h4><p>持续集成工具：jenkins、CruiseControl、Hudson、gauntlet<br>构建工具：Maven、Ant、groovy<br>CDBI：持续数据库集成，即每次项目的版本控制库中发生变更时，重建数据库和测试数据。</p>\n<h4 id=\"建议使用Jenkins\"><a href=\"#建议使用Jenkins\" class=\"headerlink\" title=\"建议使用Jenkins\"></a>建议使用Jenkins</h4><p>Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。Jenkins 还提供了非常丰富的插件支持，这使得 Jenkins 变得越来越强大。我们可以方便的安装各种第三方插件，从而方便快捷的集成第三方的应用。</p>\n<h4 id=\"基于Jenkins快速搭建CI环境\"><a href=\"#基于Jenkins快速搭建CI环境\" class=\"headerlink\" title=\"基于Jenkins快速搭建CI环境\"></a>基于Jenkins快速搭建CI环境</h4><p>首先要知道一个持续集成环境需要包括三个方面要素：代码存储库、构建过程和持续集成服务器。<br>​代码存储库一般使用GITlab;<br>1、开始新建一个 Jenkins 项目， 由于我们需要连接gitlab的代码仓库， 我们选择 Build a free-style software project。</p>\n<p>2、然后配置这个 JenkinsTest 项目了，根据实际的 gitlab服务器信息配置 Source Code Management，这能让 Jenkins 知道如何从哪里获取最新的代码。</p>\n<p>3、根据开发需要，隔一段时间需要重新构建一次。选择 Build periodically，在 Schedule 中填写 0 <em> </em> <em> </em>对应的构建时间。</p>\n<p>4、添加 build 的步骤了。Jenkins 提供了四个选项供我们选择，可以根据需要执行或调用外部命令和脚本，例如ant、shell、maven等等。这些脚本都是根据需要自己配置的。</p>\n<p>5、可以在 Jenkins 中观察构建的进度和最终的状态——成功或者失败。太阳代表之前的构建没有任何失败，蓝色的小球代表构建成功。也可以在JenkinsTest 查看单次构建的 Console 的输出结果。从中能看到构建的第一步是从 gitlab服务器上 check out 代码，然后在build。</p>\n<p>声明：文章部分内容参考来源于网络。</p>\n","excerpt":"","more":"<h4 id=\"CI（continuous-integration）持续集成\"><a href=\"#CI（continuous-integration）持续集成\" class=\"headerlink\" title=\"CI（continuous integration）持续集成\"></a>CI（continuous integration）持续集成</h4><p>持续集成指的是，频繁地（一天多次）将代码集成到主干。持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。<br>一次构建：可能包含编译，测试，审查和部署，以及其他一些事情，一次构建就是将源代码放在一起，并验证软件是否可以作为一个一致的单元运行的过程。可以理解为频繁的在多个团队的工作中集成，并且给与反馈的过程。团队开发成员经常集成它们的工作，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p>\n<h4 id=\"CI场景如下：\"><a href=\"#CI场景如下：\" class=\"headerlink\" title=\"CI场景如下：\"></a>CI场景如下：</h4><p>（1）开发人员向版本控制库提交代码，同时，集成构建计算机上的CI服务器正在轮询检查版本控制库中的变更<br>（2）在提交发生之后，CI服务器检测到版本控制库中发生了变更，所以CI服务器会从库中取得最新的代码副本，执行构建脚本，该脚本将对软件进行集成<br>（3）CI服务器向指定的项目成员发成电子邮件，提供构建结果的反馈信息。<br>（4）CI服务器继续轮询版本控制库中的变更。</p>\n<h4 id=\"CI持续集成周期\"><a href=\"#CI持续集成周期\" class=\"headerlink\" title=\"CI持续集成周期\"></a>CI持续集成周期</h4><p>一个典型的持续集成周期包括以下几个步骤：<br>（1）持续集成服务器不断从版本控制服务器上检查代码状态，看代码是否有更新。<br>（2）如果发现代码有最新的提交，那么就从版本控制服务器下载最新的代码。<br>（3）等代码完全更新以后，调用自动化编译脚本，进行代码编译。<br>（4）运行所有的自动化测试。<br>（5）进行代码分析。<br>（6）产生可执行的软件，能够提供给测试人员进行测试。</p>\n<h4 id=\"CI系统\"><a href=\"#CI系统\" class=\"headerlink\" title=\"CI系统\"></a>CI系统</h4><p>在CI中您需要一个版本控制库，比如（GIT或者SVN）来执行CI。版本控制库，大家都知道git，可以方便的管理源代码，可以沿着时间轴取得不同同版本的代码。CI服务器在变更提交到版本库后执行的集成构建，他会每个一段时间去检查版本库中的变更，所以我们需要对CI服务器进行配置。CI服务器还需要提供一个方便的显示板来显示构建的结果。但是CI服务器并不是必须的，也<strong>可以通过执行构建脚本来执行构建</strong>。</p>\n<p>从上面我们知道CI的4个基本特征：与版本控制库链接，构建脚本，某种类型的反馈机制，集成源代码变更的过程。这也是CI系统的4个基本功能。一个好的CI系统的关键特征就是速度，这个系统的本质就及时向开发者和项目风险承担者提供反馈信息。</p>\n<p>既然CI这么好，但还是有些团队并没有选择使用，其实这是一个综合考虑的结果。使用CI会增加一些成本的，比如增加了维护CI系统的开销，变化太多尤其是对于老项目需要改变很多才能实现CI。失败的构建太多，如果在提交代码之前没有私有构建一次，就会造成在使用ci的时候变更变得频繁。存在额外的硬件和软件成本，使用ci就需要一台独立的集成服务器。</p>\n<h4 id=\"CI工具\"><a href=\"#CI工具\" class=\"headerlink\" title=\"CI工具\"></a>CI工具</h4><p>持续集成工具：jenkins、CruiseControl、Hudson、gauntlet<br>构建工具：Maven、Ant、groovy<br>CDBI：持续数据库集成，即每次项目的版本控制库中发生变更时，重建数据库和测试数据。</p>\n<h4 id=\"建议使用Jenkins\"><a href=\"#建议使用Jenkins\" class=\"headerlink\" title=\"建议使用Jenkins\"></a>建议使用Jenkins</h4><p>Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。Jenkins 还提供了非常丰富的插件支持，这使得 Jenkins 变得越来越强大。我们可以方便的安装各种第三方插件，从而方便快捷的集成第三方的应用。</p>\n<h4 id=\"基于Jenkins快速搭建CI环境\"><a href=\"#基于Jenkins快速搭建CI环境\" class=\"headerlink\" title=\"基于Jenkins快速搭建CI环境\"></a>基于Jenkins快速搭建CI环境</h4><p>首先要知道一个持续集成环境需要包括三个方面要素：代码存储库、构建过程和持续集成服务器。<br>​代码存储库一般使用GITlab;<br>1、开始新建一个 Jenkins 项目， 由于我们需要连接gitlab的代码仓库， 我们选择 Build a free-style software project。</p>\n<p>2、然后配置这个 JenkinsTest 项目了，根据实际的 gitlab服务器信息配置 Source Code Management，这能让 Jenkins 知道如何从哪里获取最新的代码。</p>\n<p>3、根据开发需要，隔一段时间需要重新构建一次。选择 Build periodically，在 Schedule 中填写 0 <em> </em> <em> </em>对应的构建时间。</p>\n<p>4、添加 build 的步骤了。Jenkins 提供了四个选项供我们选择，可以根据需要执行或调用外部命令和脚本，例如ant、shell、maven等等。这些脚本都是根据需要自己配置的。</p>\n<p>5、可以在 Jenkins 中观察构建的进度和最终的状态——成功或者失败。太阳代表之前的构建没有任何失败，蓝色的小球代表构建成功。也可以在JenkinsTest 查看单次构建的 Console 的输出结果。从中能看到构建的第一步是从 gitlab服务器上 check out 代码，然后在build。</p>\n<p>声明：文章部分内容参考来源于网络。</p>\n"},{"title":"Angular中的测试-Karma","date":"2016-08-12T12:34:29.000Z","_content":"#### AngularJS 测试的类型\n   1. 单元测试\n    我们可以专注于构建我们的测试来隔离具体、单独组件的代码。这种方法被称为“单元测试”，在不同阶段、不同条件下、以不同的输入来测试各种特定单元的代码。\n    单元测试专门用于测试小型、独立的代码单元，单个函数，或者较小的带有功能的交互。它不是用来测试大功能集的。\n    单元测试的麻烦在于把逻辑隔离成小块，这样我们才能测试它.\n   2. 端到端测试\n    另一方面，也可以对我们的应用作黑盒测试（也就是端到端测试）。在端到端（E2E）测试中，我们测试应用的视角是：作为最终用户，对系统的底层实现一无所知。这种方法非常适合测 试大型应用的功能。端到端测试适合测试页面上的用户交互，无需手动刷新页面。\n    关于这类测试的介绍并不新鲜，还有些了不起的工具，能使我们建立自动化的浏览器测试。我们可以使用工具如PhantomJS或CasperJS来进行无头浏览器测试（即不必打开浏览器），或Karma等工具，会真正将打开一个浏览器并在一个iframe中执行所有的测试。\n#### Karma\nKarma测试运行器同时支持单元测试和端到端测试\n要运行我们的测试，需要安装Karma测试运行器。\n```\n$ npm install -g karma\n```\n运行一个Karma测试挺容易的： karma start path/to/karma.config.js(例：test/karma.config.js)。当测试运行器启\n动的时候，它会把在Karma配置文件中列出的浏览器启动起来，默认情况下，如果不是另有规定， Karma将监控配置文件中列出的所有文件。任何时候有文产生了变化， Karma都将运行适当的测试。\n#### 初始化 Karma 配置文件\nKarma给了我们一个生成器来创建配置文件。这个生成器会问几个关于要怎样建立配置文件的问题，每个问题建议了一个默认值，可以简单地接受所有默认值即可。用karma init生成器来创建karma.conf.js配置文件。\n   1. 建立单元测试\n   在测试文件的路径运行karma init命令，在我的例子中，在tests目录中创建Karma配置文件：\n   ```\n   $ karma init test/karma.conf.js\n   ```\n   对于单元测试而言，运行测试所需的依赖项都要具备。当使用Karma生成器来构建单元测试 时，单元测试包含下列这些代码的引用是很重要的：\n   一、 一个测试框架（选一个）1、Jasmine（默认）2、Mocha  3、QUnit。二、自定义的配置文件（需要w/Mocha）三、所需的第三方代码。\n   四、应用特有的代码。五、测试代码。六、模拟用的angular-mock.js库。\n    单元测试需要引用待测试应用的所有代码，也要引用所有要写的测试代码。\n   #### 例如，一个示例单元测试的Karma配置文件可能看起来像下面这样：\n    ```\n    module.exports = function(config) {\n    config.set({\n    basePath: '..',\n    frameworks: ['jasmine'],\n    files: [\n    'lib/angular.js',\n    'lib/angular-route.js',\n    'test/lib/angular-mocks.js',\n    'js/**/*.js',\n    'test/unit/**/*.js'\n    ],\n    exclude: [],\n    port: 8080,\n    logLevel: config.LOG_INFO,\n    autoWatch: true,\n    browsers: ['Safari'],\n    singleRun: false\n    });\n    };\n    ```\n   设置了这个文件之后，就能像下面这样运行单元测试了：\n    ```\n    $ karma run test/karma.conf.js\n    ```\n   另外，如果想在每次代码有变化时运行单元测试（如果把autoWatch设置成了true） ，可以像下面这样：\n    ```\n    $ karma start test/karma.conf.js\n    ```\n   2. 建立端到端测试\n   要设置端到端测试，要使用端到端测试Karma配置文件的路径来运行Karma生成器。\n   ```\n   $ karma init test/karma-e2e.conf.js\n   ```\n   端到端测试要使用ng-scenario框架。不像单元测试那样，我们不需要引用所有的库代码：端到端测试是跑在服务器上的， ng-scenario框架只   需要在浏览器中加载所有这些测试就可以了。\n   ##### 端到端测试的示例Karma配置文件可能长这样：\n   ```\n   module.exports = function(config) {\n   config.set({\n   basePath: '..',\n   frameworks: ['ng-scenario'],\n   files: [\n   'test/e2e/**/*.js'\n   ],\n   exclude: [],\n   port: 8080,\n   logLevel: config.LOG_INFO,\n   autoWatch: false,\n   browsers: ['Chrome'],\n   singleRun: false,\n   urlRoot: '/_karma_/',\n   proxies: {\n   '/': 'http://localhost:9000/'\n   }\n   });\n   };\n   ```\n   设置好这个配置后，就可以这样运行端到端测试：\n   ```\n   $ karma run test/karma-e2e.conf.js\n   ```\n   如果想要在每次代码有变化时运行我们的测试（如果把autoWatch设置成了true)同上。\n#### 配置选项\n   1. 框架\n   生成器会问我们使用哪个测试框架来做测试。 Jasmine是默认的测试框架，不过，生成器默认也支持Mocha、 QUnit和其他测试框架。\n   这些测试框架都需要安装额外的npm库。例如，要使用Jasmine框架，需要安装Jasmine插件。\n   ```\n   $ npm install --save-dev karma-jasmine\n   ```\n   然后设置`frameworks: ['jasmine']`;\n   2. RequireJS\n   如果这个项目使用了RequireJS库，询问是否要包含RequireJS的，就要回答yes。如果项目没有包含它，就选no,不是把项目中所有文件都列在Karma配置文件中，而是要包含单独的测试文件，它负责加载特定模块。\n   3. 浏览器捕获\n   Karma生成器会询问要自动启动哪个浏览器来捕获测试结果。终止测试运行器时， Karma也会把这些浏览器关掉。我们也可以用浏览器打开Karma Web服务器监听的URL（默认为http://localhost:9876 ）来测试，如果要从本地网络的另一台机器（或者虚拟机）的IE来测试的话，\n   这一点值得牢记。\n   要使用Karma来启动和运行，每个浏览器都需要安装额外的插件。我们可以使用npm来安装这些插件。例如，为了让Karma控制Chrome，我们就要安装Chrome启动插件。\n   ```\n   $ npm install --save-dev karma-chrome-launcher\n   ```\n   如果要使用Safari，就要安装Safari启动插件，对于Firefox，就要安装Firefox启动插件，其他类同。\n   ```\n   browsers: ['Chrome', 'Safari']\n   ```\n测试指令也比测试控制器容易得多。指令并不一定要有视图模板。通常情况下，它们可以只作为视图之下处理数据的垫片。ngModelController控制器就是这种功能派上用场的一个例子。\n   其他配置可以按字面意思猜测出来了，更多案例详细讲解请参照angular权威指南19章。\n\n","source":"_posts/angualr-19-Karma.md","raw":"---\ntitle: Angular中的测试-Karma\ndate: 2016-08-12 20:34:29\ntags: angular、Karma\n---\n#### AngularJS 测试的类型\n   1. 单元测试\n    我们可以专注于构建我们的测试来隔离具体、单独组件的代码。这种方法被称为“单元测试”，在不同阶段、不同条件下、以不同的输入来测试各种特定单元的代码。\n    单元测试专门用于测试小型、独立的代码单元，单个函数，或者较小的带有功能的交互。它不是用来测试大功能集的。\n    单元测试的麻烦在于把逻辑隔离成小块，这样我们才能测试它.\n   2. 端到端测试\n    另一方面，也可以对我们的应用作黑盒测试（也就是端到端测试）。在端到端（E2E）测试中，我们测试应用的视角是：作为最终用户，对系统的底层实现一无所知。这种方法非常适合测 试大型应用的功能。端到端测试适合测试页面上的用户交互，无需手动刷新页面。\n    关于这类测试的介绍并不新鲜，还有些了不起的工具，能使我们建立自动化的浏览器测试。我们可以使用工具如PhantomJS或CasperJS来进行无头浏览器测试（即不必打开浏览器），或Karma等工具，会真正将打开一个浏览器并在一个iframe中执行所有的测试。\n#### Karma\nKarma测试运行器同时支持单元测试和端到端测试\n要运行我们的测试，需要安装Karma测试运行器。\n```\n$ npm install -g karma\n```\n运行一个Karma测试挺容易的： karma start path/to/karma.config.js(例：test/karma.config.js)。当测试运行器启\n动的时候，它会把在Karma配置文件中列出的浏览器启动起来，默认情况下，如果不是另有规定， Karma将监控配置文件中列出的所有文件。任何时候有文产生了变化， Karma都将运行适当的测试。\n#### 初始化 Karma 配置文件\nKarma给了我们一个生成器来创建配置文件。这个生成器会问几个关于要怎样建立配置文件的问题，每个问题建议了一个默认值，可以简单地接受所有默认值即可。用karma init生成器来创建karma.conf.js配置文件。\n   1. 建立单元测试\n   在测试文件的路径运行karma init命令，在我的例子中，在tests目录中创建Karma配置文件：\n   ```\n   $ karma init test/karma.conf.js\n   ```\n   对于单元测试而言，运行测试所需的依赖项都要具备。当使用Karma生成器来构建单元测试 时，单元测试包含下列这些代码的引用是很重要的：\n   一、 一个测试框架（选一个）1、Jasmine（默认）2、Mocha  3、QUnit。二、自定义的配置文件（需要w/Mocha）三、所需的第三方代码。\n   四、应用特有的代码。五、测试代码。六、模拟用的angular-mock.js库。\n    单元测试需要引用待测试应用的所有代码，也要引用所有要写的测试代码。\n   #### 例如，一个示例单元测试的Karma配置文件可能看起来像下面这样：\n    ```\n    module.exports = function(config) {\n    config.set({\n    basePath: '..',\n    frameworks: ['jasmine'],\n    files: [\n    'lib/angular.js',\n    'lib/angular-route.js',\n    'test/lib/angular-mocks.js',\n    'js/**/*.js',\n    'test/unit/**/*.js'\n    ],\n    exclude: [],\n    port: 8080,\n    logLevel: config.LOG_INFO,\n    autoWatch: true,\n    browsers: ['Safari'],\n    singleRun: false\n    });\n    };\n    ```\n   设置了这个文件之后，就能像下面这样运行单元测试了：\n    ```\n    $ karma run test/karma.conf.js\n    ```\n   另外，如果想在每次代码有变化时运行单元测试（如果把autoWatch设置成了true） ，可以像下面这样：\n    ```\n    $ karma start test/karma.conf.js\n    ```\n   2. 建立端到端测试\n   要设置端到端测试，要使用端到端测试Karma配置文件的路径来运行Karma生成器。\n   ```\n   $ karma init test/karma-e2e.conf.js\n   ```\n   端到端测试要使用ng-scenario框架。不像单元测试那样，我们不需要引用所有的库代码：端到端测试是跑在服务器上的， ng-scenario框架只   需要在浏览器中加载所有这些测试就可以了。\n   ##### 端到端测试的示例Karma配置文件可能长这样：\n   ```\n   module.exports = function(config) {\n   config.set({\n   basePath: '..',\n   frameworks: ['ng-scenario'],\n   files: [\n   'test/e2e/**/*.js'\n   ],\n   exclude: [],\n   port: 8080,\n   logLevel: config.LOG_INFO,\n   autoWatch: false,\n   browsers: ['Chrome'],\n   singleRun: false,\n   urlRoot: '/_karma_/',\n   proxies: {\n   '/': 'http://localhost:9000/'\n   }\n   });\n   };\n   ```\n   设置好这个配置后，就可以这样运行端到端测试：\n   ```\n   $ karma run test/karma-e2e.conf.js\n   ```\n   如果想要在每次代码有变化时运行我们的测试（如果把autoWatch设置成了true)同上。\n#### 配置选项\n   1. 框架\n   生成器会问我们使用哪个测试框架来做测试。 Jasmine是默认的测试框架，不过，生成器默认也支持Mocha、 QUnit和其他测试框架。\n   这些测试框架都需要安装额外的npm库。例如，要使用Jasmine框架，需要安装Jasmine插件。\n   ```\n   $ npm install --save-dev karma-jasmine\n   ```\n   然后设置`frameworks: ['jasmine']`;\n   2. RequireJS\n   如果这个项目使用了RequireJS库，询问是否要包含RequireJS的，就要回答yes。如果项目没有包含它，就选no,不是把项目中所有文件都列在Karma配置文件中，而是要包含单独的测试文件，它负责加载特定模块。\n   3. 浏览器捕获\n   Karma生成器会询问要自动启动哪个浏览器来捕获测试结果。终止测试运行器时， Karma也会把这些浏览器关掉。我们也可以用浏览器打开Karma Web服务器监听的URL（默认为http://localhost:9876 ）来测试，如果要从本地网络的另一台机器（或者虚拟机）的IE来测试的话，\n   这一点值得牢记。\n   要使用Karma来启动和运行，每个浏览器都需要安装额外的插件。我们可以使用npm来安装这些插件。例如，为了让Karma控制Chrome，我们就要安装Chrome启动插件。\n   ```\n   $ npm install --save-dev karma-chrome-launcher\n   ```\n   如果要使用Safari，就要安装Safari启动插件，对于Firefox，就要安装Firefox启动插件，其他类同。\n   ```\n   browsers: ['Chrome', 'Safari']\n   ```\n测试指令也比测试控制器容易得多。指令并不一定要有视图模板。通常情况下，它们可以只作为视图之下处理数据的垫片。ngModelController控制器就是这种功能派上用场的一个例子。\n   其他配置可以按字面意思猜测出来了，更多案例详细讲解请参照angular权威指南19章。\n\n","slug":"angualr-19-Karma","published":1,"updated":"2016-12-22T01:47:35.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv5k0009jgtujvv3b589","content":"<h4 id=\"AngularJS-测试的类型\"><a href=\"#AngularJS-测试的类型\" class=\"headerlink\" title=\"AngularJS 测试的类型\"></a>AngularJS 测试的类型</h4><ol>\n<li>单元测试<br>我们可以专注于构建我们的测试来隔离具体、单独组件的代码。这种方法被称为“单元测试”，在不同阶段、不同条件下、以不同的输入来测试各种特定单元的代码。<br>单元测试专门用于测试小型、独立的代码单元，单个函数，或者较小的带有功能的交互。它不是用来测试大功能集的。<br>单元测试的麻烦在于把逻辑隔离成小块，这样我们才能测试它.</li>\n<li>端到端测试<br>另一方面，也可以对我们的应用作黑盒测试（也就是端到端测试）。在端到端（E2E）测试中，我们测试应用的视角是：作为最终用户，对系统的底层实现一无所知。这种方法非常适合测 试大型应用的功能。端到端测试适合测试页面上的用户交互，无需手动刷新页面。<br>关于这类测试的介绍并不新鲜，还有些了不起的工具，能使我们建立自动化的浏览器测试。我们可以使用工具如PhantomJS或CasperJS来进行无头浏览器测试（即不必打开浏览器），或Karma等工具，会真正将打开一个浏览器并在一个iframe中执行所有的测试。<h4 id=\"Karma\"><a href=\"#Karma\" class=\"headerlink\" title=\"Karma\"></a>Karma</h4>Karma测试运行器同时支持单元测试和端到端测试<br>要运行我们的测试，需要安装Karma测试运行器。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g karma</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>运行一个Karma测试挺容易的： karma start path/to/karma.config.js(例：test/karma.config.js)。当测试运行器启<br>动的时候，它会把在Karma配置文件中列出的浏览器启动起来，默认情况下，如果不是另有规定， Karma将监控配置文件中列出的所有文件。任何时候有文产生了变化， Karma都将运行适当的测试。</p>\n<h4 id=\"初始化-Karma-配置文件\"><a href=\"#初始化-Karma-配置文件\" class=\"headerlink\" title=\"初始化 Karma 配置文件\"></a>初始化 Karma 配置文件</h4><p>Karma给了我们一个生成器来创建配置文件。这个生成器会问几个关于要怎样建立配置文件的问题，每个问题建议了一个默认值，可以简单地接受所有默认值即可。用karma init生成器来创建karma.conf.js配置文件。</p>\n<ol>\n<li><p>建立单元测试<br>在测试文件的路径运行karma init命令，在我的例子中，在tests目录中创建Karma配置文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ karma init test/karma.conf.js</div></pre></td></tr></table></figure>\n<p>对于单元测试而言，运行测试所需的依赖项都要具备。当使用Karma生成器来构建单元测试 时，单元测试包含下列这些代码的引用是很重要的：<br>一、 一个测试框架（选一个）1、Jasmine（默认）2、Mocha  3、QUnit。二、自定义的配置文件（需要w/Mocha）三、所需的第三方代码。<br>四、应用特有的代码。五、测试代码。六、模拟用的angular-mock.js库。<br>单元测试需要引用待测试应用的所有代码，也要引用所有要写的测试代码。</p>\n<h4 id=\"例如，一个示例单元测试的Karma配置文件可能看起来像下面这样：\"><a href=\"#例如，一个示例单元测试的Karma配置文件可能看起来像下面这样：\" class=\"headerlink\" title=\"例如，一个示例单元测试的Karma配置文件可能看起来像下面这样：\"></a>例如，一个示例单元测试的Karma配置文件可能看起来像下面这样：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = function(config) &#123;</div><div class=\"line\">config.set(&#123;</div><div class=\"line\">basePath: &apos;..&apos;,</div><div class=\"line\">frameworks: [&apos;jasmine&apos;],</div><div class=\"line\">files: [</div><div class=\"line\">&apos;lib/angular.js&apos;,</div><div class=\"line\">&apos;lib/angular-route.js&apos;,</div><div class=\"line\">&apos;test/lib/angular-mocks.js&apos;,</div><div class=\"line\">&apos;js/**/*.js&apos;,</div><div class=\"line\">&apos;test/unit/**/*.js&apos;</div><div class=\"line\">],</div><div class=\"line\">exclude: [],</div><div class=\"line\">port: 8080,</div><div class=\"line\">logLevel: config.LOG_INFO,</div><div class=\"line\">autoWatch: true,</div><div class=\"line\">browsers: [&apos;Safari&apos;],</div><div class=\"line\">singleRun: false</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>设置了这个文件之后，就能像下面这样运行单元测试了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ karma run test/karma.conf.js</div></pre></td></tr></table></figure>\n<p>另外，如果想在每次代码有变化时运行单元测试（如果把autoWatch设置成了true） ，可以像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ karma start test/karma.conf.js</div></pre></td></tr></table></figure>\n</li>\n<li><p>建立端到端测试<br>要设置端到端测试，要使用端到端测试Karma配置文件的路径来运行Karma生成器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ karma init test/karma-e2e.conf.js</div></pre></td></tr></table></figure>\n<p>端到端测试要使用ng-scenario框架。不像单元测试那样，我们不需要引用所有的库代码：端到端测试是跑在服务器上的， ng-scenario框架只   需要在浏览器中加载所有这些测试就可以了。</p>\n<h5 id=\"端到端测试的示例Karma配置文件可能长这样：\"><a href=\"#端到端测试的示例Karma配置文件可能长这样：\" class=\"headerlink\" title=\"端到端测试的示例Karma配置文件可能长这样：\"></a>端到端测试的示例Karma配置文件可能长这样：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = function(config) &#123;</div><div class=\"line\">config.set(&#123;</div><div class=\"line\">basePath: &apos;..&apos;,</div><div class=\"line\">frameworks: [&apos;ng-scenario&apos;],</div><div class=\"line\">files: [</div><div class=\"line\">&apos;test/e2e/**/*.js&apos;</div><div class=\"line\">],</div><div class=\"line\">exclude: [],</div><div class=\"line\">port: 8080,</div><div class=\"line\">logLevel: config.LOG_INFO,</div><div class=\"line\">autoWatch: false,</div><div class=\"line\">browsers: [&apos;Chrome&apos;],</div><div class=\"line\">singleRun: false,</div><div class=\"line\">urlRoot: &apos;/_karma_/&apos;,</div><div class=\"line\">proxies: &#123;</div><div class=\"line\">&apos;/&apos;: &apos;http://localhost:9000/&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>设置好这个配置后，就可以这样运行端到端测试：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ karma run test/karma-e2e.conf.js</div></pre></td></tr></table></figure>\n<p>如果想要在每次代码有变化时运行我们的测试（如果把autoWatch设置成了true)同上。</p>\n<h4 id=\"配置选项\"><a href=\"#配置选项\" class=\"headerlink\" title=\"配置选项\"></a>配置选项</h4></li>\n<li><p>框架<br>生成器会问我们使用哪个测试框架来做测试。 Jasmine是默认的测试框架，不过，生成器默认也支持Mocha、 QUnit和其他测试框架。<br>这些测试框架都需要安装额外的npm库。例如，要使用Jasmine框架，需要安装Jasmine插件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install --save-dev karma-jasmine</div></pre></td></tr></table></figure>\n<p>然后设置<code>frameworks: [&#39;jasmine&#39;]</code>;</p>\n</li>\n<li>RequireJS<br>如果这个项目使用了RequireJS库，询问是否要包含RequireJS的，就要回答yes。如果项目没有包含它，就选no,不是把项目中所有文件都列在Karma配置文件中，而是要包含单独的测试文件，它负责加载特定模块。</li>\n<li><p>浏览器捕获<br>Karma生成器会询问要自动启动哪个浏览器来捕获测试结果。终止测试运行器时， Karma也会把这些浏览器关掉。我们也可以用浏览器打开Karma Web服务器监听的URL（默认为<a href=\"http://localhost:9876\" target=\"_blank\" rel=\"external\">http://localhost:9876</a> ）来测试，如果要从本地网络的另一台机器（或者虚拟机）的IE来测试的话，<br>这一点值得牢记。<br>要使用Karma来启动和运行，每个浏览器都需要安装额外的插件。我们可以使用npm来安装这些插件。例如，为了让Karma控制Chrome，我们就要安装Chrome启动插件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install --save-dev karma-chrome-launcher</div></pre></td></tr></table></figure>\n<p>如果要使用Safari，就要安装Safari启动插件，对于Firefox，就要安装Firefox启动插件，其他类同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">browsers: [&apos;Chrome&apos;, &apos;Safari&apos;]</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>测试指令也比测试控制器容易得多。指令并不一定要有视图模板。通常情况下，它们可以只作为视图之下处理数据的垫片。ngModelController控制器就是这种功能派上用场的一个例子。<br>   其他配置可以按字面意思猜测出来了，更多案例详细讲解请参照angular权威指南19章。</p>\n","excerpt":"","more":"<h4 id=\"AngularJS-测试的类型\"><a href=\"#AngularJS-测试的类型\" class=\"headerlink\" title=\"AngularJS 测试的类型\"></a>AngularJS 测试的类型</h4><ol>\n<li>单元测试<br>我们可以专注于构建我们的测试来隔离具体、单独组件的代码。这种方法被称为“单元测试”，在不同阶段、不同条件下、以不同的输入来测试各种特定单元的代码。<br>单元测试专门用于测试小型、独立的代码单元，单个函数，或者较小的带有功能的交互。它不是用来测试大功能集的。<br>单元测试的麻烦在于把逻辑隔离成小块，这样我们才能测试它.</li>\n<li>端到端测试<br>另一方面，也可以对我们的应用作黑盒测试（也就是端到端测试）。在端到端（E2E）测试中，我们测试应用的视角是：作为最终用户，对系统的底层实现一无所知。这种方法非常适合测 试大型应用的功能。端到端测试适合测试页面上的用户交互，无需手动刷新页面。<br>关于这类测试的介绍并不新鲜，还有些了不起的工具，能使我们建立自动化的浏览器测试。我们可以使用工具如PhantomJS或CasperJS来进行无头浏览器测试（即不必打开浏览器），或Karma等工具，会真正将打开一个浏览器并在一个iframe中执行所有的测试。<h4 id=\"Karma\"><a href=\"#Karma\" class=\"headerlink\" title=\"Karma\"></a>Karma</h4>Karma测试运行器同时支持单元测试和端到端测试<br>要运行我们的测试，需要安装Karma测试运行器。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g karma</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>运行一个Karma测试挺容易的： karma start path/to/karma.config.js(例：test/karma.config.js)。当测试运行器启<br>动的时候，它会把在Karma配置文件中列出的浏览器启动起来，默认情况下，如果不是另有规定， Karma将监控配置文件中列出的所有文件。任何时候有文产生了变化， Karma都将运行适当的测试。</p>\n<h4 id=\"初始化-Karma-配置文件\"><a href=\"#初始化-Karma-配置文件\" class=\"headerlink\" title=\"初始化 Karma 配置文件\"></a>初始化 Karma 配置文件</h4><p>Karma给了我们一个生成器来创建配置文件。这个生成器会问几个关于要怎样建立配置文件的问题，每个问题建议了一个默认值，可以简单地接受所有默认值即可。用karma init生成器来创建karma.conf.js配置文件。</p>\n<ol>\n<li><p>建立单元测试<br>在测试文件的路径运行karma init命令，在我的例子中，在tests目录中创建Karma配置文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ karma init test/karma.conf.js</div></pre></td></tr></table></figure>\n<p>对于单元测试而言，运行测试所需的依赖项都要具备。当使用Karma生成器来构建单元测试 时，单元测试包含下列这些代码的引用是很重要的：<br>一、 一个测试框架（选一个）1、Jasmine（默认）2、Mocha  3、QUnit。二、自定义的配置文件（需要w/Mocha）三、所需的第三方代码。<br>四、应用特有的代码。五、测试代码。六、模拟用的angular-mock.js库。<br>单元测试需要引用待测试应用的所有代码，也要引用所有要写的测试代码。</p>\n<h4 id=\"例如，一个示例单元测试的Karma配置文件可能看起来像下面这样：\"><a href=\"#例如，一个示例单元测试的Karma配置文件可能看起来像下面这样：\" class=\"headerlink\" title=\"例如，一个示例单元测试的Karma配置文件可能看起来像下面这样：\"></a>例如，一个示例单元测试的Karma配置文件可能看起来像下面这样：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = function(config) &#123;</div><div class=\"line\">config.set(&#123;</div><div class=\"line\">basePath: &apos;..&apos;,</div><div class=\"line\">frameworks: [&apos;jasmine&apos;],</div><div class=\"line\">files: [</div><div class=\"line\">&apos;lib/angular.js&apos;,</div><div class=\"line\">&apos;lib/angular-route.js&apos;,</div><div class=\"line\">&apos;test/lib/angular-mocks.js&apos;,</div><div class=\"line\">&apos;js/**/*.js&apos;,</div><div class=\"line\">&apos;test/unit/**/*.js&apos;</div><div class=\"line\">],</div><div class=\"line\">exclude: [],</div><div class=\"line\">port: 8080,</div><div class=\"line\">logLevel: config.LOG_INFO,</div><div class=\"line\">autoWatch: true,</div><div class=\"line\">browsers: [&apos;Safari&apos;],</div><div class=\"line\">singleRun: false</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>设置了这个文件之后，就能像下面这样运行单元测试了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ karma run test/karma.conf.js</div></pre></td></tr></table></figure>\n<p>另外，如果想在每次代码有变化时运行单元测试（如果把autoWatch设置成了true） ，可以像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ karma start test/karma.conf.js</div></pre></td></tr></table></figure>\n</li>\n<li><p>建立端到端测试<br>要设置端到端测试，要使用端到端测试Karma配置文件的路径来运行Karma生成器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ karma init test/karma-e2e.conf.js</div></pre></td></tr></table></figure>\n<p>端到端测试要使用ng-scenario框架。不像单元测试那样，我们不需要引用所有的库代码：端到端测试是跑在服务器上的， ng-scenario框架只   需要在浏览器中加载所有这些测试就可以了。</p>\n<h5 id=\"端到端测试的示例Karma配置文件可能长这样：\"><a href=\"#端到端测试的示例Karma配置文件可能长这样：\" class=\"headerlink\" title=\"端到端测试的示例Karma配置文件可能长这样：\"></a>端到端测试的示例Karma配置文件可能长这样：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = function(config) &#123;</div><div class=\"line\">config.set(&#123;</div><div class=\"line\">basePath: &apos;..&apos;,</div><div class=\"line\">frameworks: [&apos;ng-scenario&apos;],</div><div class=\"line\">files: [</div><div class=\"line\">&apos;test/e2e/**/*.js&apos;</div><div class=\"line\">],</div><div class=\"line\">exclude: [],</div><div class=\"line\">port: 8080,</div><div class=\"line\">logLevel: config.LOG_INFO,</div><div class=\"line\">autoWatch: false,</div><div class=\"line\">browsers: [&apos;Chrome&apos;],</div><div class=\"line\">singleRun: false,</div><div class=\"line\">urlRoot: &apos;/_karma_/&apos;,</div><div class=\"line\">proxies: &#123;</div><div class=\"line\">&apos;/&apos;: &apos;http://localhost:9000/&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>设置好这个配置后，就可以这样运行端到端测试：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ karma run test/karma-e2e.conf.js</div></pre></td></tr></table></figure>\n<p>如果想要在每次代码有变化时运行我们的测试（如果把autoWatch设置成了true)同上。</p>\n<h4 id=\"配置选项\"><a href=\"#配置选项\" class=\"headerlink\" title=\"配置选项\"></a>配置选项</h4></li>\n<li><p>框架<br>生成器会问我们使用哪个测试框架来做测试。 Jasmine是默认的测试框架，不过，生成器默认也支持Mocha、 QUnit和其他测试框架。<br>这些测试框架都需要安装额外的npm库。例如，要使用Jasmine框架，需要安装Jasmine插件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install --save-dev karma-jasmine</div></pre></td></tr></table></figure>\n<p>然后设置<code>frameworks: [&#39;jasmine&#39;]</code>;</p>\n</li>\n<li>RequireJS<br>如果这个项目使用了RequireJS库，询问是否要包含RequireJS的，就要回答yes。如果项目没有包含它，就选no,不是把项目中所有文件都列在Karma配置文件中，而是要包含单独的测试文件，它负责加载特定模块。</li>\n<li><p>浏览器捕获<br>Karma生成器会询问要自动启动哪个浏览器来捕获测试结果。终止测试运行器时， Karma也会把这些浏览器关掉。我们也可以用浏览器打开Karma Web服务器监听的URL（默认为<a href=\"http://localhost:9876\">http://localhost:9876</a> ）来测试，如果要从本地网络的另一台机器（或者虚拟机）的IE来测试的话，<br>这一点值得牢记。<br>要使用Karma来启动和运行，每个浏览器都需要安装额外的插件。我们可以使用npm来安装这些插件。例如，为了让Karma控制Chrome，我们就要安装Chrome启动插件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install --save-dev karma-chrome-launcher</div></pre></td></tr></table></figure>\n<p>如果要使用Safari，就要安装Safari启动插件，对于Firefox，就要安装Firefox启动插件，其他类同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">browsers: [&apos;Chrome&apos;, &apos;Safari&apos;]</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>测试指令也比测试控制器容易得多。指令并不一定要有视图模板。通常情况下，它们可以只作为视图之下处理数据的垫片。ngModelController控制器就是这种功能派上用场的一个例子。<br>   其他配置可以按字面意思猜测出来了，更多案例详细讲解请参照angular权威指南19章。</p>\n"},{"title":"keep real，be myself","date":"2015-10-25T10:44:51.000Z","_content":"## 我就是我，不一样的烟火\n我是英俊潇洒、玉树临风、天下无敌、人见人爱、花见花开、气死潘安、羞死宋玉、号称一朵梨花压海棠、宇宙第一高手,人送绰号玉面小鲜肉、山崩地裂水倒流鬼见愁、美貌与智慧结合、英雄与侠义化身——Scorpio~~~~哈哈哈！\n","source":"_posts/aboutme.md","raw":"---\ntitle: keep real，be myself\ndate: 2015-10-25 18:44:51\ntags: 生活\n---\n## 我就是我，不一样的烟火\n我是英俊潇洒、玉树临风、天下无敌、人见人爱、花见花开、气死潘安、羞死宋玉、号称一朵梨花压海棠、宇宙第一高手,人送绰号玉面小鲜肉、山崩地裂水倒流鬼见愁、美貌与智慧结合、英雄与侠义化身——Scorpio~~~~哈哈哈！\n","slug":"aboutme","published":1,"updated":"2016-12-12T09:51:44.752Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv5q000ajgtuh4f5se3c","content":"<h2 id=\"我就是我，不一样的烟火\"><a href=\"#我就是我，不一样的烟火\" class=\"headerlink\" title=\"我就是我，不一样的烟火\"></a>我就是我，不一样的烟火</h2><p>我是英俊潇洒、玉树临风、天下无敌、人见人爱、花见花开、气死潘安、羞死宋玉、号称一朵梨花压海棠、宇宙第一高手,人送绰号玉面小鲜肉、山崩地裂水倒流鬼见愁、美貌与智慧结合、英雄与侠义化身——Scorpio~~~~哈哈哈！</p>\n","excerpt":"","more":"<h2 id=\"我就是我，不一样的烟火\"><a href=\"#我就是我，不一样的烟火\" class=\"headerlink\" title=\"我就是我，不一样的烟火\"></a>我就是我，不一样的烟火</h2><p>我是英俊潇洒、玉树临风、天下无敌、人见人爱、花见花开、气死潘安、羞死宋玉、号称一朵梨花压海棠、宇宙第一高手,人送绰号玉面小鲜肉、山崩地裂水倒流鬼见愁、美貌与智慧结合、英雄与侠义化身——Scorpio~~~~哈哈哈！</p>\n"},{"title":"angular-decorator","date":"2016-07-20T07:58:33.000Z","_content":"#### angular提供的一种装饰-decorator\ndecorator 通过配置函数中的$provide 进行装饰，可扩展已有的服务\n```\napp.config(function ($provide) {\n    //参数1 要装饰的内容\n    $provide.decorator('$log',function ($delegate) { //代理。我们可以将这个代理函数包装好送回去\n        var log = $delegate.log;\n        $delegate.log = function () {\n            //获取当前的形参\n       var args = Array.of(...arguments);//es6的写法,作用同下\n              //var args = Array.prototype.slice.call(arguments);\n            args.unshift(new Date());\n            log.apply(null,args);\n        };\n        return $delegate;//更改后 将原内容，送回去\n    });\n});\napp.controller('computed1',function ($scope,my,$log) {\n    //$log是angular给我们提供的一个服务，\n这里的my相当于实例化了provider的函数，并且调用了$get方法\n    $log.log('hello','ywx');\n    //装饰的好处在原基础上,增加功能，修改angular自带的服务，装饰我们写好的\n});\n```","source":"_posts/angular-decorator.md","raw":"---\ntitle: angular-decorator\ndate: 2016-07-20 15:58:33\ntags: angular decorator\n---\n#### angular提供的一种装饰-decorator\ndecorator 通过配置函数中的$provide 进行装饰，可扩展已有的服务\n```\napp.config(function ($provide) {\n    //参数1 要装饰的内容\n    $provide.decorator('$log',function ($delegate) { //代理。我们可以将这个代理函数包装好送回去\n        var log = $delegate.log;\n        $delegate.log = function () {\n            //获取当前的形参\n       var args = Array.of(...arguments);//es6的写法,作用同下\n              //var args = Array.prototype.slice.call(arguments);\n            args.unshift(new Date());\n            log.apply(null,args);\n        };\n        return $delegate;//更改后 将原内容，送回去\n    });\n});\napp.controller('computed1',function ($scope,my,$log) {\n    //$log是angular给我们提供的一个服务，\n这里的my相当于实例化了provider的函数，并且调用了$get方法\n    $log.log('hello','ywx');\n    //装饰的好处在原基础上,增加功能，修改angular自带的服务，装饰我们写好的\n});\n```","slug":"angular-decorator","published":1,"updated":"2016-12-26T08:01:49.894Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv5t000cjgtuolih0nqu","content":"<h4 id=\"angular提供的一种装饰-decorator\"><a href=\"#angular提供的一种装饰-decorator\" class=\"headerlink\" title=\"angular提供的一种装饰-decorator\"></a>angular提供的一种装饰-decorator</h4><p>decorator 通过配置函数中的$provide 进行装饰，可扩展已有的服务<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.config(function ($provide) &#123;</div><div class=\"line\">    //参数1 要装饰的内容</div><div class=\"line\">    $provide.decorator(&apos;$log&apos;,function ($delegate) &#123; //代理。我们可以将这个代理函数包装好送回去</div><div class=\"line\">        var log = $delegate.log;</div><div class=\"line\">        $delegate.log = function () &#123;</div><div class=\"line\">            //获取当前的形参</div><div class=\"line\">       var args = Array.of(...arguments);//es6的写法,作用同下</div><div class=\"line\">              //var args = Array.prototype.slice.call(arguments);</div><div class=\"line\">            args.unshift(new Date());</div><div class=\"line\">            log.apply(null,args);</div><div class=\"line\">        &#125;;</div><div class=\"line\">        return $delegate;//更改后 将原内容，送回去</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\">app.controller(&apos;computed1&apos;,function ($scope,my,$log) &#123;</div><div class=\"line\">    //$log是angular给我们提供的一个服务，</div><div class=\"line\">这里的my相当于实例化了provider的函数，并且调用了$get方法</div><div class=\"line\">    $log.log(&apos;hello&apos;,&apos;ywx&apos;);</div><div class=\"line\">    //装饰的好处在原基础上,增加功能，修改angular自带的服务，装饰我们写好的</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<h4 id=\"angular提供的一种装饰-decorator\"><a href=\"#angular提供的一种装饰-decorator\" class=\"headerlink\" title=\"angular提供的一种装饰-decorator\"></a>angular提供的一种装饰-decorator</h4><p>decorator 通过配置函数中的$provide 进行装饰，可扩展已有的服务<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.config(function ($provide) &#123;</div><div class=\"line\">    //参数1 要装饰的内容</div><div class=\"line\">    $provide.decorator(&apos;$log&apos;,function ($delegate) &#123; //代理。我们可以将这个代理函数包装好送回去</div><div class=\"line\">        var log = $delegate.log;</div><div class=\"line\">        $delegate.log = function () &#123;</div><div class=\"line\">            //获取当前的形参</div><div class=\"line\">       var args = Array.of(...arguments);//es6的写法,作用同下</div><div class=\"line\">              //var args = Array.prototype.slice.call(arguments);</div><div class=\"line\">            args.unshift(new Date());</div><div class=\"line\">            log.apply(null,args);</div><div class=\"line\">        &#125;;</div><div class=\"line\">        return $delegate;//更改后 将原内容，送回去</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\">app.controller(&apos;computed1&apos;,function ($scope,my,$log) &#123;</div><div class=\"line\">    //$log是angular给我们提供的一个服务，</div><div class=\"line\">这里的my相当于实例化了provider的函数，并且调用了$get方法</div><div class=\"line\">    $log.log(&apos;hello&apos;,&apos;ywx&apos;);</div><div class=\"line\">    //装饰的好处在原基础上,增加功能，修改angular自带的服务，装饰我们写好的</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n"},{"title":"angular中的5种服务","date":"2016-06-01T06:53:19.000Z","_content":"#### 5种创建自定义服务的方式\n1.Provider 2.Factory 3.Service 4.value 5.constant,其中只有provider可以配置，factory是项目中最常用的。\n服务的作用：提取公共内容，封装公有方法，并且服务是单例的。服务对应的是构造函数。服务名字的后面函数其实是一个服务的构造函数，单例相当于只能new一次创建一个实例，不能创建多个实例来使用。\nservice层主查写逻辑代码的，但在angularJS里也可以持久化数据（充当数据容器），以供不同的controller调用。\ncontroller层：即控制层，在angularJS里就是写控制器的。控制器里尽量不要写那些不必要的逻辑，尽量写在service层里。\n```\n//定义构造函数\nvar myServiceProvider = function(){\nthis.$get = function(){\nreturn ....\n};\n};\n//在模块中登记\nangular.module(\"myModule\",[])\n.provider(\"myService\",myServiceProvider);\n```\n#### 1.provider\nprovider 可配置  当注入后会默认调用$get方法   仅仅只有provider可配置.\n只有provder是能传.config() 函数的服务。如果想在 service 对象启用之前，先进行模块范围的配置，那就应该选择 provider。需要注意的是：在config函数里注入provider时，名字应该是：providerName+Provider. \n使用Provider的优点就是，你可以在Provider对象传递到应用程序的其他部分之前在app.config函数中对其进行修改。 当你使用Provider创建一个service时，唯一的可以在你的控制器中访问的属性和方法是通过$get()函数返回内容。\n```\napp.provider('my',function () {\n    //当我们使用这个服务的时候，会直接调用$get方法\n    this.$get = function () {\n             return {  }\n    }\n});\n```\n##### 可配置的服务\n 有时我们希望服务在不同的场景下可以有不同的行为，这意味着服务可以进行配置。比如，我们希望小计算器可以根据不同的本地化区域，给计算结果追加货币符号前缀， 那么需要在这个服务创建之前，首先配置本地化区域的值，然后在具体的计算中， 根据这个值选择合适的货币符号。\n      AngularJS使用模块的config()方法对服务进行配置，需要将实例化的服务提供者（而不是服务实例）注入到配置函数中：\n ```\n      angular.module(\"myModule\",[])\n      .config([\"myServiceProvider\",function(myServiceProvider){\n      //do some configuration.\n      }]);\n```\n#### 2.factory\nfactory方式创建的服务，作用就是返回一个有属性有方法的对象。相当于：var f = myFactory();\n```\napp.factory('my',function () {\nreturn  {}  //返回$get执行后的函数\n});\n```\n```\n注：使用provider服务时的执行顺序 先config > run > controller\n//需要注意的是：在配置provider时，名字应该是：providerName+Provider   \n    app.config(function(myProviderProvider){\n        myProviderProvider.setName(\"ywx\");       \n    });\n    app.provider('myProvider', function() {\n        var name=\"\";\n        var test={\"a\":1,\"b\":2};\n        //注意的是，setter方法必须是(set+变量首字母大写)格式\n        this.setName = function(newName){\n            name = newName  \n        }\n\n        this.$get =function($http,$q){\n            return {\n                getData : function(){\n                    var d = $q.defer();\n                    $http.get(\"url\")//读取数据的函数。\n                        .success(function(response) {\n                            d.resolve(response);\n                        })\n                        .error(function(){\n                            d.reject(\"error\");\n                        });\n                    return d.promise;\n                },\n                \"lastName\":name,\n                \"test\":test\n            }   \n        }\n\n    });\n    app.controller('myCtrl', function($scope,myProvider) {\n        alert(myProvider.lastName);\n        alert(myProvider.test.a)\n        myProvider.getData().then(function(data){\n            //alert(data)\n        },function(data){\n            //alert(data)\n        });\n    });\n```\n```\n//通过工厂模式创建自定义服务\n    app.factory('myFactory', function() {\n        var service = {};//定义一个Object对象'\n        service.name = \"张三\";\n        var age;//定义一个私有化的变量\n        //对私有属性写getter和setter方法\n        service.setAge = function(newAge){\n            age = newAge;\n        }\n        service.getAge = function(){\n            return age; \n        }\n        return service;//返回这个Object对象\n    });\n//创建控制器\n    app.controller('myCtrl', function($scope, myFactory) {\n        myFactory.setAge(20);\n        $scope.r =myFactory.getAge();\n        alert(myFactory.name);\n    });\n```\n注：在自定义服务里可以注入内置服务（例$http等），但不能注入$scope作用域对象。\n#### 3.service\n通过service方式创建自定义服务，相当于new的一个对象：var s = new myService();，只要把属性和方法添加到this上才可以在controller里调用。\n```\napp.service('myService',function () {\n     此处为return出来的那个对象，对象的属性需要加上this，this[key]=val这种形式。\n     })\n```\n```\napp.service('myService', function($http,$q) {\n        this.name = \"service\";\n        this.myFunc = function (x) {\n            return x.toString(16);//转16进制\n        }\n        this.getData = function(){\n            var d = $q.defer();\n            $http.get(\"ursl\")//读取数据的函数。\n                .success(function(response) {\n                d.resolve(response);\n            })\n                .error(function(){\n                alert(0)\n                d.reject(\"error\");\n            });\n            return d.promise;\n        }\n    });\n    app.controller('myCtrl', function($scope, myService) {\n        $scope.r = myService.myFunc(255);\n        myService.getData().then(function(data){\n            console.log(data);//正确时走这儿\n        },function(data){\n            alert(data)//错误时走这儿\n        });\n    });\n```\n#### 4.value \n以 key与value的形式来写value服务。这个值就是服务实例。\n```\napp.value('my',{\n          此处为return出来的对象\n     });\n```\n```\n有时我们需要在不同的组件之间共享一个变量，可以将这种情况视为一种服务： provider返回的总是变量的值。\nvalue方法提供了对这种情况的简化封装：\nangular.module(\"myModule\",[])\n.value(\"myValueService\",\"cx129800123\");\n\nINSIDE：AngularJS会将value方法封装为provider，上面的示例 等同于：\nangular.module(\"myModule\",[])\n.provider(\"myService\",function(){\nthis.$get = function(){\nreturn \"cx129800123\";\n};\n});\n```\n#### 5.constant  \n用法同value，也是以 key ,value的形式，但是可以配置（不是真正意义上的配置），即可以增加属性。配置时不需要再名字后面加Provider。这个常量就是服务实例。\n```\n //配置constant\n    app.config(function (my) {\n        my.currency = '￡';//在当前属性上增加一个属性\n    });\n    app.controller('computed',function ($scope,my) {\n        //my就是return这个对象,这样就可以使用return出来对象的属性了\n    })\n```\n```\n有时我们需要在不同的组件之间共享一个常量，可以将这种情况视为一种服务： provider返回的总是常量的值。constant方法提供了对这种情况的简化封装：\nangular.module(\"myModule\",[])\n.constant(\"myConstantService\",\"Great Wall\");\n和value方法不同，AngularJS并没有将constant方法封装成一个provider，而仅仅是在内部登记这个值。这使得常量在AngularJS的启动配置阶段就可以使用（创建任何 服务之前）：你可以将常量注入到模块的config()方法中。\n```\n#### 在过滤器中注入自定义服务\n```\n<body>\n<div ng-app=\"myApp\">\n    在过滤器中使用服务:\n    <h1>{{255 | myFormat}}</h1>\n    //若使用过滤器时需要传入参数，用：隔开，多个参数用多个：隔开。\n</div>\n\n<script>\n    var app = angular.module('myApp', []);\n    app.service('hexafy', function() {\n        this.myFunc = function (x) {\n            return x.toString(16);\n        }\n    });\n    app.filter('myFormat',['hexafy', function(hexafy) {\n        return function(x) {\n            return hexafy.myFunc(x);\n        };\n    }]);\n</script>\n</body>\n```","source":"_posts/angular-fiveservice.md","raw":"---\ntitle: angular中的5种服务\ndate: 2016-06-01 14:53:19\ntags: angular 服务\n---\n#### 5种创建自定义服务的方式\n1.Provider 2.Factory 3.Service 4.value 5.constant,其中只有provider可以配置，factory是项目中最常用的。\n服务的作用：提取公共内容，封装公有方法，并且服务是单例的。服务对应的是构造函数。服务名字的后面函数其实是一个服务的构造函数，单例相当于只能new一次创建一个实例，不能创建多个实例来使用。\nservice层主查写逻辑代码的，但在angularJS里也可以持久化数据（充当数据容器），以供不同的controller调用。\ncontroller层：即控制层，在angularJS里就是写控制器的。控制器里尽量不要写那些不必要的逻辑，尽量写在service层里。\n```\n//定义构造函数\nvar myServiceProvider = function(){\nthis.$get = function(){\nreturn ....\n};\n};\n//在模块中登记\nangular.module(\"myModule\",[])\n.provider(\"myService\",myServiceProvider);\n```\n#### 1.provider\nprovider 可配置  当注入后会默认调用$get方法   仅仅只有provider可配置.\n只有provder是能传.config() 函数的服务。如果想在 service 对象启用之前，先进行模块范围的配置，那就应该选择 provider。需要注意的是：在config函数里注入provider时，名字应该是：providerName+Provider. \n使用Provider的优点就是，你可以在Provider对象传递到应用程序的其他部分之前在app.config函数中对其进行修改。 当你使用Provider创建一个service时，唯一的可以在你的控制器中访问的属性和方法是通过$get()函数返回内容。\n```\napp.provider('my',function () {\n    //当我们使用这个服务的时候，会直接调用$get方法\n    this.$get = function () {\n             return {  }\n    }\n});\n```\n##### 可配置的服务\n 有时我们希望服务在不同的场景下可以有不同的行为，这意味着服务可以进行配置。比如，我们希望小计算器可以根据不同的本地化区域，给计算结果追加货币符号前缀， 那么需要在这个服务创建之前，首先配置本地化区域的值，然后在具体的计算中， 根据这个值选择合适的货币符号。\n      AngularJS使用模块的config()方法对服务进行配置，需要将实例化的服务提供者（而不是服务实例）注入到配置函数中：\n ```\n      angular.module(\"myModule\",[])\n      .config([\"myServiceProvider\",function(myServiceProvider){\n      //do some configuration.\n      }]);\n```\n#### 2.factory\nfactory方式创建的服务，作用就是返回一个有属性有方法的对象。相当于：var f = myFactory();\n```\napp.factory('my',function () {\nreturn  {}  //返回$get执行后的函数\n});\n```\n```\n注：使用provider服务时的执行顺序 先config > run > controller\n//需要注意的是：在配置provider时，名字应该是：providerName+Provider   \n    app.config(function(myProviderProvider){\n        myProviderProvider.setName(\"ywx\");       \n    });\n    app.provider('myProvider', function() {\n        var name=\"\";\n        var test={\"a\":1,\"b\":2};\n        //注意的是，setter方法必须是(set+变量首字母大写)格式\n        this.setName = function(newName){\n            name = newName  \n        }\n\n        this.$get =function($http,$q){\n            return {\n                getData : function(){\n                    var d = $q.defer();\n                    $http.get(\"url\")//读取数据的函数。\n                        .success(function(response) {\n                            d.resolve(response);\n                        })\n                        .error(function(){\n                            d.reject(\"error\");\n                        });\n                    return d.promise;\n                },\n                \"lastName\":name,\n                \"test\":test\n            }   \n        }\n\n    });\n    app.controller('myCtrl', function($scope,myProvider) {\n        alert(myProvider.lastName);\n        alert(myProvider.test.a)\n        myProvider.getData().then(function(data){\n            //alert(data)\n        },function(data){\n            //alert(data)\n        });\n    });\n```\n```\n//通过工厂模式创建自定义服务\n    app.factory('myFactory', function() {\n        var service = {};//定义一个Object对象'\n        service.name = \"张三\";\n        var age;//定义一个私有化的变量\n        //对私有属性写getter和setter方法\n        service.setAge = function(newAge){\n            age = newAge;\n        }\n        service.getAge = function(){\n            return age; \n        }\n        return service;//返回这个Object对象\n    });\n//创建控制器\n    app.controller('myCtrl', function($scope, myFactory) {\n        myFactory.setAge(20);\n        $scope.r =myFactory.getAge();\n        alert(myFactory.name);\n    });\n```\n注：在自定义服务里可以注入内置服务（例$http等），但不能注入$scope作用域对象。\n#### 3.service\n通过service方式创建自定义服务，相当于new的一个对象：var s = new myService();，只要把属性和方法添加到this上才可以在controller里调用。\n```\napp.service('myService',function () {\n     此处为return出来的那个对象，对象的属性需要加上this，this[key]=val这种形式。\n     })\n```\n```\napp.service('myService', function($http,$q) {\n        this.name = \"service\";\n        this.myFunc = function (x) {\n            return x.toString(16);//转16进制\n        }\n        this.getData = function(){\n            var d = $q.defer();\n            $http.get(\"ursl\")//读取数据的函数。\n                .success(function(response) {\n                d.resolve(response);\n            })\n                .error(function(){\n                alert(0)\n                d.reject(\"error\");\n            });\n            return d.promise;\n        }\n    });\n    app.controller('myCtrl', function($scope, myService) {\n        $scope.r = myService.myFunc(255);\n        myService.getData().then(function(data){\n            console.log(data);//正确时走这儿\n        },function(data){\n            alert(data)//错误时走这儿\n        });\n    });\n```\n#### 4.value \n以 key与value的形式来写value服务。这个值就是服务实例。\n```\napp.value('my',{\n          此处为return出来的对象\n     });\n```\n```\n有时我们需要在不同的组件之间共享一个变量，可以将这种情况视为一种服务： provider返回的总是变量的值。\nvalue方法提供了对这种情况的简化封装：\nangular.module(\"myModule\",[])\n.value(\"myValueService\",\"cx129800123\");\n\nINSIDE：AngularJS会将value方法封装为provider，上面的示例 等同于：\nangular.module(\"myModule\",[])\n.provider(\"myService\",function(){\nthis.$get = function(){\nreturn \"cx129800123\";\n};\n});\n```\n#### 5.constant  \n用法同value，也是以 key ,value的形式，但是可以配置（不是真正意义上的配置），即可以增加属性。配置时不需要再名字后面加Provider。这个常量就是服务实例。\n```\n //配置constant\n    app.config(function (my) {\n        my.currency = '￡';//在当前属性上增加一个属性\n    });\n    app.controller('computed',function ($scope,my) {\n        //my就是return这个对象,这样就可以使用return出来对象的属性了\n    })\n```\n```\n有时我们需要在不同的组件之间共享一个常量，可以将这种情况视为一种服务： provider返回的总是常量的值。constant方法提供了对这种情况的简化封装：\nangular.module(\"myModule\",[])\n.constant(\"myConstantService\",\"Great Wall\");\n和value方法不同，AngularJS并没有将constant方法封装成一个provider，而仅仅是在内部登记这个值。这使得常量在AngularJS的启动配置阶段就可以使用（创建任何 服务之前）：你可以将常量注入到模块的config()方法中。\n```\n#### 在过滤器中注入自定义服务\n```\n<body>\n<div ng-app=\"myApp\">\n    在过滤器中使用服务:\n    <h1>{{255 | myFormat}}</h1>\n    //若使用过滤器时需要传入参数，用：隔开，多个参数用多个：隔开。\n</div>\n\n<script>\n    var app = angular.module('myApp', []);\n    app.service('hexafy', function() {\n        this.myFunc = function (x) {\n            return x.toString(16);\n        }\n    });\n    app.filter('myFormat',['hexafy', function(hexafy) {\n        return function(x) {\n            return hexafy.myFunc(x);\n        };\n    }]);\n</script>\n</body>\n```","slug":"angular-fiveservice","published":1,"updated":"2016-12-26T07:56:52.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv5v000ejgtuviv89vyk","content":"<h4 id=\"5种创建自定义服务的方式\"><a href=\"#5种创建自定义服务的方式\" class=\"headerlink\" title=\"5种创建自定义服务的方式\"></a>5种创建自定义服务的方式</h4><p>1.Provider 2.Factory 3.Service 4.value 5.constant,其中只有provider可以配置，factory是项目中最常用的。<br>服务的作用：提取公共内容，封装公有方法，并且服务是单例的。服务对应的是构造函数。服务名字的后面函数其实是一个服务的构造函数，单例相当于只能new一次创建一个实例，不能创建多个实例来使用。<br>service层主查写逻辑代码的，但在angularJS里也可以持久化数据（充当数据容器），以供不同的controller调用。<br>controller层：即控制层，在angularJS里就是写控制器的。控制器里尽量不要写那些不必要的逻辑，尽量写在service层里。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//定义构造函数</div><div class=\"line\">var myServiceProvider = function()&#123;</div><div class=\"line\">this.$get = function()&#123;</div><div class=\"line\">return ....</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\">//在模块中登记</div><div class=\"line\">angular.module(&quot;myModule&quot;,[])</div><div class=\"line\">.provider(&quot;myService&quot;,myServiceProvider);</div></pre></td></tr></table></figure></p>\n<h4 id=\"1-provider\"><a href=\"#1-provider\" class=\"headerlink\" title=\"1.provider\"></a>1.provider</h4><p>provider 可配置  当注入后会默认调用$get方法   仅仅只有provider可配置.<br>只有provder是能传.config() 函数的服务。如果想在 service 对象启用之前，先进行模块范围的配置，那就应该选择 provider。需要注意的是：在config函数里注入provider时，名字应该是：providerName+Provider.<br>使用Provider的优点就是，你可以在Provider对象传递到应用程序的其他部分之前在app.config函数中对其进行修改。 当你使用Provider创建一个service时，唯一的可以在你的控制器中访问的属性和方法是通过$get()函数返回内容。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.provider(&apos;my&apos;,function () &#123;</div><div class=\"line\">    //当我们使用这个服务的时候，会直接调用$get方法</div><div class=\"line\">    this.$get = function () &#123;</div><div class=\"line\">             return &#123;  &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h5 id=\"可配置的服务\"><a href=\"#可配置的服务\" class=\"headerlink\" title=\"可配置的服务\"></a>可配置的服务</h5><p> 有时我们希望服务在不同的场景下可以有不同的行为，这意味着服务可以进行配置。比如，我们希望小计算器可以根据不同的本地化区域，给计算结果追加货币符号前缀， 那么需要在这个服务创建之前，首先配置本地化区域的值，然后在具体的计算中， 根据这个值选择合适的货币符号。<br>      AngularJS使用模块的config()方法对服务进行配置，需要将实例化的服务提供者（而不是服务实例）注入到配置函数中：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&quot;myModule&quot;,[])</div><div class=\"line\">.config([&quot;myServiceProvider&quot;,function(myServiceProvider)&#123;</div><div class=\"line\">//do some configuration.</div><div class=\"line\">&#125;]);</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-factory\"><a href=\"#2-factory\" class=\"headerlink\" title=\"2.factory\"></a>2.factory</h4><p>factory方式创建的服务，作用就是返回一个有属性有方法的对象。相当于：var f = myFactory();<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.factory(&apos;my&apos;,function () &#123;</div><div class=\"line\">return  &#123;&#125;  //返回$get执行后的函数</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">注：使用provider服务时的执行顺序 先config &gt; run &gt; controller</div><div class=\"line\">//需要注意的是：在配置provider时，名字应该是：providerName+Provider   </div><div class=\"line\">    app.config(function(myProviderProvider)&#123;</div><div class=\"line\">        myProviderProvider.setName(&quot;ywx&quot;);       </div><div class=\"line\">    &#125;);</div><div class=\"line\">    app.provider(&apos;myProvider&apos;, function() &#123;</div><div class=\"line\">        var name=&quot;&quot;;</div><div class=\"line\">        var test=&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;;</div><div class=\"line\">        //注意的是，setter方法必须是(set+变量首字母大写)格式</div><div class=\"line\">        this.setName = function(newName)&#123;</div><div class=\"line\">            name = newName  </div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        this.$get =function($http,$q)&#123;</div><div class=\"line\">            return &#123;</div><div class=\"line\">                getData : function()&#123;</div><div class=\"line\">                    var d = $q.defer();</div><div class=\"line\">                    $http.get(&quot;url&quot;)//读取数据的函数。</div><div class=\"line\">                        .success(function(response) &#123;</div><div class=\"line\">                            d.resolve(response);</div><div class=\"line\">                        &#125;)</div><div class=\"line\">                        .error(function()&#123;</div><div class=\"line\">                            d.reject(&quot;error&quot;);</div><div class=\"line\">                        &#125;);</div><div class=\"line\">                    return d.promise;</div><div class=\"line\">                &#125;,</div><div class=\"line\">                &quot;lastName&quot;:name,</div><div class=\"line\">                &quot;test&quot;:test</div><div class=\"line\">            &#125;   </div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div><div class=\"line\">    app.controller(&apos;myCtrl&apos;, function($scope,myProvider) &#123;</div><div class=\"line\">        alert(myProvider.lastName);</div><div class=\"line\">        alert(myProvider.test.a)</div><div class=\"line\">        myProvider.getData().then(function(data)&#123;</div><div class=\"line\">            //alert(data)</div><div class=\"line\">        &#125;,function(data)&#123;</div><div class=\"line\">            //alert(data)</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">//通过工厂模式创建自定义服务</div><div class=\"line\">    app.factory(&apos;myFactory&apos;, function() &#123;</div><div class=\"line\">        var service = &#123;&#125;;//定义一个Object对象&apos;</div><div class=\"line\">        service.name = &quot;张三&quot;;</div><div class=\"line\">        var age;//定义一个私有化的变量</div><div class=\"line\">        //对私有属性写getter和setter方法</div><div class=\"line\">        service.setAge = function(newAge)&#123;</div><div class=\"line\">            age = newAge;</div><div class=\"line\">        &#125;</div><div class=\"line\">        service.getAge = function()&#123;</div><div class=\"line\">            return age; </div><div class=\"line\">        &#125;</div><div class=\"line\">        return service;//返回这个Object对象</div><div class=\"line\">    &#125;);</div><div class=\"line\">//创建控制器</div><div class=\"line\">    app.controller(&apos;myCtrl&apos;, function($scope, myFactory) &#123;</div><div class=\"line\">        myFactory.setAge(20);</div><div class=\"line\">        $scope.r =myFactory.getAge();</div><div class=\"line\">        alert(myFactory.name);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>注：在自定义服务里可以注入内置服务（例$http等），但不能注入$scope作用域对象。</p>\n<h4 id=\"3-service\"><a href=\"#3-service\" class=\"headerlink\" title=\"3.service\"></a>3.service</h4><p>通过service方式创建自定义服务，相当于new的一个对象：var s = new myService();，只要把属性和方法添加到this上才可以在controller里调用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.service(&apos;myService&apos;,function () &#123;</div><div class=\"line\">     此处为return出来的那个对象，对象的属性需要加上this，this[key]=val这种形式。</div><div class=\"line\">     &#125;)</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.service(&apos;myService&apos;, function($http,$q) &#123;</div><div class=\"line\">        this.name = &quot;service&quot;;</div><div class=\"line\">        this.myFunc = function (x) &#123;</div><div class=\"line\">            return x.toString(16);//转16进制</div><div class=\"line\">        &#125;</div><div class=\"line\">        this.getData = function()&#123;</div><div class=\"line\">            var d = $q.defer();</div><div class=\"line\">            $http.get(&quot;ursl&quot;)//读取数据的函数。</div><div class=\"line\">                .success(function(response) &#123;</div><div class=\"line\">                d.resolve(response);</div><div class=\"line\">            &#125;)</div><div class=\"line\">                .error(function()&#123;</div><div class=\"line\">                alert(0)</div><div class=\"line\">                d.reject(&quot;error&quot;);</div><div class=\"line\">            &#125;);</div><div class=\"line\">            return d.promise;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    app.controller(&apos;myCtrl&apos;, function($scope, myService) &#123;</div><div class=\"line\">        $scope.r = myService.myFunc(255);</div><div class=\"line\">        myService.getData().then(function(data)&#123;</div><div class=\"line\">            console.log(data);//正确时走这儿</div><div class=\"line\">        &#125;,function(data)&#123;</div><div class=\"line\">            alert(data)//错误时走这儿</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"4-value\"><a href=\"#4-value\" class=\"headerlink\" title=\"4.value\"></a>4.value</h4><p>以 key与value的形式来写value服务。这个值就是服务实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.value(&apos;my&apos;,&#123;</div><div class=\"line\">          此处为return出来的对象</div><div class=\"line\">     &#125;);</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">有时我们需要在不同的组件之间共享一个变量，可以将这种情况视为一种服务： provider返回的总是变量的值。</div><div class=\"line\">value方法提供了对这种情况的简化封装：</div><div class=\"line\">angular.module(&quot;myModule&quot;,[])</div><div class=\"line\">.value(&quot;myValueService&quot;,&quot;cx129800123&quot;);</div><div class=\"line\"></div><div class=\"line\">INSIDE：AngularJS会将value方法封装为provider，上面的示例 等同于：</div><div class=\"line\">angular.module(&quot;myModule&quot;,[])</div><div class=\"line\">.provider(&quot;myService&quot;,function()&#123;</div><div class=\"line\">this.$get = function()&#123;</div><div class=\"line\">return &quot;cx129800123&quot;;</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"5-constant\"><a href=\"#5-constant\" class=\"headerlink\" title=\"5.constant\"></a>5.constant</h4><p>用法同value，也是以 key ,value的形式，但是可以配置（不是真正意义上的配置），即可以增加属性。配置时不需要再名字后面加Provider。这个常量就是服务实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//配置constant</div><div class=\"line\">   app.config(function (my) &#123;</div><div class=\"line\">       my.currency = &apos;￡&apos;;//在当前属性上增加一个属性</div><div class=\"line\">   &#125;);</div><div class=\"line\">   app.controller(&apos;computed&apos;,function ($scope,my) &#123;</div><div class=\"line\">       //my就是return这个对象,这样就可以使用return出来对象的属性了</div><div class=\"line\">   &#125;)</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">有时我们需要在不同的组件之间共享一个常量，可以将这种情况视为一种服务： provider返回的总是常量的值。constant方法提供了对这种情况的简化封装：</div><div class=\"line\">angular.module(&quot;myModule&quot;,[])</div><div class=\"line\">.constant(&quot;myConstantService&quot;,&quot;Great Wall&quot;);</div><div class=\"line\">和value方法不同，AngularJS并没有将constant方法封装成一个provider，而仅仅是在内部登记这个值。这使得常量在AngularJS的启动配置阶段就可以使用（创建任何 服务之前）：你可以将常量注入到模块的config()方法中。</div></pre></td></tr></table></figure>\n<h4 id=\"在过滤器中注入自定义服务\"><a href=\"#在过滤器中注入自定义服务\" class=\"headerlink\" title=\"在过滤器中注入自定义服务\"></a>在过滤器中注入自定义服务</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;body&gt;</div><div class=\"line\">&lt;div ng-app=&quot;myApp&quot;&gt;</div><div class=\"line\">    在过滤器中使用服务:</div><div class=\"line\">    &lt;h1&gt;&#123;&#123;255 | myFormat&#125;&#125;&lt;/h1&gt;</div><div class=\"line\">    //若使用过滤器时需要传入参数，用：隔开，多个参数用多个：隔开。</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;script&gt;</div><div class=\"line\">    var app = angular.module(&apos;myApp&apos;, []);</div><div class=\"line\">    app.service(&apos;hexafy&apos;, function() &#123;</div><div class=\"line\">        this.myFunc = function (x) &#123;</div><div class=\"line\">            return x.toString(16);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    app.filter(&apos;myFormat&apos;,[&apos;hexafy&apos;, function(hexafy) &#123;</div><div class=\"line\">        return function(x) &#123;</div><div class=\"line\">            return hexafy.myFunc(x);</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;]);</div><div class=\"line\">&lt;/script&gt;</div><div class=\"line\">&lt;/body&gt;</div></pre></td></tr></table></figure>","excerpt":"","more":"<h4 id=\"5种创建自定义服务的方式\"><a href=\"#5种创建自定义服务的方式\" class=\"headerlink\" title=\"5种创建自定义服务的方式\"></a>5种创建自定义服务的方式</h4><p>1.Provider 2.Factory 3.Service 4.value 5.constant,其中只有provider可以配置，factory是项目中最常用的。<br>服务的作用：提取公共内容，封装公有方法，并且服务是单例的。服务对应的是构造函数。服务名字的后面函数其实是一个服务的构造函数，单例相当于只能new一次创建一个实例，不能创建多个实例来使用。<br>service层主查写逻辑代码的，但在angularJS里也可以持久化数据（充当数据容器），以供不同的controller调用。<br>controller层：即控制层，在angularJS里就是写控制器的。控制器里尽量不要写那些不必要的逻辑，尽量写在service层里。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//定义构造函数</div><div class=\"line\">var myServiceProvider = function()&#123;</div><div class=\"line\">this.$get = function()&#123;</div><div class=\"line\">return ....</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\">//在模块中登记</div><div class=\"line\">angular.module(&quot;myModule&quot;,[])</div><div class=\"line\">.provider(&quot;myService&quot;,myServiceProvider);</div></pre></td></tr></table></figure></p>\n<h4 id=\"1-provider\"><a href=\"#1-provider\" class=\"headerlink\" title=\"1.provider\"></a>1.provider</h4><p>provider 可配置  当注入后会默认调用$get方法   仅仅只有provider可配置.<br>只有provder是能传.config() 函数的服务。如果想在 service 对象启用之前，先进行模块范围的配置，那就应该选择 provider。需要注意的是：在config函数里注入provider时，名字应该是：providerName+Provider.<br>使用Provider的优点就是，你可以在Provider对象传递到应用程序的其他部分之前在app.config函数中对其进行修改。 当你使用Provider创建一个service时，唯一的可以在你的控制器中访问的属性和方法是通过$get()函数返回内容。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.provider(&apos;my&apos;,function () &#123;</div><div class=\"line\">    //当我们使用这个服务的时候，会直接调用$get方法</div><div class=\"line\">    this.$get = function () &#123;</div><div class=\"line\">             return &#123;  &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h5 id=\"可配置的服务\"><a href=\"#可配置的服务\" class=\"headerlink\" title=\"可配置的服务\"></a>可配置的服务</h5><p> 有时我们希望服务在不同的场景下可以有不同的行为，这意味着服务可以进行配置。比如，我们希望小计算器可以根据不同的本地化区域，给计算结果追加货币符号前缀， 那么需要在这个服务创建之前，首先配置本地化区域的值，然后在具体的计算中， 根据这个值选择合适的货币符号。<br>      AngularJS使用模块的config()方法对服务进行配置，需要将实例化的服务提供者（而不是服务实例）注入到配置函数中：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&quot;myModule&quot;,[])</div><div class=\"line\">.config([&quot;myServiceProvider&quot;,function(myServiceProvider)&#123;</div><div class=\"line\">//do some configuration.</div><div class=\"line\">&#125;]);</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-factory\"><a href=\"#2-factory\" class=\"headerlink\" title=\"2.factory\"></a>2.factory</h4><p>factory方式创建的服务，作用就是返回一个有属性有方法的对象。相当于：var f = myFactory();<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.factory(&apos;my&apos;,function () &#123;</div><div class=\"line\">return  &#123;&#125;  //返回$get执行后的函数</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">注：使用provider服务时的执行顺序 先config &gt; run &gt; controller</div><div class=\"line\">//需要注意的是：在配置provider时，名字应该是：providerName+Provider   </div><div class=\"line\">    app.config(function(myProviderProvider)&#123;</div><div class=\"line\">        myProviderProvider.setName(&quot;ywx&quot;);       </div><div class=\"line\">    &#125;);</div><div class=\"line\">    app.provider(&apos;myProvider&apos;, function() &#123;</div><div class=\"line\">        var name=&quot;&quot;;</div><div class=\"line\">        var test=&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;;</div><div class=\"line\">        //注意的是，setter方法必须是(set+变量首字母大写)格式</div><div class=\"line\">        this.setName = function(newName)&#123;</div><div class=\"line\">            name = newName  </div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        this.$get =function($http,$q)&#123;</div><div class=\"line\">            return &#123;</div><div class=\"line\">                getData : function()&#123;</div><div class=\"line\">                    var d = $q.defer();</div><div class=\"line\">                    $http.get(&quot;url&quot;)//读取数据的函数。</div><div class=\"line\">                        .success(function(response) &#123;</div><div class=\"line\">                            d.resolve(response);</div><div class=\"line\">                        &#125;)</div><div class=\"line\">                        .error(function()&#123;</div><div class=\"line\">                            d.reject(&quot;error&quot;);</div><div class=\"line\">                        &#125;);</div><div class=\"line\">                    return d.promise;</div><div class=\"line\">                &#125;,</div><div class=\"line\">                &quot;lastName&quot;:name,</div><div class=\"line\">                &quot;test&quot;:test</div><div class=\"line\">            &#125;   </div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div><div class=\"line\">    app.controller(&apos;myCtrl&apos;, function($scope,myProvider) &#123;</div><div class=\"line\">        alert(myProvider.lastName);</div><div class=\"line\">        alert(myProvider.test.a)</div><div class=\"line\">        myProvider.getData().then(function(data)&#123;</div><div class=\"line\">            //alert(data)</div><div class=\"line\">        &#125;,function(data)&#123;</div><div class=\"line\">            //alert(data)</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">//通过工厂模式创建自定义服务</div><div class=\"line\">    app.factory(&apos;myFactory&apos;, function() &#123;</div><div class=\"line\">        var service = &#123;&#125;;//定义一个Object对象&apos;</div><div class=\"line\">        service.name = &quot;张三&quot;;</div><div class=\"line\">        var age;//定义一个私有化的变量</div><div class=\"line\">        //对私有属性写getter和setter方法</div><div class=\"line\">        service.setAge = function(newAge)&#123;</div><div class=\"line\">            age = newAge;</div><div class=\"line\">        &#125;</div><div class=\"line\">        service.getAge = function()&#123;</div><div class=\"line\">            return age; </div><div class=\"line\">        &#125;</div><div class=\"line\">        return service;//返回这个Object对象</div><div class=\"line\">    &#125;);</div><div class=\"line\">//创建控制器</div><div class=\"line\">    app.controller(&apos;myCtrl&apos;, function($scope, myFactory) &#123;</div><div class=\"line\">        myFactory.setAge(20);</div><div class=\"line\">        $scope.r =myFactory.getAge();</div><div class=\"line\">        alert(myFactory.name);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>注：在自定义服务里可以注入内置服务（例$http等），但不能注入$scope作用域对象。</p>\n<h4 id=\"3-service\"><a href=\"#3-service\" class=\"headerlink\" title=\"3.service\"></a>3.service</h4><p>通过service方式创建自定义服务，相当于new的一个对象：var s = new myService();，只要把属性和方法添加到this上才可以在controller里调用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.service(&apos;myService&apos;,function () &#123;</div><div class=\"line\">     此处为return出来的那个对象，对象的属性需要加上this，this[key]=val这种形式。</div><div class=\"line\">     &#125;)</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.service(&apos;myService&apos;, function($http,$q) &#123;</div><div class=\"line\">        this.name = &quot;service&quot;;</div><div class=\"line\">        this.myFunc = function (x) &#123;</div><div class=\"line\">            return x.toString(16);//转16进制</div><div class=\"line\">        &#125;</div><div class=\"line\">        this.getData = function()&#123;</div><div class=\"line\">            var d = $q.defer();</div><div class=\"line\">            $http.get(&quot;ursl&quot;)//读取数据的函数。</div><div class=\"line\">                .success(function(response) &#123;</div><div class=\"line\">                d.resolve(response);</div><div class=\"line\">            &#125;)</div><div class=\"line\">                .error(function()&#123;</div><div class=\"line\">                alert(0)</div><div class=\"line\">                d.reject(&quot;error&quot;);</div><div class=\"line\">            &#125;);</div><div class=\"line\">            return d.promise;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    app.controller(&apos;myCtrl&apos;, function($scope, myService) &#123;</div><div class=\"line\">        $scope.r = myService.myFunc(255);</div><div class=\"line\">        myService.getData().then(function(data)&#123;</div><div class=\"line\">            console.log(data);//正确时走这儿</div><div class=\"line\">        &#125;,function(data)&#123;</div><div class=\"line\">            alert(data)//错误时走这儿</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"4-value\"><a href=\"#4-value\" class=\"headerlink\" title=\"4.value\"></a>4.value</h4><p>以 key与value的形式来写value服务。这个值就是服务实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.value(&apos;my&apos;,&#123;</div><div class=\"line\">          此处为return出来的对象</div><div class=\"line\">     &#125;);</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">有时我们需要在不同的组件之间共享一个变量，可以将这种情况视为一种服务： provider返回的总是变量的值。</div><div class=\"line\">value方法提供了对这种情况的简化封装：</div><div class=\"line\">angular.module(&quot;myModule&quot;,[])</div><div class=\"line\">.value(&quot;myValueService&quot;,&quot;cx129800123&quot;);</div><div class=\"line\"></div><div class=\"line\">INSIDE：AngularJS会将value方法封装为provider，上面的示例 等同于：</div><div class=\"line\">angular.module(&quot;myModule&quot;,[])</div><div class=\"line\">.provider(&quot;myService&quot;,function()&#123;</div><div class=\"line\">this.$get = function()&#123;</div><div class=\"line\">return &quot;cx129800123&quot;;</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"5-constant\"><a href=\"#5-constant\" class=\"headerlink\" title=\"5.constant\"></a>5.constant</h4><p>用法同value，也是以 key ,value的形式，但是可以配置（不是真正意义上的配置），即可以增加属性。配置时不需要再名字后面加Provider。这个常量就是服务实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//配置constant</div><div class=\"line\">   app.config(function (my) &#123;</div><div class=\"line\">       my.currency = &apos;￡&apos;;//在当前属性上增加一个属性</div><div class=\"line\">   &#125;);</div><div class=\"line\">   app.controller(&apos;computed&apos;,function ($scope,my) &#123;</div><div class=\"line\">       //my就是return这个对象,这样就可以使用return出来对象的属性了</div><div class=\"line\">   &#125;)</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">有时我们需要在不同的组件之间共享一个常量，可以将这种情况视为一种服务： provider返回的总是常量的值。constant方法提供了对这种情况的简化封装：</div><div class=\"line\">angular.module(&quot;myModule&quot;,[])</div><div class=\"line\">.constant(&quot;myConstantService&quot;,&quot;Great Wall&quot;);</div><div class=\"line\">和value方法不同，AngularJS并没有将constant方法封装成一个provider，而仅仅是在内部登记这个值。这使得常量在AngularJS的启动配置阶段就可以使用（创建任何 服务之前）：你可以将常量注入到模块的config()方法中。</div></pre></td></tr></table></figure>\n<h4 id=\"在过滤器中注入自定义服务\"><a href=\"#在过滤器中注入自定义服务\" class=\"headerlink\" title=\"在过滤器中注入自定义服务\"></a>在过滤器中注入自定义服务</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;body&gt;</div><div class=\"line\">&lt;div ng-app=&quot;myApp&quot;&gt;</div><div class=\"line\">    在过滤器中使用服务:</div><div class=\"line\">    &lt;h1&gt;&#123;&#123;255 | myFormat&#125;&#125;&lt;/h1&gt;</div><div class=\"line\">    //若使用过滤器时需要传入参数，用：隔开，多个参数用多个：隔开。</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;script&gt;</div><div class=\"line\">    var app = angular.module(&apos;myApp&apos;, []);</div><div class=\"line\">    app.service(&apos;hexafy&apos;, function() &#123;</div><div class=\"line\">        this.myFunc = function (x) &#123;</div><div class=\"line\">            return x.toString(16);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    app.filter(&apos;myFormat&apos;,[&apos;hexafy&apos;, function(hexafy) &#123;</div><div class=\"line\">        return function(x) &#123;</div><div class=\"line\">            return hexafy.myFunc(x);</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;]);</div><div class=\"line\">&lt;/script&gt;</div><div class=\"line\">&lt;/body&gt;</div></pre></td></tr></table></figure>"},{"title":"Angular权威指南学习（第1到5章）模块、控制器及一些基础","date":"2016-05-04T03:35:12.000Z","_content":"#### angular在现代Web应用中经常要用到的一系列高级功能，例如：\n1.解耦应用逻辑、数据模型和视图；2. Ajax服务；3. 依赖注入；4. 浏览历史（使书签和前进、后退按钮能够像在普通Web应用中一样工作）；5. 测试；\n#### ip地址的类型\n目前有IPv4和IPv6两种主要的IP地址类型,普遍使用的是IPv4地址，例如192.168.0.199这种形式，而IPv6地址是IPv62001:0db8:0000:0000:0000:ff00:0042:8329这种形式的。\n#### ng-model\n当AngularJS认为某个值可能发生变化时，它会运行自己的事件循环来检查这个值是否变“脏”。如果该值从上次事件循环运行之后发生了变化，则该值被认为是“脏”值。这也是Angular可以跟踪和响应应用变化的方式。这个事件循环会调用$digest()循环,这个过程被称作脏检查（dirty checking).\n\n#### ng-app\n `ng-app`属性声明所有被其包含的内容都属于这个AngularJS应用，这也是我们可以在Web应用中嵌套AngularJS应用的原因。只有被具有`ng-app`属性的DOM元素包含的元素才会受AngularJS影响.\n\n#### 使用module的好处：\n 1.保持全局命名空间的清洁；2.编写测试代码更容易，并能保持其清洁，以便更容易找到互相隔离的功能；3.易于在不同应用间复用代码；4.使应用能够以任意顺序加载代码的各个部分。\n#### 声明模块\nAngularJS允许我们使用angular.module()方法来声明模块，这个方法能够接受两个参数，\n第一个是模块的名称，第二个是依赖列表，也就是可以被注入到模块中的对象列表。\n```\nangular.module('myApp', []);\n```\n注：这个方法相当于AngularJS模块的setter方法，是用来定义模块的。\n#### 引用模块\n调用这个方法时如果只传递一个参数，就可以用它来引用模块。例如，可以通过以下代码来\n引用myApp模块：`angular.module('myApp')`\n注：这个方法相当于AngularJS模块的getter方法，用来获取对模块的引用。\n#### 作用域\n作用域scope是构成AngularJS应用的核心基础，作用域是视图和控制器之间的胶水。$scope对象是定义应用业务逻辑、控制器方法和视图属性的地方。$scope可以进行嵌套，也就是说我们可以引用父级$scope中的属性。\n#### rootScope\nAngularJS启动并生成视图时，会将根ng-app元素同$rootScope进行绑定。 $rootScope是所有$scope对象的最上层,$scope对象在AngularJS中充当数据模型，但与传统的数据模型不一样， $scope并不负责处理和操作数据，它只是视图和HTML之间的桥梁，它是视图和控制器之间的胶水。\n```\nangular.module('myApp', [])\n.run(function($rootScope) {\n$rootScope.name = \"World\";\n});\n```\n#### 可以在AngularJS应用的模板中使用多种标记\n 1.指令：将DOM元素增强为可复用的DOM组件的属性或元素。2.值绑定：模板语法\\{ \\{\n \\} \\}可以将表达式绑定到视图上。3.过滤器：可以在视图中使用的函数，用来进行格式化。 4.表单控件：用来检验用户输入的控件\n#### ng-controller\nng-controller指令为这个DOM元素创建了一个新的$scope对象，并将它嵌套在$rootScope中。\n```\nangular.module(\"myApp\", [])\n.controller('MyController',\nfunction($scope) {\n$scope.name = \"ywx\";\n});\n```\n#### $scope 的生命周期\n$scope对象的生命周期处理有四个不同阶段。\n1. 创建\n在创建控制器或指令时， AngularJS会用$injector创建一个新的作用域，并在这个新建的控\n制器或指令运行时将作用域传递进去。\n2. 链接\n当Angular开始运行时，所有的$scope对象都会附加或者链接到视图中。所有创建$scope对\n象的函数也会将自身附加到视图中。这些作用域将会注册当Angular应用上下文中发生变化时需\n要运行的函数。\n这些函数被称为$watch函数， Angular通过这些函数获知何时启动事件循环。\n3. 更新\n当事件循环运行时，它通常执行在顶层$scope对象上（被称作$rootScope），每个子作用域\n都执行自己的脏值检测。每个监控函数都会检查变化。如果检测到任意变化， $scope对象就会触\n发指定的回调函数。\n4. 销毁\n当一个$scope在视图中不再需要时，这个作用域将会清理和销毁自己。\n尽管永远不会需要清理作用域（因为Angular会为你处理），但是知道是谁创建了这个作用域\n还是有用的，因为你可以使用这个$scope上叫做$destory()的方法来清理这个作用域。\n#### 控制器\nAngularJS中的控制器是一个函数，用来向视图的作用域中添加额外的功能。我们用它来给\n作用域对象设置初始状态，并添加自定义行为。\n注：将控制器命名为`[Name]Controller`而不是`[Name]Ctrl`是一个最佳实践。\n```\napp.controller('FirstController', function($scope) {\n$scope.counter = 0;\n$scope.add = function(amount) { $scope.counter += amount; };\n$scope.subtract = function(amount) { $scope.counter -= amount; };\n});\n```\n用这种设置方式我们可以在视图中调用add()或subtract()方法，这两个方法可以定义在FirstController的作用域中，或其父级的$scope中。\n注意：AngularJS同其他JavaScript框架最主要的一个区别就是，控制器并不适合用来执行DOM操作、格式化或数据操作，以及除存储数据模型之外的状态维护操作。它只是视图和$scope之间的桥梁。设计良好的应用会将复杂的逻辑放到指令和服务中。通过使用指令和服务，我们可以将控制器重构成一个轻量且更易维护的形式。\n#### 控制器嵌套（作用域包含作用域）\nAngularJS应用的任何一个部分，无论它渲染在哪个上下文中，都有父级作用域存在。对于ng-app所处的层级来讲，它的父级作用域就是$rootScope。\n有一个例外：在指令内部创建的作用域被称作孤立作用域。除了孤立作用域外，所有的作用域都通过原型继承而来，也就是说它们都可以访问父级作用\n域。\n默认情况下， AngularJS在当前作用域中无法找到某个属性时，便会在父级作用域中进行查找。如果AngularJS找不到对应的属性，会顺着父级作用域一直向上寻找，直到抵达$rootScope为止。如果在$rootScope中也找不到，程序会继续运行，但视图无法更新。\n","source":"_posts/angular-guide1-5章.md","raw":"---\ntitle: Angular权威指南学习（第1到5章）模块、控制器及一些基础\ndate: 2016-05-04 11:35:12\ntags: angular、module、controller\n---\n#### angular在现代Web应用中经常要用到的一系列高级功能，例如：\n1.解耦应用逻辑、数据模型和视图；2. Ajax服务；3. 依赖注入；4. 浏览历史（使书签和前进、后退按钮能够像在普通Web应用中一样工作）；5. 测试；\n#### ip地址的类型\n目前有IPv4和IPv6两种主要的IP地址类型,普遍使用的是IPv4地址，例如192.168.0.199这种形式，而IPv6地址是IPv62001:0db8:0000:0000:0000:ff00:0042:8329这种形式的。\n#### ng-model\n当AngularJS认为某个值可能发生变化时，它会运行自己的事件循环来检查这个值是否变“脏”。如果该值从上次事件循环运行之后发生了变化，则该值被认为是“脏”值。这也是Angular可以跟踪和响应应用变化的方式。这个事件循环会调用$digest()循环,这个过程被称作脏检查（dirty checking).\n\n#### ng-app\n `ng-app`属性声明所有被其包含的内容都属于这个AngularJS应用，这也是我们可以在Web应用中嵌套AngularJS应用的原因。只有被具有`ng-app`属性的DOM元素包含的元素才会受AngularJS影响.\n\n#### 使用module的好处：\n 1.保持全局命名空间的清洁；2.编写测试代码更容易，并能保持其清洁，以便更容易找到互相隔离的功能；3.易于在不同应用间复用代码；4.使应用能够以任意顺序加载代码的各个部分。\n#### 声明模块\nAngularJS允许我们使用angular.module()方法来声明模块，这个方法能够接受两个参数，\n第一个是模块的名称，第二个是依赖列表，也就是可以被注入到模块中的对象列表。\n```\nangular.module('myApp', []);\n```\n注：这个方法相当于AngularJS模块的setter方法，是用来定义模块的。\n#### 引用模块\n调用这个方法时如果只传递一个参数，就可以用它来引用模块。例如，可以通过以下代码来\n引用myApp模块：`angular.module('myApp')`\n注：这个方法相当于AngularJS模块的getter方法，用来获取对模块的引用。\n#### 作用域\n作用域scope是构成AngularJS应用的核心基础，作用域是视图和控制器之间的胶水。$scope对象是定义应用业务逻辑、控制器方法和视图属性的地方。$scope可以进行嵌套，也就是说我们可以引用父级$scope中的属性。\n#### rootScope\nAngularJS启动并生成视图时，会将根ng-app元素同$rootScope进行绑定。 $rootScope是所有$scope对象的最上层,$scope对象在AngularJS中充当数据模型，但与传统的数据模型不一样， $scope并不负责处理和操作数据，它只是视图和HTML之间的桥梁，它是视图和控制器之间的胶水。\n```\nangular.module('myApp', [])\n.run(function($rootScope) {\n$rootScope.name = \"World\";\n});\n```\n#### 可以在AngularJS应用的模板中使用多种标记\n 1.指令：将DOM元素增强为可复用的DOM组件的属性或元素。2.值绑定：模板语法\\{ \\{\n \\} \\}可以将表达式绑定到视图上。3.过滤器：可以在视图中使用的函数，用来进行格式化。 4.表单控件：用来检验用户输入的控件\n#### ng-controller\nng-controller指令为这个DOM元素创建了一个新的$scope对象，并将它嵌套在$rootScope中。\n```\nangular.module(\"myApp\", [])\n.controller('MyController',\nfunction($scope) {\n$scope.name = \"ywx\";\n});\n```\n#### $scope 的生命周期\n$scope对象的生命周期处理有四个不同阶段。\n1. 创建\n在创建控制器或指令时， AngularJS会用$injector创建一个新的作用域，并在这个新建的控\n制器或指令运行时将作用域传递进去。\n2. 链接\n当Angular开始运行时，所有的$scope对象都会附加或者链接到视图中。所有创建$scope对\n象的函数也会将自身附加到视图中。这些作用域将会注册当Angular应用上下文中发生变化时需\n要运行的函数。\n这些函数被称为$watch函数， Angular通过这些函数获知何时启动事件循环。\n3. 更新\n当事件循环运行时，它通常执行在顶层$scope对象上（被称作$rootScope），每个子作用域\n都执行自己的脏值检测。每个监控函数都会检查变化。如果检测到任意变化， $scope对象就会触\n发指定的回调函数。\n4. 销毁\n当一个$scope在视图中不再需要时，这个作用域将会清理和销毁自己。\n尽管永远不会需要清理作用域（因为Angular会为你处理），但是知道是谁创建了这个作用域\n还是有用的，因为你可以使用这个$scope上叫做$destory()的方法来清理这个作用域。\n#### 控制器\nAngularJS中的控制器是一个函数，用来向视图的作用域中添加额外的功能。我们用它来给\n作用域对象设置初始状态，并添加自定义行为。\n注：将控制器命名为`[Name]Controller`而不是`[Name]Ctrl`是一个最佳实践。\n```\napp.controller('FirstController', function($scope) {\n$scope.counter = 0;\n$scope.add = function(amount) { $scope.counter += amount; };\n$scope.subtract = function(amount) { $scope.counter -= amount; };\n});\n```\n用这种设置方式我们可以在视图中调用add()或subtract()方法，这两个方法可以定义在FirstController的作用域中，或其父级的$scope中。\n注意：AngularJS同其他JavaScript框架最主要的一个区别就是，控制器并不适合用来执行DOM操作、格式化或数据操作，以及除存储数据模型之外的状态维护操作。它只是视图和$scope之间的桥梁。设计良好的应用会将复杂的逻辑放到指令和服务中。通过使用指令和服务，我们可以将控制器重构成一个轻量且更易维护的形式。\n#### 控制器嵌套（作用域包含作用域）\nAngularJS应用的任何一个部分，无论它渲染在哪个上下文中，都有父级作用域存在。对于ng-app所处的层级来讲，它的父级作用域就是$rootScope。\n有一个例外：在指令内部创建的作用域被称作孤立作用域。除了孤立作用域外，所有的作用域都通过原型继承而来，也就是说它们都可以访问父级作用\n域。\n默认情况下， AngularJS在当前作用域中无法找到某个属性时，便会在父级作用域中进行查找。如果AngularJS找不到对应的属性，会顺着父级作用域一直向上寻找，直到抵达$rootScope为止。如果在$rootScope中也找不到，程序会继续运行，但视图无法更新。\n","slug":"angular-guide1-5章","published":1,"updated":"2016-12-26T05:00:42.778Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv60000hjgtuluwozd7m","content":"<h4 id=\"angular在现代Web应用中经常要用到的一系列高级功能，例如：\"><a href=\"#angular在现代Web应用中经常要用到的一系列高级功能，例如：\" class=\"headerlink\" title=\"angular在现代Web应用中经常要用到的一系列高级功能，例如：\"></a>angular在现代Web应用中经常要用到的一系列高级功能，例如：</h4><p>1.解耦应用逻辑、数据模型和视图；2. Ajax服务；3. 依赖注入；4. 浏览历史（使书签和前进、后退按钮能够像在普通Web应用中一样工作）；5. 测试；</p>\n<h4 id=\"ip地址的类型\"><a href=\"#ip地址的类型\" class=\"headerlink\" title=\"ip地址的类型\"></a>ip地址的类型</h4><p>目前有IPv4和IPv6两种主要的IP地址类型,普遍使用的是IPv4地址，例如192.168.0.199这种形式，而IPv6地址是IPv62001:0db8:0000:0000:0000:ff00:0042:8329这种形式的。</p>\n<h4 id=\"ng-model\"><a href=\"#ng-model\" class=\"headerlink\" title=\"ng-model\"></a>ng-model</h4><p>当AngularJS认为某个值可能发生变化时，它会运行自己的事件循环来检查这个值是否变“脏”。如果该值从上次事件循环运行之后发生了变化，则该值被认为是“脏”值。这也是Angular可以跟踪和响应应用变化的方式。这个事件循环会调用$digest()循环,这个过程被称作脏检查（dirty checking).</p>\n<h4 id=\"ng-app\"><a href=\"#ng-app\" class=\"headerlink\" title=\"ng-app\"></a>ng-app</h4><p> <code>ng-app</code>属性声明所有被其包含的内容都属于这个AngularJS应用，这也是我们可以在Web应用中嵌套AngularJS应用的原因。只有被具有<code>ng-app</code>属性的DOM元素包含的元素才会受AngularJS影响.</p>\n<h4 id=\"使用module的好处：\"><a href=\"#使用module的好处：\" class=\"headerlink\" title=\"使用module的好处：\"></a>使用module的好处：</h4><p> 1.保持全局命名空间的清洁；2.编写测试代码更容易，并能保持其清洁，以便更容易找到互相隔离的功能；3.易于在不同应用间复用代码；4.使应用能够以任意顺序加载代码的各个部分。</p>\n<h4 id=\"声明模块\"><a href=\"#声明模块\" class=\"headerlink\" title=\"声明模块\"></a>声明模块</h4><p>AngularJS允许我们使用angular.module()方法来声明模块，这个方法能够接受两个参数，<br>第一个是模块的名称，第二个是依赖列表，也就是可以被注入到模块中的对象列表。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp&apos;, []);</div></pre></td></tr></table></figure></p>\n<p>注：这个方法相当于AngularJS模块的setter方法，是用来定义模块的。</p>\n<h4 id=\"引用模块\"><a href=\"#引用模块\" class=\"headerlink\" title=\"引用模块\"></a>引用模块</h4><p>调用这个方法时如果只传递一个参数，就可以用它来引用模块。例如，可以通过以下代码来<br>引用myApp模块：<code>angular.module(&#39;myApp&#39;)</code><br>注：这个方法相当于AngularJS模块的getter方法，用来获取对模块的引用。</p>\n<h4 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h4><p>作用域scope是构成AngularJS应用的核心基础，作用域是视图和控制器之间的胶水。$scope对象是定义应用业务逻辑、控制器方法和视图属性的地方。$scope可以进行嵌套，也就是说我们可以引用父级$scope中的属性。</p>\n<h4 id=\"rootScope\"><a href=\"#rootScope\" class=\"headerlink\" title=\"rootScope\"></a>rootScope</h4><p>AngularJS启动并生成视图时，会将根ng-app元素同$rootScope进行绑定。 $rootScope是所有$scope对象的最上层,$scope对象在AngularJS中充当数据模型，但与传统的数据模型不一样， $scope并不负责处理和操作数据，它只是视图和HTML之间的桥梁，它是视图和控制器之间的胶水。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp&apos;, [])</div><div class=\"line\">.run(function($rootScope) &#123;</div><div class=\"line\">$rootScope.name = &quot;World&quot;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"可以在AngularJS应用的模板中使用多种标记\"><a href=\"#可以在AngularJS应用的模板中使用多种标记\" class=\"headerlink\" title=\"可以在AngularJS应用的模板中使用多种标记\"></a>可以在AngularJS应用的模板中使用多种标记</h4><p> 1.指令：将DOM元素增强为可复用的DOM组件的属性或元素。2.值绑定：模板语法{ {<br> } }可以将表达式绑定到视图上。3.过滤器：可以在视图中使用的函数，用来进行格式化。 4.表单控件：用来检验用户输入的控件</p>\n<h4 id=\"ng-controller\"><a href=\"#ng-controller\" class=\"headerlink\" title=\"ng-controller\"></a>ng-controller</h4><p>ng-controller指令为这个DOM元素创建了一个新的$scope对象，并将它嵌套在$rootScope中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&quot;myApp&quot;, [])</div><div class=\"line\">.controller(&apos;MyController&apos;,</div><div class=\"line\">function($scope) &#123;</div><div class=\"line\">$scope.name = &quot;ywx&quot;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"scope-的生命周期\"><a href=\"#scope-的生命周期\" class=\"headerlink\" title=\"$scope 的生命周期\"></a>$scope 的生命周期</h4><p>$scope对象的生命周期处理有四个不同阶段。</p>\n<ol>\n<li>创建<br>在创建控制器或指令时， AngularJS会用$injector创建一个新的作用域，并在这个新建的控<br>制器或指令运行时将作用域传递进去。</li>\n<li>链接<br>当Angular开始运行时，所有的$scope对象都会附加或者链接到视图中。所有创建$scope对<br>象的函数也会将自身附加到视图中。这些作用域将会注册当Angular应用上下文中发生变化时需<br>要运行的函数。<br>这些函数被称为$watch函数， Angular通过这些函数获知何时启动事件循环。</li>\n<li>更新<br>当事件循环运行时，它通常执行在顶层$scope对象上（被称作$rootScope），每个子作用域<br>都执行自己的脏值检测。每个监控函数都会检查变化。如果检测到任意变化， $scope对象就会触<br>发指定的回调函数。</li>\n<li>销毁<br>当一个$scope在视图中不再需要时，这个作用域将会清理和销毁自己。<br>尽管永远不会需要清理作用域（因为Angular会为你处理），但是知道是谁创建了这个作用域<br>还是有用的，因为你可以使用这个$scope上叫做$destory()的方法来清理这个作用域。<h4 id=\"控制器\"><a href=\"#控制器\" class=\"headerlink\" title=\"控制器\"></a>控制器</h4>AngularJS中的控制器是一个函数，用来向视图的作用域中添加额外的功能。我们用它来给<br>作用域对象设置初始状态，并添加自定义行为。<br>注：将控制器命名为<code>[Name]Controller</code>而不是<code>[Name]Ctrl</code>是一个最佳实践。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.controller(&apos;FirstController&apos;, function($scope) &#123;</div><div class=\"line\">$scope.counter = 0;</div><div class=\"line\">$scope.add = function(amount) &#123; $scope.counter += amount; &#125;;</div><div class=\"line\">$scope.subtract = function(amount) &#123; $scope.counter -= amount; &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>用这种设置方式我们可以在视图中调用add()或subtract()方法，这两个方法可以定义在FirstController的作用域中，或其父级的$scope中。<br>注意：AngularJS同其他JavaScript框架最主要的一个区别就是，控制器并不适合用来执行DOM操作、格式化或数据操作，以及除存储数据模型之外的状态维护操作。它只是视图和$scope之间的桥梁。设计良好的应用会将复杂的逻辑放到指令和服务中。通过使用指令和服务，我们可以将控制器重构成一个轻量且更易维护的形式。</p>\n<h4 id=\"控制器嵌套（作用域包含作用域）\"><a href=\"#控制器嵌套（作用域包含作用域）\" class=\"headerlink\" title=\"控制器嵌套（作用域包含作用域）\"></a>控制器嵌套（作用域包含作用域）</h4><p>AngularJS应用的任何一个部分，无论它渲染在哪个上下文中，都有父级作用域存在。对于ng-app所处的层级来讲，它的父级作用域就是$rootScope。<br>有一个例外：在指令内部创建的作用域被称作孤立作用域。除了孤立作用域外，所有的作用域都通过原型继承而来，也就是说它们都可以访问父级作用<br>域。<br>默认情况下， AngularJS在当前作用域中无法找到某个属性时，便会在父级作用域中进行查找。如果AngularJS找不到对应的属性，会顺着父级作用域一直向上寻找，直到抵达$rootScope为止。如果在$rootScope中也找不到，程序会继续运行，但视图无法更新。</p>\n","excerpt":"","more":"<h4 id=\"angular在现代Web应用中经常要用到的一系列高级功能，例如：\"><a href=\"#angular在现代Web应用中经常要用到的一系列高级功能，例如：\" class=\"headerlink\" title=\"angular在现代Web应用中经常要用到的一系列高级功能，例如：\"></a>angular在现代Web应用中经常要用到的一系列高级功能，例如：</h4><p>1.解耦应用逻辑、数据模型和视图；2. Ajax服务；3. 依赖注入；4. 浏览历史（使书签和前进、后退按钮能够像在普通Web应用中一样工作）；5. 测试；</p>\n<h4 id=\"ip地址的类型\"><a href=\"#ip地址的类型\" class=\"headerlink\" title=\"ip地址的类型\"></a>ip地址的类型</h4><p>目前有IPv4和IPv6两种主要的IP地址类型,普遍使用的是IPv4地址，例如192.168.0.199这种形式，而IPv6地址是IPv62001:0db8:0000:0000:0000:ff00:0042:8329这种形式的。</p>\n<h4 id=\"ng-model\"><a href=\"#ng-model\" class=\"headerlink\" title=\"ng-model\"></a>ng-model</h4><p>当AngularJS认为某个值可能发生变化时，它会运行自己的事件循环来检查这个值是否变“脏”。如果该值从上次事件循环运行之后发生了变化，则该值被认为是“脏”值。这也是Angular可以跟踪和响应应用变化的方式。这个事件循环会调用$digest()循环,这个过程被称作脏检查（dirty checking).</p>\n<h4 id=\"ng-app\"><a href=\"#ng-app\" class=\"headerlink\" title=\"ng-app\"></a>ng-app</h4><p> <code>ng-app</code>属性声明所有被其包含的内容都属于这个AngularJS应用，这也是我们可以在Web应用中嵌套AngularJS应用的原因。只有被具有<code>ng-app</code>属性的DOM元素包含的元素才会受AngularJS影响.</p>\n<h4 id=\"使用module的好处：\"><a href=\"#使用module的好处：\" class=\"headerlink\" title=\"使用module的好处：\"></a>使用module的好处：</h4><p> 1.保持全局命名空间的清洁；2.编写测试代码更容易，并能保持其清洁，以便更容易找到互相隔离的功能；3.易于在不同应用间复用代码；4.使应用能够以任意顺序加载代码的各个部分。</p>\n<h4 id=\"声明模块\"><a href=\"#声明模块\" class=\"headerlink\" title=\"声明模块\"></a>声明模块</h4><p>AngularJS允许我们使用angular.module()方法来声明模块，这个方法能够接受两个参数，<br>第一个是模块的名称，第二个是依赖列表，也就是可以被注入到模块中的对象列表。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp&apos;, []);</div></pre></td></tr></table></figure></p>\n<p>注：这个方法相当于AngularJS模块的setter方法，是用来定义模块的。</p>\n<h4 id=\"引用模块\"><a href=\"#引用模块\" class=\"headerlink\" title=\"引用模块\"></a>引用模块</h4><p>调用这个方法时如果只传递一个参数，就可以用它来引用模块。例如，可以通过以下代码来<br>引用myApp模块：<code>angular.module(&#39;myApp&#39;)</code><br>注：这个方法相当于AngularJS模块的getter方法，用来获取对模块的引用。</p>\n<h4 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h4><p>作用域scope是构成AngularJS应用的核心基础，作用域是视图和控制器之间的胶水。$scope对象是定义应用业务逻辑、控制器方法和视图属性的地方。$scope可以进行嵌套，也就是说我们可以引用父级$scope中的属性。</p>\n<h4 id=\"rootScope\"><a href=\"#rootScope\" class=\"headerlink\" title=\"rootScope\"></a>rootScope</h4><p>AngularJS启动并生成视图时，会将根ng-app元素同$rootScope进行绑定。 $rootScope是所有$scope对象的最上层,$scope对象在AngularJS中充当数据模型，但与传统的数据模型不一样， $scope并不负责处理和操作数据，它只是视图和HTML之间的桥梁，它是视图和控制器之间的胶水。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp&apos;, [])</div><div class=\"line\">.run(function($rootScope) &#123;</div><div class=\"line\">$rootScope.name = &quot;World&quot;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"可以在AngularJS应用的模板中使用多种标记\"><a href=\"#可以在AngularJS应用的模板中使用多种标记\" class=\"headerlink\" title=\"可以在AngularJS应用的模板中使用多种标记\"></a>可以在AngularJS应用的模板中使用多种标记</h4><p> 1.指令：将DOM元素增强为可复用的DOM组件的属性或元素。2.值绑定：模板语法{ {<br> } }可以将表达式绑定到视图上。3.过滤器：可以在视图中使用的函数，用来进行格式化。 4.表单控件：用来检验用户输入的控件</p>\n<h4 id=\"ng-controller\"><a href=\"#ng-controller\" class=\"headerlink\" title=\"ng-controller\"></a>ng-controller</h4><p>ng-controller指令为这个DOM元素创建了一个新的$scope对象，并将它嵌套在$rootScope中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&quot;myApp&quot;, [])</div><div class=\"line\">.controller(&apos;MyController&apos;,</div><div class=\"line\">function($scope) &#123;</div><div class=\"line\">$scope.name = &quot;ywx&quot;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"scope-的生命周期\"><a href=\"#scope-的生命周期\" class=\"headerlink\" title=\"$scope 的生命周期\"></a>$scope 的生命周期</h4><p>$scope对象的生命周期处理有四个不同阶段。</p>\n<ol>\n<li>创建<br>在创建控制器或指令时， AngularJS会用$injector创建一个新的作用域，并在这个新建的控<br>制器或指令运行时将作用域传递进去。</li>\n<li>链接<br>当Angular开始运行时，所有的$scope对象都会附加或者链接到视图中。所有创建$scope对<br>象的函数也会将自身附加到视图中。这些作用域将会注册当Angular应用上下文中发生变化时需<br>要运行的函数。<br>这些函数被称为$watch函数， Angular通过这些函数获知何时启动事件循环。</li>\n<li>更新<br>当事件循环运行时，它通常执行在顶层$scope对象上（被称作$rootScope），每个子作用域<br>都执行自己的脏值检测。每个监控函数都会检查变化。如果检测到任意变化， $scope对象就会触<br>发指定的回调函数。</li>\n<li>销毁<br>当一个$scope在视图中不再需要时，这个作用域将会清理和销毁自己。<br>尽管永远不会需要清理作用域（因为Angular会为你处理），但是知道是谁创建了这个作用域<br>还是有用的，因为你可以使用这个$scope上叫做$destory()的方法来清理这个作用域。<h4 id=\"控制器\"><a href=\"#控制器\" class=\"headerlink\" title=\"控制器\"></a>控制器</h4>AngularJS中的控制器是一个函数，用来向视图的作用域中添加额外的功能。我们用它来给<br>作用域对象设置初始状态，并添加自定义行为。<br>注：将控制器命名为<code>[Name]Controller</code>而不是<code>[Name]Ctrl</code>是一个最佳实践。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.controller(&apos;FirstController&apos;, function($scope) &#123;</div><div class=\"line\">$scope.counter = 0;</div><div class=\"line\">$scope.add = function(amount) &#123; $scope.counter += amount; &#125;;</div><div class=\"line\">$scope.subtract = function(amount) &#123; $scope.counter -= amount; &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>用这种设置方式我们可以在视图中调用add()或subtract()方法，这两个方法可以定义在FirstController的作用域中，或其父级的$scope中。<br>注意：AngularJS同其他JavaScript框架最主要的一个区别就是，控制器并不适合用来执行DOM操作、格式化或数据操作，以及除存储数据模型之外的状态维护操作。它只是视图和$scope之间的桥梁。设计良好的应用会将复杂的逻辑放到指令和服务中。通过使用指令和服务，我们可以将控制器重构成一个轻量且更易维护的形式。</p>\n<h4 id=\"控制器嵌套（作用域包含作用域）\"><a href=\"#控制器嵌套（作用域包含作用域）\" class=\"headerlink\" title=\"控制器嵌套（作用域包含作用域）\"></a>控制器嵌套（作用域包含作用域）</h4><p>AngularJS应用的任何一个部分，无论它渲染在哪个上下文中，都有父级作用域存在。对于ng-app所处的层级来讲，它的父级作用域就是$rootScope。<br>有一个例外：在指令内部创建的作用域被称作孤立作用域。除了孤立作用域外，所有的作用域都通过原型继承而来，也就是说它们都可以访问父级作用<br>域。<br>默认情况下， AngularJS在当前作用域中无法找到某个属性时，便会在父级作用域中进行查找。如果AngularJS找不到对应的属性，会顺着父级作用域一直向上寻找，直到抵达$rootScope为止。如果在$rootScope中也找不到，程序会继续运行，但视图无法更新。</p>\n"},{"title":"Angular中的异步请求-xhr","date":"2016-07-19T18:30:12.000Z","_content":"### 跨域和同源策略\n  　同源策略允许页面从同一个站点加载和执行特定的脚本。浏览器通过对比每一个资源的协议、主机名和端口号来判断资源是否与页面同源。站外其他来源的脚本同页面的交互则被严格限制。跨域资源共享（Cross Origin Resource Sharing， CORS）是一个解决跨域问题的好方法，从而可以使用XHR从不同的源加载数据和资源．除此之外：还能使用jsonp,服务器代理（它需要服务器端的额外支持）。\n   1. jsonp\n   JSONP的原理是通过`<script>`标签发起一个GET请求来取代XHR请求。 JSONP生成一个`<script>`标签并插到DOM中，然后浏览器会接管并向src属性所指向的地址发送请求。\n   当服务器返回请求时，响应结果会被包装成一个JavaScript函数，并由该请求所对应的回调函数调用。\n   AngularJS在$http服务中提供了一个JSONP辅助函数。通过$http服务的jsonp方法可以发送请求，如下所示：\n   ```\n   $http\n   .jsonp(\"https://api.github.com?callback=JSON_CALLBACK\") .success(function(data) {\n   // 数据\n   });\n   ```\n   当请求被发送时， AngularJS会在DOM中生成一个如下所示的`<script>`标签：\n   ```\n   <script src=\"https://api.github.com?callback=angular.callbacks._0\"\n   type=\"text/javascript\"></script>\n   ```\n   注意， JSON_CALLBACK被替换成了一个特地为此请求生成的自定义函数。当支持 JSOPN的服务器返回数据时，数据会被包装在由 AngularJS生成的具名函数angular.callbacks._0中。\n   在这个例子中， GitHub服务器会返回包含在回调函数中的JSON数据，响应看起来如下所示：\n   ```\n   // 简写\n   angular.callbacks._0({\n   'meta': {\n   'X-RateLimit-Limit': '60',\n   'status': 200\n   },\n   'data': {\n   'current_user_url': 'https://api.github.com/user'\n   }\n   })\n   ```\n   当AngularJS调用指定的回调函数时会对$http的promise对象进行resolve。\n    jsonp的缺点：1、只能发送get请求。2.有潜在的安全风险。\n   2. 使用 CORS\n   CORS规范简单地扩展了标准的XHR对象，以允许JavaScript发送跨域的XHR请求。它会通过预检查（preflight）来确认是否有权限向目标服务器发送请求。\n   预检查可以让服务器接受或拒绝来自全部服务器、特定服务器或一组服务器的请求。这意味着客户端和服务端应用需要协同工作，才能向客户端或服务器发送数据。\n   1. 设置\n    为了在AngularJS中使用CORS，首先需要告诉AngularJS我们正在使用CORS。使用config()方法在应用模块上设置两个参数以达到此目的。\n    首先，告诉AngularJS使用XDomain，并从所有的请求中把X-Request-With头移除掉。\n    X-Request-With头默认就是移除掉的，但是再次确认它已经被移除没有坏处。\n    ```\n    angular.module('myApp', [])\n    .config(function($httpProvider) {\n    $httpProvider.defaults.useXDomain = true;\n    delete $httpProvider.defaults.headers\n    .common['X-Requested-With'];\n    });\n    ```\n    现在可以发送CORS请求了.\n   2. 服务器端CORS支持\n   支持CORS的服务器必须在响应中加入几个访问控制相关的头。\n    -  Access-Control-Allow-Origin\n   这个头的值可以是与请求头的值相呼应的值，也可以是*，从而允许接收从任何来源发来的请求。\n    -  Access-Control-Allow-Credentials（可选）\n   默认情况下， CORS请求不会发送cookie。如果服务器返回了这个头，那么就可以通过将withCredentials设置为true来将cookie同请求一同发送出去。\n       如果将$http发送的请求中的withCredentials设置为true，但服务器没有返回AccessControl-Allow-Credentials，请求就会失败，反之亦然。\n       后端服务器必须能处理OPTIONS方法的HTTP请求。\n       CORS请求分为简单和非简单两种类型。\n        1. 简单请求\n        如果请求使用下面一种HTTP方法就是简单请求：HEAD；GET；POST。\n        如果请求除了下面列表中的一个或多个HTTP头以外，没有使用其他头： Accept； Accept-Language ； Content-Language； Last-Event-ID； Content-Type；application/x-www-form-urlencoded；multipart/form-data；text/plain。\n        我们把这类请求归类为简单请求，因为浏览器可以不需要使用CORS就发送这类请求。简单请求不要求浏览器和服务器之间有任何的特殊通信。\n        一个使用$http服务的简单CORS请求和其他简单请求看起来是下面这样的：\n        ```\n        $http\n        .get(\"https://api.github.com\")\n        .success(function(data) {\n        // 数据\n        });\n        ```\n        2. 非简单请求\n        不符合简单请求标准的请求被称为非简单请求。如果想要支持PUT或DELETE方法，又或者想给请求设置特殊的内容类型，就需要发送非简单请求。 尽管这些请求在客户端开发者看来没什么不同，但浏览器会以不同的方式处理它们。\n        浏览器实际上会发送两个请求：预请求和请求。浏览器首先会向服务器发送预请求来获得发送请求的许可，只有许可通过了，浏览器才会发送真正的请求。\n        浏览器处理CORS的过程是透明的。\n        同简单请求一样，浏览器会给预请求和请求都加上Origin头。\n        - 预请求\n        浏览器发送的预请求是OPTIONS类型的，预请求中包含以下头信息：\n        1.  Access-Control-Request-Method\n        这个头是请求所使用的HTTP方法，会始终包含在请求中。\n        2.  Access-Control-Request-Headers （可选)\n        这个头的值是一个以逗号分隔的非简单头列表，列表中的每个头都会包含在这个请求中。\n        服务器必须接受这个请求，然后检查HTTP方法和头的合法性。如果通过了检查，服务器会\n        在响应中添加下面这个头：\n        3.  Access-Control-Allow-Origin\n        这个头的值必须和请求的来源相同，或者是*符号，以允许接受来自任何来源的请求。\n        4.  Access-Control-Allow-Methods\n        这是一个可以接受的HTTP方法列表，对在客户端缓存响应结果很有帮助，并且未来发送的\n        请求可以不必总是发送预请求。\n        5.  Access-Control-Allow-Headers\n        如果设置了Access-Control-Request-Headers头，服务器必须在响应中添加同一个头。\n        我们希望服务器在可以接受这个请求时返回200状态码。如果服务器返回了200状态码，真正\n        的请求才会发出。\n        CORS并不是一个安全机制，只是现代浏览器实现的一个标准。在应用中设置安\n        全策略依然是我们的责任。\n        AngularJS中的非简单请求与普通请求看起来没有什么区别：\n        ```\n        $http\n        .delete(\"https://api.github.com/api/users/1\")\n        .success(function(data) {\n        // 数据\n        });\n        ```\n   3. 服务器端代理\n    实现向所有服务器发送请求的最简单方式是使用服务器端代理。这个服务器和页面处在同一 个域中（或者不在同一个域中但支持CORS），做为所有远程资源的代理。\n    可以简单地通过使用本地服务器来代替客户端向外部资源发送请求，并将响应结果返回给客\n    户端。通过这种方式，老式浏览器不必使用需要发送额外请求的CORS（只有现代浏览器支持\n    CORS）也能发送跨域请求，并且可以在浏览器中采用标准的安全策略。为了实现服务器端代理，需要架设一个本地服务器来处理我们所有的请求，并负责向第三方发送实际的请求.\n#### 数据格式：常见的有json、xml。\n   若服务器返回的是json格式的，angular能正常解析，假如服务器返回的是XML而非JSON格式的数据，需要将其转换成JavaScript对象。有不少出色的开源库可以使用，同样，某些浏览器也内置了解析器，可以帮助我们将XML格式转换成JavaScript对象\n   #### 下面介绍一个非常好用的开源库——X2JS\n   首选需要确保安装了X2JS库，我们通过Bower来安装：\n   ```\n   $ bower install x2js\n   ```\n   然后可以在页面中从googlecode.com或我们自己安装的Bower组件中引用这个库：\n   ```\n   <script type=\"text/javascript\"\n   src=\"https://x2js.googlecode.com/hg/xml2json.js\"></script>\n   <!-- 或者 -->\n   <script type=\"text/javascript\"\n   src=\"bower_components/xml2json/xml2json.js\"></script>\n   ```\n   创建一个工厂服务以开始使用这个轻量的XML解析器，这个服务的功能很简单，就是在DOM中解析XML：\n   ```\n   angular.factory('xmlParser', function() {\n   var x2js = new X2JS();\n   return {\n   xml2json: x2js.xml2json,\n   json2xml: x2js.json2xml_str\n   };\n   });\n   ```\n   借助这个轻量的解析服务，可以将$http请求返回的XML解析成JSON格式，如下所示：\n   ```\n   angular.factory('Data', [$http, 'xmlParser', function($http, xmlParser) {\n   $http.get('/api/msgs.xml', {\n   transformResponse: function(data) {\n   return xmlParser.xml2json(data);\n   }\n   });\n   });\n   ```\n   现在请求的结果被转换成了JSON对象，可以像服务器本来返回的就是JSON格式一样来使用这个对象。\n#### 使用 AngularJS 进行身份验证\n   首先必须保证服务器端API的安全性。由于我们处理的代码是未编译的，且可能是由不信任的源发送的，不能假设所有的用户都聪明到可以认识到这些潜在的风险。\n   下面介绍常被用来保护客户端应用的两种方法。\n   1. 服务器端视图渲染\n   如果站点所有的HTML页面都是由后端服务器处理的，可以使用传统的授权方式，由服务器端进行鉴权，只发送客户端需要的HTML。\n   2. 纯客户端身份验证\n   我们希望客户端和服务端的开发工作可以解耦并各自独立进行，且可以将组件独立地发布到生产环境中，互相没有影响。因此，需要通过使用服务器端API来保护客户端身份验证的安全，但并不依赖这些API来进行身份验证。\n   通过令牌授权来实现客户端身份验证，服务器需要做的是给客户端应用提供授权令牌。\n   令牌本身是一个由服务器端生成的随机字符串，由数字和字母组成，它与特定的用户会话相关联。\n   **注：uuid库是用来生成令牌的好选择**\n  当用户登录到我们的站点后，服务器会生成一个随机的令牌，并将用户会话同令牌之间建立关联，用户无需将ID或其他身份验证信息发送给服务器。\n  客户端发送的每个请求都应该包含此令牌，这样服务器才能根据令牌来对请求的发送者进行身份验证。\n  服务器端则无论请求是否合法，都会将对应事件的状态码返回给客户端，这样客户端才能做出响应。\n##### 当客户端收到这些状态码时会做出相应的响应。数据流程如下：\n   1.  一个未经过身份验证的用户浏览了我们的站点；\n   2.  用户试图访问一个受保护的资源，被重定向到登录页面，或者用户手动访问了登录页面；\n   3.  用户输入了他的登录ID（用户名或电子邮箱）以及密码，接着AngularJS应用通过POST用户的信息发送给服务端；\n   4.  服务端对ID和密码进行校验，检查它们是否匹配；\n   5.  如果ID和密码匹配，服务端生成一个唯一的令牌，并将其同一个状态码为200的响应一起返回。如果ID和密码不匹配，服务器返回一个状态码为401的响应。注：401状态码：未授权的请求。\n\n##### 对一个已经通过身份验证的用户（通过了上面5个步骤的用户），流程如下：\n   1. 用户请求一个受保护的资源路径（比如他自己的账号页面）；\n   2. 如果用户尚未登录，应用会将他重定向到登录页面。如果用户登录了，应用会使用该会话对应的令牌来发送请求；\n   3. 服务器对令牌进行校验，并根据请求返回合适的数据。\n","source":"_posts/angular-guide16-xhr实践.md","raw":"---\ntitle: Angular中的异步请求-xhr\ndate: 2016-07-20 02:30:12\ntags: angular、$http\n---\n### 跨域和同源策略\n  　同源策略允许页面从同一个站点加载和执行特定的脚本。浏览器通过对比每一个资源的协议、主机名和端口号来判断资源是否与页面同源。站外其他来源的脚本同页面的交互则被严格限制。跨域资源共享（Cross Origin Resource Sharing， CORS）是一个解决跨域问题的好方法，从而可以使用XHR从不同的源加载数据和资源．除此之外：还能使用jsonp,服务器代理（它需要服务器端的额外支持）。\n   1. jsonp\n   JSONP的原理是通过`<script>`标签发起一个GET请求来取代XHR请求。 JSONP生成一个`<script>`标签并插到DOM中，然后浏览器会接管并向src属性所指向的地址发送请求。\n   当服务器返回请求时，响应结果会被包装成一个JavaScript函数，并由该请求所对应的回调函数调用。\n   AngularJS在$http服务中提供了一个JSONP辅助函数。通过$http服务的jsonp方法可以发送请求，如下所示：\n   ```\n   $http\n   .jsonp(\"https://api.github.com?callback=JSON_CALLBACK\") .success(function(data) {\n   // 数据\n   });\n   ```\n   当请求被发送时， AngularJS会在DOM中生成一个如下所示的`<script>`标签：\n   ```\n   <script src=\"https://api.github.com?callback=angular.callbacks._0\"\n   type=\"text/javascript\"></script>\n   ```\n   注意， JSON_CALLBACK被替换成了一个特地为此请求生成的自定义函数。当支持 JSOPN的服务器返回数据时，数据会被包装在由 AngularJS生成的具名函数angular.callbacks._0中。\n   在这个例子中， GitHub服务器会返回包含在回调函数中的JSON数据，响应看起来如下所示：\n   ```\n   // 简写\n   angular.callbacks._0({\n   'meta': {\n   'X-RateLimit-Limit': '60',\n   'status': 200\n   },\n   'data': {\n   'current_user_url': 'https://api.github.com/user'\n   }\n   })\n   ```\n   当AngularJS调用指定的回调函数时会对$http的promise对象进行resolve。\n    jsonp的缺点：1、只能发送get请求。2.有潜在的安全风险。\n   2. 使用 CORS\n   CORS规范简单地扩展了标准的XHR对象，以允许JavaScript发送跨域的XHR请求。它会通过预检查（preflight）来确认是否有权限向目标服务器发送请求。\n   预检查可以让服务器接受或拒绝来自全部服务器、特定服务器或一组服务器的请求。这意味着客户端和服务端应用需要协同工作，才能向客户端或服务器发送数据。\n   1. 设置\n    为了在AngularJS中使用CORS，首先需要告诉AngularJS我们正在使用CORS。使用config()方法在应用模块上设置两个参数以达到此目的。\n    首先，告诉AngularJS使用XDomain，并从所有的请求中把X-Request-With头移除掉。\n    X-Request-With头默认就是移除掉的，但是再次确认它已经被移除没有坏处。\n    ```\n    angular.module('myApp', [])\n    .config(function($httpProvider) {\n    $httpProvider.defaults.useXDomain = true;\n    delete $httpProvider.defaults.headers\n    .common['X-Requested-With'];\n    });\n    ```\n    现在可以发送CORS请求了.\n   2. 服务器端CORS支持\n   支持CORS的服务器必须在响应中加入几个访问控制相关的头。\n    -  Access-Control-Allow-Origin\n   这个头的值可以是与请求头的值相呼应的值，也可以是*，从而允许接收从任何来源发来的请求。\n    -  Access-Control-Allow-Credentials（可选）\n   默认情况下， CORS请求不会发送cookie。如果服务器返回了这个头，那么就可以通过将withCredentials设置为true来将cookie同请求一同发送出去。\n       如果将$http发送的请求中的withCredentials设置为true，但服务器没有返回AccessControl-Allow-Credentials，请求就会失败，反之亦然。\n       后端服务器必须能处理OPTIONS方法的HTTP请求。\n       CORS请求分为简单和非简单两种类型。\n        1. 简单请求\n        如果请求使用下面一种HTTP方法就是简单请求：HEAD；GET；POST。\n        如果请求除了下面列表中的一个或多个HTTP头以外，没有使用其他头： Accept； Accept-Language ； Content-Language； Last-Event-ID； Content-Type；application/x-www-form-urlencoded；multipart/form-data；text/plain。\n        我们把这类请求归类为简单请求，因为浏览器可以不需要使用CORS就发送这类请求。简单请求不要求浏览器和服务器之间有任何的特殊通信。\n        一个使用$http服务的简单CORS请求和其他简单请求看起来是下面这样的：\n        ```\n        $http\n        .get(\"https://api.github.com\")\n        .success(function(data) {\n        // 数据\n        });\n        ```\n        2. 非简单请求\n        不符合简单请求标准的请求被称为非简单请求。如果想要支持PUT或DELETE方法，又或者想给请求设置特殊的内容类型，就需要发送非简单请求。 尽管这些请求在客户端开发者看来没什么不同，但浏览器会以不同的方式处理它们。\n        浏览器实际上会发送两个请求：预请求和请求。浏览器首先会向服务器发送预请求来获得发送请求的许可，只有许可通过了，浏览器才会发送真正的请求。\n        浏览器处理CORS的过程是透明的。\n        同简单请求一样，浏览器会给预请求和请求都加上Origin头。\n        - 预请求\n        浏览器发送的预请求是OPTIONS类型的，预请求中包含以下头信息：\n        1.  Access-Control-Request-Method\n        这个头是请求所使用的HTTP方法，会始终包含在请求中。\n        2.  Access-Control-Request-Headers （可选)\n        这个头的值是一个以逗号分隔的非简单头列表，列表中的每个头都会包含在这个请求中。\n        服务器必须接受这个请求，然后检查HTTP方法和头的合法性。如果通过了检查，服务器会\n        在响应中添加下面这个头：\n        3.  Access-Control-Allow-Origin\n        这个头的值必须和请求的来源相同，或者是*符号，以允许接受来自任何来源的请求。\n        4.  Access-Control-Allow-Methods\n        这是一个可以接受的HTTP方法列表，对在客户端缓存响应结果很有帮助，并且未来发送的\n        请求可以不必总是发送预请求。\n        5.  Access-Control-Allow-Headers\n        如果设置了Access-Control-Request-Headers头，服务器必须在响应中添加同一个头。\n        我们希望服务器在可以接受这个请求时返回200状态码。如果服务器返回了200状态码，真正\n        的请求才会发出。\n        CORS并不是一个安全机制，只是现代浏览器实现的一个标准。在应用中设置安\n        全策略依然是我们的责任。\n        AngularJS中的非简单请求与普通请求看起来没有什么区别：\n        ```\n        $http\n        .delete(\"https://api.github.com/api/users/1\")\n        .success(function(data) {\n        // 数据\n        });\n        ```\n   3. 服务器端代理\n    实现向所有服务器发送请求的最简单方式是使用服务器端代理。这个服务器和页面处在同一 个域中（或者不在同一个域中但支持CORS），做为所有远程资源的代理。\n    可以简单地通过使用本地服务器来代替客户端向外部资源发送请求，并将响应结果返回给客\n    户端。通过这种方式，老式浏览器不必使用需要发送额外请求的CORS（只有现代浏览器支持\n    CORS）也能发送跨域请求，并且可以在浏览器中采用标准的安全策略。为了实现服务器端代理，需要架设一个本地服务器来处理我们所有的请求，并负责向第三方发送实际的请求.\n#### 数据格式：常见的有json、xml。\n   若服务器返回的是json格式的，angular能正常解析，假如服务器返回的是XML而非JSON格式的数据，需要将其转换成JavaScript对象。有不少出色的开源库可以使用，同样，某些浏览器也内置了解析器，可以帮助我们将XML格式转换成JavaScript对象\n   #### 下面介绍一个非常好用的开源库——X2JS\n   首选需要确保安装了X2JS库，我们通过Bower来安装：\n   ```\n   $ bower install x2js\n   ```\n   然后可以在页面中从googlecode.com或我们自己安装的Bower组件中引用这个库：\n   ```\n   <script type=\"text/javascript\"\n   src=\"https://x2js.googlecode.com/hg/xml2json.js\"></script>\n   <!-- 或者 -->\n   <script type=\"text/javascript\"\n   src=\"bower_components/xml2json/xml2json.js\"></script>\n   ```\n   创建一个工厂服务以开始使用这个轻量的XML解析器，这个服务的功能很简单，就是在DOM中解析XML：\n   ```\n   angular.factory('xmlParser', function() {\n   var x2js = new X2JS();\n   return {\n   xml2json: x2js.xml2json,\n   json2xml: x2js.json2xml_str\n   };\n   });\n   ```\n   借助这个轻量的解析服务，可以将$http请求返回的XML解析成JSON格式，如下所示：\n   ```\n   angular.factory('Data', [$http, 'xmlParser', function($http, xmlParser) {\n   $http.get('/api/msgs.xml', {\n   transformResponse: function(data) {\n   return xmlParser.xml2json(data);\n   }\n   });\n   });\n   ```\n   现在请求的结果被转换成了JSON对象，可以像服务器本来返回的就是JSON格式一样来使用这个对象。\n#### 使用 AngularJS 进行身份验证\n   首先必须保证服务器端API的安全性。由于我们处理的代码是未编译的，且可能是由不信任的源发送的，不能假设所有的用户都聪明到可以认识到这些潜在的风险。\n   下面介绍常被用来保护客户端应用的两种方法。\n   1. 服务器端视图渲染\n   如果站点所有的HTML页面都是由后端服务器处理的，可以使用传统的授权方式，由服务器端进行鉴权，只发送客户端需要的HTML。\n   2. 纯客户端身份验证\n   我们希望客户端和服务端的开发工作可以解耦并各自独立进行，且可以将组件独立地发布到生产环境中，互相没有影响。因此，需要通过使用服务器端API来保护客户端身份验证的安全，但并不依赖这些API来进行身份验证。\n   通过令牌授权来实现客户端身份验证，服务器需要做的是给客户端应用提供授权令牌。\n   令牌本身是一个由服务器端生成的随机字符串，由数字和字母组成，它与特定的用户会话相关联。\n   **注：uuid库是用来生成令牌的好选择**\n  当用户登录到我们的站点后，服务器会生成一个随机的令牌，并将用户会话同令牌之间建立关联，用户无需将ID或其他身份验证信息发送给服务器。\n  客户端发送的每个请求都应该包含此令牌，这样服务器才能根据令牌来对请求的发送者进行身份验证。\n  服务器端则无论请求是否合法，都会将对应事件的状态码返回给客户端，这样客户端才能做出响应。\n##### 当客户端收到这些状态码时会做出相应的响应。数据流程如下：\n   1.  一个未经过身份验证的用户浏览了我们的站点；\n   2.  用户试图访问一个受保护的资源，被重定向到登录页面，或者用户手动访问了登录页面；\n   3.  用户输入了他的登录ID（用户名或电子邮箱）以及密码，接着AngularJS应用通过POST用户的信息发送给服务端；\n   4.  服务端对ID和密码进行校验，检查它们是否匹配；\n   5.  如果ID和密码匹配，服务端生成一个唯一的令牌，并将其同一个状态码为200的响应一起返回。如果ID和密码不匹配，服务器返回一个状态码为401的响应。注：401状态码：未授权的请求。\n\n##### 对一个已经通过身份验证的用户（通过了上面5个步骤的用户），流程如下：\n   1. 用户请求一个受保护的资源路径（比如他自己的账号页面）；\n   2. 如果用户尚未登录，应用会将他重定向到登录页面。如果用户登录了，应用会使用该会话对应的令牌来发送请求；\n   3. 服务器对令牌进行校验，并根据请求返回合适的数据。\n","slug":"angular-guide16-xhr实践","published":1,"updated":"2016-12-22T01:47:35.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv63000jjgtugqiyxfvv","content":"<h3 id=\"跨域和同源策略\"><a href=\"#跨域和同源策略\" class=\"headerlink\" title=\"跨域和同源策略\"></a>跨域和同源策略</h3><p>  　同源策略允许页面从同一个站点加载和执行特定的脚本。浏览器通过对比每一个资源的协议、主机名和端口号来判断资源是否与页面同源。站外其他来源的脚本同页面的交互则被严格限制。跨域资源共享（Cross Origin Resource Sharing， CORS）是一个解决跨域问题的好方法，从而可以使用XHR从不同的源加载数据和资源．除此之外：还能使用jsonp,服务器代理（它需要服务器端的额外支持）。</p>\n<ol>\n<li><p>jsonp<br>JSONP的原理是通过<code>&lt;script&gt;</code>标签发起一个GET请求来取代XHR请求。 JSONP生成一个<code>&lt;script&gt;</code>标签并插到DOM中，然后浏览器会接管并向src属性所指向的地址发送请求。<br>当服务器返回请求时，响应结果会被包装成一个JavaScript函数，并由该请求所对应的回调函数调用。<br>AngularJS在$http服务中提供了一个JSONP辅助函数。通过$http服务的jsonp方法可以发送请求，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$http</div><div class=\"line\">.jsonp(&quot;https://api.github.com?callback=JSON_CALLBACK&quot;) .success(function(data) &#123;</div><div class=\"line\">// 数据</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>当请求被发送时， AngularJS会在DOM中生成一个如下所示的<code>&lt;script&gt;</code>标签：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;https://api.github.com?callback=angular.callbacks._0&quot;</div><div class=\"line\">type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>注意， JSON_CALLBACK被替换成了一个特地为此请求生成的自定义函数。当支持 JSOPN的服务器返回数据时，数据会被包装在由 AngularJS生成的具名函数angular.callbacks._0中。<br>在这个例子中， GitHub服务器会返回包含在回调函数中的JSON数据，响应看起来如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 简写</div><div class=\"line\">angular.callbacks._0(&#123;</div><div class=\"line\">&apos;meta&apos;: &#123;</div><div class=\"line\">&apos;X-RateLimit-Limit&apos;: &apos;60&apos;,</div><div class=\"line\">&apos;status&apos;: 200</div><div class=\"line\">&#125;,</div><div class=\"line\">&apos;data&apos;: &#123;</div><div class=\"line\">&apos;current_user_url&apos;: &apos;https://api.github.com/user&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>当AngularJS调用指定的回调函数时会对$http的promise对象进行resolve。<br>jsonp的缺点：1、只能发送get请求。2.有潜在的安全风险。</p>\n</li>\n<li>使用 CORS<br>CORS规范简单地扩展了标准的XHR对象，以允许JavaScript发送跨域的XHR请求。它会通过预检查（preflight）来确认是否有权限向目标服务器发送请求。<br>预检查可以让服务器接受或拒绝来自全部服务器、特定服务器或一组服务器的请求。这意味着客户端和服务端应用需要协同工作，才能向客户端或服务器发送数据。</li>\n<li><p>设置<br>为了在AngularJS中使用CORS，首先需要告诉AngularJS我们正在使用CORS。使用config()方法在应用模块上设置两个参数以达到此目的。<br>首先，告诉AngularJS使用XDomain，并从所有的请求中把X-Request-With头移除掉。<br>X-Request-With头默认就是移除掉的，但是再次确认它已经被移除没有坏处。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp&apos;, [])</div><div class=\"line\">.config(function($httpProvider) &#123;</div><div class=\"line\">$httpProvider.defaults.useXDomain = true;</div><div class=\"line\">delete $httpProvider.defaults.headers</div><div class=\"line\">.common[&apos;X-Requested-With&apos;];</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>现在可以发送CORS请求了.</p>\n</li>\n<li><p>服务器端CORS支持<br>支持CORS的服务器必须在响应中加入几个访问控制相关的头。</p>\n<ul>\n<li> Access-Control-Allow-Origin<br>这个头的值可以是与请求头的值相呼应的值，也可以是*，从而允许接收从任何来源发来的请求。</li>\n<li><p> Access-Control-Allow-Credentials（可选）<br>默认情况下， CORS请求不会发送cookie。如果服务器返回了这个头，那么就可以通过将withCredentials设置为true来将cookie同请求一同发送出去。<br>如果将$http发送的请求中的withCredentials设置为true，但服务器没有返回AccessControl-Allow-Credentials，请求就会失败，反之亦然。<br>后端服务器必须能处理OPTIONS方法的HTTP请求。<br>CORS请求分为简单和非简单两种类型。</p>\n<ol>\n<li><p>简单请求<br>如果请求使用下面一种HTTP方法就是简单请求：HEAD；GET；POST。<br>如果请求除了下面列表中的一个或多个HTTP头以外，没有使用其他头： Accept； Accept-Language ； Content-Language； Last-Event-ID； Content-Type；application/x-www-form-urlencoded；multipart/form-data；text/plain。<br>我们把这类请求归类为简单请求，因为浏览器可以不需要使用CORS就发送这类请求。简单请求不要求浏览器和服务器之间有任何的特殊通信。<br>一个使用$http服务的简单CORS请求和其他简单请求看起来是下面这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$http</div><div class=\"line\">.get(&quot;https://api.github.com&quot;)</div><div class=\"line\">.success(function(data) &#123;</div><div class=\"line\">// 数据</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>非简单请求<br>不符合简单请求标准的请求被称为非简单请求。如果想要支持PUT或DELETE方法，又或者想给请求设置特殊的内容类型，就需要发送非简单请求。 尽管这些请求在客户端开发者看来没什么不同，但浏览器会以不同的方式处理它们。<br>浏览器实际上会发送两个请求：预请求和请求。浏览器首先会向服务器发送预请求来获得发送请求的许可，只有许可通过了，浏览器才会发送真正的请求。<br>浏览器处理CORS的过程是透明的。<br>同简单请求一样，浏览器会给预请求和请求都加上Origin头。</p>\n</li>\n</ol>\n<ul>\n<li>预请求<br>浏览器发送的预请求是OPTIONS类型的，预请求中包含以下头信息：</li>\n</ul>\n<ol>\n<li> Access-Control-Request-Method<br>这个头是请求所使用的HTTP方法，会始终包含在请求中。</li>\n<li> Access-Control-Request-Headers （可选)<br>这个头的值是一个以逗号分隔的非简单头列表，列表中的每个头都会包含在这个请求中。<br>服务器必须接受这个请求，然后检查HTTP方法和头的合法性。如果通过了检查，服务器会<br>在响应中添加下面这个头：</li>\n<li> Access-Control-Allow-Origin<br>这个头的值必须和请求的来源相同，或者是*符号，以允许接受来自任何来源的请求。</li>\n<li> Access-Control-Allow-Methods<br>这是一个可以接受的HTTP方法列表，对在客户端缓存响应结果很有帮助，并且未来发送的<br>请求可以不必总是发送预请求。</li>\n<li> Access-Control-Allow-Headers<br>如果设置了Access-Control-Request-Headers头，服务器必须在响应中添加同一个头。<br>我们希望服务器在可以接受这个请求时返回200状态码。如果服务器返回了200状态码，真正<br>的请求才会发出。<br>CORS并不是一个安全机制，只是现代浏览器实现的一个标准。在应用中设置安<br>全策略依然是我们的责任。<br>AngularJS中的非简单请求与普通请求看起来没有什么区别：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$http</div><div class=\"line\">.delete(&quot;https://api.github.com/api/users/1&quot;)</div><div class=\"line\">.success(function(data) &#123;</div><div class=\"line\">// 数据</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>服务器端代理<br>实现向所有服务器发送请求的最简单方式是使用服务器端代理。这个服务器和页面处在同一 个域中（或者不在同一个域中但支持CORS），做为所有远程资源的代理。<br>可以简单地通过使用本地服务器来代替客户端向外部资源发送请求，并将响应结果返回给客<br>户端。通过这种方式，老式浏览器不必使用需要发送额外请求的CORS（只有现代浏览器支持<br>CORS）也能发送跨域请求，并且可以在浏览器中采用标准的安全策略。为了实现服务器端代理，需要架设一个本地服务器来处理我们所有的请求，并负责向第三方发送实际的请求.</p>\n<h4 id=\"数据格式：常见的有json、xml。\"><a href=\"#数据格式：常见的有json、xml。\" class=\"headerlink\" title=\"数据格式：常见的有json、xml。\"></a>数据格式：常见的有json、xml。</h4><p>若服务器返回的是json格式的，angular能正常解析，假如服务器返回的是XML而非JSON格式的数据，需要将其转换成JavaScript对象。有不少出色的开源库可以使用，同样，某些浏览器也内置了解析器，可以帮助我们将XML格式转换成JavaScript对象</p>\n<h4 id=\"下面介绍一个非常好用的开源库——X2JS\"><a href=\"#下面介绍一个非常好用的开源库——X2JS\" class=\"headerlink\" title=\"下面介绍一个非常好用的开源库——X2JS\"></a>下面介绍一个非常好用的开源库——X2JS</h4><p>首选需要确保安装了X2JS库，我们通过Bower来安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ bower install x2js</div></pre></td></tr></table></figure>\n<p>然后可以在页面中从googlecode.com或我们自己安装的Bower组件中引用这个库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot;</div><div class=\"line\">src=&quot;https://x2js.googlecode.com/hg/xml2json.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;!-- 或者 --&gt;</div><div class=\"line\">&lt;script type=&quot;text/javascript&quot;</div><div class=\"line\">src=&quot;bower_components/xml2json/xml2json.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>创建一个工厂服务以开始使用这个轻量的XML解析器，这个服务的功能很简单，就是在DOM中解析XML：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.factory(&apos;xmlParser&apos;, function() &#123;</div><div class=\"line\">var x2js = new X2JS();</div><div class=\"line\">return &#123;</div><div class=\"line\">xml2json: x2js.xml2json,</div><div class=\"line\">json2xml: x2js.json2xml_str</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>借助这个轻量的解析服务，可以将$http请求返回的XML解析成JSON格式，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.factory(&apos;Data&apos;, [$http, &apos;xmlParser&apos;, function($http, xmlParser) &#123;</div><div class=\"line\">$http.get(&apos;/api/msgs.xml&apos;, &#123;</div><div class=\"line\">transformResponse: function(data) &#123;</div><div class=\"line\">return xmlParser.xml2json(data);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>现在请求的结果被转换成了JSON对象，可以像服务器本来返回的就是JSON格式一样来使用这个对象。</p>\n<h4 id=\"使用-AngularJS-进行身份验证\"><a href=\"#使用-AngularJS-进行身份验证\" class=\"headerlink\" title=\"使用 AngularJS 进行身份验证\"></a>使用 AngularJS 进行身份验证</h4><p>首先必须保证服务器端API的安全性。由于我们处理的代码是未编译的，且可能是由不信任的源发送的，不能假设所有的用户都聪明到可以认识到这些潜在的风险。<br>下面介绍常被用来保护客户端应用的两种方法。</p>\n</li>\n<li>服务器端视图渲染<br>如果站点所有的HTML页面都是由后端服务器处理的，可以使用传统的授权方式，由服务器端进行鉴权，只发送客户端需要的HTML。</li>\n<li>纯客户端身份验证<br>我们希望客户端和服务端的开发工作可以解耦并各自独立进行，且可以将组件独立地发布到生产环境中，互相没有影响。因此，需要通过使用服务器端API来保护客户端身份验证的安全，但并不依赖这些API来进行身份验证。<br>通过令牌授权来实现客户端身份验证，服务器需要做的是给客户端应用提供授权令牌。<br>令牌本身是一个由服务器端生成的随机字符串，由数字和字母组成，它与特定的用户会话相关联。<br><strong>注：uuid库是用来生成令牌的好选择</strong><br>当用户登录到我们的站点后，服务器会生成一个随机的令牌，并将用户会话同令牌之间建立关联，用户无需将ID或其他身份验证信息发送给服务器。<br>客户端发送的每个请求都应该包含此令牌，这样服务器才能根据令牌来对请求的发送者进行身份验证。<br>服务器端则无论请求是否合法，都会将对应事件的状态码返回给客户端，这样客户端才能做出响应。<h5 id=\"当客户端收到这些状态码时会做出相应的响应。数据流程如下：\"><a href=\"#当客户端收到这些状态码时会做出相应的响应。数据流程如下：\" class=\"headerlink\" title=\"当客户端收到这些状态码时会做出相应的响应。数据流程如下：\"></a>当客户端收到这些状态码时会做出相应的响应。数据流程如下：</h5></li>\n<li>一个未经过身份验证的用户浏览了我们的站点；</li>\n<li>用户试图访问一个受保护的资源，被重定向到登录页面，或者用户手动访问了登录页面；</li>\n<li>用户输入了他的登录ID（用户名或电子邮箱）以及密码，接着AngularJS应用通过POST用户的信息发送给服务端；</li>\n<li>服务端对ID和密码进行校验，检查它们是否匹配；</li>\n<li>如果ID和密码匹配，服务端生成一个唯一的令牌，并将其同一个状态码为200的响应一起返回。如果ID和密码不匹配，服务器返回一个状态码为401的响应。注：401状态码：未授权的请求。</li>\n</ol>\n<h5 id=\"对一个已经通过身份验证的用户（通过了上面5个步骤的用户），流程如下：\"><a href=\"#对一个已经通过身份验证的用户（通过了上面5个步骤的用户），流程如下：\" class=\"headerlink\" title=\"对一个已经通过身份验证的用户（通过了上面5个步骤的用户），流程如下：\"></a>对一个已经通过身份验证的用户（通过了上面5个步骤的用户），流程如下：</h5><ol>\n<li>用户请求一个受保护的资源路径（比如他自己的账号页面）；</li>\n<li>如果用户尚未登录，应用会将他重定向到登录页面。如果用户登录了，应用会使用该会话对应的令牌来发送请求；</li>\n<li>服务器对令牌进行校验，并根据请求返回合适的数据。</li>\n</ol>\n","excerpt":"","more":"<h3 id=\"跨域和同源策略\"><a href=\"#跨域和同源策略\" class=\"headerlink\" title=\"跨域和同源策略\"></a>跨域和同源策略</h3><p>  　同源策略允许页面从同一个站点加载和执行特定的脚本。浏览器通过对比每一个资源的协议、主机名和端口号来判断资源是否与页面同源。站外其他来源的脚本同页面的交互则被严格限制。跨域资源共享（Cross Origin Resource Sharing， CORS）是一个解决跨域问题的好方法，从而可以使用XHR从不同的源加载数据和资源．除此之外：还能使用jsonp,服务器代理（它需要服务器端的额外支持）。</p>\n<ol>\n<li><p>jsonp<br>JSONP的原理是通过<code>&lt;script&gt;</code>标签发起一个GET请求来取代XHR请求。 JSONP生成一个<code>&lt;script&gt;</code>标签并插到DOM中，然后浏览器会接管并向src属性所指向的地址发送请求。<br>当服务器返回请求时，响应结果会被包装成一个JavaScript函数，并由该请求所对应的回调函数调用。<br>AngularJS在$http服务中提供了一个JSONP辅助函数。通过$http服务的jsonp方法可以发送请求，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$http</div><div class=\"line\">.jsonp(&quot;https://api.github.com?callback=JSON_CALLBACK&quot;) .success(function(data) &#123;</div><div class=\"line\">// 数据</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>当请求被发送时， AngularJS会在DOM中生成一个如下所示的<code>&lt;script&gt;</code>标签：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;https://api.github.com?callback=angular.callbacks._0&quot;</div><div class=\"line\">type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>注意， JSON_CALLBACK被替换成了一个特地为此请求生成的自定义函数。当支持 JSOPN的服务器返回数据时，数据会被包装在由 AngularJS生成的具名函数angular.callbacks._0中。<br>在这个例子中， GitHub服务器会返回包含在回调函数中的JSON数据，响应看起来如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 简写</div><div class=\"line\">angular.callbacks._0(&#123;</div><div class=\"line\">&apos;meta&apos;: &#123;</div><div class=\"line\">&apos;X-RateLimit-Limit&apos;: &apos;60&apos;,</div><div class=\"line\">&apos;status&apos;: 200</div><div class=\"line\">&#125;,</div><div class=\"line\">&apos;data&apos;: &#123;</div><div class=\"line\">&apos;current_user_url&apos;: &apos;https://api.github.com/user&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>当AngularJS调用指定的回调函数时会对$http的promise对象进行resolve。<br>jsonp的缺点：1、只能发送get请求。2.有潜在的安全风险。</p>\n</li>\n<li>使用 CORS<br>CORS规范简单地扩展了标准的XHR对象，以允许JavaScript发送跨域的XHR请求。它会通过预检查（preflight）来确认是否有权限向目标服务器发送请求。<br>预检查可以让服务器接受或拒绝来自全部服务器、特定服务器或一组服务器的请求。这意味着客户端和服务端应用需要协同工作，才能向客户端或服务器发送数据。</li>\n<li><p>设置<br>为了在AngularJS中使用CORS，首先需要告诉AngularJS我们正在使用CORS。使用config()方法在应用模块上设置两个参数以达到此目的。<br>首先，告诉AngularJS使用XDomain，并从所有的请求中把X-Request-With头移除掉。<br>X-Request-With头默认就是移除掉的，但是再次确认它已经被移除没有坏处。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp&apos;, [])</div><div class=\"line\">.config(function($httpProvider) &#123;</div><div class=\"line\">$httpProvider.defaults.useXDomain = true;</div><div class=\"line\">delete $httpProvider.defaults.headers</div><div class=\"line\">.common[&apos;X-Requested-With&apos;];</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>现在可以发送CORS请求了.</p>\n</li>\n<li><p>服务器端CORS支持<br>支持CORS的服务器必须在响应中加入几个访问控制相关的头。</p>\n<ul>\n<li> Access-Control-Allow-Origin<br>这个头的值可以是与请求头的值相呼应的值，也可以是*，从而允许接收从任何来源发来的请求。</li>\n<li><p> Access-Control-Allow-Credentials（可选）<br>默认情况下， CORS请求不会发送cookie。如果服务器返回了这个头，那么就可以通过将withCredentials设置为true来将cookie同请求一同发送出去。<br>如果将$http发送的请求中的withCredentials设置为true，但服务器没有返回AccessControl-Allow-Credentials，请求就会失败，反之亦然。<br>后端服务器必须能处理OPTIONS方法的HTTP请求。<br>CORS请求分为简单和非简单两种类型。</p>\n<ol>\n<li><p>简单请求<br>如果请求使用下面一种HTTP方法就是简单请求：HEAD；GET；POST。<br>如果请求除了下面列表中的一个或多个HTTP头以外，没有使用其他头： Accept； Accept-Language ； Content-Language； Last-Event-ID； Content-Type；application/x-www-form-urlencoded；multipart/form-data；text/plain。<br>我们把这类请求归类为简单请求，因为浏览器可以不需要使用CORS就发送这类请求。简单请求不要求浏览器和服务器之间有任何的特殊通信。<br>一个使用$http服务的简单CORS请求和其他简单请求看起来是下面这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$http</div><div class=\"line\">.get(&quot;https://api.github.com&quot;)</div><div class=\"line\">.success(function(data) &#123;</div><div class=\"line\">// 数据</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>非简单请求<br>不符合简单请求标准的请求被称为非简单请求。如果想要支持PUT或DELETE方法，又或者想给请求设置特殊的内容类型，就需要发送非简单请求。 尽管这些请求在客户端开发者看来没什么不同，但浏览器会以不同的方式处理它们。<br>浏览器实际上会发送两个请求：预请求和请求。浏览器首先会向服务器发送预请求来获得发送请求的许可，只有许可通过了，浏览器才会发送真正的请求。<br>浏览器处理CORS的过程是透明的。<br>同简单请求一样，浏览器会给预请求和请求都加上Origin头。</p>\n</li>\n</ol>\n<ul>\n<li>预请求<br>浏览器发送的预请求是OPTIONS类型的，预请求中包含以下头信息：</li>\n</ul>\n<ol>\n<li> Access-Control-Request-Method<br>这个头是请求所使用的HTTP方法，会始终包含在请求中。</li>\n<li> Access-Control-Request-Headers （可选)<br>这个头的值是一个以逗号分隔的非简单头列表，列表中的每个头都会包含在这个请求中。<br>服务器必须接受这个请求，然后检查HTTP方法和头的合法性。如果通过了检查，服务器会<br>在响应中添加下面这个头：</li>\n<li> Access-Control-Allow-Origin<br>这个头的值必须和请求的来源相同，或者是*符号，以允许接受来自任何来源的请求。</li>\n<li> Access-Control-Allow-Methods<br>这是一个可以接受的HTTP方法列表，对在客户端缓存响应结果很有帮助，并且未来发送的<br>请求可以不必总是发送预请求。</li>\n<li> Access-Control-Allow-Headers<br>如果设置了Access-Control-Request-Headers头，服务器必须在响应中添加同一个头。<br>我们希望服务器在可以接受这个请求时返回200状态码。如果服务器返回了200状态码，真正<br>的请求才会发出。<br>CORS并不是一个安全机制，只是现代浏览器实现的一个标准。在应用中设置安<br>全策略依然是我们的责任。<br>AngularJS中的非简单请求与普通请求看起来没有什么区别：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$http</div><div class=\"line\">.delete(&quot;https://api.github.com/api/users/1&quot;)</div><div class=\"line\">.success(function(data) &#123;</div><div class=\"line\">// 数据</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>服务器端代理<br>实现向所有服务器发送请求的最简单方式是使用服务器端代理。这个服务器和页面处在同一 个域中（或者不在同一个域中但支持CORS），做为所有远程资源的代理。<br>可以简单地通过使用本地服务器来代替客户端向外部资源发送请求，并将响应结果返回给客<br>户端。通过这种方式，老式浏览器不必使用需要发送额外请求的CORS（只有现代浏览器支持<br>CORS）也能发送跨域请求，并且可以在浏览器中采用标准的安全策略。为了实现服务器端代理，需要架设一个本地服务器来处理我们所有的请求，并负责向第三方发送实际的请求.</p>\n<h4 id=\"数据格式：常见的有json、xml。\"><a href=\"#数据格式：常见的有json、xml。\" class=\"headerlink\" title=\"数据格式：常见的有json、xml。\"></a>数据格式：常见的有json、xml。</h4><p>若服务器返回的是json格式的，angular能正常解析，假如服务器返回的是XML而非JSON格式的数据，需要将其转换成JavaScript对象。有不少出色的开源库可以使用，同样，某些浏览器也内置了解析器，可以帮助我们将XML格式转换成JavaScript对象</p>\n<h4 id=\"下面介绍一个非常好用的开源库——X2JS\"><a href=\"#下面介绍一个非常好用的开源库——X2JS\" class=\"headerlink\" title=\"下面介绍一个非常好用的开源库——X2JS\"></a>下面介绍一个非常好用的开源库——X2JS</h4><p>首选需要确保安装了X2JS库，我们通过Bower来安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ bower install x2js</div></pre></td></tr></table></figure>\n<p>然后可以在页面中从googlecode.com或我们自己安装的Bower组件中引用这个库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot;</div><div class=\"line\">src=&quot;https://x2js.googlecode.com/hg/xml2json.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;!-- 或者 --&gt;</div><div class=\"line\">&lt;script type=&quot;text/javascript&quot;</div><div class=\"line\">src=&quot;bower_components/xml2json/xml2json.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>创建一个工厂服务以开始使用这个轻量的XML解析器，这个服务的功能很简单，就是在DOM中解析XML：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.factory(&apos;xmlParser&apos;, function() &#123;</div><div class=\"line\">var x2js = new X2JS();</div><div class=\"line\">return &#123;</div><div class=\"line\">xml2json: x2js.xml2json,</div><div class=\"line\">json2xml: x2js.json2xml_str</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>借助这个轻量的解析服务，可以将$http请求返回的XML解析成JSON格式，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.factory(&apos;Data&apos;, [$http, &apos;xmlParser&apos;, function($http, xmlParser) &#123;</div><div class=\"line\">$http.get(&apos;/api/msgs.xml&apos;, &#123;</div><div class=\"line\">transformResponse: function(data) &#123;</div><div class=\"line\">return xmlParser.xml2json(data);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>现在请求的结果被转换成了JSON对象，可以像服务器本来返回的就是JSON格式一样来使用这个对象。</p>\n<h4 id=\"使用-AngularJS-进行身份验证\"><a href=\"#使用-AngularJS-进行身份验证\" class=\"headerlink\" title=\"使用 AngularJS 进行身份验证\"></a>使用 AngularJS 进行身份验证</h4><p>首先必须保证服务器端API的安全性。由于我们处理的代码是未编译的，且可能是由不信任的源发送的，不能假设所有的用户都聪明到可以认识到这些潜在的风险。<br>下面介绍常被用来保护客户端应用的两种方法。</p>\n</li>\n<li>服务器端视图渲染<br>如果站点所有的HTML页面都是由后端服务器处理的，可以使用传统的授权方式，由服务器端进行鉴权，只发送客户端需要的HTML。</li>\n<li>纯客户端身份验证<br>我们希望客户端和服务端的开发工作可以解耦并各自独立进行，且可以将组件独立地发布到生产环境中，互相没有影响。因此，需要通过使用服务器端API来保护客户端身份验证的安全，但并不依赖这些API来进行身份验证。<br>通过令牌授权来实现客户端身份验证，服务器需要做的是给客户端应用提供授权令牌。<br>令牌本身是一个由服务器端生成的随机字符串，由数字和字母组成，它与特定的用户会话相关联。<br><strong>注：uuid库是用来生成令牌的好选择</strong><br>当用户登录到我们的站点后，服务器会生成一个随机的令牌，并将用户会话同令牌之间建立关联，用户无需将ID或其他身份验证信息发送给服务器。<br>客户端发送的每个请求都应该包含此令牌，这样服务器才能根据令牌来对请求的发送者进行身份验证。<br>服务器端则无论请求是否合法，都会将对应事件的状态码返回给客户端，这样客户端才能做出响应。<h5 id=\"当客户端收到这些状态码时会做出相应的响应。数据流程如下：\"><a href=\"#当客户端收到这些状态码时会做出相应的响应。数据流程如下：\" class=\"headerlink\" title=\"当客户端收到这些状态码时会做出相应的响应。数据流程如下：\"></a>当客户端收到这些状态码时会做出相应的响应。数据流程如下：</h5></li>\n<li>一个未经过身份验证的用户浏览了我们的站点；</li>\n<li>用户试图访问一个受保护的资源，被重定向到登录页面，或者用户手动访问了登录页面；</li>\n<li>用户输入了他的登录ID（用户名或电子邮箱）以及密码，接着AngularJS应用通过POST用户的信息发送给服务端；</li>\n<li>服务端对ID和密码进行校验，检查它们是否匹配；</li>\n<li>如果ID和密码匹配，服务端生成一个唯一的令牌，并将其同一个状态码为200的响应一起返回。如果ID和密码不匹配，服务器返回一个状态码为401的响应。注：401状态码：未授权的请求。</li>\n</ol>\n<h5 id=\"对一个已经通过身份验证的用户（通过了上面5个步骤的用户），流程如下：\"><a href=\"#对一个已经通过身份验证的用户（通过了上面5个步骤的用户），流程如下：\" class=\"headerlink\" title=\"对一个已经通过身份验证的用户（通过了上面5个步骤的用户），流程如下：\"></a>对一个已经通过身份验证的用户（通过了上面5个步骤的用户），流程如下：</h5><ol>\n<li>用户请求一个受保护的资源路径（比如他自己的账号页面）；</li>\n<li>如果用户尚未登录，应用会将他重定向到登录页面。如果用户登录了，应用会使用该会话对应的令牌来发送请求；</li>\n<li>服务器对令牌进行校验，并根据请求返回合适的数据。</li>\n</ol>\n"},{"title":"Angular中如何使用promise","date":"2016-06-28T16:50:58.000Z","_content":"#### Angular 中的 promise\nAngular的事件循环给予了Angular特有的能力，能在$rootScope.$evalAsync阶段中执行promise, promise会坐等$digest运行循环结束。\n我们来建一个例子，从GitHub上返回一组针对AngularJS的开放pull请求。\n```\n<h1>Open Pull Requests for Angular JS</h1>\n<ul ng-controller=\"DashboardController\">\n<li ng-repeat=\"pr in pullRequests\">\n{{ pr.title }}\n</li>\n</ul>\n```\n如果有个服务返回了一个promise，可以在.then()方法中与这个promise交互，它允许我们修改作用域上的任意变量，放置到视图上，并且期望Angular会为我们执行它：\n```\nangular.module('myApp', [])\n.controller('DashboardController', [\n'$scope', 'GithubService',\nfunction($scope, UserService) {\n// GithubService的getPullRequests()方法\n// 返回了一个promise\nUser.getPullRequests(123)\n.then(function(data) {\n$scope.pullRequests = data.data;\n});\n}]);\n```\n当 对 getPullRequests 的 异 步 调 用 返回 时 ， 在 .then()方 法 中 就 可 以 用 $scope.pull Requests这个值了，然后它会更新$scope.pullRequests数组。\nAngular 中的 promise\nAngular的事件循环给予了Angular特有的能力，能在$rootScope.$evalAsync阶段中执行\npromise（关于运行循环的更多细节，参见第24章）。 promise会坐等$digest运行循环结束。\n这件事让我们能毫无压力地把promise的结果转换到视图上。它也能让我们不加思考地把\nXHR调用的结果直接赋值到$scope对象的属性上。\n```\n<h1>Open Pull Requests for Angular JS</h1>\n<ul ng-controller=\"DashboardController\">\n<li ng-repeat=\"pr in pullRequests\">\n{{ pr.title }}\n</li>\n</ul>\n```\n如果有个服务返回了一个promise，可以在.then()方法中与这个promise交互，它允许我们修改作用域上的任意变量，放置到视图上，并且期望Angular会为我们执行它：\n```\nangular.module('myApp', [])\n.controller('DashboardController', [\n'$scope', 'GithubService',\nfunction($scope, UserService) {\n// GithubService的getPullRequests()方法\n// 返回了一个promise\nUser.getPullRequests(123)\n.then(function(data) {\n$scope.pullRequests = data.data;\n});\n}]);\n```\n当 对 getPullRequests 的 异 步 调 用 返回 时 ， 在 .then()方 法 中 就 可 以 用 $scope.pull\nRequests这个值了，然后它会更新$scope.pullRequests数组。\n\n#### 如何创建一个 promise\n想要在Angular中创建promise，可以使用内置的$q服务。 $q服务在它的deferred API中提供了一些方法。\n首先，需要把$q服务注入到想要使用它的对象中。\n```\nangular.module('myApp', [])\n.factory('GithubService', ['$q', function($q) {\n// 现在就可以访问到$q库了\n}]);\n```\n要创建一个deferred对象，可以调用defer()方法：\n```\nvar deferred = $q.defer();\n```\ndeferred对象暴露了三个方法，以及一个可以用于处理promise的promise属性。\n可以用于处理promise的promise属性：这句话其实就是说deferred对象有一个promise属性。即deferred.promise。\ndeffered 对象属性promise ：最后返回的是一个新的deferred对象 promise 属性，而不是原来的deferred对象。这个新的Promise对象只能观察原来Promise对象的状态，而无法修改deferred对象的内在状态可以防止任务状态被外部修改。\n1. resolve（value）\nresolve函数用这个值来执行deferred promise。\n```\ndeferred.resolve({name: \"Ari\", username: \"@auser\"});\n```\n2. reject（reason）\n这个方法用一个原因来拒绝deferred promise。它等同于使用一个“拒绝”来执行一个promise。\n```\ndeferred.reject(\"Can't update user\");\n// 等同于\ndeferred.resolve($q.reject(\"Can't update user\"));\n```\n3.  notify（value）\n这个方法用promise的执行状态来进行响应。notify 回调可能被调用 0到多次,提供一个进度指示在解决或拒绝（resolve和rejected）之前。\n#### 方法介绍：\n$http(options)返回的是一个被封装的promise对象，可以直接使用.then等方法。\n1. then(successFn, errFn, notifyFn)\n无论promise成功还是失败了，当结果可用之后， then都会立刻异步调用successFn或者errFn。这个方法始终用一个参数来调用回调函数：结果，或者是拒绝的理由。在promise被执行或者拒绝之前， notifyFn回调可能会被调用0到多次，以提供过程状态的提示。\nthen()方法总是返回一个新的promise，可以通过successFn或者errFn这样的返回值执行或者被拒绝。它也能通过notifyFn提供通知。\n2. catch(errFn)\n这个方法就只是个帮助函数，能让我们用.catch(function(reason){})取代err回调：\n```\n$http.get('/repos/angular/angular.js/pulls')\n.catch(function(reason) {\ndeferred.reject(reason);\n});\n```\n3. finally(callback)\nfinally方法允许我们观察promise的履行或者拒绝，而无需修改结果的值。当我们需要释放一个资源，或者是运行一些清理工作，不管promise是成功还是失败时，这个方法会很有用。\n我们不能直接调用这个方法，因为finally是IE中JavaScript的一个保留字。纠结到最后，只好这样调用它了：\n```\npromise['finally'](function() {});\n```\nAngular的$q deferred对象是可以串成链的，这样即使是then，返回的也是一个promise。这个promise一被执行， then返回的promise就已经是resolved或者rejected的了。\n#### $q服务类似于原始的Kris Kowal的Q库：\n   1. $q是跟Angular的$rootScope模型集成的，所以在Angular中，执行和拒绝都很快。\n   2. $q promise是跟Angular模板引擎集成的，这意味着在视图中找到的任何promise都会在视\n图中被执行或者拒绝。\n   3. $q很小，所以没有包含Q库的完整功能。\n### 链式请求\nthen方法在初始promise被执行之后，返回一个新的派生promise。这种返回形式给了我们一种特有的能力，把另一个then接在初始的then方法结果之后。\n```\n// 一个响应promise的服务\nGithubService.then(function(data) {\nvar events = [];\nfor (var i = 0; i < data.length; i++) {\nevents.push(data[i].events);\n}\nreturn events;\n}).then(function(events) {\n$scope.events = events;\n});\n```\n在本例中，我们可以创建一个执行链，它允许我们中断基于更多功能的应用流程，可以籍此导向不同的结果。这个中断能让我们在执行链的任意时刻暂停或者推迟promise的执行。\n#### $q库自带了几个不同的有用方法。\n1. all(promises)\n如果我们有多个promise，想要把它们合并成一个，可以使用$q.all(promises)方法来把它们合并成一个promise。这个方法带有一个参数。即promises（数组或者promise对象），一个promise数组或者promise的hash。\nall()方法返回单个promise，会执行一个数组或者一个散列的值。每个值会响应promise散列中的相同序号或者键。如果任意一个promise被拒绝了，结果的promise也会被拒绝。\n2. defer()\n  defer()方法创建了一个deferred对象，它没有参数，返回deferred对象的一个实例。\n3. reject(reason)\n这个方法创建了一个promise，被以某一原因拒绝执行了。它专门用于让我们能在一个promise链中转发拒绝的promise，类似JavaScript中的throw。在同样意义上，我们能在JavaScript中捕获一个异常，也能够转发这个拒绝，我们需要把这个错误重新抛出。可以通过$q.reject(reason)来做到这点。\n这个方法带有单个参数：reason（常量、字符串、异常、对象），拒绝的原因。\nreject()方法返回一个已经用某个原因拒绝的promise。\n4. when(value)\nwhen()函数把一个可能是值或者能接着then的promise包装成一个$q promise。这样我们就能处理一个可能是也可能不是promise的对象。when()函数有一个参数： value，该参数是个值，或者是promise\nwhen()函数返回了一个promise，我们可以像使用其他promise一样使用它。\n","source":"_posts/angular-guide17-angular中的promise.md","raw":"---\ntitle: Angular中如何使用promise\ndate: 2016-06-29 00:50:58\ntags: angular、promise、$q、deferred\n---\n#### Angular 中的 promise\nAngular的事件循环给予了Angular特有的能力，能在$rootScope.$evalAsync阶段中执行promise, promise会坐等$digest运行循环结束。\n我们来建一个例子，从GitHub上返回一组针对AngularJS的开放pull请求。\n```\n<h1>Open Pull Requests for Angular JS</h1>\n<ul ng-controller=\"DashboardController\">\n<li ng-repeat=\"pr in pullRequests\">\n{{ pr.title }}\n</li>\n</ul>\n```\n如果有个服务返回了一个promise，可以在.then()方法中与这个promise交互，它允许我们修改作用域上的任意变量，放置到视图上，并且期望Angular会为我们执行它：\n```\nangular.module('myApp', [])\n.controller('DashboardController', [\n'$scope', 'GithubService',\nfunction($scope, UserService) {\n// GithubService的getPullRequests()方法\n// 返回了一个promise\nUser.getPullRequests(123)\n.then(function(data) {\n$scope.pullRequests = data.data;\n});\n}]);\n```\n当 对 getPullRequests 的 异 步 调 用 返回 时 ， 在 .then()方 法 中 就 可 以 用 $scope.pull Requests这个值了，然后它会更新$scope.pullRequests数组。\nAngular 中的 promise\nAngular的事件循环给予了Angular特有的能力，能在$rootScope.$evalAsync阶段中执行\npromise（关于运行循环的更多细节，参见第24章）。 promise会坐等$digest运行循环结束。\n这件事让我们能毫无压力地把promise的结果转换到视图上。它也能让我们不加思考地把\nXHR调用的结果直接赋值到$scope对象的属性上。\n```\n<h1>Open Pull Requests for Angular JS</h1>\n<ul ng-controller=\"DashboardController\">\n<li ng-repeat=\"pr in pullRequests\">\n{{ pr.title }}\n</li>\n</ul>\n```\n如果有个服务返回了一个promise，可以在.then()方法中与这个promise交互，它允许我们修改作用域上的任意变量，放置到视图上，并且期望Angular会为我们执行它：\n```\nangular.module('myApp', [])\n.controller('DashboardController', [\n'$scope', 'GithubService',\nfunction($scope, UserService) {\n// GithubService的getPullRequests()方法\n// 返回了一个promise\nUser.getPullRequests(123)\n.then(function(data) {\n$scope.pullRequests = data.data;\n});\n}]);\n```\n当 对 getPullRequests 的 异 步 调 用 返回 时 ， 在 .then()方 法 中 就 可 以 用 $scope.pull\nRequests这个值了，然后它会更新$scope.pullRequests数组。\n\n#### 如何创建一个 promise\n想要在Angular中创建promise，可以使用内置的$q服务。 $q服务在它的deferred API中提供了一些方法。\n首先，需要把$q服务注入到想要使用它的对象中。\n```\nangular.module('myApp', [])\n.factory('GithubService', ['$q', function($q) {\n// 现在就可以访问到$q库了\n}]);\n```\n要创建一个deferred对象，可以调用defer()方法：\n```\nvar deferred = $q.defer();\n```\ndeferred对象暴露了三个方法，以及一个可以用于处理promise的promise属性。\n可以用于处理promise的promise属性：这句话其实就是说deferred对象有一个promise属性。即deferred.promise。\ndeffered 对象属性promise ：最后返回的是一个新的deferred对象 promise 属性，而不是原来的deferred对象。这个新的Promise对象只能观察原来Promise对象的状态，而无法修改deferred对象的内在状态可以防止任务状态被外部修改。\n1. resolve（value）\nresolve函数用这个值来执行deferred promise。\n```\ndeferred.resolve({name: \"Ari\", username: \"@auser\"});\n```\n2. reject（reason）\n这个方法用一个原因来拒绝deferred promise。它等同于使用一个“拒绝”来执行一个promise。\n```\ndeferred.reject(\"Can't update user\");\n// 等同于\ndeferred.resolve($q.reject(\"Can't update user\"));\n```\n3.  notify（value）\n这个方法用promise的执行状态来进行响应。notify 回调可能被调用 0到多次,提供一个进度指示在解决或拒绝（resolve和rejected）之前。\n#### 方法介绍：\n$http(options)返回的是一个被封装的promise对象，可以直接使用.then等方法。\n1. then(successFn, errFn, notifyFn)\n无论promise成功还是失败了，当结果可用之后， then都会立刻异步调用successFn或者errFn。这个方法始终用一个参数来调用回调函数：结果，或者是拒绝的理由。在promise被执行或者拒绝之前， notifyFn回调可能会被调用0到多次，以提供过程状态的提示。\nthen()方法总是返回一个新的promise，可以通过successFn或者errFn这样的返回值执行或者被拒绝。它也能通过notifyFn提供通知。\n2. catch(errFn)\n这个方法就只是个帮助函数，能让我们用.catch(function(reason){})取代err回调：\n```\n$http.get('/repos/angular/angular.js/pulls')\n.catch(function(reason) {\ndeferred.reject(reason);\n});\n```\n3. finally(callback)\nfinally方法允许我们观察promise的履行或者拒绝，而无需修改结果的值。当我们需要释放一个资源，或者是运行一些清理工作，不管promise是成功还是失败时，这个方法会很有用。\n我们不能直接调用这个方法，因为finally是IE中JavaScript的一个保留字。纠结到最后，只好这样调用它了：\n```\npromise['finally'](function() {});\n```\nAngular的$q deferred对象是可以串成链的，这样即使是then，返回的也是一个promise。这个promise一被执行， then返回的promise就已经是resolved或者rejected的了。\n#### $q服务类似于原始的Kris Kowal的Q库：\n   1. $q是跟Angular的$rootScope模型集成的，所以在Angular中，执行和拒绝都很快。\n   2. $q promise是跟Angular模板引擎集成的，这意味着在视图中找到的任何promise都会在视\n图中被执行或者拒绝。\n   3. $q很小，所以没有包含Q库的完整功能。\n### 链式请求\nthen方法在初始promise被执行之后，返回一个新的派生promise。这种返回形式给了我们一种特有的能力，把另一个then接在初始的then方法结果之后。\n```\n// 一个响应promise的服务\nGithubService.then(function(data) {\nvar events = [];\nfor (var i = 0; i < data.length; i++) {\nevents.push(data[i].events);\n}\nreturn events;\n}).then(function(events) {\n$scope.events = events;\n});\n```\n在本例中，我们可以创建一个执行链，它允许我们中断基于更多功能的应用流程，可以籍此导向不同的结果。这个中断能让我们在执行链的任意时刻暂停或者推迟promise的执行。\n#### $q库自带了几个不同的有用方法。\n1. all(promises)\n如果我们有多个promise，想要把它们合并成一个，可以使用$q.all(promises)方法来把它们合并成一个promise。这个方法带有一个参数。即promises（数组或者promise对象），一个promise数组或者promise的hash。\nall()方法返回单个promise，会执行一个数组或者一个散列的值。每个值会响应promise散列中的相同序号或者键。如果任意一个promise被拒绝了，结果的promise也会被拒绝。\n2. defer()\n  defer()方法创建了一个deferred对象，它没有参数，返回deferred对象的一个实例。\n3. reject(reason)\n这个方法创建了一个promise，被以某一原因拒绝执行了。它专门用于让我们能在一个promise链中转发拒绝的promise，类似JavaScript中的throw。在同样意义上，我们能在JavaScript中捕获一个异常，也能够转发这个拒绝，我们需要把这个错误重新抛出。可以通过$q.reject(reason)来做到这点。\n这个方法带有单个参数：reason（常量、字符串、异常、对象），拒绝的原因。\nreject()方法返回一个已经用某个原因拒绝的promise。\n4. when(value)\nwhen()函数把一个可能是值或者能接着then的promise包装成一个$q promise。这样我们就能处理一个可能是也可能不是promise的对象。when()函数有一个参数： value，该参数是个值，或者是promise\nwhen()函数返回了一个promise，我们可以像使用其他promise一样使用它。\n","slug":"angular-guide17-angular中的promise","published":1,"updated":"2016-12-23T07:22:47.666Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv65000ljgtuxfun0hk7","content":"<h4 id=\"Angular-中的-promise\"><a href=\"#Angular-中的-promise\" class=\"headerlink\" title=\"Angular 中的 promise\"></a>Angular 中的 promise</h4><p>Angular的事件循环给予了Angular特有的能力，能在$rootScope.$evalAsync阶段中执行promise, promise会坐等$digest运行循环结束。<br>我们来建一个例子，从GitHub上返回一组针对AngularJS的开放pull请求。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;h1&gt;Open Pull Requests for Angular JS&lt;/h1&gt;</div><div class=\"line\">&lt;ul ng-controller=&quot;DashboardController&quot;&gt;</div><div class=\"line\">&lt;li ng-repeat=&quot;pr in pullRequests&quot;&gt;</div><div class=\"line\">&#123;&#123; pr.title &#125;&#125;</div><div class=\"line\">&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>\n<p>如果有个服务返回了一个promise，可以在.then()方法中与这个promise交互，它允许我们修改作用域上的任意变量，放置到视图上，并且期望Angular会为我们执行它：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp&apos;, [])</div><div class=\"line\">.controller(&apos;DashboardController&apos;, [</div><div class=\"line\">&apos;$scope&apos;, &apos;GithubService&apos;,</div><div class=\"line\">function($scope, UserService) &#123;</div><div class=\"line\">// GithubService的getPullRequests()方法</div><div class=\"line\">// 返回了一个promise</div><div class=\"line\">User.getPullRequests(123)</div><div class=\"line\">.then(function(data) &#123;</div><div class=\"line\">$scope.pullRequests = data.data;</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;]);</div></pre></td></tr></table></figure></p>\n<p>当 对 getPullRequests 的 异 步 调 用 返回 时 ， 在 .then()方 法 中 就 可 以 用 $scope.pull Requests这个值了，然后它会更新$scope.pullRequests数组。<br>Angular 中的 promise<br>Angular的事件循环给予了Angular特有的能力，能在$rootScope.$evalAsync阶段中执行<br>promise（关于运行循环的更多细节，参见第24章）。 promise会坐等$digest运行循环结束。<br>这件事让我们能毫无压力地把promise的结果转换到视图上。它也能让我们不加思考地把<br>XHR调用的结果直接赋值到$scope对象的属性上。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;h1&gt;Open Pull Requests for Angular JS&lt;/h1&gt;</div><div class=\"line\">&lt;ul ng-controller=&quot;DashboardController&quot;&gt;</div><div class=\"line\">&lt;li ng-repeat=&quot;pr in pullRequests&quot;&gt;</div><div class=\"line\">&#123;&#123; pr.title &#125;&#125;</div><div class=\"line\">&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>\n<p>如果有个服务返回了一个promise，可以在.then()方法中与这个promise交互，它允许我们修改作用域上的任意变量，放置到视图上，并且期望Angular会为我们执行它：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp&apos;, [])</div><div class=\"line\">.controller(&apos;DashboardController&apos;, [</div><div class=\"line\">&apos;$scope&apos;, &apos;GithubService&apos;,</div><div class=\"line\">function($scope, UserService) &#123;</div><div class=\"line\">// GithubService的getPullRequests()方法</div><div class=\"line\">// 返回了一个promise</div><div class=\"line\">User.getPullRequests(123)</div><div class=\"line\">.then(function(data) &#123;</div><div class=\"line\">$scope.pullRequests = data.data;</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;]);</div></pre></td></tr></table></figure></p>\n<p>当 对 getPullRequests 的 异 步 调 用 返回 时 ， 在 .then()方 法 中 就 可 以 用 $scope.pull<br>Requests这个值了，然后它会更新$scope.pullRequests数组。</p>\n<h4 id=\"如何创建一个-promise\"><a href=\"#如何创建一个-promise\" class=\"headerlink\" title=\"如何创建一个 promise\"></a>如何创建一个 promise</h4><p>想要在Angular中创建promise，可以使用内置的$q服务。 $q服务在它的deferred API中提供了一些方法。<br>首先，需要把$q服务注入到想要使用它的对象中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp&apos;, [])</div><div class=\"line\">.factory(&apos;GithubService&apos;, [&apos;$q&apos;, function($q) &#123;</div><div class=\"line\">// 现在就可以访问到$q库了</div><div class=\"line\">&#125;]);</div></pre></td></tr></table></figure></p>\n<p>要创建一个deferred对象，可以调用defer()方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var deferred = $q.defer();</div></pre></td></tr></table></figure></p>\n<p>deferred对象暴露了三个方法，以及一个可以用于处理promise的promise属性。<br>可以用于处理promise的promise属性：这句话其实就是说deferred对象有一个promise属性。即deferred.promise。<br>deffered 对象属性promise ：最后返回的是一个新的deferred对象 promise 属性，而不是原来的deferred对象。这个新的Promise对象只能观察原来Promise对象的状态，而无法修改deferred对象的内在状态可以防止任务状态被外部修改。</p>\n<ol>\n<li><p>resolve（value）<br>resolve函数用这个值来执行deferred promise。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">deferred.resolve(&#123;name: &quot;Ari&quot;, username: &quot;@auser&quot;&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>reject（reason）<br>这个方法用一个原因来拒绝deferred promise。它等同于使用一个“拒绝”来执行一个promise。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">deferred.reject(&quot;Can&apos;t update user&quot;);</div><div class=\"line\">// 等同于</div><div class=\"line\">deferred.resolve($q.reject(&quot;Can&apos;t update user&quot;));</div></pre></td></tr></table></figure>\n</li>\n<li><p>notify（value）<br>这个方法用promise的执行状态来进行响应。notify 回调可能被调用 0到多次,提供一个进度指示在解决或拒绝（resolve和rejected）之前。</p>\n<h4 id=\"方法介绍：\"><a href=\"#方法介绍：\" class=\"headerlink\" title=\"方法介绍：\"></a>方法介绍：</h4><p>$http(options)返回的是一个被封装的promise对象，可以直接使用.then等方法。</p>\n</li>\n<li>then(successFn, errFn, notifyFn)<br>无论promise成功还是失败了，当结果可用之后， then都会立刻异步调用successFn或者errFn。这个方法始终用一个参数来调用回调函数：结果，或者是拒绝的理由。在promise被执行或者拒绝之前， notifyFn回调可能会被调用0到多次，以提供过程状态的提示。<br>then()方法总是返回一个新的promise，可以通过successFn或者errFn这样的返回值执行或者被拒绝。它也能通过notifyFn提供通知。</li>\n<li><p>catch(errFn)<br>这个方法就只是个帮助函数，能让我们用.catch(function(reason){})取代err回调：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$http.get(&apos;/repos/angular/angular.js/pulls&apos;)</div><div class=\"line\">.catch(function(reason) &#123;</div><div class=\"line\">deferred.reject(reason);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>finally(callback)<br>finally方法允许我们观察promise的履行或者拒绝，而无需修改结果的值。当我们需要释放一个资源，或者是运行一些清理工作，不管promise是成功还是失败时，这个方法会很有用。<br>我们不能直接调用这个方法，因为finally是IE中JavaScript的一个保留字。纠结到最后，只好这样调用它了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">promise[&apos;finally&apos;](function() &#123;&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>Angular的$q deferred对象是可以串成链的，这样即使是then，返回的也是一个promise。这个promise一被执行， then返回的promise就已经是resolved或者rejected的了。</p>\n<h4 id=\"q服务类似于原始的Kris-Kowal的Q库：\"><a href=\"#q服务类似于原始的Kris-Kowal的Q库：\" class=\"headerlink\" title=\"$q服务类似于原始的Kris Kowal的Q库：\"></a>$q服务类似于原始的Kris Kowal的Q库：</h4><ol>\n<li>$q是跟Angular的$rootScope模型集成的，所以在Angular中，执行和拒绝都很快。</li>\n<li>$q promise是跟Angular模板引擎集成的，这意味着在视图中找到的任何promise都会在视<br>图中被执行或者拒绝。</li>\n<li>$q很小，所以没有包含Q库的完整功能。<h3 id=\"链式请求\"><a href=\"#链式请求\" class=\"headerlink\" title=\"链式请求\"></a>链式请求</h3>then方法在初始promise被执行之后，返回一个新的派生promise。这种返回形式给了我们一种特有的能力，把另一个then接在初始的then方法结果之后。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 一个响应promise的服务</div><div class=\"line\">GithubService.then(function(data) &#123;</div><div class=\"line\">var events = [];</div><div class=\"line\">for (var i = 0; i &lt; data.length; i++) &#123;</div><div class=\"line\">events.push(data[i].events);</div><div class=\"line\">&#125;</div><div class=\"line\">return events;</div><div class=\"line\">&#125;).then(function(events) &#123;</div><div class=\"line\">$scope.events = events;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>在本例中，我们可以创建一个执行链，它允许我们中断基于更多功能的应用流程，可以籍此导向不同的结果。这个中断能让我们在执行链的任意时刻暂停或者推迟promise的执行。</p>\n<h4 id=\"q库自带了几个不同的有用方法。\"><a href=\"#q库自带了几个不同的有用方法。\" class=\"headerlink\" title=\"$q库自带了几个不同的有用方法。\"></a>$q库自带了几个不同的有用方法。</h4><ol>\n<li>all(promises)<br>如果我们有多个promise，想要把它们合并成一个，可以使用$q.all(promises)方法来把它们合并成一个promise。这个方法带有一个参数。即promises（数组或者promise对象），一个promise数组或者promise的hash。<br>all()方法返回单个promise，会执行一个数组或者一个散列的值。每个值会响应promise散列中的相同序号或者键。如果任意一个promise被拒绝了，结果的promise也会被拒绝。</li>\n<li>defer()<br>defer()方法创建了一个deferred对象，它没有参数，返回deferred对象的一个实例。</li>\n<li>reject(reason)<br>这个方法创建了一个promise，被以某一原因拒绝执行了。它专门用于让我们能在一个promise链中转发拒绝的promise，类似JavaScript中的throw。在同样意义上，我们能在JavaScript中捕获一个异常，也能够转发这个拒绝，我们需要把这个错误重新抛出。可以通过$q.reject(reason)来做到这点。<br>这个方法带有单个参数：reason（常量、字符串、异常、对象），拒绝的原因。<br>reject()方法返回一个已经用某个原因拒绝的promise。</li>\n<li>when(value)<br>when()函数把一个可能是值或者能接着then的promise包装成一个$q promise。这样我们就能处理一个可能是也可能不是promise的对象。when()函数有一个参数： value，该参数是个值，或者是promise<br>when()函数返回了一个promise，我们可以像使用其他promise一样使用它。</li>\n</ol>\n","excerpt":"","more":"<h4 id=\"Angular-中的-promise\"><a href=\"#Angular-中的-promise\" class=\"headerlink\" title=\"Angular 中的 promise\"></a>Angular 中的 promise</h4><p>Angular的事件循环给予了Angular特有的能力，能在$rootScope.$evalAsync阶段中执行promise, promise会坐等$digest运行循环结束。<br>我们来建一个例子，从GitHub上返回一组针对AngularJS的开放pull请求。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;h1&gt;Open Pull Requests for Angular JS&lt;/h1&gt;</div><div class=\"line\">&lt;ul ng-controller=&quot;DashboardController&quot;&gt;</div><div class=\"line\">&lt;li ng-repeat=&quot;pr in pullRequests&quot;&gt;</div><div class=\"line\">&#123;&#123; pr.title &#125;&#125;</div><div class=\"line\">&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>\n<p>如果有个服务返回了一个promise，可以在.then()方法中与这个promise交互，它允许我们修改作用域上的任意变量，放置到视图上，并且期望Angular会为我们执行它：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp&apos;, [])</div><div class=\"line\">.controller(&apos;DashboardController&apos;, [</div><div class=\"line\">&apos;$scope&apos;, &apos;GithubService&apos;,</div><div class=\"line\">function($scope, UserService) &#123;</div><div class=\"line\">// GithubService的getPullRequests()方法</div><div class=\"line\">// 返回了一个promise</div><div class=\"line\">User.getPullRequests(123)</div><div class=\"line\">.then(function(data) &#123;</div><div class=\"line\">$scope.pullRequests = data.data;</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;]);</div></pre></td></tr></table></figure></p>\n<p>当 对 getPullRequests 的 异 步 调 用 返回 时 ， 在 .then()方 法 中 就 可 以 用 $scope.pull Requests这个值了，然后它会更新$scope.pullRequests数组。<br>Angular 中的 promise<br>Angular的事件循环给予了Angular特有的能力，能在$rootScope.$evalAsync阶段中执行<br>promise（关于运行循环的更多细节，参见第24章）。 promise会坐等$digest运行循环结束。<br>这件事让我们能毫无压力地把promise的结果转换到视图上。它也能让我们不加思考地把<br>XHR调用的结果直接赋值到$scope对象的属性上。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;h1&gt;Open Pull Requests for Angular JS&lt;/h1&gt;</div><div class=\"line\">&lt;ul ng-controller=&quot;DashboardController&quot;&gt;</div><div class=\"line\">&lt;li ng-repeat=&quot;pr in pullRequests&quot;&gt;</div><div class=\"line\">&#123;&#123; pr.title &#125;&#125;</div><div class=\"line\">&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>\n<p>如果有个服务返回了一个promise，可以在.then()方法中与这个promise交互，它允许我们修改作用域上的任意变量，放置到视图上，并且期望Angular会为我们执行它：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp&apos;, [])</div><div class=\"line\">.controller(&apos;DashboardController&apos;, [</div><div class=\"line\">&apos;$scope&apos;, &apos;GithubService&apos;,</div><div class=\"line\">function($scope, UserService) &#123;</div><div class=\"line\">// GithubService的getPullRequests()方法</div><div class=\"line\">// 返回了一个promise</div><div class=\"line\">User.getPullRequests(123)</div><div class=\"line\">.then(function(data) &#123;</div><div class=\"line\">$scope.pullRequests = data.data;</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;]);</div></pre></td></tr></table></figure></p>\n<p>当 对 getPullRequests 的 异 步 调 用 返回 时 ， 在 .then()方 法 中 就 可 以 用 $scope.pull<br>Requests这个值了，然后它会更新$scope.pullRequests数组。</p>\n<h4 id=\"如何创建一个-promise\"><a href=\"#如何创建一个-promise\" class=\"headerlink\" title=\"如何创建一个 promise\"></a>如何创建一个 promise</h4><p>想要在Angular中创建promise，可以使用内置的$q服务。 $q服务在它的deferred API中提供了一些方法。<br>首先，需要把$q服务注入到想要使用它的对象中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp&apos;, [])</div><div class=\"line\">.factory(&apos;GithubService&apos;, [&apos;$q&apos;, function($q) &#123;</div><div class=\"line\">// 现在就可以访问到$q库了</div><div class=\"line\">&#125;]);</div></pre></td></tr></table></figure></p>\n<p>要创建一个deferred对象，可以调用defer()方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var deferred = $q.defer();</div></pre></td></tr></table></figure></p>\n<p>deferred对象暴露了三个方法，以及一个可以用于处理promise的promise属性。<br>可以用于处理promise的promise属性：这句话其实就是说deferred对象有一个promise属性。即deferred.promise。<br>deffered 对象属性promise ：最后返回的是一个新的deferred对象 promise 属性，而不是原来的deferred对象。这个新的Promise对象只能观察原来Promise对象的状态，而无法修改deferred对象的内在状态可以防止任务状态被外部修改。</p>\n<ol>\n<li><p>resolve（value）<br>resolve函数用这个值来执行deferred promise。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">deferred.resolve(&#123;name: &quot;Ari&quot;, username: &quot;@auser&quot;&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>reject（reason）<br>这个方法用一个原因来拒绝deferred promise。它等同于使用一个“拒绝”来执行一个promise。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">deferred.reject(&quot;Can&apos;t update user&quot;);</div><div class=\"line\">// 等同于</div><div class=\"line\">deferred.resolve($q.reject(&quot;Can&apos;t update user&quot;));</div></pre></td></tr></table></figure>\n</li>\n<li><p>notify（value）<br>这个方法用promise的执行状态来进行响应。notify 回调可能被调用 0到多次,提供一个进度指示在解决或拒绝（resolve和rejected）之前。</p>\n<h4 id=\"方法介绍：\"><a href=\"#方法介绍：\" class=\"headerlink\" title=\"方法介绍：\"></a>方法介绍：</h4><p>$http(options)返回的是一个被封装的promise对象，可以直接使用.then等方法。</p>\n</li>\n<li>then(successFn, errFn, notifyFn)<br>无论promise成功还是失败了，当结果可用之后， then都会立刻异步调用successFn或者errFn。这个方法始终用一个参数来调用回调函数：结果，或者是拒绝的理由。在promise被执行或者拒绝之前， notifyFn回调可能会被调用0到多次，以提供过程状态的提示。<br>then()方法总是返回一个新的promise，可以通过successFn或者errFn这样的返回值执行或者被拒绝。它也能通过notifyFn提供通知。</li>\n<li><p>catch(errFn)<br>这个方法就只是个帮助函数，能让我们用.catch(function(reason){})取代err回调：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$http.get(&apos;/repos/angular/angular.js/pulls&apos;)</div><div class=\"line\">.catch(function(reason) &#123;</div><div class=\"line\">deferred.reject(reason);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>finally(callback)<br>finally方法允许我们观察promise的履行或者拒绝，而无需修改结果的值。当我们需要释放一个资源，或者是运行一些清理工作，不管promise是成功还是失败时，这个方法会很有用。<br>我们不能直接调用这个方法，因为finally是IE中JavaScript的一个保留字。纠结到最后，只好这样调用它了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">promise[&apos;finally&apos;](function() &#123;&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>Angular的$q deferred对象是可以串成链的，这样即使是then，返回的也是一个promise。这个promise一被执行， then返回的promise就已经是resolved或者rejected的了。</p>\n<h4 id=\"q服务类似于原始的Kris-Kowal的Q库：\"><a href=\"#q服务类似于原始的Kris-Kowal的Q库：\" class=\"headerlink\" title=\"$q服务类似于原始的Kris Kowal的Q库：\"></a>$q服务类似于原始的Kris Kowal的Q库：</h4><ol>\n<li>$q是跟Angular的$rootScope模型集成的，所以在Angular中，执行和拒绝都很快。</li>\n<li>$q promise是跟Angular模板引擎集成的，这意味着在视图中找到的任何promise都会在视<br>图中被执行或者拒绝。</li>\n<li>$q很小，所以没有包含Q库的完整功能。<h3 id=\"链式请求\"><a href=\"#链式请求\" class=\"headerlink\" title=\"链式请求\"></a>链式请求</h3>then方法在初始promise被执行之后，返回一个新的派生promise。这种返回形式给了我们一种特有的能力，把另一个then接在初始的then方法结果之后。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 一个响应promise的服务</div><div class=\"line\">GithubService.then(function(data) &#123;</div><div class=\"line\">var events = [];</div><div class=\"line\">for (var i = 0; i &lt; data.length; i++) &#123;</div><div class=\"line\">events.push(data[i].events);</div><div class=\"line\">&#125;</div><div class=\"line\">return events;</div><div class=\"line\">&#125;).then(function(events) &#123;</div><div class=\"line\">$scope.events = events;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>在本例中，我们可以创建一个执行链，它允许我们中断基于更多功能的应用流程，可以籍此导向不同的结果。这个中断能让我们在执行链的任意时刻暂停或者推迟promise的执行。</p>\n<h4 id=\"q库自带了几个不同的有用方法。\"><a href=\"#q库自带了几个不同的有用方法。\" class=\"headerlink\" title=\"$q库自带了几个不同的有用方法。\"></a>$q库自带了几个不同的有用方法。</h4><ol>\n<li>all(promises)<br>如果我们有多个promise，想要把它们合并成一个，可以使用$q.all(promises)方法来把它们合并成一个promise。这个方法带有一个参数。即promises（数组或者promise对象），一个promise数组或者promise的hash。<br>all()方法返回单个promise，会执行一个数组或者一个散列的值。每个值会响应promise散列中的相同序号或者键。如果任意一个promise被拒绝了，结果的promise也会被拒绝。</li>\n<li>defer()<br>defer()方法创建了一个deferred对象，它没有参数，返回deferred对象的一个实例。</li>\n<li>reject(reason)<br>这个方法创建了一个promise，被以某一原因拒绝执行了。它专门用于让我们能在一个promise链中转发拒绝的promise，类似JavaScript中的throw。在同样意义上，我们能在JavaScript中捕获一个异常，也能够转发这个拒绝，我们需要把这个错误重新抛出。可以通过$q.reject(reason)来做到这点。<br>这个方法带有单个参数：reason（常量、字符串、异常、对象），拒绝的原因。<br>reject()方法返回一个已经用某个原因拒绝的promise。</li>\n<li>when(value)<br>when()函数把一个可能是值或者能接着then的promise包装成一个$q promise。这样我们就能处理一个可能是也可能不是promise的对象。when()函数有一个参数： value，该参数是个值，或者是promise<br>when()函数返回了一个promise，我们可以像使用其他promise一样使用它。</li>\n</ol>\n"},{"title":"Angular权威指南学习(第6-7章)表达式和过滤器","date":"2016-05-10T07:09:49.000Z","_content":"#### 表达式\n用\\{ \\{ \\} \\}符号将一个变量绑定到$scope上的写法本质上就是一个表达式：`{{expression}}`。当用$watch进行监听时， AngularJS会对表达式或函数进行运算。\n表达式和eval(javascript)非常相似，但是由于表达式由AngularJS来处理，它们有以下显著不同的特性：\n   1. 所有的表达式都在其所属的作用域内部执行，并有访问本地$scope的权限；\n   2. 如果表达式发生了TypeError和ReferenceError并不会抛出异常；\n   3. 不允许使用任何流程控制功能（条件控制，例如if/eles）；\n   4. 可以接受过滤器和过滤器链。\n#### 解析 AngularJS 表达式\nAngularJS会在运行$digest循环的过程中自动解析表达式，AngularJS通过$parse这个内部服务来进行表达式的运算，这个服务能够访问当前所处的作用域。这个过程允许我们访问定义在$scope上的原始JavaScript数据和函数。将$parse服务注入到控制器中，然后调用它就可以实现手动解析表达式。\n如果页面上有一个输入框绑定到了expr变量上，如下所示:\n```\n<div ng-controller=\"MyController\">\n<input ng-model=\"expr\"\ntype=\"text\"\nplaceholder=\"Enter an expression\" />\n<h2>{{ parseValue }}</h2>\n</div>\n我们可以在MyController中给expr这个表达式设置一个$watch并解析它：\nangular.module(\"myApp\", [])\n.controller('MyController',\nfunction($scope,$parse) {\n$scope.$watch('expr', function(newVal, oldVal, scope) {\nif (newVal !== oldVal) {\n// 用该表达式设置parseFun\nvar parseFun = $parse(newVal);\n// 获取经过解析后表达式的值\n$scope.parsedValue = parseFun(scope);\n}\n});\n});\n```\n注：$watch函数会监视$scope上的某个属性。只要属性发生变化就会调用对应的函数。可以使用$watch函数在$scope上某个属性发生变化时直接运行一个自定义函数。\n#### 插值字符串（不常用）\n在开发中，我们的确有手动运行模板编译的能力。要在字符串模板中做插值操作，需要在你的对象中注入$interpolate服务。\n$interpolate服务返回一个函数，用来在特定的上下文中运算表达式。\n#### 过滤器\n过滤器用来格式化需要展示给用户的数据。 AngularJS有很多实用的内置过滤器，同时也提供了方便的途径可以自己创建过滤器。在HTML中的模板绑定符号\\{ \\{ \\} \\}内通过|符号来调用过滤器。例如，假设我们希望将字符串转换成大写，可以对字符串中的每个字符都单独进行转换操作，也可以使用过滤器：\n```\n{{ name | uppercase }}\n```\n在JavaScript代码中可以通过$filter来调用过滤器。例如，在JavaScript代码中使用lowercase过滤器：\n```\napp.controller('DemoController', ['$scope', '$filter',\nfunction($scope, $filter) {\n$scope.name = $filter('lowercase')('WEBYWX');\n}]);\n```\n\n以HTML的形式使用过滤器时，如果需要传递参数给过滤器，只要在过滤器名字后面加冒号即可。如果有多个参数，可以在每个参数后面都加入冒号。例如，数值过滤器可以限制小数点后的位数，在过滤器后写上:2可以将2作为参数传给过滤器：\n```\n<!-- 显示： 123.46 -->\n{{ 123.456789 | number:2 }}\n```\n可以用|符号作为分割符来同时使用多个过滤器.\n#### angular 内置过滤器\n1. currency\n   currecy过滤器可以将一个数值格式化为货币格式。用\\{ \\{ 123 | currency \\} \\}`来将123转化成货币格式。\n2. date\ndate过滤器可以将日期格式化成需要的格式。 AngularJS中内置了几种日期格式，如果没有指定使用任何格式，默认会采用mediumDate格式，下面的例子中展示了这个格式。下面是内置的支持本地化的日期格式：\n```\n{{ today | date:'medium' }} <!-- Aug 09, 2013 12:09:02 PM -->\n{{ today | date:'short' }} <!-- 8/9/1312:09PM -->\n{{ today | date:'fullDate' }} <!-- Thursday, August 09, 2013 -->\n{{ today | date:'longDate' }} <!-- August 09, 2013 -->\n{{ today | date:'mediumDate' }}<!-- Aug 09, 2013 -->\n{{ today | date:'shortDate' }} <!-- 8/9/13 -->\n{{ today | date:'mediumTime' }}<!-- 12:09:02 PM -->\n{{ today | date:'shortTime' }} <!-- 12:09 PM -->\n 年份格式化\n四位年份： {{ today | date:'yyyy' }} <!-- 2013 -->\n两位年份： {{ today | date:'yy' }} <!-- 13 -->\n一位年份： {{ today | date:'y' }} <!-- 2013 -->\n 月份格式化\n英文月份： {{ today | date:'MMMM' }} <!-- August -->\n英文月份简写： {{ today | date:'MMM' }} <!-- Aug -->\n数字月份： {{ today |date:'MM' }} <!-- 08 -->\n一年中的第几个月份： {{ today |date:'M' }} <!-- 8 -->\n 日期格式化\n数字日期： {{ today|date:'dd' }} <!-- 09 -->\n一个月中的第几天： {{ today | date:'d' }} <!-- 9 -->\n英文星期： {{ today | date:'EEEE' }} <!-- Thursday -->\n英文星期简写： {{ today | date:'EEE' }} <!-- Thu -->\n 小时格式化\n24小时制数字小时： {{today|date:'HH'}} <!--00-->\n一天中的第几个小时： {{today|date:'H'}} <!--0-->\n12小时制数字小时： {{today|date:'hh'}} <!--12-->\n上午或下午的第几个小时： {{today|date:'h'}} <!--12-->\n 分钟格式化\n数字分钟数： {{ today | date:'mm' }} <!-- 09 -->\n一个小时中的第几分钟： {{ today | date:'m' }} <!-- 9 -->\n 秒数格式化\n数字秒数： {{ today | date:'ss' }} <!-- 02 -->\n一分钟内的第几秒： {{ today | date:'s' }} <!-- 2 -->\n毫秒数： {{ today | date:'.sss' }} <!-- .995 -->\n 字符格式化\n上下午标识： {{ today | date:'a' }} <!-- AM -->\n四位时区标识： {{ today | date:'Z' }} <!--- 0700 -->\n下面是一些自定义日期格式的示例：\n{{ today | date:'MMMd, y' }} <!-- Aug9, 2013 -->\n{{ today | date:'EEEE, d, M' }} <!-- Thursday, 9, 8-->\n{{ today | date:'hh:mm:ss.sss' }} <!-- 12:09:02.995 -->\n```\n3. filter\nfilter过滤器可以从给定数组中选择一个子集，并将其生成一个新数组返回。这个过滤器通常用来过滤需要进行展示的元素。例如，在做客户端搜索时，可以从一个数组中立刻过滤出所需的结果。这个过滤器的第一个参数可以是字符串、对象或是一个用来从数组中选择元素的函数。\n    下面分情况介绍传入不同类型的参数。\n    1.  字符串\n    返回所有包含这个字符串的元素。如果我们想返回不包含该字符串的元素，在参数前加!符号。\n    2.  对象\n    AngularJS会将待过滤对象的属性同这个对象中的同名属性进行比较，如果属性值是字符串就会判断是否包含该字符串。如果我们希望对全部属性都进行对比，可以将$当作键名。\n    3.  函数\n    对每个元素都执行这个函数，返回非假值的元素会出现在新的数组中并返回。\n    例如，用下面的过滤器可以选择所有包含字母e的单词：\n    ```\n    {{ ['Ari','Lerner','Likes','To','Eat','Pizza'] | filter:'e' }}\n    <!-- [\"Lerner\",\"Likes\",\"Eat\"] -->\n    ```\n    如果要过滤对象，可以使用上面提到的对象过滤器。例如，如果有一个由people对象组成的\n    数组，每个对象都含有他们最喜欢吃的食物的列表，那么可以用下面的形式进行过滤：\n    ```\n    {{ [{\n    'name': 'Ari',\n    'City': 'San Francisco',\n    'favorite food': 'Pizza'\n    },{\n    'name': 'Nate',\n    'City': 'San Francisco',\n    'favorite food': 'indian food'\n    }] | filter:{'favorite food': 'Pizza'} }}\n    <!-- [{\"name\":\"Ari\",\"City\":\"SanFrancisco\",\"favoritefood\":\"Pizza\"}] -->\n    ```\n    也可以用自定义函数进行过滤（在这个例子中函数定义在$scope上）：\n    ```\n    {{ ['Ari','likes','to','travel'] | filter:isCapitalized }}\n    <!-- [\"Ari\"] -->\n    isCapitalized函数的功能是根据首字母是否为大写返回true或false，具体如下所示：\n    $scope.isCapitalized = function(str) {\n    return str[0] == str[0].toUpperCase();\n    };\n    ```\n    我们也可以给filter过滤器传入第二个参数，用来指定预期值同实际值进行比较的方式。\n    第二个参数可以是以下三种情况之一。\n     true\n    用angular.equals(expected, actual)对两个值进行严格比较。\n     false\n    进行区分大小写的子字符串比较。\n     函数\n    运行这个函数，如果返回真值就接受这个元素。\n#### json\njson过滤器可以将一个JSON或JavaScript对象转换成字符串。这种转换对调试非常有帮助：\n```\n{{ {'name': 'Ari', 'City': 'SanFrancisco'} | json }}\n<!--\n{\n\"name\": \"Ari\",\n\"City\": \"San Francisco\"\n}\n-->\n```\n5. limitTo\nlimitTo过滤器会根据传入的参数生成一个新的数组或字符串，新的数组或字符串的长度取决于传入的参数，通过传入参数的正负值来控制从前面还是从后面开始截取。如果传入的长度值大于被操作数组或字符串的长度，那么整个数组或字符串都会被返回。\n例如，我们可以截取字符串的前三个字符：\n```\n{{ San Francisco is very cloudy | limitTo:3 }}\n<!-- San -->\n或最后的六个字符：\n{{ San Francisco is very cloudy | limitTo:-6 }}\n<!-- cloudy -->\n对数组也可以进行同样的操作。返回数组的第一个元素：\n{{ ['a','b','c','d','e','f'] | limitTo:1 }}\n<!-- [\"a\"] -->\n```\n6. lowercase\nlowercase过滤器将字符串转为小写。\n```\n{{ \"San Francisco is very cloudy\" | lowercase }}\n<!-- san francisco is very cloudy -->\n```\n7. number\nnumber过滤器将数字格式化成文本。它的第二个参数是可选的，用来控制小数点后截取的位数。如果传入了一个非数字字符，会返会空字符串。\n```\n{{ 123456789 | number }}\n<!-- 1,234,567,890 -->\n{{ 1.234567 | number:2 }}\n<!-- 1.23 -->\n```\n8. orderBy\norderBy过滤器可以用表达式对指定的数组进行排序。orderBy可以接受两个参数，第一个是必需的，第二个是可选的。\n第一个参数是用来确定数组排序方向的谓词。\n    下面分情况讨论第一个参数的类型。\n     函数\n    当第一个参数是函数时，该函数会被当作待排序对象的getter方法。\n     字符串\n    对这个字符串进行解析的结果将决定数组元素的排序方向。我们可以传入+或-来强制进行升序或降序排列。\n     数组\n    在排序表达式中使用数组元素作为谓词。对于与表达式结果并不严格相等的每个元素，则使用第一个谓词。\n    第二个参数用来控制排序的方向（是否逆向）。\n    例如，我们将下面的对象数组用name字段进行排序：\n    ```\n    {{ [{\n    'name': 'Ari',\n    'status': 'awake'\n    },{\n    'name': 'Q',\n    'status': 'sleeping'\n    },{\n    'name': 'Nate',\n    'status': 'awake'\n    }] | orderBy:'name' }}\n    <!--\n    [\n    {\"name\":\"Ari\",\"status\":\"awake\"},\n    {\"name\":\"Nate\",\"status\":\"awake\"},\n    {\"name\":\"Q\",\"status\":\"sleeping\"}\n    ]\n    -->\n    也可以对排序结果进行反转。例如，通过将第二个参数设置为true可以将排序结果进行反转：\n    {{ [{\n    'name': 'Ari',\n    'status': 'awake'\n    },{\n    'name': 'Q',\n    'status': 'sleeping'\n    },{\n    'name': 'Nate',\n    'status': 'awake'\n    }] | orderBy:'name':true }}\n    <!--\n    [\n    {\"name\":\"Q\",\"status\":\"sleeping\"},\n    {\"name\":\"Nate\",\"status\":\"awake\"},\n    {\"name\":\"Ari\",\"status\":\"awake\"}\n    ]\n    -->\n    ```\n9. uppercase\nuppercase过滤器可以将字符串转换为大写形式：\n```\n{{ \"San Francisco is very cloudy\" | uppercase }}\n<!-- SAN FRANCISCO IS VERY CLOUDY -->\n```\n#### 自定义过滤器\n创建自定义过滤器非常容易。创建自定义过滤器需要将它放到自己的模块中。\n例：实现一个过滤器，将字符串第一个字母转换为大写\n首先，创建一个模块用以在应用中进行引用（这是一个非常好的实践）：\n```\nangular.module('myApp.filters', [])\n.filter('capitalize', function() {\nreturn function(input) {};\n});\n```\n过滤器本质上是一个会把我们输入的内容当作参数传入进去的函数。上面这个例子中，我们在调用过滤器时简单地把input当作字符串来处理。可以在这个函数中做一些错误检查：\n```\nangular.module('myApp.filters', [])\n.filter('capitalize', function() {\nreturn function(input) {\n// input是我们传入的字符串\nif (input) {\nreturn input[0].toUpperCase() + input.slice(1);\n}\n});\n```\n现在，如果想将一个句子的首字母转换成大写形式，可以用过滤器先将整个句子都转换成小写，再把首字母转换成大写：\n```\n<!-- Ginger loves dog treats -->\n{{ 'ginger loves dog treats' | lowercase | capitalize }}\n```\n#### 表单验证\nAngularJS能够将HTML5表单验证功能同它自己的验证指令结合起来使用，并且非常方便。\n```\n<form name=\"form\" novalidate>\n<label name=\"email\">Your email</label>\n<input type=\"email\"\nname=\"email\"\nng-model=\"email\" placeholder=\"Email Address\" />\n</form>\n```\n注：要使用表单验证，首先要确保表单像上面的例子一样有一个name属性。\n所有输入字段都可以进行基本的验证，比如最大、最小长度等。这些功能是由新的HTML5表单属性提供的。如果想要屏蔽浏览器对表单的默认验证行为，可以在表单元素上添加novalidate标记。\n   - input元素所有验证选项如下：\n   1. 必填项\n   验证某个表单输入是否已填写，只要在输入字段元素上添加HTML5标记required即可：\n   ```\n   <input type=\"text\" required />\n   ```\n   2. 最小长度\n   验证表单输入的文本长度是否大于某个最小值，在输入字段上使用AngularJS指令ng-minleng=\"{number}\"：\n   ```\n   <input type=\"text\" ng-minlength=\"5\" />\n   ```\n   3. 最大长度\n   验证表单输入的文本长度是否小于或等于某个最大值，在输入字段上使用AngularJS指令ng-maxlength=\"{number}\"：\n   ```\n   <input type=\"text\" ng-maxlength=\"20\" />\n   ```\n   4. 模式匹配\n   使用ng-pattern=\"/PATTERN/\"来确保输入能够匹配指定的正则表达式：\n   ```\n   <input type=\"text\" ng-pattern=\"[a-zA-Z]\" />\n   ```\n   5. 电子邮件\n   验证输入内容是否是电子邮件，只要像下面这样将input的类型设置为email即可：\n   ```\n   <input type=\"email\" name=\"email\" ng-model=\"user.email\" />\n   ```\n   6. 数字\n   验证输入内容是否是数字，将input的类型设置为number：\n   ```\n   <input type=\"number\" name=\"age\" ng-model=\"user.age\" />\n   ```\n   7. URL\n   验证输入内容是否是URL，将input的类型设置为 url：\n   ```\n   <input type=\"url\" name=\"homepage\" ng-model=\"user.facebook_url\" />\n   ```\n   8. 在表单中控制变量\n   表单的属性可以在其所属的$scope对象中访问到，而我们又可以访问$scope对象，因此JavaScript可以间接地访问DOM中的表单属性。借助这些属性，我们可以对表单做出实时（和AngularJS中其他东西一样）响应。\n   注：可以使用下面的格式访问这些属性。\n   formName.inputFieldName.property\n    未修改的表单\n   这是一个布尔属性，用来判断用户是否修改了表单。如果未修改，值为true，如果修改过值\n   为false：\n   formName.inputFieldName.$pristine\n    修改过的表单\n   只要用户修改过表单，无论输入是否通过验证，该值都返回true：\n   formName.inputFieldName.$dirty\n    合法的表单\n   这个布尔型的属性用来判断表单的内容是否合法。如果当前表单内容是合法的，下面属性的\n   值就是true：\n   formName.inputFieldName.$valid\n    不合法的表单\n   这个布尔属性用来判断表单的内容是否不合法。如果当前表单内容是不合法的，下面属性的\n   值为true：\n   formName.inputFieldName.$invalid\n    错误\n   这是AngularJS提供的另外一个非常有用的属性： $error对象。它包含当前表单的所有验证\n   内容，以及它们是否合法的信息。用下面的语法访问这个属性：\n   formName.inputfieldName.$error\n   如果验证失败，这个属性的值为true；如果值为false，说明输入字段的值通过了验证。\n   ```\n   例：判断错误提示框是否显示：\n   ng-show=\"signup_form.name.$dirty && signup_form.name.$invalid\"\n   signup_form为表单的name属性值，name为input输入框的name属性值。\n   ```\n   9. 一些有用的CSS样式\n   AngularJS处理表单时，会根据表单当前的状态添加一些CSS类（例如当前是合法的、未发生变化的，等等），这些CSS类的命名和前面介绍的属性很相似。\n   ```\n   .ng-pristine {}\n   .ng-dirty {}\n   .ng-valid {}\n   .ng-invalid {}\n   ```\n   它们对应着表单输入字段的特定状态。\n   当某个字段中的输入非法时， .ng-invlid类会被添加到这个字段上。当前例子中的站点将对应的CSS样式设置为：\n   ```\n   input.ng-invalid {\n   border: 1px solid red;\n   }\n   input.ng-valid {\n   border: 1px solid green;\n   } \n   ```\n   - $parsers\n  使用$parsers数组是实现自定义验证的途径之一。\n  - $formatters\n注：表单本身会提供$invalid和$valid属性。例：formName.$invalid;当用户试图提交表单时，你可以在作用域中捕获到一个submitted值，然后对表单内容进行验证并显示错误信息。一般当formName.submitted设置为true时，容纳错误信息的div才会展示出来。\n#### 从1.3开始， Angular中新增了一个ngMessages指令。\n   1. 安装ngMessages很简单，因为它被打包成了一个Angular模块。首先下载这个模块：\n```\n$ bower install --save angular-messages\n```\n   2. 还需要将angular-messages.js这个JavaScript引入我们的主HTML中：\n   ```\n<script type=\"text/javascript\" src=\"bower_components/angular-messages/angular-messages.js\">\n</script>\n```\n   3. 最后，我们还要告诉Angular将ngMessages作为应用程序的依赖模块引入，就像这样：\n   ```\nangular.module('myApp', ['ngMessages']);\n```\n  例：在没有使用ngMessages之前，我们可能这样写验证：\n  ```\n  <form name=\"userForm\">\n  <input \n  type=\"text\"\n  name=\"username\"\n  ng-model=\"user.username\"\n  ng-minlength=\"3\"\n  ng-maxlength=\"8\"\n  required>\n  <p ng-show=\"userForm.username.$error.minlength\">Username is too short.</p>\n  <p ng-show=\"userForm.username.$error.maxlength\">Username is too long.</p>\n  <p ng-show=\"userForm.username.$error.required\">Your username is required.</p>\n  </form>\n  ```\n  有了\"ngMessages\"这个module,大致这么写：\n  ```\n  <div class=\"help-block\" ng-messages=\"userForm.name.$error\" ng-if=\"userForm.name.$touched\">\n  <p ng-message=\"minlength\">用户名最小长度5</p>\n  <p ng-message=\"maxlength\">用户名最大长度10</p>\n  <p ng-message=\"required\">用户名必填</p>\n  </div>\n  ```\n  ngMessages为我们自动判断显示哪种错误。\n  \n####  使用ngMessages的几个关键点：\n  \n   1. ● npm install angular-messages\n   2. ● 引用：angular-messages.js\n   3. ● 依赖：angular.module('app',['ngMessages'])\n\n","source":"_posts/angular-guide6-7.md","raw":"---\ntitle: Angular权威指南学习(第6-7章)表达式和过滤器\ndate: 2016-05-10 15:09:49\ntags: angular、表达式、filter\n---\n#### 表达式\n用\\{ \\{ \\} \\}符号将一个变量绑定到$scope上的写法本质上就是一个表达式：`{{expression}}`。当用$watch进行监听时， AngularJS会对表达式或函数进行运算。\n表达式和eval(javascript)非常相似，但是由于表达式由AngularJS来处理，它们有以下显著不同的特性：\n   1. 所有的表达式都在其所属的作用域内部执行，并有访问本地$scope的权限；\n   2. 如果表达式发生了TypeError和ReferenceError并不会抛出异常；\n   3. 不允许使用任何流程控制功能（条件控制，例如if/eles）；\n   4. 可以接受过滤器和过滤器链。\n#### 解析 AngularJS 表达式\nAngularJS会在运行$digest循环的过程中自动解析表达式，AngularJS通过$parse这个内部服务来进行表达式的运算，这个服务能够访问当前所处的作用域。这个过程允许我们访问定义在$scope上的原始JavaScript数据和函数。将$parse服务注入到控制器中，然后调用它就可以实现手动解析表达式。\n如果页面上有一个输入框绑定到了expr变量上，如下所示:\n```\n<div ng-controller=\"MyController\">\n<input ng-model=\"expr\"\ntype=\"text\"\nplaceholder=\"Enter an expression\" />\n<h2>{{ parseValue }}</h2>\n</div>\n我们可以在MyController中给expr这个表达式设置一个$watch并解析它：\nangular.module(\"myApp\", [])\n.controller('MyController',\nfunction($scope,$parse) {\n$scope.$watch('expr', function(newVal, oldVal, scope) {\nif (newVal !== oldVal) {\n// 用该表达式设置parseFun\nvar parseFun = $parse(newVal);\n// 获取经过解析后表达式的值\n$scope.parsedValue = parseFun(scope);\n}\n});\n});\n```\n注：$watch函数会监视$scope上的某个属性。只要属性发生变化就会调用对应的函数。可以使用$watch函数在$scope上某个属性发生变化时直接运行一个自定义函数。\n#### 插值字符串（不常用）\n在开发中，我们的确有手动运行模板编译的能力。要在字符串模板中做插值操作，需要在你的对象中注入$interpolate服务。\n$interpolate服务返回一个函数，用来在特定的上下文中运算表达式。\n#### 过滤器\n过滤器用来格式化需要展示给用户的数据。 AngularJS有很多实用的内置过滤器，同时也提供了方便的途径可以自己创建过滤器。在HTML中的模板绑定符号\\{ \\{ \\} \\}内通过|符号来调用过滤器。例如，假设我们希望将字符串转换成大写，可以对字符串中的每个字符都单独进行转换操作，也可以使用过滤器：\n```\n{{ name | uppercase }}\n```\n在JavaScript代码中可以通过$filter来调用过滤器。例如，在JavaScript代码中使用lowercase过滤器：\n```\napp.controller('DemoController', ['$scope', '$filter',\nfunction($scope, $filter) {\n$scope.name = $filter('lowercase')('WEBYWX');\n}]);\n```\n\n以HTML的形式使用过滤器时，如果需要传递参数给过滤器，只要在过滤器名字后面加冒号即可。如果有多个参数，可以在每个参数后面都加入冒号。例如，数值过滤器可以限制小数点后的位数，在过滤器后写上:2可以将2作为参数传给过滤器：\n```\n<!-- 显示： 123.46 -->\n{{ 123.456789 | number:2 }}\n```\n可以用|符号作为分割符来同时使用多个过滤器.\n#### angular 内置过滤器\n1. currency\n   currecy过滤器可以将一个数值格式化为货币格式。用\\{ \\{ 123 | currency \\} \\}`来将123转化成货币格式。\n2. date\ndate过滤器可以将日期格式化成需要的格式。 AngularJS中内置了几种日期格式，如果没有指定使用任何格式，默认会采用mediumDate格式，下面的例子中展示了这个格式。下面是内置的支持本地化的日期格式：\n```\n{{ today | date:'medium' }} <!-- Aug 09, 2013 12:09:02 PM -->\n{{ today | date:'short' }} <!-- 8/9/1312:09PM -->\n{{ today | date:'fullDate' }} <!-- Thursday, August 09, 2013 -->\n{{ today | date:'longDate' }} <!-- August 09, 2013 -->\n{{ today | date:'mediumDate' }}<!-- Aug 09, 2013 -->\n{{ today | date:'shortDate' }} <!-- 8/9/13 -->\n{{ today | date:'mediumTime' }}<!-- 12:09:02 PM -->\n{{ today | date:'shortTime' }} <!-- 12:09 PM -->\n 年份格式化\n四位年份： {{ today | date:'yyyy' }} <!-- 2013 -->\n两位年份： {{ today | date:'yy' }} <!-- 13 -->\n一位年份： {{ today | date:'y' }} <!-- 2013 -->\n 月份格式化\n英文月份： {{ today | date:'MMMM' }} <!-- August -->\n英文月份简写： {{ today | date:'MMM' }} <!-- Aug -->\n数字月份： {{ today |date:'MM' }} <!-- 08 -->\n一年中的第几个月份： {{ today |date:'M' }} <!-- 8 -->\n 日期格式化\n数字日期： {{ today|date:'dd' }} <!-- 09 -->\n一个月中的第几天： {{ today | date:'d' }} <!-- 9 -->\n英文星期： {{ today | date:'EEEE' }} <!-- Thursday -->\n英文星期简写： {{ today | date:'EEE' }} <!-- Thu -->\n 小时格式化\n24小时制数字小时： {{today|date:'HH'}} <!--00-->\n一天中的第几个小时： {{today|date:'H'}} <!--0-->\n12小时制数字小时： {{today|date:'hh'}} <!--12-->\n上午或下午的第几个小时： {{today|date:'h'}} <!--12-->\n 分钟格式化\n数字分钟数： {{ today | date:'mm' }} <!-- 09 -->\n一个小时中的第几分钟： {{ today | date:'m' }} <!-- 9 -->\n 秒数格式化\n数字秒数： {{ today | date:'ss' }} <!-- 02 -->\n一分钟内的第几秒： {{ today | date:'s' }} <!-- 2 -->\n毫秒数： {{ today | date:'.sss' }} <!-- .995 -->\n 字符格式化\n上下午标识： {{ today | date:'a' }} <!-- AM -->\n四位时区标识： {{ today | date:'Z' }} <!--- 0700 -->\n下面是一些自定义日期格式的示例：\n{{ today | date:'MMMd, y' }} <!-- Aug9, 2013 -->\n{{ today | date:'EEEE, d, M' }} <!-- Thursday, 9, 8-->\n{{ today | date:'hh:mm:ss.sss' }} <!-- 12:09:02.995 -->\n```\n3. filter\nfilter过滤器可以从给定数组中选择一个子集，并将其生成一个新数组返回。这个过滤器通常用来过滤需要进行展示的元素。例如，在做客户端搜索时，可以从一个数组中立刻过滤出所需的结果。这个过滤器的第一个参数可以是字符串、对象或是一个用来从数组中选择元素的函数。\n    下面分情况介绍传入不同类型的参数。\n    1.  字符串\n    返回所有包含这个字符串的元素。如果我们想返回不包含该字符串的元素，在参数前加!符号。\n    2.  对象\n    AngularJS会将待过滤对象的属性同这个对象中的同名属性进行比较，如果属性值是字符串就会判断是否包含该字符串。如果我们希望对全部属性都进行对比，可以将$当作键名。\n    3.  函数\n    对每个元素都执行这个函数，返回非假值的元素会出现在新的数组中并返回。\n    例如，用下面的过滤器可以选择所有包含字母e的单词：\n    ```\n    {{ ['Ari','Lerner','Likes','To','Eat','Pizza'] | filter:'e' }}\n    <!-- [\"Lerner\",\"Likes\",\"Eat\"] -->\n    ```\n    如果要过滤对象，可以使用上面提到的对象过滤器。例如，如果有一个由people对象组成的\n    数组，每个对象都含有他们最喜欢吃的食物的列表，那么可以用下面的形式进行过滤：\n    ```\n    {{ [{\n    'name': 'Ari',\n    'City': 'San Francisco',\n    'favorite food': 'Pizza'\n    },{\n    'name': 'Nate',\n    'City': 'San Francisco',\n    'favorite food': 'indian food'\n    }] | filter:{'favorite food': 'Pizza'} }}\n    <!-- [{\"name\":\"Ari\",\"City\":\"SanFrancisco\",\"favoritefood\":\"Pizza\"}] -->\n    ```\n    也可以用自定义函数进行过滤（在这个例子中函数定义在$scope上）：\n    ```\n    {{ ['Ari','likes','to','travel'] | filter:isCapitalized }}\n    <!-- [\"Ari\"] -->\n    isCapitalized函数的功能是根据首字母是否为大写返回true或false，具体如下所示：\n    $scope.isCapitalized = function(str) {\n    return str[0] == str[0].toUpperCase();\n    };\n    ```\n    我们也可以给filter过滤器传入第二个参数，用来指定预期值同实际值进行比较的方式。\n    第二个参数可以是以下三种情况之一。\n     true\n    用angular.equals(expected, actual)对两个值进行严格比较。\n     false\n    进行区分大小写的子字符串比较。\n     函数\n    运行这个函数，如果返回真值就接受这个元素。\n#### json\njson过滤器可以将一个JSON或JavaScript对象转换成字符串。这种转换对调试非常有帮助：\n```\n{{ {'name': 'Ari', 'City': 'SanFrancisco'} | json }}\n<!--\n{\n\"name\": \"Ari\",\n\"City\": \"San Francisco\"\n}\n-->\n```\n5. limitTo\nlimitTo过滤器会根据传入的参数生成一个新的数组或字符串，新的数组或字符串的长度取决于传入的参数，通过传入参数的正负值来控制从前面还是从后面开始截取。如果传入的长度值大于被操作数组或字符串的长度，那么整个数组或字符串都会被返回。\n例如，我们可以截取字符串的前三个字符：\n```\n{{ San Francisco is very cloudy | limitTo:3 }}\n<!-- San -->\n或最后的六个字符：\n{{ San Francisco is very cloudy | limitTo:-6 }}\n<!-- cloudy -->\n对数组也可以进行同样的操作。返回数组的第一个元素：\n{{ ['a','b','c','d','e','f'] | limitTo:1 }}\n<!-- [\"a\"] -->\n```\n6. lowercase\nlowercase过滤器将字符串转为小写。\n```\n{{ \"San Francisco is very cloudy\" | lowercase }}\n<!-- san francisco is very cloudy -->\n```\n7. number\nnumber过滤器将数字格式化成文本。它的第二个参数是可选的，用来控制小数点后截取的位数。如果传入了一个非数字字符，会返会空字符串。\n```\n{{ 123456789 | number }}\n<!-- 1,234,567,890 -->\n{{ 1.234567 | number:2 }}\n<!-- 1.23 -->\n```\n8. orderBy\norderBy过滤器可以用表达式对指定的数组进行排序。orderBy可以接受两个参数，第一个是必需的，第二个是可选的。\n第一个参数是用来确定数组排序方向的谓词。\n    下面分情况讨论第一个参数的类型。\n     函数\n    当第一个参数是函数时，该函数会被当作待排序对象的getter方法。\n     字符串\n    对这个字符串进行解析的结果将决定数组元素的排序方向。我们可以传入+或-来强制进行升序或降序排列。\n     数组\n    在排序表达式中使用数组元素作为谓词。对于与表达式结果并不严格相等的每个元素，则使用第一个谓词。\n    第二个参数用来控制排序的方向（是否逆向）。\n    例如，我们将下面的对象数组用name字段进行排序：\n    ```\n    {{ [{\n    'name': 'Ari',\n    'status': 'awake'\n    },{\n    'name': 'Q',\n    'status': 'sleeping'\n    },{\n    'name': 'Nate',\n    'status': 'awake'\n    }] | orderBy:'name' }}\n    <!--\n    [\n    {\"name\":\"Ari\",\"status\":\"awake\"},\n    {\"name\":\"Nate\",\"status\":\"awake\"},\n    {\"name\":\"Q\",\"status\":\"sleeping\"}\n    ]\n    -->\n    也可以对排序结果进行反转。例如，通过将第二个参数设置为true可以将排序结果进行反转：\n    {{ [{\n    'name': 'Ari',\n    'status': 'awake'\n    },{\n    'name': 'Q',\n    'status': 'sleeping'\n    },{\n    'name': 'Nate',\n    'status': 'awake'\n    }] | orderBy:'name':true }}\n    <!--\n    [\n    {\"name\":\"Q\",\"status\":\"sleeping\"},\n    {\"name\":\"Nate\",\"status\":\"awake\"},\n    {\"name\":\"Ari\",\"status\":\"awake\"}\n    ]\n    -->\n    ```\n9. uppercase\nuppercase过滤器可以将字符串转换为大写形式：\n```\n{{ \"San Francisco is very cloudy\" | uppercase }}\n<!-- SAN FRANCISCO IS VERY CLOUDY -->\n```\n#### 自定义过滤器\n创建自定义过滤器非常容易。创建自定义过滤器需要将它放到自己的模块中。\n例：实现一个过滤器，将字符串第一个字母转换为大写\n首先，创建一个模块用以在应用中进行引用（这是一个非常好的实践）：\n```\nangular.module('myApp.filters', [])\n.filter('capitalize', function() {\nreturn function(input) {};\n});\n```\n过滤器本质上是一个会把我们输入的内容当作参数传入进去的函数。上面这个例子中，我们在调用过滤器时简单地把input当作字符串来处理。可以在这个函数中做一些错误检查：\n```\nangular.module('myApp.filters', [])\n.filter('capitalize', function() {\nreturn function(input) {\n// input是我们传入的字符串\nif (input) {\nreturn input[0].toUpperCase() + input.slice(1);\n}\n});\n```\n现在，如果想将一个句子的首字母转换成大写形式，可以用过滤器先将整个句子都转换成小写，再把首字母转换成大写：\n```\n<!-- Ginger loves dog treats -->\n{{ 'ginger loves dog treats' | lowercase | capitalize }}\n```\n#### 表单验证\nAngularJS能够将HTML5表单验证功能同它自己的验证指令结合起来使用，并且非常方便。\n```\n<form name=\"form\" novalidate>\n<label name=\"email\">Your email</label>\n<input type=\"email\"\nname=\"email\"\nng-model=\"email\" placeholder=\"Email Address\" />\n</form>\n```\n注：要使用表单验证，首先要确保表单像上面的例子一样有一个name属性。\n所有输入字段都可以进行基本的验证，比如最大、最小长度等。这些功能是由新的HTML5表单属性提供的。如果想要屏蔽浏览器对表单的默认验证行为，可以在表单元素上添加novalidate标记。\n   - input元素所有验证选项如下：\n   1. 必填项\n   验证某个表单输入是否已填写，只要在输入字段元素上添加HTML5标记required即可：\n   ```\n   <input type=\"text\" required />\n   ```\n   2. 最小长度\n   验证表单输入的文本长度是否大于某个最小值，在输入字段上使用AngularJS指令ng-minleng=\"{number}\"：\n   ```\n   <input type=\"text\" ng-minlength=\"5\" />\n   ```\n   3. 最大长度\n   验证表单输入的文本长度是否小于或等于某个最大值，在输入字段上使用AngularJS指令ng-maxlength=\"{number}\"：\n   ```\n   <input type=\"text\" ng-maxlength=\"20\" />\n   ```\n   4. 模式匹配\n   使用ng-pattern=\"/PATTERN/\"来确保输入能够匹配指定的正则表达式：\n   ```\n   <input type=\"text\" ng-pattern=\"[a-zA-Z]\" />\n   ```\n   5. 电子邮件\n   验证输入内容是否是电子邮件，只要像下面这样将input的类型设置为email即可：\n   ```\n   <input type=\"email\" name=\"email\" ng-model=\"user.email\" />\n   ```\n   6. 数字\n   验证输入内容是否是数字，将input的类型设置为number：\n   ```\n   <input type=\"number\" name=\"age\" ng-model=\"user.age\" />\n   ```\n   7. URL\n   验证输入内容是否是URL，将input的类型设置为 url：\n   ```\n   <input type=\"url\" name=\"homepage\" ng-model=\"user.facebook_url\" />\n   ```\n   8. 在表单中控制变量\n   表单的属性可以在其所属的$scope对象中访问到，而我们又可以访问$scope对象，因此JavaScript可以间接地访问DOM中的表单属性。借助这些属性，我们可以对表单做出实时（和AngularJS中其他东西一样）响应。\n   注：可以使用下面的格式访问这些属性。\n   formName.inputFieldName.property\n    未修改的表单\n   这是一个布尔属性，用来判断用户是否修改了表单。如果未修改，值为true，如果修改过值\n   为false：\n   formName.inputFieldName.$pristine\n    修改过的表单\n   只要用户修改过表单，无论输入是否通过验证，该值都返回true：\n   formName.inputFieldName.$dirty\n    合法的表单\n   这个布尔型的属性用来判断表单的内容是否合法。如果当前表单内容是合法的，下面属性的\n   值就是true：\n   formName.inputFieldName.$valid\n    不合法的表单\n   这个布尔属性用来判断表单的内容是否不合法。如果当前表单内容是不合法的，下面属性的\n   值为true：\n   formName.inputFieldName.$invalid\n    错误\n   这是AngularJS提供的另外一个非常有用的属性： $error对象。它包含当前表单的所有验证\n   内容，以及它们是否合法的信息。用下面的语法访问这个属性：\n   formName.inputfieldName.$error\n   如果验证失败，这个属性的值为true；如果值为false，说明输入字段的值通过了验证。\n   ```\n   例：判断错误提示框是否显示：\n   ng-show=\"signup_form.name.$dirty && signup_form.name.$invalid\"\n   signup_form为表单的name属性值，name为input输入框的name属性值。\n   ```\n   9. 一些有用的CSS样式\n   AngularJS处理表单时，会根据表单当前的状态添加一些CSS类（例如当前是合法的、未发生变化的，等等），这些CSS类的命名和前面介绍的属性很相似。\n   ```\n   .ng-pristine {}\n   .ng-dirty {}\n   .ng-valid {}\n   .ng-invalid {}\n   ```\n   它们对应着表单输入字段的特定状态。\n   当某个字段中的输入非法时， .ng-invlid类会被添加到这个字段上。当前例子中的站点将对应的CSS样式设置为：\n   ```\n   input.ng-invalid {\n   border: 1px solid red;\n   }\n   input.ng-valid {\n   border: 1px solid green;\n   } \n   ```\n   - $parsers\n  使用$parsers数组是实现自定义验证的途径之一。\n  - $formatters\n注：表单本身会提供$invalid和$valid属性。例：formName.$invalid;当用户试图提交表单时，你可以在作用域中捕获到一个submitted值，然后对表单内容进行验证并显示错误信息。一般当formName.submitted设置为true时，容纳错误信息的div才会展示出来。\n#### 从1.3开始， Angular中新增了一个ngMessages指令。\n   1. 安装ngMessages很简单，因为它被打包成了一个Angular模块。首先下载这个模块：\n```\n$ bower install --save angular-messages\n```\n   2. 还需要将angular-messages.js这个JavaScript引入我们的主HTML中：\n   ```\n<script type=\"text/javascript\" src=\"bower_components/angular-messages/angular-messages.js\">\n</script>\n```\n   3. 最后，我们还要告诉Angular将ngMessages作为应用程序的依赖模块引入，就像这样：\n   ```\nangular.module('myApp', ['ngMessages']);\n```\n  例：在没有使用ngMessages之前，我们可能这样写验证：\n  ```\n  <form name=\"userForm\">\n  <input \n  type=\"text\"\n  name=\"username\"\n  ng-model=\"user.username\"\n  ng-minlength=\"3\"\n  ng-maxlength=\"8\"\n  required>\n  <p ng-show=\"userForm.username.$error.minlength\">Username is too short.</p>\n  <p ng-show=\"userForm.username.$error.maxlength\">Username is too long.</p>\n  <p ng-show=\"userForm.username.$error.required\">Your username is required.</p>\n  </form>\n  ```\n  有了\"ngMessages\"这个module,大致这么写：\n  ```\n  <div class=\"help-block\" ng-messages=\"userForm.name.$error\" ng-if=\"userForm.name.$touched\">\n  <p ng-message=\"minlength\">用户名最小长度5</p>\n  <p ng-message=\"maxlength\">用户名最大长度10</p>\n  <p ng-message=\"required\">用户名必填</p>\n  </div>\n  ```\n  ngMessages为我们自动判断显示哪种错误。\n  \n####  使用ngMessages的几个关键点：\n  \n   1. ● npm install angular-messages\n   2. ● 引用：angular-messages.js\n   3. ● 依赖：angular.module('app',['ngMessages'])\n\n","slug":"angular-guide6-7","published":1,"updated":"2016-12-26T05:12:10.203Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv68000njgtu177c0oj4","content":"<h4 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h4><p>用{ { } }符号将一个变量绑定到$scope上的写法本质上就是一个表达式：<code></code>。当用$watch进行监听时， AngularJS会对表达式或函数进行运算。<br>表达式和eval(javascript)非常相似，但是由于表达式由AngularJS来处理，它们有以下显著不同的特性：</p>\n<ol>\n<li>所有的表达式都在其所属的作用域内部执行，并有访问本地$scope的权限；</li>\n<li>如果表达式发生了TypeError和ReferenceError并不会抛出异常；</li>\n<li>不允许使用任何流程控制功能（条件控制，例如if/eles）；</li>\n<li>可以接受过滤器和过滤器链。<h4 id=\"解析-AngularJS-表达式\"><a href=\"#解析-AngularJS-表达式\" class=\"headerlink\" title=\"解析 AngularJS 表达式\"></a>解析 AngularJS 表达式</h4>AngularJS会在运行$digest循环的过程中自动解析表达式，AngularJS通过$parse这个内部服务来进行表达式的运算，这个服务能够访问当前所处的作用域。这个过程允许我们访问定义在$scope上的原始JavaScript数据和函数。将$parse服务注入到控制器中，然后调用它就可以实现手动解析表达式。<br>如果页面上有一个输入框绑定到了expr变量上，如下所示:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-controller=&quot;MyController&quot;&gt;</div><div class=\"line\">&lt;input ng-model=&quot;expr&quot;</div><div class=\"line\">type=&quot;text&quot;</div><div class=\"line\">placeholder=&quot;Enter an expression&quot; /&gt;</div><div class=\"line\">&lt;h2&gt;&#123;&#123; parseValue &#125;&#125;&lt;/h2&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">我们可以在MyController中给expr这个表达式设置一个$watch并解析它：</div><div class=\"line\">angular.module(&quot;myApp&quot;, [])</div><div class=\"line\">.controller(&apos;MyController&apos;,</div><div class=\"line\">function($scope,$parse) &#123;</div><div class=\"line\">$scope.$watch(&apos;expr&apos;, function(newVal, oldVal, scope) &#123;</div><div class=\"line\">if (newVal !== oldVal) &#123;</div><div class=\"line\">// 用该表达式设置parseFun</div><div class=\"line\">var parseFun = $parse(newVal);</div><div class=\"line\">// 获取经过解析后表达式的值</div><div class=\"line\">$scope.parsedValue = parseFun(scope);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>注：$watch函数会监视$scope上的某个属性。只要属性发生变化就会调用对应的函数。可以使用$watch函数在$scope上某个属性发生变化时直接运行一个自定义函数。</p>\n<h4 id=\"插值字符串（不常用）\"><a href=\"#插值字符串（不常用）\" class=\"headerlink\" title=\"插值字符串（不常用）\"></a>插值字符串（不常用）</h4><p>在开发中，我们的确有手动运行模板编译的能力。要在字符串模板中做插值操作，需要在你的对象中注入$interpolate服务。<br>$interpolate服务返回一个函数，用来在特定的上下文中运算表达式。</p>\n<h4 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h4><p>过滤器用来格式化需要展示给用户的数据。 AngularJS有很多实用的内置过滤器，同时也提供了方便的途径可以自己创建过滤器。在HTML中的模板绑定符号{ { } }内通过|符号来调用过滤器。例如，假设我们希望将字符串转换成大写，可以对字符串中的每个字符都单独进行转换操作，也可以使用过滤器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; name | uppercase &#125;&#125;</div></pre></td></tr></table></figure></p>\n<p>在JavaScript代码中可以通过$filter来调用过滤器。例如，在JavaScript代码中使用lowercase过滤器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.controller(&apos;DemoController&apos;, [&apos;$scope&apos;, &apos;$filter&apos;,</div><div class=\"line\">function($scope, $filter) &#123;</div><div class=\"line\">$scope.name = $filter(&apos;lowercase&apos;)(&apos;WEBYWX&apos;);</div><div class=\"line\">&#125;]);</div></pre></td></tr></table></figure></p>\n<p>以HTML的形式使用过滤器时，如果需要传递参数给过滤器，只要在过滤器名字后面加冒号即可。如果有多个参数，可以在每个参数后面都加入冒号。例如，数值过滤器可以限制小数点后的位数，在过滤器后写上:2可以将2作为参数传给过滤器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 显示： 123.46 --&gt;</div><div class=\"line\">&#123;&#123; 123.456789 | number:2 &#125;&#125;</div></pre></td></tr></table></figure></p>\n<p>可以用|符号作为分割符来同时使用多个过滤器.</p>\n<h4 id=\"angular-内置过滤器\"><a href=\"#angular-内置过滤器\" class=\"headerlink\" title=\"angular 内置过滤器\"></a>angular 内置过滤器</h4><ol>\n<li>currency<br>currecy过滤器可以将一个数值格式化为货币格式。用{ { 123 | currency } }`来将123转化成货币格式。</li>\n<li><p>date<br>date过滤器可以将日期格式化成需要的格式。 AngularJS中内置了几种日期格式，如果没有指定使用任何格式，默认会采用mediumDate格式，下面的例子中展示了这个格式。下面是内置的支持本地化的日期格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; today | date:&apos;medium&apos; &#125;&#125; &lt;!-- Aug 09, 2013 12:09:02 PM --&gt;</div><div class=\"line\">&#123;&#123; today | date:&apos;short&apos; &#125;&#125; &lt;!-- 8/9/1312:09PM --&gt;</div><div class=\"line\">&#123;&#123; today | date:&apos;fullDate&apos; &#125;&#125; &lt;!-- Thursday, August 09, 2013 --&gt;</div><div class=\"line\">&#123;&#123; today | date:&apos;longDate&apos; &#125;&#125; &lt;!-- August 09, 2013 --&gt;</div><div class=\"line\">&#123;&#123; today | date:&apos;mediumDate&apos; &#125;&#125;&lt;!-- Aug 09, 2013 --&gt;</div><div class=\"line\">&#123;&#123; today | date:&apos;shortDate&apos; &#125;&#125; &lt;!-- 8/9/13 --&gt;</div><div class=\"line\">&#123;&#123; today | date:&apos;mediumTime&apos; &#125;&#125;&lt;!-- 12:09:02 PM --&gt;</div><div class=\"line\">&#123;&#123; today | date:&apos;shortTime&apos; &#125;&#125; &lt;!-- 12:09 PM --&gt;</div><div class=\"line\"> 年份格式化</div><div class=\"line\">四位年份： &#123;&#123; today | date:&apos;yyyy&apos; &#125;&#125; &lt;!-- 2013 --&gt;</div><div class=\"line\">两位年份： &#123;&#123; today | date:&apos;yy&apos; &#125;&#125; &lt;!-- 13 --&gt;</div><div class=\"line\">一位年份： &#123;&#123; today | date:&apos;y&apos; &#125;&#125; &lt;!-- 2013 --&gt;</div><div class=\"line\"> 月份格式化</div><div class=\"line\">英文月份： &#123;&#123; today | date:&apos;MMMM&apos; &#125;&#125; &lt;!-- August --&gt;</div><div class=\"line\">英文月份简写： &#123;&#123; today | date:&apos;MMM&apos; &#125;&#125; &lt;!-- Aug --&gt;</div><div class=\"line\">数字月份： &#123;&#123; today |date:&apos;MM&apos; &#125;&#125; &lt;!-- 08 --&gt;</div><div class=\"line\">一年中的第几个月份： &#123;&#123; today |date:&apos;M&apos; &#125;&#125; &lt;!-- 8 --&gt;</div><div class=\"line\"> 日期格式化</div><div class=\"line\">数字日期： &#123;&#123; today|date:&apos;dd&apos; &#125;&#125; &lt;!-- 09 --&gt;</div><div class=\"line\">一个月中的第几天： &#123;&#123; today | date:&apos;d&apos; &#125;&#125; &lt;!-- 9 --&gt;</div><div class=\"line\">英文星期： &#123;&#123; today | date:&apos;EEEE&apos; &#125;&#125; &lt;!-- Thursday --&gt;</div><div class=\"line\">英文星期简写： &#123;&#123; today | date:&apos;EEE&apos; &#125;&#125; &lt;!-- Thu --&gt;</div><div class=\"line\"> 小时格式化</div><div class=\"line\">24小时制数字小时： &#123;&#123;today|date:&apos;HH&apos;&#125;&#125; &lt;!--00--&gt;</div><div class=\"line\">一天中的第几个小时： &#123;&#123;today|date:&apos;H&apos;&#125;&#125; &lt;!--0--&gt;</div><div class=\"line\">12小时制数字小时： &#123;&#123;today|date:&apos;hh&apos;&#125;&#125; &lt;!--12--&gt;</div><div class=\"line\">上午或下午的第几个小时： &#123;&#123;today|date:&apos;h&apos;&#125;&#125; &lt;!--12--&gt;</div><div class=\"line\"> 分钟格式化</div><div class=\"line\">数字分钟数： &#123;&#123; today | date:&apos;mm&apos; &#125;&#125; &lt;!-- 09 --&gt;</div><div class=\"line\">一个小时中的第几分钟： &#123;&#123; today | date:&apos;m&apos; &#125;&#125; &lt;!-- 9 --&gt;</div><div class=\"line\"> 秒数格式化</div><div class=\"line\">数字秒数： &#123;&#123; today | date:&apos;ss&apos; &#125;&#125; &lt;!-- 02 --&gt;</div><div class=\"line\">一分钟内的第几秒： &#123;&#123; today | date:&apos;s&apos; &#125;&#125; &lt;!-- 2 --&gt;</div><div class=\"line\">毫秒数： &#123;&#123; today | date:&apos;.sss&apos; &#125;&#125; &lt;!-- .995 --&gt;</div><div class=\"line\"> 字符格式化</div><div class=\"line\">上下午标识： &#123;&#123; today | date:&apos;a&apos; &#125;&#125; &lt;!-- AM --&gt;</div><div class=\"line\">四位时区标识： &#123;&#123; today | date:&apos;Z&apos; &#125;&#125; &lt;!--- 0700 --&gt;</div><div class=\"line\">下面是一些自定义日期格式的示例：</div><div class=\"line\">&#123;&#123; today | date:&apos;MMMd, y&apos; &#125;&#125; &lt;!-- Aug9, 2013 --&gt;</div><div class=\"line\">&#123;&#123; today | date:&apos;EEEE, d, M&apos; &#125;&#125; &lt;!-- Thursday, 9, 8--&gt;</div><div class=\"line\">&#123;&#123; today | date:&apos;hh:mm:ss.sss&apos; &#125;&#125; &lt;!-- 12:09:02.995 --&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>filter<br>filter过滤器可以从给定数组中选择一个子集，并将其生成一个新数组返回。这个过滤器通常用来过滤需要进行展示的元素。例如，在做客户端搜索时，可以从一个数组中立刻过滤出所需的结果。这个过滤器的第一个参数可以是字符串、对象或是一个用来从数组中选择元素的函数。<br> 下面分情况介绍传入不同类型的参数。</p>\n<ol>\n<li> 字符串<br>返回所有包含这个字符串的元素。如果我们想返回不包含该字符串的元素，在参数前加!符号。</li>\n<li> 对象<br>AngularJS会将待过滤对象的属性同这个对象中的同名属性进行比较，如果属性值是字符串就会判断是否包含该字符串。如果我们希望对全部属性都进行对比，可以将$当作键名。</li>\n<li><p> 函数<br>对每个元素都执行这个函数，返回非假值的元素会出现在新的数组中并返回。<br>例如，用下面的过滤器可以选择所有包含字母e的单词：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; [&apos;Ari&apos;,&apos;Lerner&apos;,&apos;Likes&apos;,&apos;To&apos;,&apos;Eat&apos;,&apos;Pizza&apos;] | filter:&apos;e&apos; &#125;&#125;</div><div class=\"line\">&lt;!-- [&quot;Lerner&quot;,&quot;Likes&quot;,&quot;Eat&quot;] --&gt;</div></pre></td></tr></table></figure>\n<p>如果要过滤对象，可以使用上面提到的对象过滤器。例如，如果有一个由people对象组成的<br>数组，每个对象都含有他们最喜欢吃的食物的列表，那么可以用下面的形式进行过滤：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; [&#123;</div><div class=\"line\">&apos;name&apos;: &apos;Ari&apos;,</div><div class=\"line\">&apos;City&apos;: &apos;San Francisco&apos;,</div><div class=\"line\">&apos;favorite food&apos;: &apos;Pizza&apos;</div><div class=\"line\">&#125;,&#123;</div><div class=\"line\">&apos;name&apos;: &apos;Nate&apos;,</div><div class=\"line\">&apos;City&apos;: &apos;San Francisco&apos;,</div><div class=\"line\">&apos;favorite food&apos;: &apos;indian food&apos;</div><div class=\"line\">&#125;] | filter:&#123;&apos;favorite food&apos;: &apos;Pizza&apos;&#125; &#125;&#125;</div><div class=\"line\">&lt;!-- [&#123;&quot;name&quot;:&quot;Ari&quot;,&quot;City&quot;:&quot;SanFrancisco&quot;,&quot;favoritefood&quot;:&quot;Pizza&quot;&#125;] --&gt;</div></pre></td></tr></table></figure>\n<p>也可以用自定义函数进行过滤（在这个例子中函数定义在$scope上）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; [&apos;Ari&apos;,&apos;likes&apos;,&apos;to&apos;,&apos;travel&apos;] | filter:isCapitalized &#125;&#125;</div><div class=\"line\">&lt;!-- [&quot;Ari&quot;] --&gt;</div><div class=\"line\">isCapitalized函数的功能是根据首字母是否为大写返回true或false，具体如下所示：</div><div class=\"line\">$scope.isCapitalized = function(str) &#123;</div><div class=\"line\">return str[0] == str[0].toUpperCase();</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>我们也可以给filter过滤器传入第二个参数，用来指定预期值同实际值进行比较的方式。<br>第二个参数可以是以下三种情况之一。<br> true<br>用angular.equals(expected, actual)对两个值进行严格比较。<br> false<br>进行区分大小写的子字符串比较。<br> 函数<br>运行这个函数，如果返回真值就接受这个元素。</p>\n<h4 id=\"json\"><a href=\"#json\" class=\"headerlink\" title=\"json\"></a>json</h4><p>json过滤器可以将一个JSON或JavaScript对象转换成字符串。这种转换对调试非常有帮助：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; &#123;&apos;name&apos;: &apos;Ari&apos;, &apos;City&apos;: &apos;SanFrancisco&apos;&#125; | json &#125;&#125;</div><div class=\"line\">&lt;!--</div><div class=\"line\">&#123;</div><div class=\"line\">&quot;name&quot;: &quot;Ari&quot;,</div><div class=\"line\">&quot;City&quot;: &quot;San Francisco&quot;</div><div class=\"line\">&#125;</div><div class=\"line\">--&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>limitTo<br>limitTo过滤器会根据传入的参数生成一个新的数组或字符串，新的数组或字符串的长度取决于传入的参数，通过传入参数的正负值来控制从前面还是从后面开始截取。如果传入的长度值大于被操作数组或字符串的长度，那么整个数组或字符串都会被返回。<br>例如，我们可以截取字符串的前三个字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; San Francisco is very cloudy | limitTo:3 &#125;&#125;</div><div class=\"line\">&lt;!-- San --&gt;</div><div class=\"line\">或最后的六个字符：</div><div class=\"line\">&#123;&#123; San Francisco is very cloudy | limitTo:-6 &#125;&#125;</div><div class=\"line\">&lt;!-- cloudy --&gt;</div><div class=\"line\">对数组也可以进行同样的操作。返回数组的第一个元素：</div><div class=\"line\">&#123;&#123; [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;] | limitTo:1 &#125;&#125;</div><div class=\"line\">&lt;!-- [&quot;a&quot;] --&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>lowercase<br>lowercase过滤器将字符串转为小写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; &quot;San Francisco is very cloudy&quot; | lowercase &#125;&#125;</div><div class=\"line\">&lt;!-- san francisco is very cloudy --&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>number<br>number过滤器将数字格式化成文本。它的第二个参数是可选的，用来控制小数点后截取的位数。如果传入了一个非数字字符，会返会空字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; 123456789 | number &#125;&#125;</div><div class=\"line\">&lt;!-- 1,234,567,890 --&gt;</div><div class=\"line\">&#123;&#123; 1.234567 | number:2 &#125;&#125;</div><div class=\"line\">&lt;!-- 1.23 --&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>orderBy<br>orderBy过滤器可以用表达式对指定的数组进行排序。orderBy可以接受两个参数，第一个是必需的，第二个是可选的。<br>第一个参数是用来确定数组排序方向的谓词。<br> 下面分情况讨论第一个参数的类型。<br>  函数<br> 当第一个参数是函数时，该函数会被当作待排序对象的getter方法。<br>  字符串<br> 对这个字符串进行解析的结果将决定数组元素的排序方向。我们可以传入+或-来强制进行升序或降序排列。<br>  数组<br> 在排序表达式中使用数组元素作为谓词。对于与表达式结果并不严格相等的每个元素，则使用第一个谓词。<br> 第二个参数用来控制排序的方向（是否逆向）。<br> 例如，我们将下面的对象数组用name字段进行排序：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; [&#123;</div><div class=\"line\">&apos;name&apos;: &apos;Ari&apos;,</div><div class=\"line\">&apos;status&apos;: &apos;awake&apos;</div><div class=\"line\">&#125;,&#123;</div><div class=\"line\">&apos;name&apos;: &apos;Q&apos;,</div><div class=\"line\">&apos;status&apos;: &apos;sleeping&apos;</div><div class=\"line\">&#125;,&#123;</div><div class=\"line\">&apos;name&apos;: &apos;Nate&apos;,</div><div class=\"line\">&apos;status&apos;: &apos;awake&apos;</div><div class=\"line\">&#125;] | orderBy:&apos;name&apos; &#125;&#125;</div><div class=\"line\">&lt;!--</div><div class=\"line\">[</div><div class=\"line\">&#123;&quot;name&quot;:&quot;Ari&quot;,&quot;status&quot;:&quot;awake&quot;&#125;,</div><div class=\"line\">&#123;&quot;name&quot;:&quot;Nate&quot;,&quot;status&quot;:&quot;awake&quot;&#125;,</div><div class=\"line\">&#123;&quot;name&quot;:&quot;Q&quot;,&quot;status&quot;:&quot;sleeping&quot;&#125;</div><div class=\"line\">]</div><div class=\"line\">--&gt;</div><div class=\"line\">也可以对排序结果进行反转。例如，通过将第二个参数设置为true可以将排序结果进行反转：</div><div class=\"line\">&#123;&#123; [&#123;</div><div class=\"line\">&apos;name&apos;: &apos;Ari&apos;,</div><div class=\"line\">&apos;status&apos;: &apos;awake&apos;</div><div class=\"line\">&#125;,&#123;</div><div class=\"line\">&apos;name&apos;: &apos;Q&apos;,</div><div class=\"line\">&apos;status&apos;: &apos;sleeping&apos;</div><div class=\"line\">&#125;,&#123;</div><div class=\"line\">&apos;name&apos;: &apos;Nate&apos;,</div><div class=\"line\">&apos;status&apos;: &apos;awake&apos;</div><div class=\"line\">&#125;] | orderBy:&apos;name&apos;:true &#125;&#125;</div><div class=\"line\">&lt;!--</div><div class=\"line\">[</div><div class=\"line\">&#123;&quot;name&quot;:&quot;Q&quot;,&quot;status&quot;:&quot;sleeping&quot;&#125;,</div><div class=\"line\">&#123;&quot;name&quot;:&quot;Nate&quot;,&quot;status&quot;:&quot;awake&quot;&#125;,</div><div class=\"line\">&#123;&quot;name&quot;:&quot;Ari&quot;,&quot;status&quot;:&quot;awake&quot;&#125;</div><div class=\"line\">]</div><div class=\"line\">--&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>uppercase<br>uppercase过滤器可以将字符串转换为大写形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; &quot;San Francisco is very cloudy&quot; | uppercase &#125;&#125;</div><div class=\"line\">&lt;!-- SAN FRANCISCO IS VERY CLOUDY --&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"自定义过滤器\"><a href=\"#自定义过滤器\" class=\"headerlink\" title=\"自定义过滤器\"></a>自定义过滤器</h4><p>创建自定义过滤器非常容易。创建自定义过滤器需要将它放到自己的模块中。<br>例：实现一个过滤器，将字符串第一个字母转换为大写<br>首先，创建一个模块用以在应用中进行引用（这是一个非常好的实践）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp.filters&apos;, [])</div><div class=\"line\">.filter(&apos;capitalize&apos;, function() &#123;</div><div class=\"line\">return function(input) &#123;&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>过滤器本质上是一个会把我们输入的内容当作参数传入进去的函数。上面这个例子中，我们在调用过滤器时简单地把input当作字符串来处理。可以在这个函数中做一些错误检查：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp.filters&apos;, [])</div><div class=\"line\">.filter(&apos;capitalize&apos;, function() &#123;</div><div class=\"line\">return function(input) &#123;</div><div class=\"line\">// input是我们传入的字符串</div><div class=\"line\">if (input) &#123;</div><div class=\"line\">return input[0].toUpperCase() + input.slice(1);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>现在，如果想将一个句子的首字母转换成大写形式，可以用过滤器先将整个句子都转换成小写，再把首字母转换成大写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- Ginger loves dog treats --&gt;</div><div class=\"line\">&#123;&#123; &apos;ginger loves dog treats&apos; | lowercase | capitalize &#125;&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"表单验证\"><a href=\"#表单验证\" class=\"headerlink\" title=\"表单验证\"></a>表单验证</h4><p>AngularJS能够将HTML5表单验证功能同它自己的验证指令结合起来使用，并且非常方便。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;form&quot; novalidate&gt;</div><div class=\"line\">&lt;label name=&quot;email&quot;&gt;Your email&lt;/label&gt;</div><div class=\"line\">&lt;input type=&quot;email&quot;</div><div class=\"line\">name=&quot;email&quot;</div><div class=\"line\">ng-model=&quot;email&quot; placeholder=&quot;Email Address&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<p>注：要使用表单验证，首先要确保表单像上面的例子一样有一个name属性。<br>所有输入字段都可以进行基本的验证，比如最大、最小长度等。这些功能是由新的HTML5表单属性提供的。如果想要屏蔽浏览器对表单的默认验证行为，可以在表单元素上添加novalidate标记。</p>\n<ul>\n<li>input元素所有验证选项如下：</li>\n</ul>\n<ol>\n<li><p>必填项<br>验证某个表单输入是否已填写，只要在输入字段元素上添加HTML5标记required即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input type=&quot;text&quot; required /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>最小长度<br>验证表单输入的文本长度是否大于某个最小值，在输入字段上使用AngularJS指令ng-minleng=”{number}”：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input type=&quot;text&quot; ng-minlength=&quot;5&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>最大长度<br>验证表单输入的文本长度是否小于或等于某个最大值，在输入字段上使用AngularJS指令ng-maxlength=”{number}”：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input type=&quot;text&quot; ng-maxlength=&quot;20&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>模式匹配<br>使用ng-pattern=”/PATTERN/“来确保输入能够匹配指定的正则表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input type=&quot;text&quot; ng-pattern=&quot;[a-zA-Z]&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>电子邮件<br>验证输入内容是否是电子邮件，只要像下面这样将input的类型设置为email即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input type=&quot;email&quot; name=&quot;email&quot; ng-model=&quot;user.email&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>数字<br>验证输入内容是否是数字，将input的类型设置为number：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input type=&quot;number&quot; name=&quot;age&quot; ng-model=&quot;user.age&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>URL<br>验证输入内容是否是URL，将input的类型设置为 url：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input type=&quot;url&quot; name=&quot;homepage&quot; ng-model=&quot;user.facebook_url&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在表单中控制变量<br>表单的属性可以在其所属的$scope对象中访问到，而我们又可以访问$scope对象，因此JavaScript可以间接地访问DOM中的表单属性。借助这些属性，我们可以对表单做出实时（和AngularJS中其他东西一样）响应。<br>注：可以使用下面的格式访问这些属性。<br>formName.inputFieldName.property<br> 未修改的表单<br>这是一个布尔属性，用来判断用户是否修改了表单。如果未修改，值为true，如果修改过值<br>为false：<br>formName.inputFieldName.$pristine<br> 修改过的表单<br>只要用户修改过表单，无论输入是否通过验证，该值都返回true：<br>formName.inputFieldName.$dirty<br> 合法的表单<br>这个布尔型的属性用来判断表单的内容是否合法。如果当前表单内容是合法的，下面属性的<br>值就是true：<br>formName.inputFieldName.$valid<br> 不合法的表单<br>这个布尔属性用来判断表单的内容是否不合法。如果当前表单内容是不合法的，下面属性的<br>值为true：<br>formName.inputFieldName.$invalid<br> 错误<br>这是AngularJS提供的另外一个非常有用的属性： $error对象。它包含当前表单的所有验证<br>内容，以及它们是否合法的信息。用下面的语法访问这个属性：<br>formName.inputfieldName.$error<br>如果验证失败，这个属性的值为true；如果值为false，说明输入字段的值通过了验证。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">例：判断错误提示框是否显示：</div><div class=\"line\">ng-show=&quot;signup_form.name.$dirty &amp;&amp; signup_form.name.$invalid&quot;</div><div class=\"line\">signup_form为表单的name属性值，name为input输入框的name属性值。</div></pre></td></tr></table></figure>\n</li>\n<li><p>一些有用的CSS样式<br>AngularJS处理表单时，会根据表单当前的状态添加一些CSS类（例如当前是合法的、未发生变化的，等等），这些CSS类的命名和前面介绍的属性很相似。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">.ng-pristine &#123;&#125;</div><div class=\"line\">.ng-dirty &#123;&#125;</div><div class=\"line\">.ng-valid &#123;&#125;</div><div class=\"line\">.ng-invalid &#123;&#125;</div></pre></td></tr></table></figure>\n<p>它们对应着表单输入字段的特定状态。<br>当某个字段中的输入非法时， .ng-invlid类会被添加到这个字段上。当前例子中的站点将对应的CSS样式设置为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">input.ng-invalid &#123;</div><div class=\"line\">border: 1px solid red;</div><div class=\"line\">&#125;</div><div class=\"line\">input.ng-valid &#123;</div><div class=\"line\">border: 1px solid green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>$parsers<br>使用$parsers数组是实现自定义验证的途径之一。<ul>\n<li>$formatters<br>注：表单本身会提供$invalid和$valid属性。例：formName.$invalid;当用户试图提交表单时，你可以在作用域中捕获到一个submitted值，然后对表单内容进行验证并显示错误信息。一般当formName.submitted设置为true时，容纳错误信息的div才会展示出来。<h4 id=\"从1-3开始，-Angular中新增了一个ngMessages指令。\"><a href=\"#从1-3开始，-Angular中新增了一个ngMessages指令。\" class=\"headerlink\" title=\"从1.3开始， Angular中新增了一个ngMessages指令。\"></a>从1.3开始， Angular中新增了一个ngMessages指令。</h4></li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>安装ngMessages很简单，因为它被打包成了一个Angular模块。首先下载这个模块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ bower install --save angular-messages</div></pre></td></tr></table></figure>\n</li>\n<li><p>还需要将angular-messages.js这个JavaScript引入我们的主HTML中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;bower_components/angular-messages/angular-messages.js&quot;&gt;</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>最后，我们还要告诉Angular将ngMessages作为应用程序的依赖模块引入，就像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp&apos;, [&apos;ngMessages&apos;]);</div></pre></td></tr></table></figure>\n<p>例：在没有使用ngMessages之前，我们可能这样写验证：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;userForm&quot;&gt;</div><div class=\"line\">&lt;input </div><div class=\"line\">type=&quot;text&quot;</div><div class=\"line\">name=&quot;username&quot;</div><div class=\"line\">ng-model=&quot;user.username&quot;</div><div class=\"line\">ng-minlength=&quot;3&quot;</div><div class=\"line\">ng-maxlength=&quot;8&quot;</div><div class=\"line\">required&gt;</div><div class=\"line\">&lt;p ng-show=&quot;userForm.username.$error.minlength&quot;&gt;Username is too short.&lt;/p&gt;</div><div class=\"line\">&lt;p ng-show=&quot;userForm.username.$error.maxlength&quot;&gt;Username is too long.&lt;/p&gt;</div><div class=\"line\">&lt;p ng-show=&quot;userForm.username.$error.required&quot;&gt;Your username is required.&lt;/p&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure>\n<p>有了”ngMessages”这个module,大致这么写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;help-block&quot; ng-messages=&quot;userForm.name.$error&quot; ng-if=&quot;userForm.name.$touched&quot;&gt;</div><div class=\"line\">&lt;p ng-message=&quot;minlength&quot;&gt;用户名最小长度5&lt;/p&gt;</div><div class=\"line\">&lt;p ng-message=&quot;maxlength&quot;&gt;用户名最大长度10&lt;/p&gt;</div><div class=\"line\">&lt;p ng-message=&quot;required&quot;&gt;用户名必填&lt;/p&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>ngMessages为我们自动判断显示哪种错误。</p>\n</li>\n</ol>\n<h4 id=\"使用ngMessages的几个关键点：\"><a href=\"#使用ngMessages的几个关键点：\" class=\"headerlink\" title=\"使用ngMessages的几个关键点：\"></a>使用ngMessages的几个关键点：</h4><ol>\n<li>● npm install angular-messages</li>\n<li>● 引用：angular-messages.js</li>\n<li>● 依赖：angular.module(‘app’,[‘ngMessages’])</li>\n</ol>\n","excerpt":"","more":"<h4 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h4><p>用{ { } }符号将一个变量绑定到$scope上的写法本质上就是一个表达式：<code></code>。当用$watch进行监听时， AngularJS会对表达式或函数进行运算。<br>表达式和eval(javascript)非常相似，但是由于表达式由AngularJS来处理，它们有以下显著不同的特性：</p>\n<ol>\n<li>所有的表达式都在其所属的作用域内部执行，并有访问本地$scope的权限；</li>\n<li>如果表达式发生了TypeError和ReferenceError并不会抛出异常；</li>\n<li>不允许使用任何流程控制功能（条件控制，例如if/eles）；</li>\n<li>可以接受过滤器和过滤器链。<h4 id=\"解析-AngularJS-表达式\"><a href=\"#解析-AngularJS-表达式\" class=\"headerlink\" title=\"解析 AngularJS 表达式\"></a>解析 AngularJS 表达式</h4>AngularJS会在运行$digest循环的过程中自动解析表达式，AngularJS通过$parse这个内部服务来进行表达式的运算，这个服务能够访问当前所处的作用域。这个过程允许我们访问定义在$scope上的原始JavaScript数据和函数。将$parse服务注入到控制器中，然后调用它就可以实现手动解析表达式。<br>如果页面上有一个输入框绑定到了expr变量上，如下所示:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-controller=&quot;MyController&quot;&gt;</div><div class=\"line\">&lt;input ng-model=&quot;expr&quot;</div><div class=\"line\">type=&quot;text&quot;</div><div class=\"line\">placeholder=&quot;Enter an expression&quot; /&gt;</div><div class=\"line\">&lt;h2&gt;&#123;&#123; parseValue &#125;&#125;&lt;/h2&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">我们可以在MyController中给expr这个表达式设置一个$watch并解析它：</div><div class=\"line\">angular.module(&quot;myApp&quot;, [])</div><div class=\"line\">.controller(&apos;MyController&apos;,</div><div class=\"line\">function($scope,$parse) &#123;</div><div class=\"line\">$scope.$watch(&apos;expr&apos;, function(newVal, oldVal, scope) &#123;</div><div class=\"line\">if (newVal !== oldVal) &#123;</div><div class=\"line\">// 用该表达式设置parseFun</div><div class=\"line\">var parseFun = $parse(newVal);</div><div class=\"line\">// 获取经过解析后表达式的值</div><div class=\"line\">$scope.parsedValue = parseFun(scope);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>注：$watch函数会监视$scope上的某个属性。只要属性发生变化就会调用对应的函数。可以使用$watch函数在$scope上某个属性发生变化时直接运行一个自定义函数。</p>\n<h4 id=\"插值字符串（不常用）\"><a href=\"#插值字符串（不常用）\" class=\"headerlink\" title=\"插值字符串（不常用）\"></a>插值字符串（不常用）</h4><p>在开发中，我们的确有手动运行模板编译的能力。要在字符串模板中做插值操作，需要在你的对象中注入$interpolate服务。<br>$interpolate服务返回一个函数，用来在特定的上下文中运算表达式。</p>\n<h4 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h4><p>过滤器用来格式化需要展示给用户的数据。 AngularJS有很多实用的内置过滤器，同时也提供了方便的途径可以自己创建过滤器。在HTML中的模板绑定符号{ { } }内通过|符号来调用过滤器。例如，假设我们希望将字符串转换成大写，可以对字符串中的每个字符都单独进行转换操作，也可以使用过滤器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; name | uppercase &#125;&#125;</div></pre></td></tr></table></figure></p>\n<p>在JavaScript代码中可以通过$filter来调用过滤器。例如，在JavaScript代码中使用lowercase过滤器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.controller(&apos;DemoController&apos;, [&apos;$scope&apos;, &apos;$filter&apos;,</div><div class=\"line\">function($scope, $filter) &#123;</div><div class=\"line\">$scope.name = $filter(&apos;lowercase&apos;)(&apos;WEBYWX&apos;);</div><div class=\"line\">&#125;]);</div></pre></td></tr></table></figure></p>\n<p>以HTML的形式使用过滤器时，如果需要传递参数给过滤器，只要在过滤器名字后面加冒号即可。如果有多个参数，可以在每个参数后面都加入冒号。例如，数值过滤器可以限制小数点后的位数，在过滤器后写上:2可以将2作为参数传给过滤器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 显示： 123.46 --&gt;</div><div class=\"line\">&#123;&#123; 123.456789 | number:2 &#125;&#125;</div></pre></td></tr></table></figure></p>\n<p>可以用|符号作为分割符来同时使用多个过滤器.</p>\n<h4 id=\"angular-内置过滤器\"><a href=\"#angular-内置过滤器\" class=\"headerlink\" title=\"angular 内置过滤器\"></a>angular 内置过滤器</h4><ol>\n<li>currency<br>currecy过滤器可以将一个数值格式化为货币格式。用{ { 123 | currency } }`来将123转化成货币格式。</li>\n<li><p>date<br>date过滤器可以将日期格式化成需要的格式。 AngularJS中内置了几种日期格式，如果没有指定使用任何格式，默认会采用mediumDate格式，下面的例子中展示了这个格式。下面是内置的支持本地化的日期格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; today | date:&apos;medium&apos; &#125;&#125; &lt;!-- Aug 09, 2013 12:09:02 PM --&gt;</div><div class=\"line\">&#123;&#123; today | date:&apos;short&apos; &#125;&#125; &lt;!-- 8/9/1312:09PM --&gt;</div><div class=\"line\">&#123;&#123; today | date:&apos;fullDate&apos; &#125;&#125; &lt;!-- Thursday, August 09, 2013 --&gt;</div><div class=\"line\">&#123;&#123; today | date:&apos;longDate&apos; &#125;&#125; &lt;!-- August 09, 2013 --&gt;</div><div class=\"line\">&#123;&#123; today | date:&apos;mediumDate&apos; &#125;&#125;&lt;!-- Aug 09, 2013 --&gt;</div><div class=\"line\">&#123;&#123; today | date:&apos;shortDate&apos; &#125;&#125; &lt;!-- 8/9/13 --&gt;</div><div class=\"line\">&#123;&#123; today | date:&apos;mediumTime&apos; &#125;&#125;&lt;!-- 12:09:02 PM --&gt;</div><div class=\"line\">&#123;&#123; today | date:&apos;shortTime&apos; &#125;&#125; &lt;!-- 12:09 PM --&gt;</div><div class=\"line\"> 年份格式化</div><div class=\"line\">四位年份： &#123;&#123; today | date:&apos;yyyy&apos; &#125;&#125; &lt;!-- 2013 --&gt;</div><div class=\"line\">两位年份： &#123;&#123; today | date:&apos;yy&apos; &#125;&#125; &lt;!-- 13 --&gt;</div><div class=\"line\">一位年份： &#123;&#123; today | date:&apos;y&apos; &#125;&#125; &lt;!-- 2013 --&gt;</div><div class=\"line\"> 月份格式化</div><div class=\"line\">英文月份： &#123;&#123; today | date:&apos;MMMM&apos; &#125;&#125; &lt;!-- August --&gt;</div><div class=\"line\">英文月份简写： &#123;&#123; today | date:&apos;MMM&apos; &#125;&#125; &lt;!-- Aug --&gt;</div><div class=\"line\">数字月份： &#123;&#123; today |date:&apos;MM&apos; &#125;&#125; &lt;!-- 08 --&gt;</div><div class=\"line\">一年中的第几个月份： &#123;&#123; today |date:&apos;M&apos; &#125;&#125; &lt;!-- 8 --&gt;</div><div class=\"line\"> 日期格式化</div><div class=\"line\">数字日期： &#123;&#123; today|date:&apos;dd&apos; &#125;&#125; &lt;!-- 09 --&gt;</div><div class=\"line\">一个月中的第几天： &#123;&#123; today | date:&apos;d&apos; &#125;&#125; &lt;!-- 9 --&gt;</div><div class=\"line\">英文星期： &#123;&#123; today | date:&apos;EEEE&apos; &#125;&#125; &lt;!-- Thursday --&gt;</div><div class=\"line\">英文星期简写： &#123;&#123; today | date:&apos;EEE&apos; &#125;&#125; &lt;!-- Thu --&gt;</div><div class=\"line\"> 小时格式化</div><div class=\"line\">24小时制数字小时： &#123;&#123;today|date:&apos;HH&apos;&#125;&#125; &lt;!--00--&gt;</div><div class=\"line\">一天中的第几个小时： &#123;&#123;today|date:&apos;H&apos;&#125;&#125; &lt;!--0--&gt;</div><div class=\"line\">12小时制数字小时： &#123;&#123;today|date:&apos;hh&apos;&#125;&#125; &lt;!--12--&gt;</div><div class=\"line\">上午或下午的第几个小时： &#123;&#123;today|date:&apos;h&apos;&#125;&#125; &lt;!--12--&gt;</div><div class=\"line\"> 分钟格式化</div><div class=\"line\">数字分钟数： &#123;&#123; today | date:&apos;mm&apos; &#125;&#125; &lt;!-- 09 --&gt;</div><div class=\"line\">一个小时中的第几分钟： &#123;&#123; today | date:&apos;m&apos; &#125;&#125; &lt;!-- 9 --&gt;</div><div class=\"line\"> 秒数格式化</div><div class=\"line\">数字秒数： &#123;&#123; today | date:&apos;ss&apos; &#125;&#125; &lt;!-- 02 --&gt;</div><div class=\"line\">一分钟内的第几秒： &#123;&#123; today | date:&apos;s&apos; &#125;&#125; &lt;!-- 2 --&gt;</div><div class=\"line\">毫秒数： &#123;&#123; today | date:&apos;.sss&apos; &#125;&#125; &lt;!-- .995 --&gt;</div><div class=\"line\"> 字符格式化</div><div class=\"line\">上下午标识： &#123;&#123; today | date:&apos;a&apos; &#125;&#125; &lt;!-- AM --&gt;</div><div class=\"line\">四位时区标识： &#123;&#123; today | date:&apos;Z&apos; &#125;&#125; &lt;!--- 0700 --&gt;</div><div class=\"line\">下面是一些自定义日期格式的示例：</div><div class=\"line\">&#123;&#123; today | date:&apos;MMMd, y&apos; &#125;&#125; &lt;!-- Aug9, 2013 --&gt;</div><div class=\"line\">&#123;&#123; today | date:&apos;EEEE, d, M&apos; &#125;&#125; &lt;!-- Thursday, 9, 8--&gt;</div><div class=\"line\">&#123;&#123; today | date:&apos;hh:mm:ss.sss&apos; &#125;&#125; &lt;!-- 12:09:02.995 --&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>filter<br>filter过滤器可以从给定数组中选择一个子集，并将其生成一个新数组返回。这个过滤器通常用来过滤需要进行展示的元素。例如，在做客户端搜索时，可以从一个数组中立刻过滤出所需的结果。这个过滤器的第一个参数可以是字符串、对象或是一个用来从数组中选择元素的函数。<br> 下面分情况介绍传入不同类型的参数。</p>\n<ol>\n<li> 字符串<br>返回所有包含这个字符串的元素。如果我们想返回不包含该字符串的元素，在参数前加!符号。</li>\n<li> 对象<br>AngularJS会将待过滤对象的属性同这个对象中的同名属性进行比较，如果属性值是字符串就会判断是否包含该字符串。如果我们希望对全部属性都进行对比，可以将$当作键名。</li>\n<li><p> 函数<br>对每个元素都执行这个函数，返回非假值的元素会出现在新的数组中并返回。<br>例如，用下面的过滤器可以选择所有包含字母e的单词：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; [&apos;Ari&apos;,&apos;Lerner&apos;,&apos;Likes&apos;,&apos;To&apos;,&apos;Eat&apos;,&apos;Pizza&apos;] | filter:&apos;e&apos; &#125;&#125;</div><div class=\"line\">&lt;!-- [&quot;Lerner&quot;,&quot;Likes&quot;,&quot;Eat&quot;] --&gt;</div></pre></td></tr></table></figure>\n<p>如果要过滤对象，可以使用上面提到的对象过滤器。例如，如果有一个由people对象组成的<br>数组，每个对象都含有他们最喜欢吃的食物的列表，那么可以用下面的形式进行过滤：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; [&#123;</div><div class=\"line\">&apos;name&apos;: &apos;Ari&apos;,</div><div class=\"line\">&apos;City&apos;: &apos;San Francisco&apos;,</div><div class=\"line\">&apos;favorite food&apos;: &apos;Pizza&apos;</div><div class=\"line\">&#125;,&#123;</div><div class=\"line\">&apos;name&apos;: &apos;Nate&apos;,</div><div class=\"line\">&apos;City&apos;: &apos;San Francisco&apos;,</div><div class=\"line\">&apos;favorite food&apos;: &apos;indian food&apos;</div><div class=\"line\">&#125;] | filter:&#123;&apos;favorite food&apos;: &apos;Pizza&apos;&#125; &#125;&#125;</div><div class=\"line\">&lt;!-- [&#123;&quot;name&quot;:&quot;Ari&quot;,&quot;City&quot;:&quot;SanFrancisco&quot;,&quot;favoritefood&quot;:&quot;Pizza&quot;&#125;] --&gt;</div></pre></td></tr></table></figure>\n<p>也可以用自定义函数进行过滤（在这个例子中函数定义在$scope上）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; [&apos;Ari&apos;,&apos;likes&apos;,&apos;to&apos;,&apos;travel&apos;] | filter:isCapitalized &#125;&#125;</div><div class=\"line\">&lt;!-- [&quot;Ari&quot;] --&gt;</div><div class=\"line\">isCapitalized函数的功能是根据首字母是否为大写返回true或false，具体如下所示：</div><div class=\"line\">$scope.isCapitalized = function(str) &#123;</div><div class=\"line\">return str[0] == str[0].toUpperCase();</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>我们也可以给filter过滤器传入第二个参数，用来指定预期值同实际值进行比较的方式。<br>第二个参数可以是以下三种情况之一。<br> true<br>用angular.equals(expected, actual)对两个值进行严格比较。<br> false<br>进行区分大小写的子字符串比较。<br> 函数<br>运行这个函数，如果返回真值就接受这个元素。</p>\n<h4 id=\"json\"><a href=\"#json\" class=\"headerlink\" title=\"json\"></a>json</h4><p>json过滤器可以将一个JSON或JavaScript对象转换成字符串。这种转换对调试非常有帮助：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; &#123;&apos;name&apos;: &apos;Ari&apos;, &apos;City&apos;: &apos;SanFrancisco&apos;&#125; | json &#125;&#125;</div><div class=\"line\">&lt;!--</div><div class=\"line\">&#123;</div><div class=\"line\">&quot;name&quot;: &quot;Ari&quot;,</div><div class=\"line\">&quot;City&quot;: &quot;San Francisco&quot;</div><div class=\"line\">&#125;</div><div class=\"line\">--&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>limitTo<br>limitTo过滤器会根据传入的参数生成一个新的数组或字符串，新的数组或字符串的长度取决于传入的参数，通过传入参数的正负值来控制从前面还是从后面开始截取。如果传入的长度值大于被操作数组或字符串的长度，那么整个数组或字符串都会被返回。<br>例如，我们可以截取字符串的前三个字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; San Francisco is very cloudy | limitTo:3 &#125;&#125;</div><div class=\"line\">&lt;!-- San --&gt;</div><div class=\"line\">或最后的六个字符：</div><div class=\"line\">&#123;&#123; San Francisco is very cloudy | limitTo:-6 &#125;&#125;</div><div class=\"line\">&lt;!-- cloudy --&gt;</div><div class=\"line\">对数组也可以进行同样的操作。返回数组的第一个元素：</div><div class=\"line\">&#123;&#123; [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;] | limitTo:1 &#125;&#125;</div><div class=\"line\">&lt;!-- [&quot;a&quot;] --&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>lowercase<br>lowercase过滤器将字符串转为小写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; &quot;San Francisco is very cloudy&quot; | lowercase &#125;&#125;</div><div class=\"line\">&lt;!-- san francisco is very cloudy --&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>number<br>number过滤器将数字格式化成文本。它的第二个参数是可选的，用来控制小数点后截取的位数。如果传入了一个非数字字符，会返会空字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; 123456789 | number &#125;&#125;</div><div class=\"line\">&lt;!-- 1,234,567,890 --&gt;</div><div class=\"line\">&#123;&#123; 1.234567 | number:2 &#125;&#125;</div><div class=\"line\">&lt;!-- 1.23 --&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>orderBy<br>orderBy过滤器可以用表达式对指定的数组进行排序。orderBy可以接受两个参数，第一个是必需的，第二个是可选的。<br>第一个参数是用来确定数组排序方向的谓词。<br> 下面分情况讨论第一个参数的类型。<br>  函数<br> 当第一个参数是函数时，该函数会被当作待排序对象的getter方法。<br>  字符串<br> 对这个字符串进行解析的结果将决定数组元素的排序方向。我们可以传入+或-来强制进行升序或降序排列。<br>  数组<br> 在排序表达式中使用数组元素作为谓词。对于与表达式结果并不严格相等的每个元素，则使用第一个谓词。<br> 第二个参数用来控制排序的方向（是否逆向）。<br> 例如，我们将下面的对象数组用name字段进行排序：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; [&#123;</div><div class=\"line\">&apos;name&apos;: &apos;Ari&apos;,</div><div class=\"line\">&apos;status&apos;: &apos;awake&apos;</div><div class=\"line\">&#125;,&#123;</div><div class=\"line\">&apos;name&apos;: &apos;Q&apos;,</div><div class=\"line\">&apos;status&apos;: &apos;sleeping&apos;</div><div class=\"line\">&#125;,&#123;</div><div class=\"line\">&apos;name&apos;: &apos;Nate&apos;,</div><div class=\"line\">&apos;status&apos;: &apos;awake&apos;</div><div class=\"line\">&#125;] | orderBy:&apos;name&apos; &#125;&#125;</div><div class=\"line\">&lt;!--</div><div class=\"line\">[</div><div class=\"line\">&#123;&quot;name&quot;:&quot;Ari&quot;,&quot;status&quot;:&quot;awake&quot;&#125;,</div><div class=\"line\">&#123;&quot;name&quot;:&quot;Nate&quot;,&quot;status&quot;:&quot;awake&quot;&#125;,</div><div class=\"line\">&#123;&quot;name&quot;:&quot;Q&quot;,&quot;status&quot;:&quot;sleeping&quot;&#125;</div><div class=\"line\">]</div><div class=\"line\">--&gt;</div><div class=\"line\">也可以对排序结果进行反转。例如，通过将第二个参数设置为true可以将排序结果进行反转：</div><div class=\"line\">&#123;&#123; [&#123;</div><div class=\"line\">&apos;name&apos;: &apos;Ari&apos;,</div><div class=\"line\">&apos;status&apos;: &apos;awake&apos;</div><div class=\"line\">&#125;,&#123;</div><div class=\"line\">&apos;name&apos;: &apos;Q&apos;,</div><div class=\"line\">&apos;status&apos;: &apos;sleeping&apos;</div><div class=\"line\">&#125;,&#123;</div><div class=\"line\">&apos;name&apos;: &apos;Nate&apos;,</div><div class=\"line\">&apos;status&apos;: &apos;awake&apos;</div><div class=\"line\">&#125;] | orderBy:&apos;name&apos;:true &#125;&#125;</div><div class=\"line\">&lt;!--</div><div class=\"line\">[</div><div class=\"line\">&#123;&quot;name&quot;:&quot;Q&quot;,&quot;status&quot;:&quot;sleeping&quot;&#125;,</div><div class=\"line\">&#123;&quot;name&quot;:&quot;Nate&quot;,&quot;status&quot;:&quot;awake&quot;&#125;,</div><div class=\"line\">&#123;&quot;name&quot;:&quot;Ari&quot;,&quot;status&quot;:&quot;awake&quot;&#125;</div><div class=\"line\">]</div><div class=\"line\">--&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>uppercase<br>uppercase过滤器可以将字符串转换为大写形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; &quot;San Francisco is very cloudy&quot; | uppercase &#125;&#125;</div><div class=\"line\">&lt;!-- SAN FRANCISCO IS VERY CLOUDY --&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"自定义过滤器\"><a href=\"#自定义过滤器\" class=\"headerlink\" title=\"自定义过滤器\"></a>自定义过滤器</h4><p>创建自定义过滤器非常容易。创建自定义过滤器需要将它放到自己的模块中。<br>例：实现一个过滤器，将字符串第一个字母转换为大写<br>首先，创建一个模块用以在应用中进行引用（这是一个非常好的实践）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp.filters&apos;, [])</div><div class=\"line\">.filter(&apos;capitalize&apos;, function() &#123;</div><div class=\"line\">return function(input) &#123;&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>过滤器本质上是一个会把我们输入的内容当作参数传入进去的函数。上面这个例子中，我们在调用过滤器时简单地把input当作字符串来处理。可以在这个函数中做一些错误检查：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp.filters&apos;, [])</div><div class=\"line\">.filter(&apos;capitalize&apos;, function() &#123;</div><div class=\"line\">return function(input) &#123;</div><div class=\"line\">// input是我们传入的字符串</div><div class=\"line\">if (input) &#123;</div><div class=\"line\">return input[0].toUpperCase() + input.slice(1);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>现在，如果想将一个句子的首字母转换成大写形式，可以用过滤器先将整个句子都转换成小写，再把首字母转换成大写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- Ginger loves dog treats --&gt;</div><div class=\"line\">&#123;&#123; &apos;ginger loves dog treats&apos; | lowercase | capitalize &#125;&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"表单验证\"><a href=\"#表单验证\" class=\"headerlink\" title=\"表单验证\"></a>表单验证</h4><p>AngularJS能够将HTML5表单验证功能同它自己的验证指令结合起来使用，并且非常方便。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;form&quot; novalidate&gt;</div><div class=\"line\">&lt;label name=&quot;email&quot;&gt;Your email&lt;/label&gt;</div><div class=\"line\">&lt;input type=&quot;email&quot;</div><div class=\"line\">name=&quot;email&quot;</div><div class=\"line\">ng-model=&quot;email&quot; placeholder=&quot;Email Address&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<p>注：要使用表单验证，首先要确保表单像上面的例子一样有一个name属性。<br>所有输入字段都可以进行基本的验证，比如最大、最小长度等。这些功能是由新的HTML5表单属性提供的。如果想要屏蔽浏览器对表单的默认验证行为，可以在表单元素上添加novalidate标记。</p>\n<ul>\n<li>input元素所有验证选项如下：</li>\n</ul>\n<ol>\n<li><p>必填项<br>验证某个表单输入是否已填写，只要在输入字段元素上添加HTML5标记required即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input type=&quot;text&quot; required /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>最小长度<br>验证表单输入的文本长度是否大于某个最小值，在输入字段上使用AngularJS指令ng-minleng=”{number}”：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input type=&quot;text&quot; ng-minlength=&quot;5&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>最大长度<br>验证表单输入的文本长度是否小于或等于某个最大值，在输入字段上使用AngularJS指令ng-maxlength=”{number}”：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input type=&quot;text&quot; ng-maxlength=&quot;20&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>模式匹配<br>使用ng-pattern=”/PATTERN/“来确保输入能够匹配指定的正则表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input type=&quot;text&quot; ng-pattern=&quot;[a-zA-Z]&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>电子邮件<br>验证输入内容是否是电子邮件，只要像下面这样将input的类型设置为email即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input type=&quot;email&quot; name=&quot;email&quot; ng-model=&quot;user.email&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>数字<br>验证输入内容是否是数字，将input的类型设置为number：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input type=&quot;number&quot; name=&quot;age&quot; ng-model=&quot;user.age&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>URL<br>验证输入内容是否是URL，将input的类型设置为 url：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input type=&quot;url&quot; name=&quot;homepage&quot; ng-model=&quot;user.facebook_url&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在表单中控制变量<br>表单的属性可以在其所属的$scope对象中访问到，而我们又可以访问$scope对象，因此JavaScript可以间接地访问DOM中的表单属性。借助这些属性，我们可以对表单做出实时（和AngularJS中其他东西一样）响应。<br>注：可以使用下面的格式访问这些属性。<br>formName.inputFieldName.property<br> 未修改的表单<br>这是一个布尔属性，用来判断用户是否修改了表单。如果未修改，值为true，如果修改过值<br>为false：<br>formName.inputFieldName.$pristine<br> 修改过的表单<br>只要用户修改过表单，无论输入是否通过验证，该值都返回true：<br>formName.inputFieldName.$dirty<br> 合法的表单<br>这个布尔型的属性用来判断表单的内容是否合法。如果当前表单内容是合法的，下面属性的<br>值就是true：<br>formName.inputFieldName.$valid<br> 不合法的表单<br>这个布尔属性用来判断表单的内容是否不合法。如果当前表单内容是不合法的，下面属性的<br>值为true：<br>formName.inputFieldName.$invalid<br> 错误<br>这是AngularJS提供的另外一个非常有用的属性： $error对象。它包含当前表单的所有验证<br>内容，以及它们是否合法的信息。用下面的语法访问这个属性：<br>formName.inputfieldName.$error<br>如果验证失败，这个属性的值为true；如果值为false，说明输入字段的值通过了验证。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">例：判断错误提示框是否显示：</div><div class=\"line\">ng-show=&quot;signup_form.name.$dirty &amp;&amp; signup_form.name.$invalid&quot;</div><div class=\"line\">signup_form为表单的name属性值，name为input输入框的name属性值。</div></pre></td></tr></table></figure>\n</li>\n<li><p>一些有用的CSS样式<br>AngularJS处理表单时，会根据表单当前的状态添加一些CSS类（例如当前是合法的、未发生变化的，等等），这些CSS类的命名和前面介绍的属性很相似。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">.ng-pristine &#123;&#125;</div><div class=\"line\">.ng-dirty &#123;&#125;</div><div class=\"line\">.ng-valid &#123;&#125;</div><div class=\"line\">.ng-invalid &#123;&#125;</div></pre></td></tr></table></figure>\n<p>它们对应着表单输入字段的特定状态。<br>当某个字段中的输入非法时， .ng-invlid类会被添加到这个字段上。当前例子中的站点将对应的CSS样式设置为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">input.ng-invalid &#123;</div><div class=\"line\">border: 1px solid red;</div><div class=\"line\">&#125;</div><div class=\"line\">input.ng-valid &#123;</div><div class=\"line\">border: 1px solid green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>$parsers<br>使用$parsers数组是实现自定义验证的途径之一。<ul>\n<li>$formatters<br>注：表单本身会提供$invalid和$valid属性。例：formName.$invalid;当用户试图提交表单时，你可以在作用域中捕获到一个submitted值，然后对表单内容进行验证并显示错误信息。一般当formName.submitted设置为true时，容纳错误信息的div才会展示出来。<h4 id=\"从1-3开始，-Angular中新增了一个ngMessages指令。\"><a href=\"#从1-3开始，-Angular中新增了一个ngMessages指令。\" class=\"headerlink\" title=\"从1.3开始， Angular中新增了一个ngMessages指令。\"></a>从1.3开始， Angular中新增了一个ngMessages指令。</h4></li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>安装ngMessages很简单，因为它被打包成了一个Angular模块。首先下载这个模块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ bower install --save angular-messages</div></pre></td></tr></table></figure>\n</li>\n<li><p>还需要将angular-messages.js这个JavaScript引入我们的主HTML中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;bower_components/angular-messages/angular-messages.js&quot;&gt;</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>最后，我们还要告诉Angular将ngMessages作为应用程序的依赖模块引入，就像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp&apos;, [&apos;ngMessages&apos;]);</div></pre></td></tr></table></figure>\n<p>例：在没有使用ngMessages之前，我们可能这样写验证：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;userForm&quot;&gt;</div><div class=\"line\">&lt;input </div><div class=\"line\">type=&quot;text&quot;</div><div class=\"line\">name=&quot;username&quot;</div><div class=\"line\">ng-model=&quot;user.username&quot;</div><div class=\"line\">ng-minlength=&quot;3&quot;</div><div class=\"line\">ng-maxlength=&quot;8&quot;</div><div class=\"line\">required&gt;</div><div class=\"line\">&lt;p ng-show=&quot;userForm.username.$error.minlength&quot;&gt;Username is too short.&lt;/p&gt;</div><div class=\"line\">&lt;p ng-show=&quot;userForm.username.$error.maxlength&quot;&gt;Username is too long.&lt;/p&gt;</div><div class=\"line\">&lt;p ng-show=&quot;userForm.username.$error.required&quot;&gt;Your username is required.&lt;/p&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure>\n<p>有了”ngMessages”这个module,大致这么写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;help-block&quot; ng-messages=&quot;userForm.name.$error&quot; ng-if=&quot;userForm.name.$touched&quot;&gt;</div><div class=\"line\">&lt;p ng-message=&quot;minlength&quot;&gt;用户名最小长度5&lt;/p&gt;</div><div class=\"line\">&lt;p ng-message=&quot;maxlength&quot;&gt;用户名最大长度10&lt;/p&gt;</div><div class=\"line\">&lt;p ng-message=&quot;required&quot;&gt;用户名必填&lt;/p&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>ngMessages为我们自动判断显示哪种错误。</p>\n</li>\n</ol>\n<h4 id=\"使用ngMessages的几个关键点：\"><a href=\"#使用ngMessages的几个关键点：\" class=\"headerlink\" title=\"使用ngMessages的几个关键点：\"></a>使用ngMessages的几个关键点：</h4><ol>\n<li>● npm install angular-messages</li>\n<li>● 引用：angular-messages.js</li>\n<li>● 依赖：angular.module(‘app’,[‘ngMessages’])</li>\n</ol>\n"},{"title":"Angular权威指南学习（第8到9章）指令","date":"2016-05-13T13:09:01.000Z","_content":"#### 指令\n指令本质上就是AngularJS扩展具有自定义功能的HTML元素的途径。例如，我们可以创建一个自定义元素，它实现了`<video>`标签的功能并且能在所有浏览器中工作：\n\n```\n<my-better-video my-href=\"/goofy-video.mp4\">\nCaneventaketext</my-better-video>\n\n```\n内置指令是打包在AngularJS内部的指令。所有内置指令的命名空间都使用ng作为前缀。为了防止命名空间冲突，不要在自定义指令前加ng前缀。\n   - 第一个自定义指令\n   通过AngularJS模块API中的.directive()方法，我们可以通过传入一个字符串和一个函数来注册一个新指令。其中字符串是这个指令的名字，指令名应该是驼峰命名风格的，函数应该返回一个对象\n   ```\n   <my-directive></my-directive>\n   angular.module('myApp',[])\n   .directive('myDirective', function() {\n   return {\n   restrict: 'E',\n   replace: true,//生成的代码中不含<my-directive></my-directive>\n   template: '<a href=\"http://webywx.com\">\n   Click me to go to webywx</a>'\n   };\n   });\n   ```\n   注：在我们的例子中，在HTML里使用my-directive声明指令，因此指令定义必须以myDirective为名字（驼峰命名法）。\n   \n####声明指令本质上是在HTML中通过元素、属性、类或注释来添加功能。\n   为了让AngularJS能够调用我们的指令，需要修改指令定义中的restrict设置。这个设置告诉AngularJS在编译HTML时用哪种声明格式来匹配指令定义。我们可以指定一个或多个格式。创建的指令中可以指定以元素（E）、属性（A）、类（C）或注释（M）的格式来调用指令，例：restrict: 'EAC'。\n   无论有多少种方式可以声明指令，我们坚持使用属性方式，因为它有比较好的跨浏览器兼容性：\n   ```\n   <div my-directive></div>\n   ```\n   声明指令时既可以使用表达式，也可以不使用表达式。下面是几种合法的表达式声明：\n   ```\n   <my-directive=\"someExpression\">\n   </my-directive>\n   <div my-directive=\"someExpression\">\n   </div>\n   <div class=\"my-directive:someExpression\">\n   </div>\n   <!-- directive: my-directive someExpression -->\n   ```\n   为了更加明确我们的意图，将restrict设置为字母A（代表attribute）：\n   restrict: 'A\n   遵循这个约定的同时，也要注意每个浏览器的内置样式，以便决定指令模板在HTML中是嵌套在声明元素内，还是替换声明元素。\n   值得注意的一个例外是，扩展内置HTML标签，例如用AngularJS重载`<a>`、`<form>`和`<input>`。这些场景不会导致浏览器的兼容性问题，因为它们本身就是浏览器所支持的标签。好的经验法则就是始终用属性来声明指令，这样会给以后带来方便。\n   注意，所有以ng前缀开头作为命名空间的指令都是AngularJS提供的内置指令，因此不要把你自己开发的指令以这个前缀命名。\n   1. ng-disabled\n   使用ng-disabled可以把disabled属性绑定到以下表单输入字段上：\n   ```\n    <input> （text、 checkbox、 radio、 number、 url, email、 submit）；\n    <textarea>；\n    <select>；\n    <button>。\n   ```\n   当写普通的HTML输入字段时，如果在元素标签上出现了disabled属性就会禁用这个输入字段。通过ng-disabled可以对是否出现属性进行绑定。例如，在下面的例子中按钮会一直禁用， 直到用户在文本字段中输入内容：\n   ```\n   <input type=\"text\" ng-model=\"someProperty\" placeholder=\"TypetoEnable\">\n   <button ng-model=\"button\" ng-disabled=\"!someProperty\">AButton</button>\n   ```\n   2. ng-readonly\n   同其他布尔属性一样， HTML定义只会检查readonly属性是否出现，而不是它的实际值。\n   通过ng-readonly可以将某个返回真或假的表达式同是否出现readonly属性进行绑定：\n   ```\n   Type here to make sibling readonly:\n   <input type=\"text\" ng-model=\"someProperty\"><br/>\n   <input type=\"text\"\n   ng-readonly=\"someProperty\"\n   value=\"Some text here\"/>\n   ```\n   3. ng-checked\n   ```\n   默认情况下会把复选框勾选：\n   <label>someProperty = {{someProperty}}</label>\n   <input type=\"checkbox\"\n   ng-checked=\"someProperty\"\n   ng-init=\"someProperty = true\"\n   ng-model=\"someProperty\">\n   ```\n   4. ng-selected\n   ng-selected可以对是否出现option标签的selected属性进行绑定：\n   ```\n   <label>Select Two Fish:</label>\n   <input type=\"checkbox\"\n   ng-model=\"isTwoFish\"><br/>\n   <select>\n   <option>One Fish</option>\n   <option ng-selected=\"isTwoFish\">Two Fish</option>\n   </select>\n   ```\n   5. ng-href\n   当使用当前作用域中的属性动态创建URL时，应该用ng-href代替href（用href会404）\n   6. ng-src\n   AngularJS会告诉浏览器在ng-src对应的表达式生效之前不要加载图像(用src会找不到图片)\n   7. ng-app\n   任何具有ng-app属性的DOM元素将被标记为$rootScope的起始点。\n   $rootScope是作用域链的起始点，任何嵌套在ng-app内的指令都会继承它。\n   在JavaScript代码中通过run方法来访问$rootScope。\n   ```\n   <html ng-app=\"myApp\">\n   <body>\n   {{ someProperty }}\n   <button ng-click=\"someAction()\"></button>\n   </body>\n   </html>\n   angular.module('myApp', [])\n   .run(function($rootScope) {\n   $rootScope.someProperty = 'hello computer';\n   $rootScope.someAction = function() {\n   $rootScope.someProperty = 'hello human';\n   };\n   });\n   ```\n   这里为了演示方便，像使用全局作用域一样使用$rootScope，实际生产中不建议这样做。\n   8. ng-controller\n   内置指令ng-controller的作用是为嵌套在其中的指令创建一个子作用域，避免将所有操作和模型都定义在$rootScope上。用这个指令可以在一个DOM元素上放置控制器。\n   9. ng-include\n   使用ng-include可以加载、编译并包含外部HTML片段到当前的应用中。模板的URL被限制\n   在与应用文档相同的域和协议下，可以通过白名单或包装成被信任的值来突破限制。更进一步，\n   需要考虑跨域资源共享（Cross-Origin Resource Sharing， CORS）和同源规则（Same Origin Policy）\n   来确保模板可以在任何浏览器中正常加载。例如，所有浏览器都不能进行跨域的请求，部分浏览\n   器也不能访问file://协议的资源。\n   10. ng-switch\n   这个指令和ng-switch-when及on=\"propertyName\"一起使用，可以在propertyName发生变\n   化时渲染不同指令到视图中。在下面的例子中，当person.name是Ari时，文本域下面的div会显\n   示出来，并且这个人会获得胜利：\n   ```\n   <input type=\"text\" ng-model=\"person.name\"/>\n   <div ng-switch on=\"person.name\">\n   <p ng-switch-default>And the winner is</p>\n   <h1 ng-switch-when=\"Ari\">{{ person.name }}</h1>\n   </div>\n   ```\n   注意，在switch被调用之前我们用ng-switch-default来输出默认值。\n   11. ng-view\n   ng-view指令用来设置将被路由管理和放置在HTML中的视图的位置。\n   12. ng-if\n   使用ng-if指令可以完全根据表达式的值在DOM中生成或移除一个元素。如果赋值给ng-if的表达式的值是false，那对应的元素将会从DOM中移除，否则对应元素的一个克隆将被重新插入DOM中。\n   ng-if同no-show和ng-hide指令最本质的区别是，它不是通过CSS显示或隐藏DOM节点，而是真正生成或移除节点.\n   13. ng-repeat\n   ng-repeat用来遍历一个集合或为集合中的每个元素生成一个模板实例。集合中的每个元素都会被赋予自己的模板和作用域。同时每个模板实例的作用域中都会暴露一些特殊的属性。\n   ```\n    $index：遍历的进度（0...length-1）。\n    $first：当元素是遍历的第一个时值为true。\n    $middle：当元素处于第一个和最后元素之间时值为true。\n    $last：当元素是遍历的最后一个时值为true。\n    $even：当$index值是偶数时值为true。\n    $odd：当$index值是奇数时值为true。\n   ```\n  10. ng-bind\n  尽管可以在视图中使用\\{ \\{ \\} \\}模板语法（AngularJS内置的方式），我们也可以通过ng-bind指令实现同样的行为。\n  HTML加载含有\\{ \\{ \\} \\}语法的元素后并不会立刻渲染它们，导致未渲染内容闪烁（Flash of Unrendered Content， FOUC）。我可以用ng-bind将内容同元素绑定在一起避免FOUC。内容会被当作子文本节点渲染到含有ng-bind指令的元素内。\n  11. ng-cloak\n      除使用ng-bind来避免未渲染元素闪烁，还可以在含有\\{ \\{ \\} \\}的元素上使用ng-cloak指令：\n      ```\n      <body ng-init=\"greeting='HelloWorld'\">\n      <p ng-cloak>{{ greeting }}</p>\n      </body>\n      ```\n      ng-cloak指令会将内部元素隐藏，直到路由调用对应的页面时才显示出来。\n  12. ng-bind-template\n  同ng-bind指令类似， ng-bind-template用来在视图中绑定多个表达式。\n  ```\n  <div\n  ng-bind-template=\"{{message}}{{name}}\">\n  </div>\n  ```\n  13. ng-model\n  ng-model指令用来将input、 select、 text area或自定义表单控件同包含它们的作用域中的属性进行绑定。它可以提供并处理表单验证功能，在元素上设置相关的CSS类（ng-valid、ng-invalid等），并负责在父表单中注册控件。\n  它将当前作用域中运算表达式的值同给定的元素进行绑定。如果属性并不存在，它会隐式创建并将其添加到当前作用域中。我们应该始终用ngModel来绑定$scope上一个数据模型内的属性，而不是$scope上的属性，这可以避免在作用域或后代作用域中发生属性覆盖。\n  ```\n  例如：\n  <input type=\"text\"\n  ng-model=\"modelName.someProperty\" />\n  ```\n  14. ng-show/ng-hide\n  ng-show和ng-hide根据所给表达式的值来显示或隐藏HTML元素。\n  15. ng-change\n  这个指令会在表单输入发生变化时计算给定表达式的值。因为要处理表单输入，这个指令要和ngModel联合起来使用。\n  ```\n  <div ng-controller=\"EquationController\">\n  <input type=\"text\"\n  ng-model=\"equation.x\"\n  ng-change=\"change()\" />\n  <code>{{ equation.output }}</code>\n  </div>\n  angular.module('myApp',[])\n  .controller('EquationController',function($scope) {\n  $scope.equation = {};\n  $scope.change = function() {\n  $scope.equation.output\n  = parseInt($scope.equation.x) + 2;\n  };\n  });\n  ```\n  上面的例子中，只要文本输入字段中的内容发生了变化就会改变equation.x的值，进而运行change()函数。\n  16. ng-form\n  ng-form用来在一个表单内部嵌套另一个表单。普通的HTML <form>标签不允许嵌套，但ng-form可以。\n  这意味着内部所有的子表单都合法时，外部的表单才会合法。这对于用ng-repeat动态创建表单是非常有用的。\n  由于不能通过字符插值来给输入元素动态地生成name属性，所以需要将ng-form指令内每组重复的输入字段都包含在一个外部表单元素内。\n  下面的CSS类会根据表单的验证状态自动设置：\n   1.  表单合法时设置ng-valid；\n   2.  表单不合法时设置ng-invlid；\n   3.  表单未进行修改时设置ng-pristion；\n   4.  表单进行过修改时设置ng-dirty。\n  Angular不会将表单提交到服务器，除非它指定了action属性。要指定提交表单时调用哪个JavaScript方法，使用下面两个指令中的一个。\n   1.  ng-submit：在表单元素上使用。\n   2.  ng-click：在第一个按钮或submit类型（input[type=submit]）的输入字段上使用。\n  为了避免处理程序被多次调用，只使用下面两个指令中的一个。\n  下面的例子展示了如何通过服务器返回的JSON数据动态生成一个表单。我们用ng-loop来遍历从服务器取回的所有数据。由于不能动态生成name属性，而我们又需要这个属性做验证，所以在循环的过程中会为每一个字段都生成一个新表单。由于AngularJS中用来取代<form>的ng-form指令可以嵌套，并且外部表单在所有子表单都合法之前一直处于不合法状态，因此我们可以在动态生成子表单的同时使用表单验证功能。是的，鱼和熊掌可以兼得。\n  下面先看一下我们硬编码的JSON数据，把它假设成是从服务器返回的：\n  ```\n  angular.module('myApp',[])\n  .controller('FormController',function($scope) {\n  $scope.fields = [\n  {placeholder: 'Username', isRequired: true},\n  {placeholder: 'Password', isRequired: true},\n  {placeholder: 'Email (optional)', isRequired: false}\n  ];\n  $scope.submitForm = function() {\n  alert(\"it works!\");\n  };\n  });\n  下面用这些数据生成一个有验证功能的动态表单：\n  <form name=\"signup_form\"\n  ng-controller=\"FormController\"\n  ng-submit=\"submitForm()\" novalidate>\n  <div ng-repeat=\"field in fields\"\n  ng-form=\"signup_form_input\">\n  <input type=\"text\"\n  name=\"dynamic_input\"\n  ng-required=\"field.isRequired\"\n  ng-model=\"field.name\"\n  placeholder=\"{{field.placeholder}}\" />\n  <div\n  ng-show=\"signup_form_input.dynamic_input.$dirty &&\n  signup_form_input.dynamic_input.$invalid\">\n  <span class=\"error\"\n  ng-show=\"signup_form_input.dynamic_input.$error.required\">\n  The field is required.\n  </span>\n  </div>\n  </div>\n  <button type=\"submit\"\n  ng-disabled=\"signup_form.$invalid\">\n  Submit All\n  </button>\n  </form>\n  input.ng-invalid {\n  border: 1px solid red;\n  }\n  input.ng-valid {\n  border: 1px solid green;\n  }\n  ```\n  17. ng-click\n  ng-click用来指定一个元素被点击时调用的方法或表达式。\n  18. ng-select\n  ng-select用来将数据同HTML的`<select>`元素进行绑定。这个指令可以和ng-model以及ng-options指令一同使用，构建精细且表现优良的动态表单。\n  ng-options的值可以是一个内涵表达式（comprehension expression），其实这只是一种有趣的说法，简单来说就是它可以接受一个数组或对象，并对它们进行循环，将内部的内容提供给select标签内部的选项。它可以是下面两种形式。\n   1.  数组作为数据源：\n   -  用数组中的值做标签；\n   -  用数组中的值作为选中的标签；\n   -  用数组中的值做标签组；\n   -  用数组中的值作为选中的标签组。\n   2.  对象作为数据源：\n   -  用对象的键-值（key-value）做标签；\n   -  用对象的键-值作为选中的标签；\n   -  用对象的键-值作为标签组；\n   -  用对象的键-值作为选中的标签组。\n  下面看一个ng-select指令的实例：\n  ```\n  <div ng-controller=\"CityController\">\n  <select ng-model=\"city\"\n  ng-options=\"city.name for city in cities\">\n  <option value=\"\">Choose City</option>\n  </select>\n  Best City: {{ city.name }}\n  </div>\n  angular.module('myApp',[])\n  .controller('CityController',function($scope) {\n  $scope.cities = [\n  {name: 'Seattle'},\n  {name: 'San Francisco'},\n  {name: 'Chicago'},\n  {name: 'New York'},\n  {name: 'Boston'}\n  ];\n  });\n  ```\n\n  19. ng-submit\n  ng-submit用来将表达式同onsubmit事件进行绑定。这个指令同时会阻止默认行为（发送请求并重新加载页面）， 除非表单不含有action属性。\n  ```\n  <form ng-submit=\"submit()\"\n  ng-controller=\"FormController\">\n  Enter text and hit enter:\n  <input type=\"text\"\n  ng-model=\"person.name\"\n  name=\"person.name\" />\n  <input type=\"submit\"\n  name=\"person.name\"\n  value=\"Submit\" />\n  <code>people={{people}}</code>\n  <ul ng-repeat=\"(index, object) in people\">\n  <li>{{ object.name }}</li>\n  </ul>\n  </form>\n  angular.module('myApp',[])\n  .controller('FormController',function($scope) {\n  $scope.person = {\n  name: null\n  };\n  $scope.people = [];\n  $scope.submit = function() {\n  if ($scope.person.name) {\n  $scope.people.push({name: $scope.person.name});\n  $scope.person.name = '';\n  }\n  };\n  });\n  ```\n  20. ng-class\n  使用ng-class 动态设置元素的类，方法是绑定一个代表所有需要添加的类的表达式。重复的类不会添加。当表达式发生变化，先前添加的类会被移除，新类会被添加。\n  下面的例子会用ng-class在一个随机数大于5时将.red类添加到一个div上：\n  ```\n  <div ng-controller=\"LotteryController\">\n  <div ng-class=\"{red: x > 5}\"//ng-class=\"{red: x > 5,green:x<5} 加多个类时用逗号隔开即可。\n  ng-if=\"x > 5\">\n  You won!\n  </div>\n  <button ng-click=\"generateNumber()\"\n  ng-init=\"x = 0\">\n  Draw Number\n  </button>\n  <p>Number is: {{ x }}</p>\n  </div>\n  \n  .red {\n  background-color: red;\n  }\n  angular.module('myApp',[])\n  .controller('LotteryController', function($scope) {\n  $scope.generateNumber = function() {\n  return Math.floor((Math.random()*10)+1);\n  };\n  })\n  ```\n  21. ng-attr-(suffix)\n  当AngularJS编译DOM时会查找花括号\\{ \\{ some expression \\} \\}内的表达式。这些表达式会被自动注册到$watch服务中并更新到$digest循环中，成为它的一部分：\n  ```\n  <-- updated when`someExpression` on the$scope\n  is updated -->\n  <h1>Hello{{someExpression}}</h1>\n  有时浏览器会对属性会进行很苛刻的限制。 SVG就是一个例子：\n  <svg>\n  <circle cx=\"{{ cx }}\"></circle>\n  </svg>\n  运行上面的代码会抛出一个错误，指出我们有一个非法属性。可以用ng-attr-cx来解决这\n  个问题。注意， cx位于这个名称的尾部。在这个属性中，通过用{{ }}来写表达式，达到前面提\n  到的目的。\n  <svg>\n  <circle ng-attr-cx=\"{{ cx }}\"><circle>\n  </svg>\n  {{person.name || \"无\"}} //绑定时做简单判断可以这么写。\n  ```\n  \n  \n","source":"_posts/angular-guide8-9章.md","raw":"---\ntitle: Angular权威指南学习（第8到9章）指令\ndate: 2016-05-13 21:09:01\ntags: angular、directive\n---\n#### 指令\n指令本质上就是AngularJS扩展具有自定义功能的HTML元素的途径。例如，我们可以创建一个自定义元素，它实现了`<video>`标签的功能并且能在所有浏览器中工作：\n\n```\n<my-better-video my-href=\"/goofy-video.mp4\">\nCaneventaketext</my-better-video>\n\n```\n内置指令是打包在AngularJS内部的指令。所有内置指令的命名空间都使用ng作为前缀。为了防止命名空间冲突，不要在自定义指令前加ng前缀。\n   - 第一个自定义指令\n   通过AngularJS模块API中的.directive()方法，我们可以通过传入一个字符串和一个函数来注册一个新指令。其中字符串是这个指令的名字，指令名应该是驼峰命名风格的，函数应该返回一个对象\n   ```\n   <my-directive></my-directive>\n   angular.module('myApp',[])\n   .directive('myDirective', function() {\n   return {\n   restrict: 'E',\n   replace: true,//生成的代码中不含<my-directive></my-directive>\n   template: '<a href=\"http://webywx.com\">\n   Click me to go to webywx</a>'\n   };\n   });\n   ```\n   注：在我们的例子中，在HTML里使用my-directive声明指令，因此指令定义必须以myDirective为名字（驼峰命名法）。\n   \n####声明指令本质上是在HTML中通过元素、属性、类或注释来添加功能。\n   为了让AngularJS能够调用我们的指令，需要修改指令定义中的restrict设置。这个设置告诉AngularJS在编译HTML时用哪种声明格式来匹配指令定义。我们可以指定一个或多个格式。创建的指令中可以指定以元素（E）、属性（A）、类（C）或注释（M）的格式来调用指令，例：restrict: 'EAC'。\n   无论有多少种方式可以声明指令，我们坚持使用属性方式，因为它有比较好的跨浏览器兼容性：\n   ```\n   <div my-directive></div>\n   ```\n   声明指令时既可以使用表达式，也可以不使用表达式。下面是几种合法的表达式声明：\n   ```\n   <my-directive=\"someExpression\">\n   </my-directive>\n   <div my-directive=\"someExpression\">\n   </div>\n   <div class=\"my-directive:someExpression\">\n   </div>\n   <!-- directive: my-directive someExpression -->\n   ```\n   为了更加明确我们的意图，将restrict设置为字母A（代表attribute）：\n   restrict: 'A\n   遵循这个约定的同时，也要注意每个浏览器的内置样式，以便决定指令模板在HTML中是嵌套在声明元素内，还是替换声明元素。\n   值得注意的一个例外是，扩展内置HTML标签，例如用AngularJS重载`<a>`、`<form>`和`<input>`。这些场景不会导致浏览器的兼容性问题，因为它们本身就是浏览器所支持的标签。好的经验法则就是始终用属性来声明指令，这样会给以后带来方便。\n   注意，所有以ng前缀开头作为命名空间的指令都是AngularJS提供的内置指令，因此不要把你自己开发的指令以这个前缀命名。\n   1. ng-disabled\n   使用ng-disabled可以把disabled属性绑定到以下表单输入字段上：\n   ```\n    <input> （text、 checkbox、 radio、 number、 url, email、 submit）；\n    <textarea>；\n    <select>；\n    <button>。\n   ```\n   当写普通的HTML输入字段时，如果在元素标签上出现了disabled属性就会禁用这个输入字段。通过ng-disabled可以对是否出现属性进行绑定。例如，在下面的例子中按钮会一直禁用， 直到用户在文本字段中输入内容：\n   ```\n   <input type=\"text\" ng-model=\"someProperty\" placeholder=\"TypetoEnable\">\n   <button ng-model=\"button\" ng-disabled=\"!someProperty\">AButton</button>\n   ```\n   2. ng-readonly\n   同其他布尔属性一样， HTML定义只会检查readonly属性是否出现，而不是它的实际值。\n   通过ng-readonly可以将某个返回真或假的表达式同是否出现readonly属性进行绑定：\n   ```\n   Type here to make sibling readonly:\n   <input type=\"text\" ng-model=\"someProperty\"><br/>\n   <input type=\"text\"\n   ng-readonly=\"someProperty\"\n   value=\"Some text here\"/>\n   ```\n   3. ng-checked\n   ```\n   默认情况下会把复选框勾选：\n   <label>someProperty = {{someProperty}}</label>\n   <input type=\"checkbox\"\n   ng-checked=\"someProperty\"\n   ng-init=\"someProperty = true\"\n   ng-model=\"someProperty\">\n   ```\n   4. ng-selected\n   ng-selected可以对是否出现option标签的selected属性进行绑定：\n   ```\n   <label>Select Two Fish:</label>\n   <input type=\"checkbox\"\n   ng-model=\"isTwoFish\"><br/>\n   <select>\n   <option>One Fish</option>\n   <option ng-selected=\"isTwoFish\">Two Fish</option>\n   </select>\n   ```\n   5. ng-href\n   当使用当前作用域中的属性动态创建URL时，应该用ng-href代替href（用href会404）\n   6. ng-src\n   AngularJS会告诉浏览器在ng-src对应的表达式生效之前不要加载图像(用src会找不到图片)\n   7. ng-app\n   任何具有ng-app属性的DOM元素将被标记为$rootScope的起始点。\n   $rootScope是作用域链的起始点，任何嵌套在ng-app内的指令都会继承它。\n   在JavaScript代码中通过run方法来访问$rootScope。\n   ```\n   <html ng-app=\"myApp\">\n   <body>\n   {{ someProperty }}\n   <button ng-click=\"someAction()\"></button>\n   </body>\n   </html>\n   angular.module('myApp', [])\n   .run(function($rootScope) {\n   $rootScope.someProperty = 'hello computer';\n   $rootScope.someAction = function() {\n   $rootScope.someProperty = 'hello human';\n   };\n   });\n   ```\n   这里为了演示方便，像使用全局作用域一样使用$rootScope，实际生产中不建议这样做。\n   8. ng-controller\n   内置指令ng-controller的作用是为嵌套在其中的指令创建一个子作用域，避免将所有操作和模型都定义在$rootScope上。用这个指令可以在一个DOM元素上放置控制器。\n   9. ng-include\n   使用ng-include可以加载、编译并包含外部HTML片段到当前的应用中。模板的URL被限制\n   在与应用文档相同的域和协议下，可以通过白名单或包装成被信任的值来突破限制。更进一步，\n   需要考虑跨域资源共享（Cross-Origin Resource Sharing， CORS）和同源规则（Same Origin Policy）\n   来确保模板可以在任何浏览器中正常加载。例如，所有浏览器都不能进行跨域的请求，部分浏览\n   器也不能访问file://协议的资源。\n   10. ng-switch\n   这个指令和ng-switch-when及on=\"propertyName\"一起使用，可以在propertyName发生变\n   化时渲染不同指令到视图中。在下面的例子中，当person.name是Ari时，文本域下面的div会显\n   示出来，并且这个人会获得胜利：\n   ```\n   <input type=\"text\" ng-model=\"person.name\"/>\n   <div ng-switch on=\"person.name\">\n   <p ng-switch-default>And the winner is</p>\n   <h1 ng-switch-when=\"Ari\">{{ person.name }}</h1>\n   </div>\n   ```\n   注意，在switch被调用之前我们用ng-switch-default来输出默认值。\n   11. ng-view\n   ng-view指令用来设置将被路由管理和放置在HTML中的视图的位置。\n   12. ng-if\n   使用ng-if指令可以完全根据表达式的值在DOM中生成或移除一个元素。如果赋值给ng-if的表达式的值是false，那对应的元素将会从DOM中移除，否则对应元素的一个克隆将被重新插入DOM中。\n   ng-if同no-show和ng-hide指令最本质的区别是，它不是通过CSS显示或隐藏DOM节点，而是真正生成或移除节点.\n   13. ng-repeat\n   ng-repeat用来遍历一个集合或为集合中的每个元素生成一个模板实例。集合中的每个元素都会被赋予自己的模板和作用域。同时每个模板实例的作用域中都会暴露一些特殊的属性。\n   ```\n    $index：遍历的进度（0...length-1）。\n    $first：当元素是遍历的第一个时值为true。\n    $middle：当元素处于第一个和最后元素之间时值为true。\n    $last：当元素是遍历的最后一个时值为true。\n    $even：当$index值是偶数时值为true。\n    $odd：当$index值是奇数时值为true。\n   ```\n  10. ng-bind\n  尽管可以在视图中使用\\{ \\{ \\} \\}模板语法（AngularJS内置的方式），我们也可以通过ng-bind指令实现同样的行为。\n  HTML加载含有\\{ \\{ \\} \\}语法的元素后并不会立刻渲染它们，导致未渲染内容闪烁（Flash of Unrendered Content， FOUC）。我可以用ng-bind将内容同元素绑定在一起避免FOUC。内容会被当作子文本节点渲染到含有ng-bind指令的元素内。\n  11. ng-cloak\n      除使用ng-bind来避免未渲染元素闪烁，还可以在含有\\{ \\{ \\} \\}的元素上使用ng-cloak指令：\n      ```\n      <body ng-init=\"greeting='HelloWorld'\">\n      <p ng-cloak>{{ greeting }}</p>\n      </body>\n      ```\n      ng-cloak指令会将内部元素隐藏，直到路由调用对应的页面时才显示出来。\n  12. ng-bind-template\n  同ng-bind指令类似， ng-bind-template用来在视图中绑定多个表达式。\n  ```\n  <div\n  ng-bind-template=\"{{message}}{{name}}\">\n  </div>\n  ```\n  13. ng-model\n  ng-model指令用来将input、 select、 text area或自定义表单控件同包含它们的作用域中的属性进行绑定。它可以提供并处理表单验证功能，在元素上设置相关的CSS类（ng-valid、ng-invalid等），并负责在父表单中注册控件。\n  它将当前作用域中运算表达式的值同给定的元素进行绑定。如果属性并不存在，它会隐式创建并将其添加到当前作用域中。我们应该始终用ngModel来绑定$scope上一个数据模型内的属性，而不是$scope上的属性，这可以避免在作用域或后代作用域中发生属性覆盖。\n  ```\n  例如：\n  <input type=\"text\"\n  ng-model=\"modelName.someProperty\" />\n  ```\n  14. ng-show/ng-hide\n  ng-show和ng-hide根据所给表达式的值来显示或隐藏HTML元素。\n  15. ng-change\n  这个指令会在表单输入发生变化时计算给定表达式的值。因为要处理表单输入，这个指令要和ngModel联合起来使用。\n  ```\n  <div ng-controller=\"EquationController\">\n  <input type=\"text\"\n  ng-model=\"equation.x\"\n  ng-change=\"change()\" />\n  <code>{{ equation.output }}</code>\n  </div>\n  angular.module('myApp',[])\n  .controller('EquationController',function($scope) {\n  $scope.equation = {};\n  $scope.change = function() {\n  $scope.equation.output\n  = parseInt($scope.equation.x) + 2;\n  };\n  });\n  ```\n  上面的例子中，只要文本输入字段中的内容发生了变化就会改变equation.x的值，进而运行change()函数。\n  16. ng-form\n  ng-form用来在一个表单内部嵌套另一个表单。普通的HTML <form>标签不允许嵌套，但ng-form可以。\n  这意味着内部所有的子表单都合法时，外部的表单才会合法。这对于用ng-repeat动态创建表单是非常有用的。\n  由于不能通过字符插值来给输入元素动态地生成name属性，所以需要将ng-form指令内每组重复的输入字段都包含在一个外部表单元素内。\n  下面的CSS类会根据表单的验证状态自动设置：\n   1.  表单合法时设置ng-valid；\n   2.  表单不合法时设置ng-invlid；\n   3.  表单未进行修改时设置ng-pristion；\n   4.  表单进行过修改时设置ng-dirty。\n  Angular不会将表单提交到服务器，除非它指定了action属性。要指定提交表单时调用哪个JavaScript方法，使用下面两个指令中的一个。\n   1.  ng-submit：在表单元素上使用。\n   2.  ng-click：在第一个按钮或submit类型（input[type=submit]）的输入字段上使用。\n  为了避免处理程序被多次调用，只使用下面两个指令中的一个。\n  下面的例子展示了如何通过服务器返回的JSON数据动态生成一个表单。我们用ng-loop来遍历从服务器取回的所有数据。由于不能动态生成name属性，而我们又需要这个属性做验证，所以在循环的过程中会为每一个字段都生成一个新表单。由于AngularJS中用来取代<form>的ng-form指令可以嵌套，并且外部表单在所有子表单都合法之前一直处于不合法状态，因此我们可以在动态生成子表单的同时使用表单验证功能。是的，鱼和熊掌可以兼得。\n  下面先看一下我们硬编码的JSON数据，把它假设成是从服务器返回的：\n  ```\n  angular.module('myApp',[])\n  .controller('FormController',function($scope) {\n  $scope.fields = [\n  {placeholder: 'Username', isRequired: true},\n  {placeholder: 'Password', isRequired: true},\n  {placeholder: 'Email (optional)', isRequired: false}\n  ];\n  $scope.submitForm = function() {\n  alert(\"it works!\");\n  };\n  });\n  下面用这些数据生成一个有验证功能的动态表单：\n  <form name=\"signup_form\"\n  ng-controller=\"FormController\"\n  ng-submit=\"submitForm()\" novalidate>\n  <div ng-repeat=\"field in fields\"\n  ng-form=\"signup_form_input\">\n  <input type=\"text\"\n  name=\"dynamic_input\"\n  ng-required=\"field.isRequired\"\n  ng-model=\"field.name\"\n  placeholder=\"{{field.placeholder}}\" />\n  <div\n  ng-show=\"signup_form_input.dynamic_input.$dirty &&\n  signup_form_input.dynamic_input.$invalid\">\n  <span class=\"error\"\n  ng-show=\"signup_form_input.dynamic_input.$error.required\">\n  The field is required.\n  </span>\n  </div>\n  </div>\n  <button type=\"submit\"\n  ng-disabled=\"signup_form.$invalid\">\n  Submit All\n  </button>\n  </form>\n  input.ng-invalid {\n  border: 1px solid red;\n  }\n  input.ng-valid {\n  border: 1px solid green;\n  }\n  ```\n  17. ng-click\n  ng-click用来指定一个元素被点击时调用的方法或表达式。\n  18. ng-select\n  ng-select用来将数据同HTML的`<select>`元素进行绑定。这个指令可以和ng-model以及ng-options指令一同使用，构建精细且表现优良的动态表单。\n  ng-options的值可以是一个内涵表达式（comprehension expression），其实这只是一种有趣的说法，简单来说就是它可以接受一个数组或对象，并对它们进行循环，将内部的内容提供给select标签内部的选项。它可以是下面两种形式。\n   1.  数组作为数据源：\n   -  用数组中的值做标签；\n   -  用数组中的值作为选中的标签；\n   -  用数组中的值做标签组；\n   -  用数组中的值作为选中的标签组。\n   2.  对象作为数据源：\n   -  用对象的键-值（key-value）做标签；\n   -  用对象的键-值作为选中的标签；\n   -  用对象的键-值作为标签组；\n   -  用对象的键-值作为选中的标签组。\n  下面看一个ng-select指令的实例：\n  ```\n  <div ng-controller=\"CityController\">\n  <select ng-model=\"city\"\n  ng-options=\"city.name for city in cities\">\n  <option value=\"\">Choose City</option>\n  </select>\n  Best City: {{ city.name }}\n  </div>\n  angular.module('myApp',[])\n  .controller('CityController',function($scope) {\n  $scope.cities = [\n  {name: 'Seattle'},\n  {name: 'San Francisco'},\n  {name: 'Chicago'},\n  {name: 'New York'},\n  {name: 'Boston'}\n  ];\n  });\n  ```\n\n  19. ng-submit\n  ng-submit用来将表达式同onsubmit事件进行绑定。这个指令同时会阻止默认行为（发送请求并重新加载页面）， 除非表单不含有action属性。\n  ```\n  <form ng-submit=\"submit()\"\n  ng-controller=\"FormController\">\n  Enter text and hit enter:\n  <input type=\"text\"\n  ng-model=\"person.name\"\n  name=\"person.name\" />\n  <input type=\"submit\"\n  name=\"person.name\"\n  value=\"Submit\" />\n  <code>people={{people}}</code>\n  <ul ng-repeat=\"(index, object) in people\">\n  <li>{{ object.name }}</li>\n  </ul>\n  </form>\n  angular.module('myApp',[])\n  .controller('FormController',function($scope) {\n  $scope.person = {\n  name: null\n  };\n  $scope.people = [];\n  $scope.submit = function() {\n  if ($scope.person.name) {\n  $scope.people.push({name: $scope.person.name});\n  $scope.person.name = '';\n  }\n  };\n  });\n  ```\n  20. ng-class\n  使用ng-class 动态设置元素的类，方法是绑定一个代表所有需要添加的类的表达式。重复的类不会添加。当表达式发生变化，先前添加的类会被移除，新类会被添加。\n  下面的例子会用ng-class在一个随机数大于5时将.red类添加到一个div上：\n  ```\n  <div ng-controller=\"LotteryController\">\n  <div ng-class=\"{red: x > 5}\"//ng-class=\"{red: x > 5,green:x<5} 加多个类时用逗号隔开即可。\n  ng-if=\"x > 5\">\n  You won!\n  </div>\n  <button ng-click=\"generateNumber()\"\n  ng-init=\"x = 0\">\n  Draw Number\n  </button>\n  <p>Number is: {{ x }}</p>\n  </div>\n  \n  .red {\n  background-color: red;\n  }\n  angular.module('myApp',[])\n  .controller('LotteryController', function($scope) {\n  $scope.generateNumber = function() {\n  return Math.floor((Math.random()*10)+1);\n  };\n  })\n  ```\n  21. ng-attr-(suffix)\n  当AngularJS编译DOM时会查找花括号\\{ \\{ some expression \\} \\}内的表达式。这些表达式会被自动注册到$watch服务中并更新到$digest循环中，成为它的一部分：\n  ```\n  <-- updated when`someExpression` on the$scope\n  is updated -->\n  <h1>Hello{{someExpression}}</h1>\n  有时浏览器会对属性会进行很苛刻的限制。 SVG就是一个例子：\n  <svg>\n  <circle cx=\"{{ cx }}\"></circle>\n  </svg>\n  运行上面的代码会抛出一个错误，指出我们有一个非法属性。可以用ng-attr-cx来解决这\n  个问题。注意， cx位于这个名称的尾部。在这个属性中，通过用{{ }}来写表达式，达到前面提\n  到的目的。\n  <svg>\n  <circle ng-attr-cx=\"{{ cx }}\"><circle>\n  </svg>\n  {{person.name || \"无\"}} //绑定时做简单判断可以这么写。\n  ```\n  \n  \n","slug":"angular-guide8-9章","published":1,"updated":"2016-12-26T05:17:09.898Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv6a000ojgtu49swi9rp","content":"<h4 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h4><p>指令本质上就是AngularJS扩展具有自定义功能的HTML元素的途径。例如，我们可以创建一个自定义元素，它实现了<code>&lt;video&gt;</code>标签的功能并且能在所有浏览器中工作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;my-better-video my-href=&quot;/goofy-video.mp4&quot;&gt;</div><div class=\"line\">Caneventaketext&lt;/my-better-video&gt;</div></pre></td></tr></table></figure>\n<p>内置指令是打包在AngularJS内部的指令。所有内置指令的命名空间都使用ng作为前缀。为了防止命名空间冲突，不要在自定义指令前加ng前缀。</p>\n<ul>\n<li><p>第一个自定义指令<br>通过AngularJS模块API中的.directive()方法，我们可以通过传入一个字符串和一个函数来注册一个新指令。其中字符串是这个指令的名字，指令名应该是驼峰命名风格的，函数应该返回一个对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;my-directive&gt;&lt;/my-directive&gt;</div><div class=\"line\">angular.module(&apos;myApp&apos;,[])</div><div class=\"line\">.directive(&apos;myDirective&apos;, function() &#123;</div><div class=\"line\">return &#123;</div><div class=\"line\">restrict: &apos;E&apos;,</div><div class=\"line\">replace: true,//生成的代码中不含&lt;my-directive&gt;&lt;/my-directive&gt;</div><div class=\"line\">template: &apos;&lt;a href=&quot;http://webywx.com&quot;&gt;</div><div class=\"line\">Click me to go to webywx&lt;/a&gt;&apos;</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>注：在我们的例子中，在HTML里使用my-directive声明指令，因此指令定义必须以myDirective为名字（驼峰命名法）。</p>\n</li>\n</ul>\n<p>####声明指令本质上是在HTML中通过元素、属性、类或注释来添加功能。<br>   为了让AngularJS能够调用我们的指令，需要修改指令定义中的restrict设置。这个设置告诉AngularJS在编译HTML时用哪种声明格式来匹配指令定义。我们可以指定一个或多个格式。创建的指令中可以指定以元素（E）、属性（A）、类（C）或注释（M）的格式来调用指令，例：restrict: ‘EAC’。<br>   无论有多少种方式可以声明指令，我们坚持使用属性方式，因为它有比较好的跨浏览器兼容性：<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div my-directive&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p>   声明指令时既可以使用表达式，也可以不使用表达式。下面是几种合法的表达式声明：<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;my-directive=&quot;someExpression&quot;&gt;</div><div class=\"line\">&lt;/my-directive&gt;</div><div class=\"line\">&lt;div my-directive=&quot;someExpression&quot;&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;my-directive:someExpression&quot;&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">&lt;!-- directive: my-directive someExpression --&gt;</div></pre></td></tr></table></figure></p>\n<p>   为了更加明确我们的意图，将restrict设置为字母A（代表attribute）：<br>   restrict: ‘A<br>   遵循这个约定的同时，也要注意每个浏览器的内置样式，以便决定指令模板在HTML中是嵌套在声明元素内，还是替换声明元素。<br>   值得注意的一个例外是，扩展内置HTML标签，例如用AngularJS重载<code>&lt;a&gt;</code>、<code>&lt;form&gt;</code>和<code>&lt;input&gt;</code>。这些场景不会导致浏览器的兼容性问题，因为它们本身就是浏览器所支持的标签。好的经验法则就是始终用属性来声明指令，这样会给以后带来方便。<br>   注意，所有以ng前缀开头作为命名空间的指令都是AngularJS提供的内置指令，因此不要把你自己开发的指令以这个前缀命名。</p>\n<ol>\n<li><p>ng-disabled<br>使用ng-disabled可以把disabled属性绑定到以下表单输入字段上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> &lt;input&gt; （text、 checkbox、 radio、 number、 url, email、 submit）；</div><div class=\"line\"> &lt;textarea&gt;；</div><div class=\"line\"> &lt;select&gt;；</div><div class=\"line\"> &lt;button&gt;。</div></pre></td></tr></table></figure>\n<p>当写普通的HTML输入字段时，如果在元素标签上出现了disabled属性就会禁用这个输入字段。通过ng-disabled可以对是否出现属性进行绑定。例如，在下面的例子中按钮会一直禁用， 直到用户在文本字段中输入内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input type=&quot;text&quot; ng-model=&quot;someProperty&quot; placeholder=&quot;TypetoEnable&quot;&gt;</div><div class=\"line\">&lt;button ng-model=&quot;button&quot; ng-disabled=&quot;!someProperty&quot;&gt;AButton&lt;/button&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>ng-readonly<br>同其他布尔属性一样， HTML定义只会检查readonly属性是否出现，而不是它的实际值。<br>通过ng-readonly可以将某个返回真或假的表达式同是否出现readonly属性进行绑定：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Type here to make sibling readonly:</div><div class=\"line\">&lt;input type=&quot;text&quot; ng-model=&quot;someProperty&quot;&gt;&lt;br/&gt;</div><div class=\"line\">&lt;input type=&quot;text&quot;</div><div class=\"line\">ng-readonly=&quot;someProperty&quot;</div><div class=\"line\">value=&quot;Some text here&quot;/&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>ng-checked</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">默认情况下会把复选框勾选：</div><div class=\"line\">&lt;label&gt;someProperty = &#123;&#123;someProperty&#125;&#125;&lt;/label&gt;</div><div class=\"line\">&lt;input type=&quot;checkbox&quot;</div><div class=\"line\">ng-checked=&quot;someProperty&quot;</div><div class=\"line\">ng-init=&quot;someProperty = true&quot;</div><div class=\"line\">ng-model=&quot;someProperty&quot;&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>ng-selected<br>ng-selected可以对是否出现option标签的selected属性进行绑定：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;label&gt;Select Two Fish:&lt;/label&gt;</div><div class=\"line\">&lt;input type=&quot;checkbox&quot;</div><div class=\"line\">ng-model=&quot;isTwoFish&quot;&gt;&lt;br/&gt;</div><div class=\"line\">&lt;select&gt;</div><div class=\"line\">&lt;option&gt;One Fish&lt;/option&gt;</div><div class=\"line\">&lt;option ng-selected=&quot;isTwoFish&quot;&gt;Two Fish&lt;/option&gt;</div><div class=\"line\">&lt;/select&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>ng-href<br>当使用当前作用域中的属性动态创建URL时，应该用ng-href代替href（用href会404）</p>\n</li>\n<li>ng-src<br>AngularJS会告诉浏览器在ng-src对应的表达式生效之前不要加载图像(用src会找不到图片)</li>\n<li><p>ng-app<br>任何具有ng-app属性的DOM元素将被标记为$rootScope的起始点。<br>$rootScope是作用域链的起始点，任何嵌套在ng-app内的指令都会继承它。<br>在JavaScript代码中通过run方法来访问$rootScope。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;html ng-app=&quot;myApp&quot;&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">&#123;&#123; someProperty &#125;&#125;</div><div class=\"line\">&lt;button ng-click=&quot;someAction()&quot;&gt;&lt;/button&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div><div class=\"line\">angular.module(&apos;myApp&apos;, [])</div><div class=\"line\">.run(function($rootScope) &#123;</div><div class=\"line\">$rootScope.someProperty = &apos;hello computer&apos;;</div><div class=\"line\">$rootScope.someAction = function() &#123;</div><div class=\"line\">$rootScope.someProperty = &apos;hello human&apos;;</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这里为了演示方便，像使用全局作用域一样使用$rootScope，实际生产中不建议这样做。</p>\n</li>\n<li>ng-controller<br>内置指令ng-controller的作用是为嵌套在其中的指令创建一个子作用域，避免将所有操作和模型都定义在$rootScope上。用这个指令可以在一个DOM元素上放置控制器。</li>\n<li>ng-include<br>使用ng-include可以加载、编译并包含外部HTML片段到当前的应用中。模板的URL被限制<br>在与应用文档相同的域和协议下，可以通过白名单或包装成被信任的值来突破限制。更进一步，<br>需要考虑跨域资源共享（Cross-Origin Resource Sharing， CORS）和同源规则（Same Origin Policy）<br>来确保模板可以在任何浏览器中正常加载。例如，所有浏览器都不能进行跨域的请求，部分浏览<br>器也不能访问file://协议的资源。</li>\n<li><p>ng-switch<br>这个指令和ng-switch-when及on=”propertyName”一起使用，可以在propertyName发生变<br>化时渲染不同指令到视图中。在下面的例子中，当person.name是Ari时，文本域下面的div会显<br>示出来，并且这个人会获得胜利：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input type=&quot;text&quot; ng-model=&quot;person.name&quot;/&gt;</div><div class=\"line\">&lt;div ng-switch on=&quot;person.name&quot;&gt;</div><div class=\"line\">&lt;p ng-switch-default&gt;And the winner is&lt;/p&gt;</div><div class=\"line\">&lt;h1 ng-switch-when=&quot;Ari&quot;&gt;&#123;&#123; person.name &#125;&#125;&lt;/h1&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>注意，在switch被调用之前我们用ng-switch-default来输出默认值。</p>\n</li>\n<li>ng-view<br>ng-view指令用来设置将被路由管理和放置在HTML中的视图的位置。</li>\n<li>ng-if<br>使用ng-if指令可以完全根据表达式的值在DOM中生成或移除一个元素。如果赋值给ng-if的表达式的值是false，那对应的元素将会从DOM中移除，否则对应元素的一个克隆将被重新插入DOM中。<br>ng-if同no-show和ng-hide指令最本质的区别是，它不是通过CSS显示或隐藏DOM节点，而是真正生成或移除节点.</li>\n<li><p>ng-repeat<br>ng-repeat用来遍历一个集合或为集合中的每个元素生成一个模板实例。集合中的每个元素都会被赋予自己的模板和作用域。同时每个模板实例的作用域中都会暴露一些特殊的属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"> $index：遍历的进度（0...length-1）。</div><div class=\"line\"> $first：当元素是遍历的第一个时值为true。</div><div class=\"line\"> $middle：当元素处于第一个和最后元素之间时值为true。</div><div class=\"line\"> $last：当元素是遍历的最后一个时值为true。</div><div class=\"line\"> $even：当$index值是偶数时值为true。</div><div class=\"line\"> $odd：当$index值是奇数时值为true。</div></pre></td></tr></table></figure>\n<ol>\n<li>ng-bind<br>尽管可以在视图中使用{ { } }模板语法（AngularJS内置的方式），我们也可以通过ng-bind指令实现同样的行为。<br>HTML加载含有{ { } }语法的元素后并不会立刻渲染它们，导致未渲染内容闪烁（Flash of Unrendered Content， FOUC）。我可以用ng-bind将内容同元素绑定在一起避免FOUC。内容会被当作子文本节点渲染到含有ng-bind指令的元素内。</li>\n<li>ng-cloak<br>除使用ng-bind来避免未渲染元素闪烁，还可以在含有{ { } }的元素上使用ng-cloak指令：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;body ng-init=&quot;greeting=&apos;HelloWorld&apos;&quot;&gt;</div><div class=\"line\">&lt;p ng-cloak&gt;&#123;&#123; greeting &#125;&#125;&lt;/p&gt;</div><div class=\"line\">&lt;/body&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>ng-cloak指令会将内部元素隐藏，直到路由调用对应的页面时才显示出来。</p>\n<ol>\n<li><p>ng-bind-template<br>同ng-bind指令类似， ng-bind-template用来在视图中绑定多个表达式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div</div><div class=\"line\">ng-bind-template=&quot;&#123;&#123;message&#125;&#125;&#123;&#123;name&#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>ng-model<br>ng-model指令用来将input、 select、 text area或自定义表单控件同包含它们的作用域中的属性进行绑定。它可以提供并处理表单验证功能，在元素上设置相关的CSS类（ng-valid、ng-invalid等），并负责在父表单中注册控件。<br>它将当前作用域中运算表达式的值同给定的元素进行绑定。如果属性并不存在，它会隐式创建并将其添加到当前作用域中。我们应该始终用ngModel来绑定$scope上一个数据模型内的属性，而不是$scope上的属性，这可以避免在作用域或后代作用域中发生属性覆盖。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">例如：</div><div class=\"line\">&lt;input type=&quot;text&quot;</div><div class=\"line\">ng-model=&quot;modelName.someProperty&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>ng-show/ng-hide<br>ng-show和ng-hide根据所给表达式的值来显示或隐藏HTML元素。</p>\n</li>\n<li>ng-change<br>这个指令会在表单输入发生变化时计算给定表达式的值。因为要处理表单输入，这个指令要和ngModel联合起来使用。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-controller=&quot;EquationController&quot;&gt;</div><div class=\"line\">&lt;input type=&quot;text&quot;</div><div class=\"line\">ng-model=&quot;equation.x&quot;</div><div class=\"line\">ng-change=&quot;change()&quot; /&gt;</div><div class=\"line\">&lt;code&gt;&#123;&#123; equation.output &#125;&#125;&lt;/code&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">angular.module(&apos;myApp&apos;,[])</div><div class=\"line\">.controller(&apos;EquationController&apos;,function($scope) &#123;</div><div class=\"line\">$scope.equation = &#123;&#125;;</div><div class=\"line\">$scope.change = function() &#123;</div><div class=\"line\">$scope.equation.output</div><div class=\"line\">= parseInt($scope.equation.x) + 2;</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>上面的例子中，只要文本输入字段中的内容发生了变化就会改变equation.x的值，进而运行change()函数。</p>\n<ol>\n<li>ng-form<br>ng-form用来在一个表单内部嵌套另一个表单。普通的HTML <form>标签不允许嵌套，但ng-form可以。<br>这意味着内部所有的子表单都合法时，外部的表单才会合法。这对于用ng-repeat动态创建表单是非常有用的。<br>由于不能通过字符插值来给输入元素动态地生成name属性，所以需要将ng-form指令内每组重复的输入字段都包含在一个外部表单元素内。<br>下面的CSS类会根据表单的验证状态自动设置：</form></li>\n</ol>\n</li>\n<li> 表单合法时设置ng-valid；</li>\n<li> 表单不合法时设置ng-invlid；</li>\n<li> 表单未进行修改时设置ng-pristion；</li>\n<li> 表单进行过修改时设置ng-dirty。<br>Angular不会将表单提交到服务器，除非它指定了action属性。要指定提交表单时调用哪个JavaScript方法，使用下面两个指令中的一个。</li>\n<li> ng-submit：在表单元素上使用。</li>\n<li><p> ng-click：在第一个按钮或submit类型（input[type=submit]）的输入字段上使用。<br>为了避免处理程序被多次调用，只使用下面两个指令中的一个。<br>下面的例子展示了如何通过服务器返回的JSON数据动态生成一个表单。我们用ng-loop来遍历从服务器取回的所有数据。由于不能动态生成name属性，而我们又需要这个属性做验证，所以在循环的过程中会为每一个字段都生成一个新表单。由于AngularJS中用来取代<form>的ng-form指令可以嵌套，并且外部表单在所有子表单都合法之前一直处于不合法状态，因此我们可以在动态生成子表单的同时使用表单验证功能。是的，鱼和熊掌可以兼得。<br>下面先看一下我们硬编码的JSON数据，把它假设成是从服务器返回的：</form></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp&apos;,[])</div><div class=\"line\">.controller(&apos;FormController&apos;,function($scope) &#123;</div><div class=\"line\">$scope.fields = [</div><div class=\"line\">&#123;placeholder: &apos;Username&apos;, isRequired: true&#125;,</div><div class=\"line\">&#123;placeholder: &apos;Password&apos;, isRequired: true&#125;,</div><div class=\"line\">&#123;placeholder: &apos;Email (optional)&apos;, isRequired: false&#125;</div><div class=\"line\">];</div><div class=\"line\">$scope.submitForm = function() &#123;</div><div class=\"line\">alert(&quot;it works!&quot;);</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;);</div><div class=\"line\">下面用这些数据生成一个有验证功能的动态表单：</div><div class=\"line\">&lt;form name=&quot;signup_form&quot;</div><div class=\"line\">ng-controller=&quot;FormController&quot;</div><div class=\"line\">ng-submit=&quot;submitForm()&quot; novalidate&gt;</div><div class=\"line\">&lt;div ng-repeat=&quot;field in fields&quot;</div><div class=\"line\">ng-form=&quot;signup_form_input&quot;&gt;</div><div class=\"line\">&lt;input type=&quot;text&quot;</div><div class=\"line\">name=&quot;dynamic_input&quot;</div><div class=\"line\">ng-required=&quot;field.isRequired&quot;</div><div class=\"line\">ng-model=&quot;field.name&quot;</div><div class=\"line\">placeholder=&quot;&#123;&#123;field.placeholder&#125;&#125;&quot; /&gt;</div><div class=\"line\">&lt;div</div><div class=\"line\">ng-show=&quot;signup_form_input.dynamic_input.$dirty &amp;&amp;</div><div class=\"line\">signup_form_input.dynamic_input.$invalid&quot;&gt;</div><div class=\"line\">&lt;span class=&quot;error&quot;</div><div class=\"line\">ng-show=&quot;signup_form_input.dynamic_input.$error.required&quot;&gt;</div><div class=\"line\">The field is required.</div><div class=\"line\">&lt;/span&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">&lt;button type=&quot;submit&quot;</div><div class=\"line\">ng-disabled=&quot;signup_form.$invalid&quot;&gt;</div><div class=\"line\">Submit All</div><div class=\"line\">&lt;/button&gt;</div><div class=\"line\">&lt;/form&gt;</div><div class=\"line\">input.ng-invalid &#123;</div><div class=\"line\">border: 1px solid red;</div><div class=\"line\">&#125;</div><div class=\"line\">input.ng-valid &#123;</div><div class=\"line\">border: 1px solid green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>ng-click<br>ng-click用来指定一个元素被点击时调用的方法或表达式。</li>\n<li>ng-select<br>ng-select用来将数据同HTML的<code>&lt;select&gt;</code>元素进行绑定。这个指令可以和ng-model以及ng-options指令一同使用，构建精细且表现优良的动态表单。<br>ng-options的值可以是一个内涵表达式（comprehension expression），其实这只是一种有趣的说法，简单来说就是它可以接受一个数组或对象，并对它们进行循环，将内部的内容提供给select标签内部的选项。它可以是下面两种形式。</li>\n</ol>\n</li>\n<li> 数组作为数据源：</li>\n</ol>\n<ul>\n<li> 用数组中的值做标签；</li>\n<li> 用数组中的值作为选中的标签；</li>\n<li> 用数组中的值做标签组；</li>\n<li> 用数组中的值作为选中的标签组。</li>\n</ul>\n<ol>\n<li> 对象作为数据源：</li>\n</ol>\n<ul>\n<li> 用对象的键-值（key-value）做标签；</li>\n<li> 用对象的键-值作为选中的标签；</li>\n<li> 用对象的键-值作为标签组；</li>\n<li><p> 用对象的键-值作为选中的标签组。<br>下面看一个ng-select指令的实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-controller=&quot;CityController&quot;&gt;</div><div class=\"line\">&lt;select ng-model=&quot;city&quot;</div><div class=\"line\">ng-options=&quot;city.name for city in cities&quot;&gt;</div><div class=\"line\">&lt;option value=&quot;&quot;&gt;Choose City&lt;/option&gt;</div><div class=\"line\">&lt;/select&gt;</div><div class=\"line\">Best City: &#123;&#123; city.name &#125;&#125;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">angular.module(&apos;myApp&apos;,[])</div><div class=\"line\">.controller(&apos;CityController&apos;,function($scope) &#123;</div><div class=\"line\">$scope.cities = [</div><div class=\"line\">&#123;name: &apos;Seattle&apos;&#125;,</div><div class=\"line\">&#123;name: &apos;San Francisco&apos;&#125;,</div><div class=\"line\">&#123;name: &apos;Chicago&apos;&#125;,</div><div class=\"line\">&#123;name: &apos;New York&apos;&#125;,</div><div class=\"line\">&#123;name: &apos;Boston&apos;&#125;</div><div class=\"line\">];</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ol>\n<li><p>ng-submit<br>ng-submit用来将表达式同onsubmit事件进行绑定。这个指令同时会阻止默认行为（发送请求并重新加载页面）， 除非表单不含有action属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form ng-submit=&quot;submit()&quot;</div><div class=\"line\">ng-controller=&quot;FormController&quot;&gt;</div><div class=\"line\">Enter text and hit enter:</div><div class=\"line\">&lt;input type=&quot;text&quot;</div><div class=\"line\">ng-model=&quot;person.name&quot;</div><div class=\"line\">name=&quot;person.name&quot; /&gt;</div><div class=\"line\">&lt;input type=&quot;submit&quot;</div><div class=\"line\">name=&quot;person.name&quot;</div><div class=\"line\">value=&quot;Submit&quot; /&gt;</div><div class=\"line\">&lt;code&gt;people=&#123;&#123;people&#125;&#125;&lt;/code&gt;</div><div class=\"line\">&lt;ul ng-repeat=&quot;(index, object) in people&quot;&gt;</div><div class=\"line\">&lt;li&gt;&#123;&#123; object.name &#125;&#125;&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div><div class=\"line\">&lt;/form&gt;</div><div class=\"line\">angular.module(&apos;myApp&apos;,[])</div><div class=\"line\">.controller(&apos;FormController&apos;,function($scope) &#123;</div><div class=\"line\">$scope.person = &#123;</div><div class=\"line\">name: null</div><div class=\"line\">&#125;;</div><div class=\"line\">$scope.people = [];</div><div class=\"line\">$scope.submit = function() &#123;</div><div class=\"line\">if ($scope.person.name) &#123;</div><div class=\"line\">$scope.people.push(&#123;name: $scope.person.name&#125;);</div><div class=\"line\">$scope.person.name = &apos;&apos;;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>ng-class<br>使用ng-class 动态设置元素的类，方法是绑定一个代表所有需要添加的类的表达式。重复的类不会添加。当表达式发生变化，先前添加的类会被移除，新类会被添加。<br>下面的例子会用ng-class在一个随机数大于5时将.red类添加到一个div上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-controller=&quot;LotteryController&quot;&gt;</div><div class=\"line\">&lt;div ng-class=&quot;&#123;red: x &gt; 5&#125;&quot;//ng-class=&quot;&#123;red: x &gt; 5,green:x&lt;5&#125; 加多个类时用逗号隔开即可。</div><div class=\"line\">ng-if=&quot;x &gt; 5&quot;&gt;</div><div class=\"line\">You won!</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">&lt;button ng-click=&quot;generateNumber()&quot;</div><div class=\"line\">ng-init=&quot;x = 0&quot;&gt;</div><div class=\"line\">Draw Number</div><div class=\"line\">&lt;/button&gt;</div><div class=\"line\">&lt;p&gt;Number is: &#123;&#123; x &#125;&#125;&lt;/p&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">.red &#123;</div><div class=\"line\">background-color: red;</div><div class=\"line\">&#125;</div><div class=\"line\">angular.module(&apos;myApp&apos;,[])</div><div class=\"line\">.controller(&apos;LotteryController&apos;, function($scope) &#123;</div><div class=\"line\">$scope.generateNumber = function() &#123;</div><div class=\"line\">return Math.floor((Math.random()*10)+1);</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p>ng-attr-(suffix)<br>当AngularJS编译DOM时会查找花括号{ { some expression } }内的表达式。这些表达式会被自动注册到$watch服务中并更新到$digest循环中，成为它的一部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;-- updated when`someExpression` on the$scope</div><div class=\"line\">is updated --&gt;</div><div class=\"line\">&lt;h1&gt;Hello&#123;&#123;someExpression&#125;&#125;&lt;/h1&gt;</div><div class=\"line\">有时浏览器会对属性会进行很苛刻的限制。 SVG就是一个例子：</div><div class=\"line\">&lt;svg&gt;</div><div class=\"line\">&lt;circle cx=&quot;&#123;&#123; cx &#125;&#125;&quot;&gt;&lt;/circle&gt;</div><div class=\"line\">&lt;/svg&gt;</div><div class=\"line\">运行上面的代码会抛出一个错误，指出我们有一个非法属性。可以用ng-attr-cx来解决这</div><div class=\"line\">个问题。注意， cx位于这个名称的尾部。在这个属性中，通过用&#123;&#123; &#125;&#125;来写表达式，达到前面提</div><div class=\"line\">到的目的。</div><div class=\"line\">&lt;svg&gt;</div><div class=\"line\">&lt;circle ng-attr-cx=&quot;&#123;&#123; cx &#125;&#125;&quot;&gt;&lt;circle&gt;</div><div class=\"line\">&lt;/svg&gt;</div><div class=\"line\">&#123;&#123;person.name || &quot;无&quot;&#125;&#125; //绑定时做简单判断可以这么写。</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n","excerpt":"","more":"<h4 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h4><p>指令本质上就是AngularJS扩展具有自定义功能的HTML元素的途径。例如，我们可以创建一个自定义元素，它实现了<code>&lt;video&gt;</code>标签的功能并且能在所有浏览器中工作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;my-better-video my-href=&quot;/goofy-video.mp4&quot;&gt;</div><div class=\"line\">Caneventaketext&lt;/my-better-video&gt;</div></pre></td></tr></table></figure>\n<p>内置指令是打包在AngularJS内部的指令。所有内置指令的命名空间都使用ng作为前缀。为了防止命名空间冲突，不要在自定义指令前加ng前缀。</p>\n<ul>\n<li><p>第一个自定义指令<br>通过AngularJS模块API中的.directive()方法，我们可以通过传入一个字符串和一个函数来注册一个新指令。其中字符串是这个指令的名字，指令名应该是驼峰命名风格的，函数应该返回一个对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;my-directive&gt;&lt;/my-directive&gt;</div><div class=\"line\">angular.module(&apos;myApp&apos;,[])</div><div class=\"line\">.directive(&apos;myDirective&apos;, function() &#123;</div><div class=\"line\">return &#123;</div><div class=\"line\">restrict: &apos;E&apos;,</div><div class=\"line\">replace: true,//生成的代码中不含&lt;my-directive&gt;&lt;/my-directive&gt;</div><div class=\"line\">template: &apos;&lt;a href=&quot;http://webywx.com&quot;&gt;</div><div class=\"line\">Click me to go to webywx&lt;/a&gt;&apos;</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>注：在我们的例子中，在HTML里使用my-directive声明指令，因此指令定义必须以myDirective为名字（驼峰命名法）。</p>\n</li>\n</ul>\n<p>####声明指令本质上是在HTML中通过元素、属性、类或注释来添加功能。<br>   为了让AngularJS能够调用我们的指令，需要修改指令定义中的restrict设置。这个设置告诉AngularJS在编译HTML时用哪种声明格式来匹配指令定义。我们可以指定一个或多个格式。创建的指令中可以指定以元素（E）、属性（A）、类（C）或注释（M）的格式来调用指令，例：restrict: ‘EAC’。<br>   无论有多少种方式可以声明指令，我们坚持使用属性方式，因为它有比较好的跨浏览器兼容性：<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div my-directive&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p>   声明指令时既可以使用表达式，也可以不使用表达式。下面是几种合法的表达式声明：<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;my-directive=&quot;someExpression&quot;&gt;</div><div class=\"line\">&lt;/my-directive&gt;</div><div class=\"line\">&lt;div my-directive=&quot;someExpression&quot;&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;my-directive:someExpression&quot;&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">&lt;!-- directive: my-directive someExpression --&gt;</div></pre></td></tr></table></figure></p>\n<p>   为了更加明确我们的意图，将restrict设置为字母A（代表attribute）：<br>   restrict: ‘A<br>   遵循这个约定的同时，也要注意每个浏览器的内置样式，以便决定指令模板在HTML中是嵌套在声明元素内，还是替换声明元素。<br>   值得注意的一个例外是，扩展内置HTML标签，例如用AngularJS重载<code>&lt;a&gt;</code>、<code>&lt;form&gt;</code>和<code>&lt;input&gt;</code>。这些场景不会导致浏览器的兼容性问题，因为它们本身就是浏览器所支持的标签。好的经验法则就是始终用属性来声明指令，这样会给以后带来方便。<br>   注意，所有以ng前缀开头作为命名空间的指令都是AngularJS提供的内置指令，因此不要把你自己开发的指令以这个前缀命名。</p>\n<ol>\n<li><p>ng-disabled<br>使用ng-disabled可以把disabled属性绑定到以下表单输入字段上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> &lt;input&gt; （text、 checkbox、 radio、 number、 url, email、 submit）；</div><div class=\"line\"> &lt;textarea&gt;；</div><div class=\"line\"> &lt;select&gt;；</div><div class=\"line\"> &lt;button&gt;。</div></pre></td></tr></table></figure>\n<p>当写普通的HTML输入字段时，如果在元素标签上出现了disabled属性就会禁用这个输入字段。通过ng-disabled可以对是否出现属性进行绑定。例如，在下面的例子中按钮会一直禁用， 直到用户在文本字段中输入内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input type=&quot;text&quot; ng-model=&quot;someProperty&quot; placeholder=&quot;TypetoEnable&quot;&gt;</div><div class=\"line\">&lt;button ng-model=&quot;button&quot; ng-disabled=&quot;!someProperty&quot;&gt;AButton&lt;/button&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>ng-readonly<br>同其他布尔属性一样， HTML定义只会检查readonly属性是否出现，而不是它的实际值。<br>通过ng-readonly可以将某个返回真或假的表达式同是否出现readonly属性进行绑定：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Type here to make sibling readonly:</div><div class=\"line\">&lt;input type=&quot;text&quot; ng-model=&quot;someProperty&quot;&gt;&lt;br/&gt;</div><div class=\"line\">&lt;input type=&quot;text&quot;</div><div class=\"line\">ng-readonly=&quot;someProperty&quot;</div><div class=\"line\">value=&quot;Some text here&quot;/&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>ng-checked</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">默认情况下会把复选框勾选：</div><div class=\"line\">&lt;label&gt;someProperty = &#123;&#123;someProperty&#125;&#125;&lt;/label&gt;</div><div class=\"line\">&lt;input type=&quot;checkbox&quot;</div><div class=\"line\">ng-checked=&quot;someProperty&quot;</div><div class=\"line\">ng-init=&quot;someProperty = true&quot;</div><div class=\"line\">ng-model=&quot;someProperty&quot;&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>ng-selected<br>ng-selected可以对是否出现option标签的selected属性进行绑定：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;label&gt;Select Two Fish:&lt;/label&gt;</div><div class=\"line\">&lt;input type=&quot;checkbox&quot;</div><div class=\"line\">ng-model=&quot;isTwoFish&quot;&gt;&lt;br/&gt;</div><div class=\"line\">&lt;select&gt;</div><div class=\"line\">&lt;option&gt;One Fish&lt;/option&gt;</div><div class=\"line\">&lt;option ng-selected=&quot;isTwoFish&quot;&gt;Two Fish&lt;/option&gt;</div><div class=\"line\">&lt;/select&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>ng-href<br>当使用当前作用域中的属性动态创建URL时，应该用ng-href代替href（用href会404）</p>\n</li>\n<li>ng-src<br>AngularJS会告诉浏览器在ng-src对应的表达式生效之前不要加载图像(用src会找不到图片)</li>\n<li><p>ng-app<br>任何具有ng-app属性的DOM元素将被标记为$rootScope的起始点。<br>$rootScope是作用域链的起始点，任何嵌套在ng-app内的指令都会继承它。<br>在JavaScript代码中通过run方法来访问$rootScope。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;html ng-app=&quot;myApp&quot;&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">&#123;&#123; someProperty &#125;&#125;</div><div class=\"line\">&lt;button ng-click=&quot;someAction()&quot;&gt;&lt;/button&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div><div class=\"line\">angular.module(&apos;myApp&apos;, [])</div><div class=\"line\">.run(function($rootScope) &#123;</div><div class=\"line\">$rootScope.someProperty = &apos;hello computer&apos;;</div><div class=\"line\">$rootScope.someAction = function() &#123;</div><div class=\"line\">$rootScope.someProperty = &apos;hello human&apos;;</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这里为了演示方便，像使用全局作用域一样使用$rootScope，实际生产中不建议这样做。</p>\n</li>\n<li>ng-controller<br>内置指令ng-controller的作用是为嵌套在其中的指令创建一个子作用域，避免将所有操作和模型都定义在$rootScope上。用这个指令可以在一个DOM元素上放置控制器。</li>\n<li>ng-include<br>使用ng-include可以加载、编译并包含外部HTML片段到当前的应用中。模板的URL被限制<br>在与应用文档相同的域和协议下，可以通过白名单或包装成被信任的值来突破限制。更进一步，<br>需要考虑跨域资源共享（Cross-Origin Resource Sharing， CORS）和同源规则（Same Origin Policy）<br>来确保模板可以在任何浏览器中正常加载。例如，所有浏览器都不能进行跨域的请求，部分浏览<br>器也不能访问file://协议的资源。</li>\n<li><p>ng-switch<br>这个指令和ng-switch-when及on=”propertyName”一起使用，可以在propertyName发生变<br>化时渲染不同指令到视图中。在下面的例子中，当person.name是Ari时，文本域下面的div会显<br>示出来，并且这个人会获得胜利：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input type=&quot;text&quot; ng-model=&quot;person.name&quot;/&gt;</div><div class=\"line\">&lt;div ng-switch on=&quot;person.name&quot;&gt;</div><div class=\"line\">&lt;p ng-switch-default&gt;And the winner is&lt;/p&gt;</div><div class=\"line\">&lt;h1 ng-switch-when=&quot;Ari&quot;&gt;&#123;&#123; person.name &#125;&#125;&lt;/h1&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>注意，在switch被调用之前我们用ng-switch-default来输出默认值。</p>\n</li>\n<li>ng-view<br>ng-view指令用来设置将被路由管理和放置在HTML中的视图的位置。</li>\n<li>ng-if<br>使用ng-if指令可以完全根据表达式的值在DOM中生成或移除一个元素。如果赋值给ng-if的表达式的值是false，那对应的元素将会从DOM中移除，否则对应元素的一个克隆将被重新插入DOM中。<br>ng-if同no-show和ng-hide指令最本质的区别是，它不是通过CSS显示或隐藏DOM节点，而是真正生成或移除节点.</li>\n<li><p>ng-repeat<br>ng-repeat用来遍历一个集合或为集合中的每个元素生成一个模板实例。集合中的每个元素都会被赋予自己的模板和作用域。同时每个模板实例的作用域中都会暴露一些特殊的属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"> $index：遍历的进度（0...length-1）。</div><div class=\"line\"> $first：当元素是遍历的第一个时值为true。</div><div class=\"line\"> $middle：当元素处于第一个和最后元素之间时值为true。</div><div class=\"line\"> $last：当元素是遍历的最后一个时值为true。</div><div class=\"line\"> $even：当$index值是偶数时值为true。</div><div class=\"line\"> $odd：当$index值是奇数时值为true。</div></pre></td></tr></table></figure>\n<ol>\n<li>ng-bind<br>尽管可以在视图中使用{ { } }模板语法（AngularJS内置的方式），我们也可以通过ng-bind指令实现同样的行为。<br>HTML加载含有{ { } }语法的元素后并不会立刻渲染它们，导致未渲染内容闪烁（Flash of Unrendered Content， FOUC）。我可以用ng-bind将内容同元素绑定在一起避免FOUC。内容会被当作子文本节点渲染到含有ng-bind指令的元素内。</li>\n<li>ng-cloak<br>除使用ng-bind来避免未渲染元素闪烁，还可以在含有{ { } }的元素上使用ng-cloak指令：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;body ng-init=&quot;greeting=&apos;HelloWorld&apos;&quot;&gt;</div><div class=\"line\">&lt;p ng-cloak&gt;&#123;&#123; greeting &#125;&#125;&lt;/p&gt;</div><div class=\"line\">&lt;/body&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>ng-cloak指令会将内部元素隐藏，直到路由调用对应的页面时才显示出来。</p>\n<ol>\n<li><p>ng-bind-template<br>同ng-bind指令类似， ng-bind-template用来在视图中绑定多个表达式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div</div><div class=\"line\">ng-bind-template=&quot;&#123;&#123;message&#125;&#125;&#123;&#123;name&#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>ng-model<br>ng-model指令用来将input、 select、 text area或自定义表单控件同包含它们的作用域中的属性进行绑定。它可以提供并处理表单验证功能，在元素上设置相关的CSS类（ng-valid、ng-invalid等），并负责在父表单中注册控件。<br>它将当前作用域中运算表达式的值同给定的元素进行绑定。如果属性并不存在，它会隐式创建并将其添加到当前作用域中。我们应该始终用ngModel来绑定$scope上一个数据模型内的属性，而不是$scope上的属性，这可以避免在作用域或后代作用域中发生属性覆盖。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">例如：</div><div class=\"line\">&lt;input type=&quot;text&quot;</div><div class=\"line\">ng-model=&quot;modelName.someProperty&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>ng-show/ng-hide<br>ng-show和ng-hide根据所给表达式的值来显示或隐藏HTML元素。</p>\n</li>\n<li>ng-change<br>这个指令会在表单输入发生变化时计算给定表达式的值。因为要处理表单输入，这个指令要和ngModel联合起来使用。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-controller=&quot;EquationController&quot;&gt;</div><div class=\"line\">&lt;input type=&quot;text&quot;</div><div class=\"line\">ng-model=&quot;equation.x&quot;</div><div class=\"line\">ng-change=&quot;change()&quot; /&gt;</div><div class=\"line\">&lt;code&gt;&#123;&#123; equation.output &#125;&#125;&lt;/code&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">angular.module(&apos;myApp&apos;,[])</div><div class=\"line\">.controller(&apos;EquationController&apos;,function($scope) &#123;</div><div class=\"line\">$scope.equation = &#123;&#125;;</div><div class=\"line\">$scope.change = function() &#123;</div><div class=\"line\">$scope.equation.output</div><div class=\"line\">= parseInt($scope.equation.x) + 2;</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>上面的例子中，只要文本输入字段中的内容发生了变化就会改变equation.x的值，进而运行change()函数。</p>\n<ol>\n<li>ng-form<br>ng-form用来在一个表单内部嵌套另一个表单。普通的HTML <form>标签不允许嵌套，但ng-form可以。<br>这意味着内部所有的子表单都合法时，外部的表单才会合法。这对于用ng-repeat动态创建表单是非常有用的。<br>由于不能通过字符插值来给输入元素动态地生成name属性，所以需要将ng-form指令内每组重复的输入字段都包含在一个外部表单元素内。<br>下面的CSS类会根据表单的验证状态自动设置：</li>\n</ol>\n</li>\n<li> 表单合法时设置ng-valid；</li>\n<li> 表单不合法时设置ng-invlid；</li>\n<li> 表单未进行修改时设置ng-pristion；</li>\n<li> 表单进行过修改时设置ng-dirty。<br>Angular不会将表单提交到服务器，除非它指定了action属性。要指定提交表单时调用哪个JavaScript方法，使用下面两个指令中的一个。</li>\n<li> ng-submit：在表单元素上使用。</li>\n<li><p> ng-click：在第一个按钮或submit类型（input[type=submit]）的输入字段上使用。<br>为了避免处理程序被多次调用，只使用下面两个指令中的一个。<br>下面的例子展示了如何通过服务器返回的JSON数据动态生成一个表单。我们用ng-loop来遍历从服务器取回的所有数据。由于不能动态生成name属性，而我们又需要这个属性做验证，所以在循环的过程中会为每一个字段都生成一个新表单。由于AngularJS中用来取代<form>的ng-form指令可以嵌套，并且外部表单在所有子表单都合法之前一直处于不合法状态，因此我们可以在动态生成子表单的同时使用表单验证功能。是的，鱼和熊掌可以兼得。<br>下面先看一下我们硬编码的JSON数据，把它假设成是从服务器返回的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp&apos;,[])</div><div class=\"line\">.controller(&apos;FormController&apos;,function($scope) &#123;</div><div class=\"line\">$scope.fields = [</div><div class=\"line\">&#123;placeholder: &apos;Username&apos;, isRequired: true&#125;,</div><div class=\"line\">&#123;placeholder: &apos;Password&apos;, isRequired: true&#125;,</div><div class=\"line\">&#123;placeholder: &apos;Email (optional)&apos;, isRequired: false&#125;</div><div class=\"line\">];</div><div class=\"line\">$scope.submitForm = function() &#123;</div><div class=\"line\">alert(&quot;it works!&quot;);</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;);</div><div class=\"line\">下面用这些数据生成一个有验证功能的动态表单：</div><div class=\"line\">&lt;form name=&quot;signup_form&quot;</div><div class=\"line\">ng-controller=&quot;FormController&quot;</div><div class=\"line\">ng-submit=&quot;submitForm()&quot; novalidate&gt;</div><div class=\"line\">&lt;div ng-repeat=&quot;field in fields&quot;</div><div class=\"line\">ng-form=&quot;signup_form_input&quot;&gt;</div><div class=\"line\">&lt;input type=&quot;text&quot;</div><div class=\"line\">name=&quot;dynamic_input&quot;</div><div class=\"line\">ng-required=&quot;field.isRequired&quot;</div><div class=\"line\">ng-model=&quot;field.name&quot;</div><div class=\"line\">placeholder=&quot;&#123;&#123;field.placeholder&#125;&#125;&quot; /&gt;</div><div class=\"line\">&lt;div</div><div class=\"line\">ng-show=&quot;signup_form_input.dynamic_input.$dirty &amp;&amp;</div><div class=\"line\">signup_form_input.dynamic_input.$invalid&quot;&gt;</div><div class=\"line\">&lt;span class=&quot;error&quot;</div><div class=\"line\">ng-show=&quot;signup_form_input.dynamic_input.$error.required&quot;&gt;</div><div class=\"line\">The field is required.</div><div class=\"line\">&lt;/span&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">&lt;button type=&quot;submit&quot;</div><div class=\"line\">ng-disabled=&quot;signup_form.$invalid&quot;&gt;</div><div class=\"line\">Submit All</div><div class=\"line\">&lt;/button&gt;</div><div class=\"line\">&lt;/form&gt;</div><div class=\"line\">input.ng-invalid &#123;</div><div class=\"line\">border: 1px solid red;</div><div class=\"line\">&#125;</div><div class=\"line\">input.ng-valid &#123;</div><div class=\"line\">border: 1px solid green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>ng-click<br>ng-click用来指定一个元素被点击时调用的方法或表达式。</li>\n<li>ng-select<br>ng-select用来将数据同HTML的<code>&lt;select&gt;</code>元素进行绑定。这个指令可以和ng-model以及ng-options指令一同使用，构建精细且表现优良的动态表单。<br>ng-options的值可以是一个内涵表达式（comprehension expression），其实这只是一种有趣的说法，简单来说就是它可以接受一个数组或对象，并对它们进行循环，将内部的内容提供给select标签内部的选项。它可以是下面两种形式。</li>\n</ol>\n</li>\n<li> 数组作为数据源：</li>\n</ol>\n<ul>\n<li> 用数组中的值做标签；</li>\n<li> 用数组中的值作为选中的标签；</li>\n<li> 用数组中的值做标签组；</li>\n<li> 用数组中的值作为选中的标签组。</li>\n</ul>\n<ol>\n<li> 对象作为数据源：</li>\n</ol>\n<ul>\n<li> 用对象的键-值（key-value）做标签；</li>\n<li> 用对象的键-值作为选中的标签；</li>\n<li> 用对象的键-值作为标签组；</li>\n<li><p> 用对象的键-值作为选中的标签组。<br>下面看一个ng-select指令的实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-controller=&quot;CityController&quot;&gt;</div><div class=\"line\">&lt;select ng-model=&quot;city&quot;</div><div class=\"line\">ng-options=&quot;city.name for city in cities&quot;&gt;</div><div class=\"line\">&lt;option value=&quot;&quot;&gt;Choose City&lt;/option&gt;</div><div class=\"line\">&lt;/select&gt;</div><div class=\"line\">Best City: &#123;&#123; city.name &#125;&#125;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">angular.module(&apos;myApp&apos;,[])</div><div class=\"line\">.controller(&apos;CityController&apos;,function($scope) &#123;</div><div class=\"line\">$scope.cities = [</div><div class=\"line\">&#123;name: &apos;Seattle&apos;&#125;,</div><div class=\"line\">&#123;name: &apos;San Francisco&apos;&#125;,</div><div class=\"line\">&#123;name: &apos;Chicago&apos;&#125;,</div><div class=\"line\">&#123;name: &apos;New York&apos;&#125;,</div><div class=\"line\">&#123;name: &apos;Boston&apos;&#125;</div><div class=\"line\">];</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ol>\n<li><p>ng-submit<br>ng-submit用来将表达式同onsubmit事件进行绑定。这个指令同时会阻止默认行为（发送请求并重新加载页面）， 除非表单不含有action属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form ng-submit=&quot;submit()&quot;</div><div class=\"line\">ng-controller=&quot;FormController&quot;&gt;</div><div class=\"line\">Enter text and hit enter:</div><div class=\"line\">&lt;input type=&quot;text&quot;</div><div class=\"line\">ng-model=&quot;person.name&quot;</div><div class=\"line\">name=&quot;person.name&quot; /&gt;</div><div class=\"line\">&lt;input type=&quot;submit&quot;</div><div class=\"line\">name=&quot;person.name&quot;</div><div class=\"line\">value=&quot;Submit&quot; /&gt;</div><div class=\"line\">&lt;code&gt;people=&#123;&#123;people&#125;&#125;&lt;/code&gt;</div><div class=\"line\">&lt;ul ng-repeat=&quot;(index, object) in people&quot;&gt;</div><div class=\"line\">&lt;li&gt;&#123;&#123; object.name &#125;&#125;&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div><div class=\"line\">&lt;/form&gt;</div><div class=\"line\">angular.module(&apos;myApp&apos;,[])</div><div class=\"line\">.controller(&apos;FormController&apos;,function($scope) &#123;</div><div class=\"line\">$scope.person = &#123;</div><div class=\"line\">name: null</div><div class=\"line\">&#125;;</div><div class=\"line\">$scope.people = [];</div><div class=\"line\">$scope.submit = function() &#123;</div><div class=\"line\">if ($scope.person.name) &#123;</div><div class=\"line\">$scope.people.push(&#123;name: $scope.person.name&#125;);</div><div class=\"line\">$scope.person.name = &apos;&apos;;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>ng-class<br>使用ng-class 动态设置元素的类，方法是绑定一个代表所有需要添加的类的表达式。重复的类不会添加。当表达式发生变化，先前添加的类会被移除，新类会被添加。<br>下面的例子会用ng-class在一个随机数大于5时将.red类添加到一个div上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-controller=&quot;LotteryController&quot;&gt;</div><div class=\"line\">&lt;div ng-class=&quot;&#123;red: x &gt; 5&#125;&quot;//ng-class=&quot;&#123;red: x &gt; 5,green:x&lt;5&#125; 加多个类时用逗号隔开即可。</div><div class=\"line\">ng-if=&quot;x &gt; 5&quot;&gt;</div><div class=\"line\">You won!</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">&lt;button ng-click=&quot;generateNumber()&quot;</div><div class=\"line\">ng-init=&quot;x = 0&quot;&gt;</div><div class=\"line\">Draw Number</div><div class=\"line\">&lt;/button&gt;</div><div class=\"line\">&lt;p&gt;Number is: &#123;&#123; x &#125;&#125;&lt;/p&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">.red &#123;</div><div class=\"line\">background-color: red;</div><div class=\"line\">&#125;</div><div class=\"line\">angular.module(&apos;myApp&apos;,[])</div><div class=\"line\">.controller(&apos;LotteryController&apos;, function($scope) &#123;</div><div class=\"line\">$scope.generateNumber = function() &#123;</div><div class=\"line\">return Math.floor((Math.random()*10)+1);</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p>ng-attr-(suffix)<br>当AngularJS编译DOM时会查找花括号{ { some expression } }内的表达式。这些表达式会被自动注册到$watch服务中并更新到$digest循环中，成为它的一部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;-- updated when`someExpression` on the$scope</div><div class=\"line\">is updated --&gt;</div><div class=\"line\">&lt;h1&gt;Hello&#123;&#123;someExpression&#125;&#125;&lt;/h1&gt;</div><div class=\"line\">有时浏览器会对属性会进行很苛刻的限制。 SVG就是一个例子：</div><div class=\"line\">&lt;svg&gt;</div><div class=\"line\">&lt;circle cx=&quot;&#123;&#123; cx &#125;&#125;&quot;&gt;&lt;/circle&gt;</div><div class=\"line\">&lt;/svg&gt;</div><div class=\"line\">运行上面的代码会抛出一个错误，指出我们有一个非法属性。可以用ng-attr-cx来解决这</div><div class=\"line\">个问题。注意， cx位于这个名称的尾部。在这个属性中，通过用&#123;&#123; &#125;&#125;来写表达式，达到前面提</div><div class=\"line\">到的目的。</div><div class=\"line\">&lt;svg&gt;</div><div class=\"line\">&lt;circle ng-attr-cx=&quot;&#123;&#123; cx &#125;&#125;&quot;&gt;&lt;circle&gt;</div><div class=\"line\">&lt;/svg&gt;</div><div class=\"line\">&#123;&#123;person.name || &quot;无&quot;&#125;&#125; //绑定时做简单判断可以这么写。</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n"},{"title":"让AngularJS指令符合html5规范","date":"2016-12-12T14:04:54.000Z","_content":"　　AngularJS,是Google开源的一款JavaScript MVVM框架，弥补了HTML在构建应用方面的不足，其通过使用指令（directives）结构来扩展HTML的属性，使开发者可以使用HTML来声明动态内容，从而使得Web开发和测试工作变得更加容易。\n\n　　在学习中无意间看到有人说自定义指令如果想符合HTML5规范，可以加上data-*或者x-*前缀，对指令本身不影响，我顺便也试了下默认指令，发现ng-app、ng-model、ng-bind这类默认指令也可以直接加上data-*的前缀，而且完全不用配置，不影响功能。\n\n　　所以，为了遵循HTML5规范，我们也可以使用data-ng-app、data-ng-model、data-ng-bind这样的属性来使用AngularJS的默认指令了。\n\n　　最后来验证一下：原程序里面是这样写的\n```\nvar ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];\n```\n　　所以说，ng-、data-ng-、ng:、x-ng-，都是可以生效的。\n","source":"_posts/angular-html5.md","raw":"---\ntitle: 让AngularJS指令符合html5规范\ndate: 2016-12-12 22:04:54\ntags: angular、html5\n---\n　　AngularJS,是Google开源的一款JavaScript MVVM框架，弥补了HTML在构建应用方面的不足，其通过使用指令（directives）结构来扩展HTML的属性，使开发者可以使用HTML来声明动态内容，从而使得Web开发和测试工作变得更加容易。\n\n　　在学习中无意间看到有人说自定义指令如果想符合HTML5规范，可以加上data-*或者x-*前缀，对指令本身不影响，我顺便也试了下默认指令，发现ng-app、ng-model、ng-bind这类默认指令也可以直接加上data-*的前缀，而且完全不用配置，不影响功能。\n\n　　所以，为了遵循HTML5规范，我们也可以使用data-ng-app、data-ng-model、data-ng-bind这样的属性来使用AngularJS的默认指令了。\n\n　　最后来验证一下：原程序里面是这样写的\n```\nvar ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];\n```\n　　所以说，ng-、data-ng-、ng:、x-ng-，都是可以生效的。\n","slug":"angular-html5","published":1,"updated":"2016-12-13T05:49:39.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv6j000rjgtujvvi3zmi","content":"<p>　　AngularJS,是Google开源的一款JavaScript MVVM框架，弥补了HTML在构建应用方面的不足，其通过使用指令（directives）结构来扩展HTML的属性，使开发者可以使用HTML来声明动态内容，从而使得Web开发和测试工作变得更加容易。</p>\n<p>　　在学习中无意间看到有人说自定义指令如果想符合HTML5规范，可以加上data-<em>或者x-</em>前缀，对指令本身不影响，我顺便也试了下默认指令，发现ng-app、ng-model、ng-bind这类默认指令也可以直接加上data-*的前缀，而且完全不用配置，不影响功能。</p>\n<p>　　所以，为了遵循HTML5规范，我们也可以使用data-ng-app、data-ng-model、data-ng-bind这样的属性来使用AngularJS的默认指令了。</p>\n<p>　　最后来验证一下：原程序里面是这样写的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var ngAttrPrefixes = [&apos;ng-&apos;, &apos;data-ng-&apos;, &apos;ng:&apos;, &apos;x-ng-&apos;];</div></pre></td></tr></table></figure></p>\n<p>　　所以说，ng-、data-ng-、ng:、x-ng-，都是可以生效的。</p>\n","excerpt":"","more":"<p>　　AngularJS,是Google开源的一款JavaScript MVVM框架，弥补了HTML在构建应用方面的不足，其通过使用指令（directives）结构来扩展HTML的属性，使开发者可以使用HTML来声明动态内容，从而使得Web开发和测试工作变得更加容易。</p>\n<p>　　在学习中无意间看到有人说自定义指令如果想符合HTML5规范，可以加上data-<em>或者x-</em>前缀，对指令本身不影响，我顺便也试了下默认指令，发现ng-app、ng-model、ng-bind这类默认指令也可以直接加上data-*的前缀，而且完全不用配置，不影响功能。</p>\n<p>　　所以，为了遵循HTML5规范，我们也可以使用data-ng-app、data-ng-model、data-ng-bind这样的属性来使用AngularJS的默认指令了。</p>\n<p>　　最后来验证一下：原程序里面是这样写的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var ngAttrPrefixes = [&apos;ng-&apos;, &apos;data-ng-&apos;, &apos;ng:&apos;, &apos;x-ng-&apos;];</div></pre></td></tr></table></figure></p>\n<p>　　所以说，ng-、data-ng-、ng:、x-ng-，都是可以生效的。</p>\n"},{"title":"通过$q,angular可以实现两种形式的promise","date":"2016-12-01T03:50:04.000Z","_content":"#### $q\n在angular中，$q是一个非常重要的service。通过$q，angular有两种比较常用的方式来实现promise，分别是ES6风格与jquery风格。\n\n**ES6风格实现代码如下：**\n```\n<div ng-app=\"app\" ng-controller=\"demoController\"></div>\nangular.module('app', [])\n.controller('demoController', function($q, $timeout) {\n    var a = 1;\n    $q(function(resolve, reject) {\n        $timeout(function() {\n            if(a == 1) {\n                console.log('resolve');\n                resolve('hello, JAKE');    \n            } else {\n                console.log('reject');\n                reject('JAKE is not here!')\n            }\n        }, 2000)\n    })\n    .then(function(greeting) {\n        console.log('success, ' + greeting);\n    }, function(reason) {\n        console.log('failed, ' + reason);\n    })\n})\n```\n当a==1，输出结果为\n```\n\"resolve\"\n\"success, hello, JAKE\"\n```\n\n当a!=1，输出结果为\n```\n\"reject\"\n\"failed, JAKE is not here!\"\n```\n上例中，我直接将第一步逻辑在$q()中处理。回调函数有两个参数，resolve, reject，分别代表执行成功与失败。\n然后在对应的逻辑里面，使用resolve/reject标记逻辑的执行状态。then方法中的代码会在第一步的逻辑执行完了才执行。\n**jquery风格代码如下**\n  \n  与jquery实现类似，我们需要定义个defer对象，并在第一步逻辑中手动返回promise\n```\nangular.module('app', [])\n.controller('demoController', function($q, $timeout) {\n    var a = 1;\n    $q.when(function() {//$q.when()方法能把函数的返回值包装成一个promise,这样可以用then方法了。\n        var defer = $q.defer();\n        $timeout(function() {\n            defer.notify('notify jake.');//notify用在resolve和reject之前，在两者之前被调用。\n            \n            if(a == 1) {\n                console.log('rsolve');\n                defer.resolve('hello, jake');\n            }\n            else {\n                console.log('reject');\n                defer.reject('jake is not here.')\n            }\n        }, 2000);\n        return defer.promise;\n    }())\n    .then(function(greeting) {\n        console.log('success, ' + greeting);\n    }, function(reason) {\n        console.log('fail, ' + reason);\n    }, function(update) {\n        console.log('notify, ' + update);\n    })\n})\n```\n当a==1，输出结果为\n```\n//先打印状态，再defer.resolve或者defer.reject之前执行defer.notify，之后才执行defer.resolve或者defer.reject。\n\"rsolve\"\n\"notify, notify jake.\"\n\"success, hello, jake\"\n```\n当a!=1 输出结果为\n```\n\"reject\"\n\"notify, notify jake.\"\n\"fail, jake is not here.\"\n```\n**Angular 中 Promise 的一些方法，其实从上面的实例就已经能够知道promise的大概用法，不算复杂。**\n\n1. then(successCallback, errorCallback, notifyCallback)\n从字面上我们就能够看出then三个回调的含义，第二个参数与第三个参数为可选。\n\n2. catch(errorCallback) \n相当于 then(null, errorCallback)\n\n3. finally(callback)\n无论promise的返回状态是resolve还是reject，该方法总是会执行。\n#### 链式操作\n如果then中逻辑的执行需要时间等待，那么，then中回调函数的返回值为promise对象时，才能够按顺序执行。因此需要我们手动返回一个promise对象，例子如下\n```\nvar app = angular.module('app', []);\n\napp.controller('demoController', function($q, $timeout) {\n    $q.when(function() {\n        var defer = $q.defer();\n        $timeout(function() {\n            console.log('first');\n            defer.resolve();\n        }, 2000);\n        return defer.promise;\n    }())\n    .then(function() {\n        var defer = $q.defer();\n        $timeout(function() {\n            defer.resolve();\n            console.log('second');\n        }, 1000);\n        return defer.promise;\n    })\n    .then(function() {\n        console.log('third');    \n    })\n});\n```\n```\n//结果如下：\n\"first\"\n\"second\"\n\"third\"\n```\n官方文档中，认为then方法中只需要有返回值即可，但是如果then的执行不需要时间等待，then中的回调函数的第一个参数，会获取到上一个then的返回值，然后按顺序执行，如下：\n```\nvar app = angular.module('app', []);\n\napp.controller('demoController', function($q, $timeout) {\n    \n    function first() {\n        var a = 1;\n        var defer = $q.defer();\n        $timeout(function() {\n            if(a == 1) {\n                console.log('first resolve');\n                defer.resolve('resolve result');    \n            } else {\n                console.log('first reject');\n                defer.reject();\n            }\n        }, 2000)\n        return defer.promise;\n    }\n    \n    var promiseA = first();\n    \n    promiseA.then(function(result) {\n        // $timeout(function() {\n        console.log('second, ' + result);\n        return 'document';\n        // }, 1000)\n        \n    })\n    .then(function(result) {\n        console.log('third, ' + result);\n    })\n    \n});\n```\n```\n//结果如下：\n\"first resolve\"\n\"second, resolve result\"\n\"third, document\"\n```\n#### $http\n$http是对promise的最佳实践。由于项目中有多个controller要用到请求回来的数据，在每一个控制器内都写一遍会使代码冗余，也太麻烦，因此我们常常会将获取数据的操作放在自定义的服务中。例子如下：\n```\nangular.module('app', [])\n.controller('demoController', function(dataFactory) {\n    dataFactory.getData().then(function(resp) {\n        console.log(resp);\n    })\n})\n.factory('dataFactory', function($http) {\n    return {\n        getData: function() {\n            var url = 'https://www.webywx.com/list?id=1';\n            return $http.get(url);    \n        }\n    }\n})\n```\n我们将then中回调函数的参数打印出来，发现格式如下:\n```\nObject {\n    config: Object {},\n    data: Object {},\n    headers: function(d) {},\n    status: 200,\n    statusText: 'OK'\n}\n```\n这一点与jquery的返回值略有不同，他们分别表示的意思为\n```\nconfig： 请求的配置信息\ndata： 返回的数据\nheaders: 请求的头部信息\nstatus: 返回的状态码\n```\n","source":"_posts/angular-promise-two.md","raw":"---\ntitle: 通过$q,angular可以实现两种形式的promise\ndate: 2016-12-1 11:50:04\ntags: angular $q promise\n---\n#### $q\n在angular中，$q是一个非常重要的service。通过$q，angular有两种比较常用的方式来实现promise，分别是ES6风格与jquery风格。\n\n**ES6风格实现代码如下：**\n```\n<div ng-app=\"app\" ng-controller=\"demoController\"></div>\nangular.module('app', [])\n.controller('demoController', function($q, $timeout) {\n    var a = 1;\n    $q(function(resolve, reject) {\n        $timeout(function() {\n            if(a == 1) {\n                console.log('resolve');\n                resolve('hello, JAKE');    \n            } else {\n                console.log('reject');\n                reject('JAKE is not here!')\n            }\n        }, 2000)\n    })\n    .then(function(greeting) {\n        console.log('success, ' + greeting);\n    }, function(reason) {\n        console.log('failed, ' + reason);\n    })\n})\n```\n当a==1，输出结果为\n```\n\"resolve\"\n\"success, hello, JAKE\"\n```\n\n当a!=1，输出结果为\n```\n\"reject\"\n\"failed, JAKE is not here!\"\n```\n上例中，我直接将第一步逻辑在$q()中处理。回调函数有两个参数，resolve, reject，分别代表执行成功与失败。\n然后在对应的逻辑里面，使用resolve/reject标记逻辑的执行状态。then方法中的代码会在第一步的逻辑执行完了才执行。\n**jquery风格代码如下**\n  \n  与jquery实现类似，我们需要定义个defer对象，并在第一步逻辑中手动返回promise\n```\nangular.module('app', [])\n.controller('demoController', function($q, $timeout) {\n    var a = 1;\n    $q.when(function() {//$q.when()方法能把函数的返回值包装成一个promise,这样可以用then方法了。\n        var defer = $q.defer();\n        $timeout(function() {\n            defer.notify('notify jake.');//notify用在resolve和reject之前，在两者之前被调用。\n            \n            if(a == 1) {\n                console.log('rsolve');\n                defer.resolve('hello, jake');\n            }\n            else {\n                console.log('reject');\n                defer.reject('jake is not here.')\n            }\n        }, 2000);\n        return defer.promise;\n    }())\n    .then(function(greeting) {\n        console.log('success, ' + greeting);\n    }, function(reason) {\n        console.log('fail, ' + reason);\n    }, function(update) {\n        console.log('notify, ' + update);\n    })\n})\n```\n当a==1，输出结果为\n```\n//先打印状态，再defer.resolve或者defer.reject之前执行defer.notify，之后才执行defer.resolve或者defer.reject。\n\"rsolve\"\n\"notify, notify jake.\"\n\"success, hello, jake\"\n```\n当a!=1 输出结果为\n```\n\"reject\"\n\"notify, notify jake.\"\n\"fail, jake is not here.\"\n```\n**Angular 中 Promise 的一些方法，其实从上面的实例就已经能够知道promise的大概用法，不算复杂。**\n\n1. then(successCallback, errorCallback, notifyCallback)\n从字面上我们就能够看出then三个回调的含义，第二个参数与第三个参数为可选。\n\n2. catch(errorCallback) \n相当于 then(null, errorCallback)\n\n3. finally(callback)\n无论promise的返回状态是resolve还是reject，该方法总是会执行。\n#### 链式操作\n如果then中逻辑的执行需要时间等待，那么，then中回调函数的返回值为promise对象时，才能够按顺序执行。因此需要我们手动返回一个promise对象，例子如下\n```\nvar app = angular.module('app', []);\n\napp.controller('demoController', function($q, $timeout) {\n    $q.when(function() {\n        var defer = $q.defer();\n        $timeout(function() {\n            console.log('first');\n            defer.resolve();\n        }, 2000);\n        return defer.promise;\n    }())\n    .then(function() {\n        var defer = $q.defer();\n        $timeout(function() {\n            defer.resolve();\n            console.log('second');\n        }, 1000);\n        return defer.promise;\n    })\n    .then(function() {\n        console.log('third');    \n    })\n});\n```\n```\n//结果如下：\n\"first\"\n\"second\"\n\"third\"\n```\n官方文档中，认为then方法中只需要有返回值即可，但是如果then的执行不需要时间等待，then中的回调函数的第一个参数，会获取到上一个then的返回值，然后按顺序执行，如下：\n```\nvar app = angular.module('app', []);\n\napp.controller('demoController', function($q, $timeout) {\n    \n    function first() {\n        var a = 1;\n        var defer = $q.defer();\n        $timeout(function() {\n            if(a == 1) {\n                console.log('first resolve');\n                defer.resolve('resolve result');    \n            } else {\n                console.log('first reject');\n                defer.reject();\n            }\n        }, 2000)\n        return defer.promise;\n    }\n    \n    var promiseA = first();\n    \n    promiseA.then(function(result) {\n        // $timeout(function() {\n        console.log('second, ' + result);\n        return 'document';\n        // }, 1000)\n        \n    })\n    .then(function(result) {\n        console.log('third, ' + result);\n    })\n    \n});\n```\n```\n//结果如下：\n\"first resolve\"\n\"second, resolve result\"\n\"third, document\"\n```\n#### $http\n$http是对promise的最佳实践。由于项目中有多个controller要用到请求回来的数据，在每一个控制器内都写一遍会使代码冗余，也太麻烦，因此我们常常会将获取数据的操作放在自定义的服务中。例子如下：\n```\nangular.module('app', [])\n.controller('demoController', function(dataFactory) {\n    dataFactory.getData().then(function(resp) {\n        console.log(resp);\n    })\n})\n.factory('dataFactory', function($http) {\n    return {\n        getData: function() {\n            var url = 'https://www.webywx.com/list?id=1';\n            return $http.get(url);    \n        }\n    }\n})\n```\n我们将then中回调函数的参数打印出来，发现格式如下:\n```\nObject {\n    config: Object {},\n    data: Object {},\n    headers: function(d) {},\n    status: 200,\n    statusText: 'OK'\n}\n```\n这一点与jquery的返回值略有不同，他们分别表示的意思为\n```\nconfig： 请求的配置信息\ndata： 返回的数据\nheaders: 请求的头部信息\nstatus: 返回的状态码\n```\n","slug":"angular-promise-two","published":1,"updated":"2016-12-23T08:01:56.379Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv6m000sjgtui64nl14i","content":"<h4 id=\"q\"><a href=\"#q\" class=\"headerlink\" title=\"$q\"></a>$q</h4><p>在angular中，$q是一个非常重要的service。通过$q，angular有两种比较常用的方式来实现promise，分别是ES6风格与jquery风格。</p>\n<p><strong>ES6风格实现代码如下：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=&quot;app&quot; ng-controller=&quot;demoController&quot;&gt;&lt;/div&gt;</div><div class=\"line\">angular.module(&apos;app&apos;, [])</div><div class=\"line\">.controller(&apos;demoController&apos;, function($q, $timeout) &#123;</div><div class=\"line\">    var a = 1;</div><div class=\"line\">    $q(function(resolve, reject) &#123;</div><div class=\"line\">        $timeout(function() &#123;</div><div class=\"line\">            if(a == 1) &#123;</div><div class=\"line\">                console.log(&apos;resolve&apos;);</div><div class=\"line\">                resolve(&apos;hello, JAKE&apos;);    </div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                console.log(&apos;reject&apos;);</div><div class=\"line\">                reject(&apos;JAKE is not here!&apos;)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;, 2000)</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .then(function(greeting) &#123;</div><div class=\"line\">        console.log(&apos;success, &apos; + greeting);</div><div class=\"line\">    &#125;, function(reason) &#123;</div><div class=\"line\">        console.log(&apos;failed, &apos; + reason);</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>当a==1，输出结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;resolve&quot;</div><div class=\"line\">&quot;success, hello, JAKE&quot;</div></pre></td></tr></table></figure></p>\n<p>当a!=1，输出结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;reject&quot;</div><div class=\"line\">&quot;failed, JAKE is not here!&quot;</div></pre></td></tr></table></figure></p>\n<p>上例中，我直接将第一步逻辑在$q()中处理。回调函数有两个参数，resolve, reject，分别代表执行成功与失败。<br>然后在对应的逻辑里面，使用resolve/reject标记逻辑的执行状态。then方法中的代码会在第一步的逻辑执行完了才执行。<br><strong>jquery风格代码如下</strong></p>\n<p>  与jquery实现类似，我们需要定义个defer对象，并在第一步逻辑中手动返回promise<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;app&apos;, [])</div><div class=\"line\">.controller(&apos;demoController&apos;, function($q, $timeout) &#123;</div><div class=\"line\">    var a = 1;</div><div class=\"line\">    $q.when(function() &#123;//$q.when()方法能把函数的返回值包装成一个promise,这样可以用then方法了。</div><div class=\"line\">        var defer = $q.defer();</div><div class=\"line\">        $timeout(function() &#123;</div><div class=\"line\">            defer.notify(&apos;notify jake.&apos;);//notify用在resolve和reject之前，在两者之前被调用。</div><div class=\"line\">            </div><div class=\"line\">            if(a == 1) &#123;</div><div class=\"line\">                console.log(&apos;rsolve&apos;);</div><div class=\"line\">                defer.resolve(&apos;hello, jake&apos;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            else &#123;</div><div class=\"line\">                console.log(&apos;reject&apos;);</div><div class=\"line\">                defer.reject(&apos;jake is not here.&apos;)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;, 2000);</div><div class=\"line\">        return defer.promise;</div><div class=\"line\">    &#125;())</div><div class=\"line\">    .then(function(greeting) &#123;</div><div class=\"line\">        console.log(&apos;success, &apos; + greeting);</div><div class=\"line\">    &#125;, function(reason) &#123;</div><div class=\"line\">        console.log(&apos;fail, &apos; + reason);</div><div class=\"line\">    &#125;, function(update) &#123;</div><div class=\"line\">        console.log(&apos;notify, &apos; + update);</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>当a==1，输出结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//先打印状态，再defer.resolve或者defer.reject之前执行defer.notify，之后才执行defer.resolve或者defer.reject。</div><div class=\"line\">&quot;rsolve&quot;</div><div class=\"line\">&quot;notify, notify jake.&quot;</div><div class=\"line\">&quot;success, hello, jake&quot;</div></pre></td></tr></table></figure></p>\n<p>当a!=1 输出结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;reject&quot;</div><div class=\"line\">&quot;notify, notify jake.&quot;</div><div class=\"line\">&quot;fail, jake is not here.&quot;</div></pre></td></tr></table></figure></p>\n<p><strong>Angular 中 Promise 的一些方法，其实从上面的实例就已经能够知道promise的大概用法，不算复杂。</strong></p>\n<ol>\n<li><p>then(successCallback, errorCallback, notifyCallback)<br>从字面上我们就能够看出then三个回调的含义，第二个参数与第三个参数为可选。</p>\n</li>\n<li><p>catch(errorCallback)<br>相当于 then(null, errorCallback)</p>\n</li>\n<li><p>finally(callback)<br>无论promise的返回状态是resolve还是reject，该方法总是会执行。</p>\n<h4 id=\"链式操作\"><a href=\"#链式操作\" class=\"headerlink\" title=\"链式操作\"></a>链式操作</h4><p>如果then中逻辑的执行需要时间等待，那么，then中回调函数的返回值为promise对象时，才能够按顺序执行。因此需要我们手动返回一个promise对象，例子如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;app&apos;, []);</div><div class=\"line\"></div><div class=\"line\">app.controller(&apos;demoController&apos;, function($q, $timeout) &#123;</div><div class=\"line\">    $q.when(function() &#123;</div><div class=\"line\">        var defer = $q.defer();</div><div class=\"line\">        $timeout(function() &#123;</div><div class=\"line\">            console.log(&apos;first&apos;);</div><div class=\"line\">            defer.resolve();</div><div class=\"line\">        &#125;, 2000);</div><div class=\"line\">        return defer.promise;</div><div class=\"line\">    &#125;())</div><div class=\"line\">    .then(function() &#123;</div><div class=\"line\">        var defer = $q.defer();</div><div class=\"line\">        $timeout(function() &#123;</div><div class=\"line\">            defer.resolve();</div><div class=\"line\">            console.log(&apos;second&apos;);</div><div class=\"line\">        &#125;, 1000);</div><div class=\"line\">        return defer.promise;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .then(function() &#123;</div><div class=\"line\">        console.log(&apos;third&apos;);    </div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//结果如下：</div><div class=\"line\">&quot;first&quot;</div><div class=\"line\">&quot;second&quot;</div><div class=\"line\">&quot;third&quot;</div></pre></td></tr></table></figure>\n<p>官方文档中，认为then方法中只需要有返回值即可，但是如果then的执行不需要时间等待，then中的回调函数的第一个参数，会获取到上一个then的返回值，然后按顺序执行，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;app&apos;, []);</div><div class=\"line\"></div><div class=\"line\">app.controller(&apos;demoController&apos;, function($q, $timeout) &#123;</div><div class=\"line\">    </div><div class=\"line\">    function first() &#123;</div><div class=\"line\">        var a = 1;</div><div class=\"line\">        var defer = $q.defer();</div><div class=\"line\">        $timeout(function() &#123;</div><div class=\"line\">            if(a == 1) &#123;</div><div class=\"line\">                console.log(&apos;first resolve&apos;);</div><div class=\"line\">                defer.resolve(&apos;resolve result&apos;);    </div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                console.log(&apos;first reject&apos;);</div><div class=\"line\">                defer.reject();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;, 2000)</div><div class=\"line\">        return defer.promise;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    var promiseA = first();</div><div class=\"line\">    </div><div class=\"line\">    promiseA.then(function(result) &#123;</div><div class=\"line\">        // $timeout(function() &#123;</div><div class=\"line\">        console.log(&apos;second, &apos; + result);</div><div class=\"line\">        return &apos;document&apos;;</div><div class=\"line\">        // &#125;, 1000)</div><div class=\"line\">        </div><div class=\"line\">    &#125;)</div><div class=\"line\">    .then(function(result) &#123;</div><div class=\"line\">        console.log(&apos;third, &apos; + result);</div><div class=\"line\">    &#125;)</div><div class=\"line\">    </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//结果如下：</div><div class=\"line\">&quot;first resolve&quot;</div><div class=\"line\">&quot;second, resolve result&quot;</div><div class=\"line\">&quot;third, document&quot;</div></pre></td></tr></table></figure>\n<h4 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"$http\"></a>$http</h4><p>$http是对promise的最佳实践。由于项目中有多个controller要用到请求回来的数据，在每一个控制器内都写一遍会使代码冗余，也太麻烦，因此我们常常会将获取数据的操作放在自定义的服务中。例子如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;app&apos;, [])</div><div class=\"line\">.controller(&apos;demoController&apos;, function(dataFactory) &#123;</div><div class=\"line\">    dataFactory.getData().then(function(resp) &#123;</div><div class=\"line\">        console.log(resp);</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\">.factory(&apos;dataFactory&apos;, function($http) &#123;</div><div class=\"line\">    return &#123;</div><div class=\"line\">        getData: function() &#123;</div><div class=\"line\">            var url = &apos;https://www.webywx.com/list?id=1&apos;;</div><div class=\"line\">            return $http.get(url);    </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>我们将then中回调函数的参数打印出来，发现格式如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object &#123;</div><div class=\"line\">    config: Object &#123;&#125;,</div><div class=\"line\">    data: Object &#123;&#125;,</div><div class=\"line\">    headers: function(d) &#123;&#125;,</div><div class=\"line\">    status: 200,</div><div class=\"line\">    statusText: &apos;OK&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这一点与jquery的返回值略有不同，他们分别表示的意思为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">config： 请求的配置信息</div><div class=\"line\">data： 返回的数据</div><div class=\"line\">headers: 请求的头部信息</div><div class=\"line\">status: 返回的状态码</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<h4 id=\"q\"><a href=\"#q\" class=\"headerlink\" title=\"$q\"></a>$q</h4><p>在angular中，$q是一个非常重要的service。通过$q，angular有两种比较常用的方式来实现promise，分别是ES6风格与jquery风格。</p>\n<p><strong>ES6风格实现代码如下：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=&quot;app&quot; ng-controller=&quot;demoController&quot;&gt;&lt;/div&gt;</div><div class=\"line\">angular.module(&apos;app&apos;, [])</div><div class=\"line\">.controller(&apos;demoController&apos;, function($q, $timeout) &#123;</div><div class=\"line\">    var a = 1;</div><div class=\"line\">    $q(function(resolve, reject) &#123;</div><div class=\"line\">        $timeout(function() &#123;</div><div class=\"line\">            if(a == 1) &#123;</div><div class=\"line\">                console.log(&apos;resolve&apos;);</div><div class=\"line\">                resolve(&apos;hello, JAKE&apos;);    </div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                console.log(&apos;reject&apos;);</div><div class=\"line\">                reject(&apos;JAKE is not here!&apos;)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;, 2000)</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .then(function(greeting) &#123;</div><div class=\"line\">        console.log(&apos;success, &apos; + greeting);</div><div class=\"line\">    &#125;, function(reason) &#123;</div><div class=\"line\">        console.log(&apos;failed, &apos; + reason);</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>当a==1，输出结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;resolve&quot;</div><div class=\"line\">&quot;success, hello, JAKE&quot;</div></pre></td></tr></table></figure></p>\n<p>当a!=1，输出结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;reject&quot;</div><div class=\"line\">&quot;failed, JAKE is not here!&quot;</div></pre></td></tr></table></figure></p>\n<p>上例中，我直接将第一步逻辑在$q()中处理。回调函数有两个参数，resolve, reject，分别代表执行成功与失败。<br>然后在对应的逻辑里面，使用resolve/reject标记逻辑的执行状态。then方法中的代码会在第一步的逻辑执行完了才执行。<br><strong>jquery风格代码如下</strong></p>\n<p>  与jquery实现类似，我们需要定义个defer对象，并在第一步逻辑中手动返回promise<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;app&apos;, [])</div><div class=\"line\">.controller(&apos;demoController&apos;, function($q, $timeout) &#123;</div><div class=\"line\">    var a = 1;</div><div class=\"line\">    $q.when(function() &#123;//$q.when()方法能把函数的返回值包装成一个promise,这样可以用then方法了。</div><div class=\"line\">        var defer = $q.defer();</div><div class=\"line\">        $timeout(function() &#123;</div><div class=\"line\">            defer.notify(&apos;notify jake.&apos;);//notify用在resolve和reject之前，在两者之前被调用。</div><div class=\"line\">            </div><div class=\"line\">            if(a == 1) &#123;</div><div class=\"line\">                console.log(&apos;rsolve&apos;);</div><div class=\"line\">                defer.resolve(&apos;hello, jake&apos;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            else &#123;</div><div class=\"line\">                console.log(&apos;reject&apos;);</div><div class=\"line\">                defer.reject(&apos;jake is not here.&apos;)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;, 2000);</div><div class=\"line\">        return defer.promise;</div><div class=\"line\">    &#125;())</div><div class=\"line\">    .then(function(greeting) &#123;</div><div class=\"line\">        console.log(&apos;success, &apos; + greeting);</div><div class=\"line\">    &#125;, function(reason) &#123;</div><div class=\"line\">        console.log(&apos;fail, &apos; + reason);</div><div class=\"line\">    &#125;, function(update) &#123;</div><div class=\"line\">        console.log(&apos;notify, &apos; + update);</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>当a==1，输出结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//先打印状态，再defer.resolve或者defer.reject之前执行defer.notify，之后才执行defer.resolve或者defer.reject。</div><div class=\"line\">&quot;rsolve&quot;</div><div class=\"line\">&quot;notify, notify jake.&quot;</div><div class=\"line\">&quot;success, hello, jake&quot;</div></pre></td></tr></table></figure></p>\n<p>当a!=1 输出结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;reject&quot;</div><div class=\"line\">&quot;notify, notify jake.&quot;</div><div class=\"line\">&quot;fail, jake is not here.&quot;</div></pre></td></tr></table></figure></p>\n<p><strong>Angular 中 Promise 的一些方法，其实从上面的实例就已经能够知道promise的大概用法，不算复杂。</strong></p>\n<ol>\n<li><p>then(successCallback, errorCallback, notifyCallback)<br>从字面上我们就能够看出then三个回调的含义，第二个参数与第三个参数为可选。</p>\n</li>\n<li><p>catch(errorCallback)<br>相当于 then(null, errorCallback)</p>\n</li>\n<li><p>finally(callback)<br>无论promise的返回状态是resolve还是reject，该方法总是会执行。</p>\n<h4 id=\"链式操作\"><a href=\"#链式操作\" class=\"headerlink\" title=\"链式操作\"></a>链式操作</h4><p>如果then中逻辑的执行需要时间等待，那么，then中回调函数的返回值为promise对象时，才能够按顺序执行。因此需要我们手动返回一个promise对象，例子如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;app&apos;, []);</div><div class=\"line\"></div><div class=\"line\">app.controller(&apos;demoController&apos;, function($q, $timeout) &#123;</div><div class=\"line\">    $q.when(function() &#123;</div><div class=\"line\">        var defer = $q.defer();</div><div class=\"line\">        $timeout(function() &#123;</div><div class=\"line\">            console.log(&apos;first&apos;);</div><div class=\"line\">            defer.resolve();</div><div class=\"line\">        &#125;, 2000);</div><div class=\"line\">        return defer.promise;</div><div class=\"line\">    &#125;())</div><div class=\"line\">    .then(function() &#123;</div><div class=\"line\">        var defer = $q.defer();</div><div class=\"line\">        $timeout(function() &#123;</div><div class=\"line\">            defer.resolve();</div><div class=\"line\">            console.log(&apos;second&apos;);</div><div class=\"line\">        &#125;, 1000);</div><div class=\"line\">        return defer.promise;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .then(function() &#123;</div><div class=\"line\">        console.log(&apos;third&apos;);    </div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//结果如下：</div><div class=\"line\">&quot;first&quot;</div><div class=\"line\">&quot;second&quot;</div><div class=\"line\">&quot;third&quot;</div></pre></td></tr></table></figure>\n<p>官方文档中，认为then方法中只需要有返回值即可，但是如果then的执行不需要时间等待，then中的回调函数的第一个参数，会获取到上一个then的返回值，然后按顺序执行，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;app&apos;, []);</div><div class=\"line\"></div><div class=\"line\">app.controller(&apos;demoController&apos;, function($q, $timeout) &#123;</div><div class=\"line\">    </div><div class=\"line\">    function first() &#123;</div><div class=\"line\">        var a = 1;</div><div class=\"line\">        var defer = $q.defer();</div><div class=\"line\">        $timeout(function() &#123;</div><div class=\"line\">            if(a == 1) &#123;</div><div class=\"line\">                console.log(&apos;first resolve&apos;);</div><div class=\"line\">                defer.resolve(&apos;resolve result&apos;);    </div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                console.log(&apos;first reject&apos;);</div><div class=\"line\">                defer.reject();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;, 2000)</div><div class=\"line\">        return defer.promise;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    var promiseA = first();</div><div class=\"line\">    </div><div class=\"line\">    promiseA.then(function(result) &#123;</div><div class=\"line\">        // $timeout(function() &#123;</div><div class=\"line\">        console.log(&apos;second, &apos; + result);</div><div class=\"line\">        return &apos;document&apos;;</div><div class=\"line\">        // &#125;, 1000)</div><div class=\"line\">        </div><div class=\"line\">    &#125;)</div><div class=\"line\">    .then(function(result) &#123;</div><div class=\"line\">        console.log(&apos;third, &apos; + result);</div><div class=\"line\">    &#125;)</div><div class=\"line\">    </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//结果如下：</div><div class=\"line\">&quot;first resolve&quot;</div><div class=\"line\">&quot;second, resolve result&quot;</div><div class=\"line\">&quot;third, document&quot;</div></pre></td></tr></table></figure>\n<h4 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"$http\"></a>$http</h4><p>$http是对promise的最佳实践。由于项目中有多个controller要用到请求回来的数据，在每一个控制器内都写一遍会使代码冗余，也太麻烦，因此我们常常会将获取数据的操作放在自定义的服务中。例子如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;app&apos;, [])</div><div class=\"line\">.controller(&apos;demoController&apos;, function(dataFactory) &#123;</div><div class=\"line\">    dataFactory.getData().then(function(resp) &#123;</div><div class=\"line\">        console.log(resp);</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\">.factory(&apos;dataFactory&apos;, function($http) &#123;</div><div class=\"line\">    return &#123;</div><div class=\"line\">        getData: function() &#123;</div><div class=\"line\">            var url = &apos;https://www.webywx.com/list?id=1&apos;;</div><div class=\"line\">            return $http.get(url);    </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>我们将then中回调函数的参数打印出来，发现格式如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object &#123;</div><div class=\"line\">    config: Object &#123;&#125;,</div><div class=\"line\">    data: Object &#123;&#125;,</div><div class=\"line\">    headers: function(d) &#123;&#125;,</div><div class=\"line\">    status: 200,</div><div class=\"line\">    statusText: &apos;OK&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这一点与jquery的返回值略有不同，他们分别表示的意思为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">config： 请求的配置信息</div><div class=\"line\">data： 返回的数据</div><div class=\"line\">headers: 请求的头部信息</div><div class=\"line\">status: 返回的状态码</div></pre></td></tr></table></figure></p>\n"},{"title":"AngularJS中的$http、$q服务和promise对象的联系","date":"2016-10-23T01:52:38.000Z","_content":"#### angular中的$http\n$http服务是AngularJS系统自带的，可以用来进行网络通信、获取远程服务器的数据。要记住的是，$http是对浏览器XMLHttpRequest的封装，也就是说，它其实是Ajax。\n\n首先为了用$http发起请求，我们得先找到一个可以测试的API，这里我用：https://randomuser.me/api/来测试：用get请求，它能够返回json格式的一个随机用户的资料。比如在浏览器中输入，可以看到返回的数据：\n ![](http://oi28tswuq.bkt.clouddn.com/images/data.png)\n 注：这是一个公开的测试接口，以后测试也可以用。\n \n #### $http的基本用法：\n ```\n $http(options).success(successFn).error(errorFn)\n ```\n options：包括url、method（get或post等）; successFn：成功的回调; errorFn：失败的回调\n ```\n angular.module('myDemo', [])\n \n     .controller('myController', ['$scope', '$http', function ($scope, $http) {\n         $scope.testHttp = function () {\n             $http({\n                 method: 'GET',\n                 url: 'https://randomuser.me/api/'\n             }).success(function (data) { // // 这里的data的类型是object，并且，它已经是返回数据的“数据”部分\n                 console.log(angular.toJson(data, true));\n                 $scope.result = data;\n             }).error(function (err) {\n                 console.log(err);\n             })\n         }\n     }]);\n ```\n 这里，$http(options)返回的是一个被封装的promise对象，我们可以console.log出来看看：\n ![](http://oi28tswuq.bkt.clouddn.com/images/promise.png)\n \n 从上图可以看到，黑色部分圈起来的是基本的promise部分（拥有then，catch，finally函数），除了这些函数以外，这个promise对象还有success和error函数（见红线处），这是$http返回的时候封装的，供我们使用的时候更方便。比如上述例子中，注释里说，success的回调函数返回的data直接就是我们想要的“数据部分”，那么如果我用的是then，那么返回的除了数据部分，还有额外的部分（比如状态码），这时候我就得自己拿出这个“数据部分”，代码如下：\n ```\n var promise = ...;  // 省略$http过程\n promise.then(function (data) {\n         // realData被包含在data的“data”字段中，一般它才是我们想要的\n         var realData = data.data;\n         console.log(realData);\n     }, function (err) {\n \n     });\n ```\n#### $q的介绍与用处:\n在上述例子中，我们是在Controller层写了网络请求。但是我们知道，在AngularJS的MVVM框架之中，业务逻辑（包括网络请求）的部分应该尽可能写到Service层中，而让Controller的逻辑尽可能少。但是，怎么把网络请求最终得到的有用的数据，返回给controller呢？这里有两种思路：\n\n方法一：把$http(options)返回的promise对象直接在Service中返回。在controller中拿到之后，再写success和error的回调。\n方法二：在Service中返回一个自定义的promise对象，用来回调给controller。这里的回调者，由$q创建的“defered”对象来担任。\n\n第一种方法比较简单，现在直接用第二种方法来写，这种方法也是在项目中常用的，在此之前，先简单介绍一下AngularJS的q服务。q服务是在AngularJS中用来创建promise对象的，但它首先创建一个defered对象：\n```\nvar deferred=$q.defer()\n```\n打印该defered对象：\n![](http://oi28tswuq.bkt.clouddn.com/images/defered.png)\n可以看到它有3个方法：resolve，reject，notify，分别对应于接受、拒绝、通知。还有一个promise属性，它的值就是一个基本的promise对象，主要用来返回。比如上面的例子，我可以这样写：\nserver.js如下：\n```\n.factory('userService', ['$http', '$q', function ($http, $q) {\n\n        var userService = {};   // 返回的服务\n\n        this.urlForRandomUser = \"https://randomuser.me/api/\";\n\n        var that = this; // 获取当前作用域，下面要用到\n        userService.getRandomUser = function () {\n\n            var defered = $q.defer();\n\n            $http.get(that.urlForRandomUser)\n                .success(function (data) {\n                    defered.resolve(data.results[0]);\n                })\n                .error(function (err) {\n                    defered.reject(err);\n                });\n            return defered.promise; // 把defered对象中的promise对象返回出来\n        };\n```\ncontroller.js如下：\n```\n.controller('firstController', ['$scope', 'userService', function ($scope, user) {\n //采用数组的方式可以防止压缩变量名称改变导致的问题，此处的变量user就代表userService.当然user也可以换成其他变量比如a,b,c等等，无论换成哪个变量，最终他都代表userService。当然要是不压缩代码的话可以直接注入userService服务，使用的时候是这个样子的：userService.getRandomUser();\n        $scope.getUser = function () {\n\n            function success(data) {\n                var str = angular.toJson(data, true);   // 用angular的格式化json的方法，更为清晰\n                $scope.result = str;\n            }\n\n            function error(err) {\n                $scope.result = err;\n                alert('error occured!\\n' + err);\n            }\n\n            // 注意这里不能用success或error函数，用then就好,defered的promise是基本的promise对象，并没有success和error函数，所以要用then来执行回调。\n            user.getRandomUser().then(success, error);\n        }\n\n    }])\n```\n\n\n \n ","source":"_posts/angular-q-promise-http.md","raw":"---\ntitle: AngularJS中的$http、$q服务和promise对象的联系\ndate: 2016-10-23 09:52:38\ntags: angular $http $q promise\n---\n#### angular中的$http\n$http服务是AngularJS系统自带的，可以用来进行网络通信、获取远程服务器的数据。要记住的是，$http是对浏览器XMLHttpRequest的封装，也就是说，它其实是Ajax。\n\n首先为了用$http发起请求，我们得先找到一个可以测试的API，这里我用：https://randomuser.me/api/来测试：用get请求，它能够返回json格式的一个随机用户的资料。比如在浏览器中输入，可以看到返回的数据：\n ![](http://oi28tswuq.bkt.clouddn.com/images/data.png)\n 注：这是一个公开的测试接口，以后测试也可以用。\n \n #### $http的基本用法：\n ```\n $http(options).success(successFn).error(errorFn)\n ```\n options：包括url、method（get或post等）; successFn：成功的回调; errorFn：失败的回调\n ```\n angular.module('myDemo', [])\n \n     .controller('myController', ['$scope', '$http', function ($scope, $http) {\n         $scope.testHttp = function () {\n             $http({\n                 method: 'GET',\n                 url: 'https://randomuser.me/api/'\n             }).success(function (data) { // // 这里的data的类型是object，并且，它已经是返回数据的“数据”部分\n                 console.log(angular.toJson(data, true));\n                 $scope.result = data;\n             }).error(function (err) {\n                 console.log(err);\n             })\n         }\n     }]);\n ```\n 这里，$http(options)返回的是一个被封装的promise对象，我们可以console.log出来看看：\n ![](http://oi28tswuq.bkt.clouddn.com/images/promise.png)\n \n 从上图可以看到，黑色部分圈起来的是基本的promise部分（拥有then，catch，finally函数），除了这些函数以外，这个promise对象还有success和error函数（见红线处），这是$http返回的时候封装的，供我们使用的时候更方便。比如上述例子中，注释里说，success的回调函数返回的data直接就是我们想要的“数据部分”，那么如果我用的是then，那么返回的除了数据部分，还有额外的部分（比如状态码），这时候我就得自己拿出这个“数据部分”，代码如下：\n ```\n var promise = ...;  // 省略$http过程\n promise.then(function (data) {\n         // realData被包含在data的“data”字段中，一般它才是我们想要的\n         var realData = data.data;\n         console.log(realData);\n     }, function (err) {\n \n     });\n ```\n#### $q的介绍与用处:\n在上述例子中，我们是在Controller层写了网络请求。但是我们知道，在AngularJS的MVVM框架之中，业务逻辑（包括网络请求）的部分应该尽可能写到Service层中，而让Controller的逻辑尽可能少。但是，怎么把网络请求最终得到的有用的数据，返回给controller呢？这里有两种思路：\n\n方法一：把$http(options)返回的promise对象直接在Service中返回。在controller中拿到之后，再写success和error的回调。\n方法二：在Service中返回一个自定义的promise对象，用来回调给controller。这里的回调者，由$q创建的“defered”对象来担任。\n\n第一种方法比较简单，现在直接用第二种方法来写，这种方法也是在项目中常用的，在此之前，先简单介绍一下AngularJS的q服务。q服务是在AngularJS中用来创建promise对象的，但它首先创建一个defered对象：\n```\nvar deferred=$q.defer()\n```\n打印该defered对象：\n![](http://oi28tswuq.bkt.clouddn.com/images/defered.png)\n可以看到它有3个方法：resolve，reject，notify，分别对应于接受、拒绝、通知。还有一个promise属性，它的值就是一个基本的promise对象，主要用来返回。比如上面的例子，我可以这样写：\nserver.js如下：\n```\n.factory('userService', ['$http', '$q', function ($http, $q) {\n\n        var userService = {};   // 返回的服务\n\n        this.urlForRandomUser = \"https://randomuser.me/api/\";\n\n        var that = this; // 获取当前作用域，下面要用到\n        userService.getRandomUser = function () {\n\n            var defered = $q.defer();\n\n            $http.get(that.urlForRandomUser)\n                .success(function (data) {\n                    defered.resolve(data.results[0]);\n                })\n                .error(function (err) {\n                    defered.reject(err);\n                });\n            return defered.promise; // 把defered对象中的promise对象返回出来\n        };\n```\ncontroller.js如下：\n```\n.controller('firstController', ['$scope', 'userService', function ($scope, user) {\n //采用数组的方式可以防止压缩变量名称改变导致的问题，此处的变量user就代表userService.当然user也可以换成其他变量比如a,b,c等等，无论换成哪个变量，最终他都代表userService。当然要是不压缩代码的话可以直接注入userService服务，使用的时候是这个样子的：userService.getRandomUser();\n        $scope.getUser = function () {\n\n            function success(data) {\n                var str = angular.toJson(data, true);   // 用angular的格式化json的方法，更为清晰\n                $scope.result = str;\n            }\n\n            function error(err) {\n                $scope.result = err;\n                alert('error occured!\\n' + err);\n            }\n\n            // 注意这里不能用success或error函数，用then就好,defered的promise是基本的promise对象，并没有success和error函数，所以要用then来执行回调。\n            user.getRandomUser().then(success, error);\n        }\n\n    }])\n```\n\n\n \n ","slug":"angular-q-promise-http","published":1,"updated":"2016-12-23T08:22:39.187Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv6o000ujgtui41agc8v","content":"<h4 id=\"angular中的-http\"><a href=\"#angular中的-http\" class=\"headerlink\" title=\"angular中的$http\"></a>angular中的$http</h4><p>$http服务是AngularJS系统自带的，可以用来进行网络通信、获取远程服务器的数据。要记住的是，$http是对浏览器XMLHttpRequest的封装，也就是说，它其实是Ajax。</p>\n<p>首先为了用$http发起请求，我们得先找到一个可以测试的API，这里我用：<a href=\"https://randomuser.me/api/来测试：用get请求，它能够返回json格式的一个随机用户的资料。比如在浏览器中输入，可以看到返回的数据：\" target=\"_blank\" rel=\"external\">https://randomuser.me/api/来测试：用get请求，它能够返回json格式的一个随机用户的资料。比如在浏览器中输入，可以看到返回的数据：</a><br> <img src=\"http://oi28tswuq.bkt.clouddn.com/images/data.png\" alt=\"\"><br> 注：这是一个公开的测试接口，以后测试也可以用。</p>\n<h4 id=\"http的基本用法：\"><a href=\"#http的基本用法：\" class=\"headerlink\" title=\"$http的基本用法：\"></a>$http的基本用法：</h4> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$http(options).success(successFn).error(errorFn)</div></pre></td></tr></table></figure>\n<p> options：包括url、method（get或post等）; successFn：成功的回调; errorFn：失败的回调<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myDemo&apos;, [])</div><div class=\"line\"></div><div class=\"line\">    .controller(&apos;myController&apos;, [&apos;$scope&apos;, &apos;$http&apos;, function ($scope, $http) &#123;</div><div class=\"line\">        $scope.testHttp = function () &#123;</div><div class=\"line\">            $http(&#123;</div><div class=\"line\">                method: &apos;GET&apos;,</div><div class=\"line\">                url: &apos;https://randomuser.me/api/&apos;</div><div class=\"line\">            &#125;).success(function (data) &#123; // // 这里的data的类型是object，并且，它已经是返回数据的“数据”部分</div><div class=\"line\">                console.log(angular.toJson(data, true));</div><div class=\"line\">                $scope.result = data;</div><div class=\"line\">            &#125;).error(function (err) &#123;</div><div class=\"line\">                console.log(err);</div><div class=\"line\">            &#125;)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;]);</div></pre></td></tr></table></figure></p>\n<p> 这里，$http(options)返回的是一个被封装的promise对象，我们可以console.log出来看看：<br> <img src=\"http://oi28tswuq.bkt.clouddn.com/images/promise.png\" alt=\"\"></p>\n<p> 从上图可以看到，黑色部分圈起来的是基本的promise部分（拥有then，catch，finally函数），除了这些函数以外，这个promise对象还有success和error函数（见红线处），这是$http返回的时候封装的，供我们使用的时候更方便。比如上述例子中，注释里说，success的回调函数返回的data直接就是我们想要的“数据部分”，那么如果我用的是then，那么返回的除了数据部分，还有额外的部分（比如状态码），这时候我就得自己拿出这个“数据部分”，代码如下：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promise = ...;  // 省略$http过程</div><div class=\"line\">promise.then(function (data) &#123;</div><div class=\"line\">        // realData被包含在data的“data”字段中，一般它才是我们想要的</div><div class=\"line\">        var realData = data.data;</div><div class=\"line\">        console.log(realData);</div><div class=\"line\">    &#125;, function (err) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"q的介绍与用处\"><a href=\"#q的介绍与用处\" class=\"headerlink\" title=\"$q的介绍与用处:\"></a>$q的介绍与用处:</h4><p>在上述例子中，我们是在Controller层写了网络请求。但是我们知道，在AngularJS的MVVM框架之中，业务逻辑（包括网络请求）的部分应该尽可能写到Service层中，而让Controller的逻辑尽可能少。但是，怎么把网络请求最终得到的有用的数据，返回给controller呢？这里有两种思路：</p>\n<p>方法一：把$http(options)返回的promise对象直接在Service中返回。在controller中拿到之后，再写success和error的回调。<br>方法二：在Service中返回一个自定义的promise对象，用来回调给controller。这里的回调者，由$q创建的“defered”对象来担任。</p>\n<p>第一种方法比较简单，现在直接用第二种方法来写，这种方法也是在项目中常用的，在此之前，先简单介绍一下AngularJS的q服务。q服务是在AngularJS中用来创建promise对象的，但它首先创建一个defered对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var deferred=$q.defer()</div></pre></td></tr></table></figure></p>\n<p>打印该defered对象：<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/defered.png\" alt=\"\"><br>可以看到它有3个方法：resolve，reject，notify，分别对应于接受、拒绝、通知。还有一个promise属性，它的值就是一个基本的promise对象，主要用来返回。比如上面的例子，我可以这样写：<br>server.js如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">.factory(&apos;userService&apos;, [&apos;$http&apos;, &apos;$q&apos;, function ($http, $q) &#123;</div><div class=\"line\"></div><div class=\"line\">        var userService = &#123;&#125;;   // 返回的服务</div><div class=\"line\"></div><div class=\"line\">        this.urlForRandomUser = &quot;https://randomuser.me/api/&quot;;</div><div class=\"line\"></div><div class=\"line\">        var that = this; // 获取当前作用域，下面要用到</div><div class=\"line\">        userService.getRandomUser = function () &#123;</div><div class=\"line\"></div><div class=\"line\">            var defered = $q.defer();</div><div class=\"line\"></div><div class=\"line\">            $http.get(that.urlForRandomUser)</div><div class=\"line\">                .success(function (data) &#123;</div><div class=\"line\">                    defered.resolve(data.results[0]);</div><div class=\"line\">                &#125;)</div><div class=\"line\">                .error(function (err) &#123;</div><div class=\"line\">                    defered.reject(err);</div><div class=\"line\">                &#125;);</div><div class=\"line\">            return defered.promise; // 把defered对象中的promise对象返回出来</div><div class=\"line\">        &#125;;</div></pre></td></tr></table></figure></p>\n<p>controller.js如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">.controller(&apos;firstController&apos;, [&apos;$scope&apos;, &apos;userService&apos;, function ($scope, user) &#123;</div><div class=\"line\"> //采用数组的方式可以防止压缩变量名称改变导致的问题，此处的变量user就代表userService.当然user也可以换成其他变量比如a,b,c等等，无论换成哪个变量，最终他都代表userService。当然要是不压缩代码的话可以直接注入userService服务，使用的时候是这个样子的：userService.getRandomUser();</div><div class=\"line\">        $scope.getUser = function () &#123;</div><div class=\"line\"></div><div class=\"line\">            function success(data) &#123;</div><div class=\"line\">                var str = angular.toJson(data, true);   // 用angular的格式化json的方法，更为清晰</div><div class=\"line\">                $scope.result = str;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            function error(err) &#123;</div><div class=\"line\">                $scope.result = err;</div><div class=\"line\">                alert(&apos;error occured!\\n&apos; + err);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // 注意这里不能用success或error函数，用then就好,defered的promise是基本的promise对象，并没有success和error函数，所以要用then来执行回调。</div><div class=\"line\">            user.getRandomUser().then(success, error);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;])</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<h4 id=\"angular中的-http\"><a href=\"#angular中的-http\" class=\"headerlink\" title=\"angular中的$http\"></a>angular中的$http</h4><p>$http服务是AngularJS系统自带的，可以用来进行网络通信、获取远程服务器的数据。要记住的是，$http是对浏览器XMLHttpRequest的封装，也就是说，它其实是Ajax。</p>\n<p>首先为了用$http发起请求，我们得先找到一个可以测试的API，这里我用：<a href=\"https://randomuser.me/api/来测试：用get请求，它能够返回json格式的一个随机用户的资料。比如在浏览器中输入，可以看到返回的数据：\">https://randomuser.me/api/来测试：用get请求，它能够返回json格式的一个随机用户的资料。比如在浏览器中输入，可以看到返回的数据：</a><br> <img src=\"http://oi28tswuq.bkt.clouddn.com/images/data.png\" alt=\"\"><br> 注：这是一个公开的测试接口，以后测试也可以用。</p>\n<h4 id=\"http的基本用法：\"><a href=\"#http的基本用法：\" class=\"headerlink\" title=\"$http的基本用法：\"></a>$http的基本用法：</h4> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$http(options).success(successFn).error(errorFn)</div></pre></td></tr></table></figure>\n<p> options：包括url、method（get或post等）; successFn：成功的回调; errorFn：失败的回调<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myDemo&apos;, [])</div><div class=\"line\"></div><div class=\"line\">    .controller(&apos;myController&apos;, [&apos;$scope&apos;, &apos;$http&apos;, function ($scope, $http) &#123;</div><div class=\"line\">        $scope.testHttp = function () &#123;</div><div class=\"line\">            $http(&#123;</div><div class=\"line\">                method: &apos;GET&apos;,</div><div class=\"line\">                url: &apos;https://randomuser.me/api/&apos;</div><div class=\"line\">            &#125;).success(function (data) &#123; // // 这里的data的类型是object，并且，它已经是返回数据的“数据”部分</div><div class=\"line\">                console.log(angular.toJson(data, true));</div><div class=\"line\">                $scope.result = data;</div><div class=\"line\">            &#125;).error(function (err) &#123;</div><div class=\"line\">                console.log(err);</div><div class=\"line\">            &#125;)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;]);</div></pre></td></tr></table></figure></p>\n<p> 这里，$http(options)返回的是一个被封装的promise对象，我们可以console.log出来看看：<br> <img src=\"http://oi28tswuq.bkt.clouddn.com/images/promise.png\" alt=\"\"></p>\n<p> 从上图可以看到，黑色部分圈起来的是基本的promise部分（拥有then，catch，finally函数），除了这些函数以外，这个promise对象还有success和error函数（见红线处），这是$http返回的时候封装的，供我们使用的时候更方便。比如上述例子中，注释里说，success的回调函数返回的data直接就是我们想要的“数据部分”，那么如果我用的是then，那么返回的除了数据部分，还有额外的部分（比如状态码），这时候我就得自己拿出这个“数据部分”，代码如下：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promise = ...;  // 省略$http过程</div><div class=\"line\">promise.then(function (data) &#123;</div><div class=\"line\">        // realData被包含在data的“data”字段中，一般它才是我们想要的</div><div class=\"line\">        var realData = data.data;</div><div class=\"line\">        console.log(realData);</div><div class=\"line\">    &#125;, function (err) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"q的介绍与用处\"><a href=\"#q的介绍与用处\" class=\"headerlink\" title=\"$q的介绍与用处:\"></a>$q的介绍与用处:</h4><p>在上述例子中，我们是在Controller层写了网络请求。但是我们知道，在AngularJS的MVVM框架之中，业务逻辑（包括网络请求）的部分应该尽可能写到Service层中，而让Controller的逻辑尽可能少。但是，怎么把网络请求最终得到的有用的数据，返回给controller呢？这里有两种思路：</p>\n<p>方法一：把$http(options)返回的promise对象直接在Service中返回。在controller中拿到之后，再写success和error的回调。<br>方法二：在Service中返回一个自定义的promise对象，用来回调给controller。这里的回调者，由$q创建的“defered”对象来担任。</p>\n<p>第一种方法比较简单，现在直接用第二种方法来写，这种方法也是在项目中常用的，在此之前，先简单介绍一下AngularJS的q服务。q服务是在AngularJS中用来创建promise对象的，但它首先创建一个defered对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var deferred=$q.defer()</div></pre></td></tr></table></figure></p>\n<p>打印该defered对象：<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/defered.png\" alt=\"\"><br>可以看到它有3个方法：resolve，reject，notify，分别对应于接受、拒绝、通知。还有一个promise属性，它的值就是一个基本的promise对象，主要用来返回。比如上面的例子，我可以这样写：<br>server.js如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">.factory(&apos;userService&apos;, [&apos;$http&apos;, &apos;$q&apos;, function ($http, $q) &#123;</div><div class=\"line\"></div><div class=\"line\">        var userService = &#123;&#125;;   // 返回的服务</div><div class=\"line\"></div><div class=\"line\">        this.urlForRandomUser = &quot;https://randomuser.me/api/&quot;;</div><div class=\"line\"></div><div class=\"line\">        var that = this; // 获取当前作用域，下面要用到</div><div class=\"line\">        userService.getRandomUser = function () &#123;</div><div class=\"line\"></div><div class=\"line\">            var defered = $q.defer();</div><div class=\"line\"></div><div class=\"line\">            $http.get(that.urlForRandomUser)</div><div class=\"line\">                .success(function (data) &#123;</div><div class=\"line\">                    defered.resolve(data.results[0]);</div><div class=\"line\">                &#125;)</div><div class=\"line\">                .error(function (err) &#123;</div><div class=\"line\">                    defered.reject(err);</div><div class=\"line\">                &#125;);</div><div class=\"line\">            return defered.promise; // 把defered对象中的promise对象返回出来</div><div class=\"line\">        &#125;;</div></pre></td></tr></table></figure></p>\n<p>controller.js如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">.controller(&apos;firstController&apos;, [&apos;$scope&apos;, &apos;userService&apos;, function ($scope, user) &#123;</div><div class=\"line\"> //采用数组的方式可以防止压缩变量名称改变导致的问题，此处的变量user就代表userService.当然user也可以换成其他变量比如a,b,c等等，无论换成哪个变量，最终他都代表userService。当然要是不压缩代码的话可以直接注入userService服务，使用的时候是这个样子的：userService.getRandomUser();</div><div class=\"line\">        $scope.getUser = function () &#123;</div><div class=\"line\"></div><div class=\"line\">            function success(data) &#123;</div><div class=\"line\">                var str = angular.toJson(data, true);   // 用angular的格式化json的方法，更为清晰</div><div class=\"line\">                $scope.result = str;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            function error(err) &#123;</div><div class=\"line\">                $scope.result = err;</div><div class=\"line\">                alert(&apos;error occured!\\n&apos; + err);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // 注意这里不能用success或error函数，用then就好,defered的promise是基本的promise对象，并没有success和error函数，所以要用then来执行回调。</div><div class=\"line\">            user.getRandomUser().then(success, error);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;])</div></pre></td></tr></table></figure></p>\n"},{"title":"Angular 路由实现原理","date":"2016-12-16T05:25:38.000Z","_content":"   路由 (route) ，几乎所有的 MVC(VM) 框架都应该具有的特性，因为它是前端构建单页面应用 (SPA) 必不可少的组成部分。那么，对于 angular 而言，它自然也有 内置 的路由模块：叫做 ngRoute 。不过，大家很少用它，因为它的功能太有限，往往不能满足开发需求！！于是，一个基于 ngRoute 开发的 第三方路由模块 ，叫做 ui.router ，用它的很多哦！\n\n#### ngRoute vs ui.router\n1. ngRoute 提供的服务和指令如下：\n - $routeProvider(服务提供者) --------- 对应于下面的urlRouterProvider和stateProvider\n - $route(服务) --------- 对应于下面的urlRouter和state\n - $routeParams(服务) --------- 对应于下面的stateParams\n - ng-view(指令) --------- 对应于下面的ui-view\n \n2.  ui.router 提供的服务和指令如下：\n - $urlRouterProvider(服务提供者) --------- 用来配置路由重定向\n - $urlRouter(服务)\n - $stateProvider(服务提供者) --------- 用来配置路由\n - $state(服务) --------- 用来显示当前路由状态信息，以及一些路由方法（如：跳转）\n - $stateParams(服务) --------- 用来存储路由匹配时的参数\n - ui-view(指令) --------- 路由模板渲染，对应的dom相关联\n - ui-sref(指令)---------链接到特定状态 例:<a ui-sref=\"home\">Home</a>\n - .......\n \n 注：服务提供者：用来提供服务实例和配置服务\n 两者不同的地方在于功能点的实现和增强！！！\n \n ##### 列举两个最重要的方面来说\n 1. 多视图\n 2. 嵌套视图\n \n#### 多视图：页面可以显示多个动态变化的不同区块。\n \n  比如：页面一个区块用来显示页面状态，另一个区块用来显示页面主内容，当路由切换时，页面状态跟着变化，对应的页面主内容也跟着变化。\n ng-route对应代码：\n ```\n html\n <div ng-view>区块1</div>\n <div ng-view>区块2</div>\n\n js\n \n $routeProvider\n     .when('/', {\n     template: 'hello world'\n });\n ```\n 我们在html中利用ng-view指令定义了两个区块，于是两个div中显示了相同的内容，这很合乎情理，但却不是我们想要的，但是又不能为力，因为，在ngRoute中：视图没有名字进行唯一标志，所以它们被同等的处理。路由配置只有一个模板，无法配置多个。\n \n 针对上述两个问题，我们尝试用 ui.router 来做：\n ```\n html\n \n   <div ui-view></div>\n   <div ui-view=\"status\"></div>\n js\n \n $stateProvider\n \t.state('home', {\n \t\turl: '/',\n \t\tviews: {\n \t\t\t'': {\n \t\t\t\ttemplate: 'hello world'\n \t\t\t},\n \t\t\t'status': {\n \t\t\t\ttemplate: 'home page'\n \t\t\t}\n \t\t}\n \t});\n ```\n 这次，结果是我们想要的，两个区块，分别显示了不同的内容，原因在于，在ui.router中：\n 可以给视图命名，如：ui-view=\"status\"。\n 可以在路由配置中根据视图名字(如：status)，配置不同的模板（其实还有controller等）。\n 注 ：视图名是一个字符串，不可以包含 @;\n \n#### 嵌套视图\n \n 嵌套视图：页面某个动态变化区块中，嵌套着另一个可以动态变化的区块。\n \n 比如：页面一个主区块显示主内容，主内容中的部分内容要求根据路由变化而变化，这时就需要另一个动态变化的区块嵌套在主区块中。\n \n 其实，嵌套视图，在html中的最终表现就像这样：\n ```\n <div ng-view>\n I am parent\n <div ng-view>I am child</div>\n </div>\n 转成javascript，我们会在程序里这样写：\n \n $routeProvider\n     .when('/', {\n     template: 'I am parent <div ng-view>I am child</div>'\n });\n ```\n   倘若，你真的用 ngRoute 这样写，你会发现浏览器崩溃了，因为在ng-view指令link的过程中，代码会无限递归下去。那么造成这种现象的最根本原因： 路由没有明确的父子层级关系！\n \n   看看 ui.router 是如何解决这一问题的？\n ```\n $stateProvider\n \t.state('parent', {\n \t\tabstract: true,\n \t\turl: '/',\n \t\ttemplate: 'I am parent <div ui-view></div>'\n \t})\n \t.state('parent.child', {\n \t\turl: '',\n \t\ttemplate: 'I am child'\n \t});\n ```\n   巧妙地，通过 parent 与 parent.child 来确定路由的 父子关系 ，从而解决无限递归问题。\n 另外子路由的模板最终也将被插入到父路由模板的div[ui-view]中去，从而达到视图嵌套的效果。\n  注：ui.router是基于state(状态)的，而不是url\n \n#### 前端路由的基本原理\n  1. 哈希 #\n  2. HTML5 中新的 history API\n  3. 路由的核心是给应用定义 \"状态\"\n  4. 使用路由机制会影响到应用的整体编码方式(需预先定义好状态)\n  5. 考虑兼容性问题与 \"优雅降级\"\n  \n#### ui.router工作原理\n  \n  路由，大致可以理解为：一个 查找匹配 的过程。\n  \n  对于前端 MVC(VM) 而言，就是将 hash值 (#xxx)与一系列的 路由规则 进行查找匹配，匹配出一个符合条件的规则，然后根据这个规则，进行数据的获取，以及页面的渲染。\n  \n#### ui-router补充\n1. $state.includes 返回 true / false\n    以上方法为查看当前状态是否在某父状态内，比如 $state.includes('contacts') 返回 true / false\n```\n<!-- 包含在 /contacts 状态内部，即其作为 parant state -->\n<li ng-class=\"{active: $state.includes('contacts')}\">\n    <a ui-serif=\"contacts.list\">Contacts</a>\n</li>\n```\n2. ui-sref-active 查看当前激活状态并设置 Class\n```\n<li ui-sref-active=\"active\"><a ui-sref=\"about\">About</a></li>\n```\n\n3. 包含模块\n```\nangular.module('uiRouter', ['ui.router']);\n```\n\n4. 方便获得当前状态的方法，绑到根作用域\n```\napp.run(['$rootScope', '$state', '$stateParams',\n    function($rootScope, $state, $stateParams) {\n        $rootScope.$state = $state;\n        $rootScope.$stateParams = $stateParams;\n    }\n]);\n```\n5. 路由重定向 $urlRouterProvider\n```\napp.config(['$stateProvider', '$urlRouterProvider',\n\tfunction($stateProvider, $urlRouterProvider) {\n\t\t$urlRouterProvider\n\t\t\t// 错误的路由重定向\n\t\t\t.when('/c?id', '/contacts/:id')\n\t\t\t.when('/user/:id', '/contacts/:id')\n\t\t\t.otherwise('/');\n\t}\n]);\n```\n6. 状态配置\n```\n$stateProvider.state('about',{})\n```\n\n","source":"_posts/angular-router.md","raw":"---\ntitle: Angular 路由实现原理\ndate: 2016-12-16 13:25:38\ntags: angular、router\n---\n   路由 (route) ，几乎所有的 MVC(VM) 框架都应该具有的特性，因为它是前端构建单页面应用 (SPA) 必不可少的组成部分。那么，对于 angular 而言，它自然也有 内置 的路由模块：叫做 ngRoute 。不过，大家很少用它，因为它的功能太有限，往往不能满足开发需求！！于是，一个基于 ngRoute 开发的 第三方路由模块 ，叫做 ui.router ，用它的很多哦！\n\n#### ngRoute vs ui.router\n1. ngRoute 提供的服务和指令如下：\n - $routeProvider(服务提供者) --------- 对应于下面的urlRouterProvider和stateProvider\n - $route(服务) --------- 对应于下面的urlRouter和state\n - $routeParams(服务) --------- 对应于下面的stateParams\n - ng-view(指令) --------- 对应于下面的ui-view\n \n2.  ui.router 提供的服务和指令如下：\n - $urlRouterProvider(服务提供者) --------- 用来配置路由重定向\n - $urlRouter(服务)\n - $stateProvider(服务提供者) --------- 用来配置路由\n - $state(服务) --------- 用来显示当前路由状态信息，以及一些路由方法（如：跳转）\n - $stateParams(服务) --------- 用来存储路由匹配时的参数\n - ui-view(指令) --------- 路由模板渲染，对应的dom相关联\n - ui-sref(指令)---------链接到特定状态 例:<a ui-sref=\"home\">Home</a>\n - .......\n \n 注：服务提供者：用来提供服务实例和配置服务\n 两者不同的地方在于功能点的实现和增强！！！\n \n ##### 列举两个最重要的方面来说\n 1. 多视图\n 2. 嵌套视图\n \n#### 多视图：页面可以显示多个动态变化的不同区块。\n \n  比如：页面一个区块用来显示页面状态，另一个区块用来显示页面主内容，当路由切换时，页面状态跟着变化，对应的页面主内容也跟着变化。\n ng-route对应代码：\n ```\n html\n <div ng-view>区块1</div>\n <div ng-view>区块2</div>\n\n js\n \n $routeProvider\n     .when('/', {\n     template: 'hello world'\n });\n ```\n 我们在html中利用ng-view指令定义了两个区块，于是两个div中显示了相同的内容，这很合乎情理，但却不是我们想要的，但是又不能为力，因为，在ngRoute中：视图没有名字进行唯一标志，所以它们被同等的处理。路由配置只有一个模板，无法配置多个。\n \n 针对上述两个问题，我们尝试用 ui.router 来做：\n ```\n html\n \n   <div ui-view></div>\n   <div ui-view=\"status\"></div>\n js\n \n $stateProvider\n \t.state('home', {\n \t\turl: '/',\n \t\tviews: {\n \t\t\t'': {\n \t\t\t\ttemplate: 'hello world'\n \t\t\t},\n \t\t\t'status': {\n \t\t\t\ttemplate: 'home page'\n \t\t\t}\n \t\t}\n \t});\n ```\n 这次，结果是我们想要的，两个区块，分别显示了不同的内容，原因在于，在ui.router中：\n 可以给视图命名，如：ui-view=\"status\"。\n 可以在路由配置中根据视图名字(如：status)，配置不同的模板（其实还有controller等）。\n 注 ：视图名是一个字符串，不可以包含 @;\n \n#### 嵌套视图\n \n 嵌套视图：页面某个动态变化区块中，嵌套着另一个可以动态变化的区块。\n \n 比如：页面一个主区块显示主内容，主内容中的部分内容要求根据路由变化而变化，这时就需要另一个动态变化的区块嵌套在主区块中。\n \n 其实，嵌套视图，在html中的最终表现就像这样：\n ```\n <div ng-view>\n I am parent\n <div ng-view>I am child</div>\n </div>\n 转成javascript，我们会在程序里这样写：\n \n $routeProvider\n     .when('/', {\n     template: 'I am parent <div ng-view>I am child</div>'\n });\n ```\n   倘若，你真的用 ngRoute 这样写，你会发现浏览器崩溃了，因为在ng-view指令link的过程中，代码会无限递归下去。那么造成这种现象的最根本原因： 路由没有明确的父子层级关系！\n \n   看看 ui.router 是如何解决这一问题的？\n ```\n $stateProvider\n \t.state('parent', {\n \t\tabstract: true,\n \t\turl: '/',\n \t\ttemplate: 'I am parent <div ui-view></div>'\n \t})\n \t.state('parent.child', {\n \t\turl: '',\n \t\ttemplate: 'I am child'\n \t});\n ```\n   巧妙地，通过 parent 与 parent.child 来确定路由的 父子关系 ，从而解决无限递归问题。\n 另外子路由的模板最终也将被插入到父路由模板的div[ui-view]中去，从而达到视图嵌套的效果。\n  注：ui.router是基于state(状态)的，而不是url\n \n#### 前端路由的基本原理\n  1. 哈希 #\n  2. HTML5 中新的 history API\n  3. 路由的核心是给应用定义 \"状态\"\n  4. 使用路由机制会影响到应用的整体编码方式(需预先定义好状态)\n  5. 考虑兼容性问题与 \"优雅降级\"\n  \n#### ui.router工作原理\n  \n  路由，大致可以理解为：一个 查找匹配 的过程。\n  \n  对于前端 MVC(VM) 而言，就是将 hash值 (#xxx)与一系列的 路由规则 进行查找匹配，匹配出一个符合条件的规则，然后根据这个规则，进行数据的获取，以及页面的渲染。\n  \n#### ui-router补充\n1. $state.includes 返回 true / false\n    以上方法为查看当前状态是否在某父状态内，比如 $state.includes('contacts') 返回 true / false\n```\n<!-- 包含在 /contacts 状态内部，即其作为 parant state -->\n<li ng-class=\"{active: $state.includes('contacts')}\">\n    <a ui-serif=\"contacts.list\">Contacts</a>\n</li>\n```\n2. ui-sref-active 查看当前激活状态并设置 Class\n```\n<li ui-sref-active=\"active\"><a ui-sref=\"about\">About</a></li>\n```\n\n3. 包含模块\n```\nangular.module('uiRouter', ['ui.router']);\n```\n\n4. 方便获得当前状态的方法，绑到根作用域\n```\napp.run(['$rootScope', '$state', '$stateParams',\n    function($rootScope, $state, $stateParams) {\n        $rootScope.$state = $state;\n        $rootScope.$stateParams = $stateParams;\n    }\n]);\n```\n5. 路由重定向 $urlRouterProvider\n```\napp.config(['$stateProvider', '$urlRouterProvider',\n\tfunction($stateProvider, $urlRouterProvider) {\n\t\t$urlRouterProvider\n\t\t\t// 错误的路由重定向\n\t\t\t.when('/c?id', '/contacts/:id')\n\t\t\t.when('/user/:id', '/contacts/:id')\n\t\t\t.otherwise('/');\n\t}\n]);\n```\n6. 状态配置\n```\n$stateProvider.state('about',{})\n```\n\n","slug":"angular-router","published":1,"updated":"2016-12-16T07:00:26.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv6r000wjgtu5jwrcckr","content":"<p>   路由 (route) ，几乎所有的 MVC(VM) 框架都应该具有的特性，因为它是前端构建单页面应用 (SPA) 必不可少的组成部分。那么，对于 angular 而言，它自然也有 内置 的路由模块：叫做 ngRoute 。不过，大家很少用它，因为它的功能太有限，往往不能满足开发需求！！于是，一个基于 ngRoute 开发的 第三方路由模块 ，叫做 ui.router ，用它的很多哦！</p>\n<h4 id=\"ngRoute-vs-ui-router\"><a href=\"#ngRoute-vs-ui-router\" class=\"headerlink\" title=\"ngRoute vs ui.router\"></a>ngRoute vs ui.router</h4><ol>\n<li><p>ngRoute 提供的服务和指令如下：</p>\n<ul>\n<li>$routeProvider(服务提供者) ——— 对应于下面的urlRouterProvider和stateProvider</li>\n<li>$route(服务) ——— 对应于下面的urlRouter和state</li>\n<li>$routeParams(服务) ——— 对应于下面的stateParams</li>\n<li>ng-view(指令) ——— 对应于下面的ui-view</li>\n</ul>\n</li>\n<li><p>ui.router 提供的服务和指令如下：</p>\n<ul>\n<li>$urlRouterProvider(服务提供者) ——— 用来配置路由重定向</li>\n<li>$urlRouter(服务)</li>\n<li>$stateProvider(服务提供者) ——— 用来配置路由</li>\n<li>$state(服务) ——— 用来显示当前路由状态信息，以及一些路由方法（如：跳转）</li>\n<li>$stateParams(服务) ——— 用来存储路由匹配时的参数</li>\n<li>ui-view(指令) ——— 路由模板渲染，对应的dom相关联</li>\n<li>ui-sref(指令)———链接到特定状态 例:<a ui-sref=\"home\">Home</a></li>\n<li>…….</li>\n</ul>\n<p>注：服务提供者：用来提供服务实例和配置服务<br>两者不同的地方在于功能点的实现和增强！！！</p>\n<h5 id=\"列举两个最重要的方面来说\"><a href=\"#列举两个最重要的方面来说\" class=\"headerlink\" title=\"列举两个最重要的方面来说\"></a>列举两个最重要的方面来说</h5><ol>\n<li>多视图</li>\n<li>嵌套视图</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"多视图：页面可以显示多个动态变化的不同区块。\"><a href=\"#多视图：页面可以显示多个动态变化的不同区块。\" class=\"headerlink\" title=\"多视图：页面可以显示多个动态变化的不同区块。\"></a>多视图：页面可以显示多个动态变化的不同区块。</h4><p>  比如：页面一个区块用来显示页面状态，另一个区块用来显示页面主内容，当路由切换时，页面状态跟着变化，对应的页面主内容也跟着变化。<br> ng-route对应代码：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">html</div><div class=\"line\">&lt;div ng-view&gt;区块1&lt;/div&gt;</div><div class=\"line\">&lt;div ng-view&gt;区块2&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">js</div><div class=\"line\"></div><div class=\"line\">$routeProvider</div><div class=\"line\">    .when(&apos;/&apos;, &#123;</div><div class=\"line\">    template: &apos;hello world&apos;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p> 我们在html中利用ng-view指令定义了两个区块，于是两个div中显示了相同的内容，这很合乎情理，但却不是我们想要的，但是又不能为力，因为，在ngRoute中：视图没有名字进行唯一标志，所以它们被同等的处理。路由配置只有一个模板，无法配置多个。</p>\n<p> 针对上述两个问题，我们尝试用 ui.router 来做：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">html</div><div class=\"line\"></div><div class=\"line\">  &lt;div ui-view&gt;&lt;/div&gt;</div><div class=\"line\">  &lt;div ui-view=&quot;status&quot;&gt;&lt;/div&gt;</div><div class=\"line\">js</div><div class=\"line\"></div><div class=\"line\">$stateProvider</div><div class=\"line\">\t.state(&apos;home&apos;, &#123;</div><div class=\"line\">\t\turl: &apos;/&apos;,</div><div class=\"line\">\t\tviews: &#123;</div><div class=\"line\">\t\t\t&apos;&apos;: &#123;</div><div class=\"line\">\t\t\t\ttemplate: &apos;hello world&apos;</div><div class=\"line\">\t\t\t&#125;,</div><div class=\"line\">\t\t\t&apos;status&apos;: &#123;</div><div class=\"line\">\t\t\t\ttemplate: &apos;home page&apos;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div></pre></td></tr></table></figure></p>\n<p> 这次，结果是我们想要的，两个区块，分别显示了不同的内容，原因在于，在ui.router中：<br> 可以给视图命名，如：ui-view=”status”。<br> 可以在路由配置中根据视图名字(如：status)，配置不同的模板（其实还有controller等）。<br> 注 ：视图名是一个字符串，不可以包含 @;</p>\n<h4 id=\"嵌套视图\"><a href=\"#嵌套视图\" class=\"headerlink\" title=\"嵌套视图\"></a>嵌套视图</h4><p> 嵌套视图：页面某个动态变化区块中，嵌套着另一个可以动态变化的区块。</p>\n<p> 比如：页面一个主区块显示主内容，主内容中的部分内容要求根据路由变化而变化，这时就需要另一个动态变化的区块嵌套在主区块中。</p>\n<p> 其实，嵌套视图，在html中的最终表现就像这样：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-view&gt;</div><div class=\"line\">I am parent</div><div class=\"line\">&lt;div ng-view&gt;I am child&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">转成javascript，我们会在程序里这样写：</div><div class=\"line\"></div><div class=\"line\">$routeProvider</div><div class=\"line\">    .when(&apos;/&apos;, &#123;</div><div class=\"line\">    template: &apos;I am parent &lt;div ng-view&gt;I am child&lt;/div&gt;&apos;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>   倘若，你真的用 ngRoute 这样写，你会发现浏览器崩溃了，因为在ng-view指令link的过程中，代码会无限递归下去。那么造成这种现象的最根本原因： 路由没有明确的父子层级关系！</p>\n<p>   看看 ui.router 是如何解决这一问题的？<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">$stateProvider</div><div class=\"line\">\t.state(&apos;parent&apos;, &#123;</div><div class=\"line\">\t\tabstract: true,</div><div class=\"line\">\t\turl: &apos;/&apos;,</div><div class=\"line\">\t\ttemplate: &apos;I am parent &lt;div ui-view&gt;&lt;/div&gt;&apos;</div><div class=\"line\">\t&#125;)</div><div class=\"line\">\t.state(&apos;parent.child&apos;, &#123;</div><div class=\"line\">\t\turl: &apos;&apos;,</div><div class=\"line\">\t\ttemplate: &apos;I am child&apos;</div><div class=\"line\">\t&#125;);</div></pre></td></tr></table></figure></p>\n<p>   巧妙地，通过 parent 与 parent.child 来确定路由的 父子关系 ，从而解决无限递归问题。<br> 另外子路由的模板最终也将被插入到父路由模板的div[ui-view]中去，从而达到视图嵌套的效果。<br>  注：ui.router是基于state(状态)的，而不是url</p>\n<h4 id=\"前端路由的基本原理\"><a href=\"#前端路由的基本原理\" class=\"headerlink\" title=\"前端路由的基本原理\"></a>前端路由的基本原理</h4><ol>\n<li>哈希 #</li>\n<li>HTML5 中新的 history API</li>\n<li>路由的核心是给应用定义 “状态”</li>\n<li>使用路由机制会影响到应用的整体编码方式(需预先定义好状态)</li>\n<li>考虑兼容性问题与 “优雅降级”</li>\n</ol>\n<h4 id=\"ui-router工作原理\"><a href=\"#ui-router工作原理\" class=\"headerlink\" title=\"ui.router工作原理\"></a>ui.router工作原理</h4><p>  路由，大致可以理解为：一个 查找匹配 的过程。</p>\n<p>  对于前端 MVC(VM) 而言，就是将 hash值 (#xxx)与一系列的 路由规则 进行查找匹配，匹配出一个符合条件的规则，然后根据这个规则，进行数据的获取，以及页面的渲染。</p>\n<h4 id=\"ui-router补充\"><a href=\"#ui-router补充\" class=\"headerlink\" title=\"ui-router补充\"></a>ui-router补充</h4><ol>\n<li><p>$state.includes 返回 true / false<br> 以上方法为查看当前状态是否在某父状态内，比如 $state.includes(‘contacts’) 返回 true / false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 包含在 /contacts 状态内部，即其作为 parant state --&gt;</div><div class=\"line\">&lt;li ng-class=&quot;&#123;active: $state.includes(&apos;contacts&apos;)&#125;&quot;&gt;</div><div class=\"line\">    &lt;a ui-serif=&quot;contacts.list&quot;&gt;Contacts&lt;/a&gt;</div><div class=\"line\">&lt;/li&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>ui-sref-active 查看当前激活状态并设置 Class</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;li ui-sref-active=&quot;active&quot;&gt;&lt;a ui-sref=&quot;about&quot;&gt;About&lt;/a&gt;&lt;/li&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>包含模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;uiRouter&apos;, [&apos;ui.router&apos;]);</div></pre></td></tr></table></figure>\n</li>\n<li><p>方便获得当前状态的方法，绑到根作用域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.run([&apos;$rootScope&apos;, &apos;$state&apos;, &apos;$stateParams&apos;,</div><div class=\"line\">    function($rootScope, $state, $stateParams) &#123;</div><div class=\"line\">        $rootScope.$state = $state;</div><div class=\"line\">        $rootScope.$stateParams = $stateParams;</div><div class=\"line\">    &#125;</div><div class=\"line\">]);</div></pre></td></tr></table></figure>\n</li>\n<li><p>路由重定向 $urlRouterProvider</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.config([&apos;$stateProvider&apos;, &apos;$urlRouterProvider&apos;,</div><div class=\"line\">\tfunction($stateProvider, $urlRouterProvider) &#123;</div><div class=\"line\">\t\t$urlRouterProvider</div><div class=\"line\">\t\t\t// 错误的路由重定向</div><div class=\"line\">\t\t\t.when(&apos;/c?id&apos;, &apos;/contacts/:id&apos;)</div><div class=\"line\">\t\t\t.when(&apos;/user/:id&apos;, &apos;/contacts/:id&apos;)</div><div class=\"line\">\t\t\t.otherwise(&apos;/&apos;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">]);</div></pre></td></tr></table></figure>\n</li>\n<li><p>状态配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$stateProvider.state(&apos;about&apos;,&#123;&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ol>\n","excerpt":"","more":"<p>   路由 (route) ，几乎所有的 MVC(VM) 框架都应该具有的特性，因为它是前端构建单页面应用 (SPA) 必不可少的组成部分。那么，对于 angular 而言，它自然也有 内置 的路由模块：叫做 ngRoute 。不过，大家很少用它，因为它的功能太有限，往往不能满足开发需求！！于是，一个基于 ngRoute 开发的 第三方路由模块 ，叫做 ui.router ，用它的很多哦！</p>\n<h4 id=\"ngRoute-vs-ui-router\"><a href=\"#ngRoute-vs-ui-router\" class=\"headerlink\" title=\"ngRoute vs ui.router\"></a>ngRoute vs ui.router</h4><ol>\n<li><p>ngRoute 提供的服务和指令如下：</p>\n<ul>\n<li>$routeProvider(服务提供者) ——— 对应于下面的urlRouterProvider和stateProvider</li>\n<li>$route(服务) ——— 对应于下面的urlRouter和state</li>\n<li>$routeParams(服务) ——— 对应于下面的stateParams</li>\n<li>ng-view(指令) ——— 对应于下面的ui-view</li>\n</ul>\n</li>\n<li><p>ui.router 提供的服务和指令如下：</p>\n<ul>\n<li>$urlRouterProvider(服务提供者) ——— 用来配置路由重定向</li>\n<li>$urlRouter(服务)</li>\n<li>$stateProvider(服务提供者) ——— 用来配置路由</li>\n<li>$state(服务) ——— 用来显示当前路由状态信息，以及一些路由方法（如：跳转）</li>\n<li>$stateParams(服务) ——— 用来存储路由匹配时的参数</li>\n<li>ui-view(指令) ——— 路由模板渲染，对应的dom相关联</li>\n<li>ui-sref(指令)———链接到特定状态 例:<a ui-sref=\"home\">Home</a></li>\n<li>…….</li>\n</ul>\n<p>注：服务提供者：用来提供服务实例和配置服务<br>两者不同的地方在于功能点的实现和增强！！！</p>\n<h5 id=\"列举两个最重要的方面来说\"><a href=\"#列举两个最重要的方面来说\" class=\"headerlink\" title=\"列举两个最重要的方面来说\"></a>列举两个最重要的方面来说</h5><ol>\n<li>多视图</li>\n<li>嵌套视图</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"多视图：页面可以显示多个动态变化的不同区块。\"><a href=\"#多视图：页面可以显示多个动态变化的不同区块。\" class=\"headerlink\" title=\"多视图：页面可以显示多个动态变化的不同区块。\"></a>多视图：页面可以显示多个动态变化的不同区块。</h4><p>  比如：页面一个区块用来显示页面状态，另一个区块用来显示页面主内容，当路由切换时，页面状态跟着变化，对应的页面主内容也跟着变化。<br> ng-route对应代码：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">html</div><div class=\"line\">&lt;div ng-view&gt;区块1&lt;/div&gt;</div><div class=\"line\">&lt;div ng-view&gt;区块2&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">js</div><div class=\"line\"></div><div class=\"line\">$routeProvider</div><div class=\"line\">    .when(&apos;/&apos;, &#123;</div><div class=\"line\">    template: &apos;hello world&apos;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p> 我们在html中利用ng-view指令定义了两个区块，于是两个div中显示了相同的内容，这很合乎情理，但却不是我们想要的，但是又不能为力，因为，在ngRoute中：视图没有名字进行唯一标志，所以它们被同等的处理。路由配置只有一个模板，无法配置多个。</p>\n<p> 针对上述两个问题，我们尝试用 ui.router 来做：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">html</div><div class=\"line\"></div><div class=\"line\">  &lt;div ui-view&gt;&lt;/div&gt;</div><div class=\"line\">  &lt;div ui-view=&quot;status&quot;&gt;&lt;/div&gt;</div><div class=\"line\">js</div><div class=\"line\"></div><div class=\"line\">$stateProvider</div><div class=\"line\">\t.state(&apos;home&apos;, &#123;</div><div class=\"line\">\t\turl: &apos;/&apos;,</div><div class=\"line\">\t\tviews: &#123;</div><div class=\"line\">\t\t\t&apos;&apos;: &#123;</div><div class=\"line\">\t\t\t\ttemplate: &apos;hello world&apos;</div><div class=\"line\">\t\t\t&#125;,</div><div class=\"line\">\t\t\t&apos;status&apos;: &#123;</div><div class=\"line\">\t\t\t\ttemplate: &apos;home page&apos;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div></pre></td></tr></table></figure></p>\n<p> 这次，结果是我们想要的，两个区块，分别显示了不同的内容，原因在于，在ui.router中：<br> 可以给视图命名，如：ui-view=”status”。<br> 可以在路由配置中根据视图名字(如：status)，配置不同的模板（其实还有controller等）。<br> 注 ：视图名是一个字符串，不可以包含 @;</p>\n<h4 id=\"嵌套视图\"><a href=\"#嵌套视图\" class=\"headerlink\" title=\"嵌套视图\"></a>嵌套视图</h4><p> 嵌套视图：页面某个动态变化区块中，嵌套着另一个可以动态变化的区块。</p>\n<p> 比如：页面一个主区块显示主内容，主内容中的部分内容要求根据路由变化而变化，这时就需要另一个动态变化的区块嵌套在主区块中。</p>\n<p> 其实，嵌套视图，在html中的最终表现就像这样：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-view&gt;</div><div class=\"line\">I am parent</div><div class=\"line\">&lt;div ng-view&gt;I am child&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">转成javascript，我们会在程序里这样写：</div><div class=\"line\"></div><div class=\"line\">$routeProvider</div><div class=\"line\">    .when(&apos;/&apos;, &#123;</div><div class=\"line\">    template: &apos;I am parent &lt;div ng-view&gt;I am child&lt;/div&gt;&apos;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>   倘若，你真的用 ngRoute 这样写，你会发现浏览器崩溃了，因为在ng-view指令link的过程中，代码会无限递归下去。那么造成这种现象的最根本原因： 路由没有明确的父子层级关系！</p>\n<p>   看看 ui.router 是如何解决这一问题的？<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">$stateProvider</div><div class=\"line\">\t.state(&apos;parent&apos;, &#123;</div><div class=\"line\">\t\tabstract: true,</div><div class=\"line\">\t\turl: &apos;/&apos;,</div><div class=\"line\">\t\ttemplate: &apos;I am parent &lt;div ui-view&gt;&lt;/div&gt;&apos;</div><div class=\"line\">\t&#125;)</div><div class=\"line\">\t.state(&apos;parent.child&apos;, &#123;</div><div class=\"line\">\t\turl: &apos;&apos;,</div><div class=\"line\">\t\ttemplate: &apos;I am child&apos;</div><div class=\"line\">\t&#125;);</div></pre></td></tr></table></figure></p>\n<p>   巧妙地，通过 parent 与 parent.child 来确定路由的 父子关系 ，从而解决无限递归问题。<br> 另外子路由的模板最终也将被插入到父路由模板的div[ui-view]中去，从而达到视图嵌套的效果。<br>  注：ui.router是基于state(状态)的，而不是url</p>\n<h4 id=\"前端路由的基本原理\"><a href=\"#前端路由的基本原理\" class=\"headerlink\" title=\"前端路由的基本原理\"></a>前端路由的基本原理</h4><ol>\n<li>哈希 #</li>\n<li>HTML5 中新的 history API</li>\n<li>路由的核心是给应用定义 “状态”</li>\n<li>使用路由机制会影响到应用的整体编码方式(需预先定义好状态)</li>\n<li>考虑兼容性问题与 “优雅降级”</li>\n</ol>\n<h4 id=\"ui-router工作原理\"><a href=\"#ui-router工作原理\" class=\"headerlink\" title=\"ui.router工作原理\"></a>ui.router工作原理</h4><p>  路由，大致可以理解为：一个 查找匹配 的过程。</p>\n<p>  对于前端 MVC(VM) 而言，就是将 hash值 (#xxx)与一系列的 路由规则 进行查找匹配，匹配出一个符合条件的规则，然后根据这个规则，进行数据的获取，以及页面的渲染。</p>\n<h4 id=\"ui-router补充\"><a href=\"#ui-router补充\" class=\"headerlink\" title=\"ui-router补充\"></a>ui-router补充</h4><ol>\n<li><p>$state.includes 返回 true / false<br> 以上方法为查看当前状态是否在某父状态内，比如 $state.includes(‘contacts’) 返回 true / false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 包含在 /contacts 状态内部，即其作为 parant state --&gt;</div><div class=\"line\">&lt;li ng-class=&quot;&#123;active: $state.includes(&apos;contacts&apos;)&#125;&quot;&gt;</div><div class=\"line\">    &lt;a ui-serif=&quot;contacts.list&quot;&gt;Contacts&lt;/a&gt;</div><div class=\"line\">&lt;/li&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>ui-sref-active 查看当前激活状态并设置 Class</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;li ui-sref-active=&quot;active&quot;&gt;&lt;a ui-sref=&quot;about&quot;&gt;About&lt;/a&gt;&lt;/li&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>包含模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;uiRouter&apos;, [&apos;ui.router&apos;]);</div></pre></td></tr></table></figure>\n</li>\n<li><p>方便获得当前状态的方法，绑到根作用域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.run([&apos;$rootScope&apos;, &apos;$state&apos;, &apos;$stateParams&apos;,</div><div class=\"line\">    function($rootScope, $state, $stateParams) &#123;</div><div class=\"line\">        $rootScope.$state = $state;</div><div class=\"line\">        $rootScope.$stateParams = $stateParams;</div><div class=\"line\">    &#125;</div><div class=\"line\">]);</div></pre></td></tr></table></figure>\n</li>\n<li><p>路由重定向 $urlRouterProvider</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.config([&apos;$stateProvider&apos;, &apos;$urlRouterProvider&apos;,</div><div class=\"line\">\tfunction($stateProvider, $urlRouterProvider) &#123;</div><div class=\"line\">\t\t$urlRouterProvider</div><div class=\"line\">\t\t\t// 错误的路由重定向</div><div class=\"line\">\t\t\t.when(&apos;/c?id&apos;, &apos;/contacts/:id&apos;)</div><div class=\"line\">\t\t\t.when(&apos;/user/:id&apos;, &apos;/contacts/:id&apos;)</div><div class=\"line\">\t\t\t.otherwise(&apos;/&apos;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">]);</div></pre></td></tr></table></figure>\n</li>\n<li><p>状态配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$stateProvider.state(&apos;about&apos;,&#123;&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"AngularJS基本知识点","date":"2016-07-13T05:36:32.000Z","_content":"　　AngularJS 是一个 MVVM框架，最适于开发客户端的单页面应用。它不是个功能库，而是用来开发动态网页的框架。它专注于扩展 HTML 的功能，提供动态数据绑定（data binding），而且它能跟其它框架（如 JQuery 等）合作融洽。\n\n### 1. 一个简单示例\n\n通过下面的示例代码，可以运行一个简单的 AngularJS 应用：\n```\n<!DOCTYPE html>\n<html>\n<body>\n\n<div ng-app=\"\">\n  <p>在输入框中尝试输入：</p>\n  <p>姓名：<input type=\"text\" ng-model=\"name\"></p>\n  <p ng-bind=\"name\"></p>\n</div>\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.3.8/angular.min.js\"></script>\n</body>\n</html>\n```\n通过浏览器访问该页面，在输入框中输入的内容会立即显示在输入框下面。\n\n##### 说明：\n\n当网页加载完毕，AngularJS 自动运行。\nng-app 指令告诉 AngularJS ，div 元素是 AngularJS 应用程序的\"所有者\"，相当于是个作用域的概率。\nng-model 指令把输入域的值绑定到应用程序变量 name。\nng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML。\n### 2. AngularJS 指令\n\nAngularJS 指令是扩展的 HTML 属性，带有前缀 ng- 。\n\nHTML5 允许扩展的（自制的）属性，以 data- 开头。AngularJS 属性以 ng- 开头，但是您可以使用 data-ng- 来让网页对 HTML5 有效。\n\n#### 常见的指令\n\n- ng-app 指令\n \n ng-app 指令初始化一个 AngularJS 应用程序。\n\n- ng-init 指令\n \n ng-init 指令初始化应用程序数据，这个不常使用。通常情况下，不使用 ng-init。您将使用一个控制器或模块来代替它。\n\n- ng-model 指令\n\n ng-model 指令把元素值（比如输入域的值）绑定到应用程序。\n\n- ng-bind 指令\n\n ng-bind 指令把应用程序数据绑定到 HTML 视图。\n\n示例：\n```\n<div ng-app=\"\">\n  <p>在输入框中尝试输入：</p>\n  <p>姓名：<input type=\"text\" ng-model=\"name\"></p>\n  <p ng-bind=\"name\"></p>\n</div>\n```\n- ng-repeat 指令\n\nng-repeat 指令会重复一个 HTML 元素：\n```\n<div ng-app=\"\" ng-init=\"names=[\n{name:'Jani',country:'Norway'},\n{name:'Hege',country:'Sweden'},\n{name:'Kai',country:'Denmark'}]\">\n\n<p>循环对象：</p>\n  <ul>\n    <li ng-repeat=\"x in names\">\n\n    </li>\n  </ul>\n</div>\n```\n除此之外，它还提供了几个变量可供使用：\n\n- index 当前索引\n- first 是否为头元素\n- middle 是否为非头非尾元素\n- last 是否为尾元素\n\n##### 样式相关的指令\n\n- ng-class\n\nng-class用来给元素绑定类名，其表达式的返回值可以是以下三种：\n\n类名字符串，可以用空格分割多个类名，如 ‘class1 class2’；\n类名数组，数组中的每一项都会层叠起来生效；\n一个名值对应的map，其键值为类名，值为boolean类型，当值为true时，该类会被加在元素上。\n与 ng-class 相近的，ng 还提供了ng-class-odd、ng-class-even 两个指令，用来配合 ng-repeat 分别在奇数列和偶数列使用对应的类。这个用来在表格中实现隔行换色再方便不过了。\n\n- ng-style\n\nng-style 用来绑定元素的 css 样式，其表达式的返回值为一个 js 对象，键为 css 样式名，值为该样式对应的合法取值。用法比较简单：\n```\n$scope.style = {color:'red'};　\n\n<div ng-style=\"{color:'red'}\">ng-style测试</div>\n<div ng-style=\"style\">ng-style测试</div>\nng-show、ng-hide、ng-switch\n```\n对于比较常用的元素显隐控制，ng 也做了封装，ng-show 和 ng-hide 的值为 boolean 类型的表达式，当值为 true 时，对应的 show 或 hide 生效。框架会用 display:block 和 display:none 来控制元素的显隐。\n\n示例：\n```\n<div ng-app=\"\">\n\t<div ng-show=\"true\">1</div>\n\t<div ng-show=\"false\">2</div>\n\t<div ng-hide=\"true\">3</div>\n\t<div ng-hide=\"false\">4</div>\n</div>\n```\n后一个 ng-switch 是根据一个值来决定哪个节点显示，其它节点移除：\n```\n<div ng-init=\"a=2\">\n    <ul ng-switch on=\"a\">\n\t    <li ng-switch-when=\"1\">1</li>\n\t    <li ng-switch-when=\"2\">2</li>\n\t    <li ng-switch-default>other</li>\n    </ul>\n</div>\n```\n### 事件指令\n\n事件相关的指令有：\n\n- ng-change\n- ng-click\n- ng-dblclick\n- ng-mousedown\n- ng-mouseenter\n- ng-mouseleave\n- ng-mousemove\n- ng-mouseover\n- ng-mouseup\n- ng-submit\n对于事件对象本身，在函数调用时可以直接使用 $event 进行传递：\n```\n<p ng-click=\"click($event)\">点击</p>\n<p ng-click=\"click($event.target)\">点击</p>\n\n$scope.click = function($event){\n         alert($event.target);\n         //……………………\n}　\n```\n\n### 表单指令\n\n　　表单控件类的模板指令，最大的作用是它预定义了需要绑定的数据的格式。这样，就可以对于既定的数据进行既定的处理。\n\n#### form\n\n　　ng 对 form 这个标签作了包装，对应的指令是 *ng-form*。\n\n　　从 ng 的角度来说， form 标签，是一个模板指令，也创建了一个 FormController 的实例。这个实例就提供了相应的属性和方法。同时，它里面的控件也是一个 NgModelController 实例。\n\n　　*很重要的一点*， form 的相关方法要生效，必须为 form 标签指定 name 和 ng-controller ，并且每个控件都要绑定一个变量。 form 和控件的名字，即是 $scope 中的相关实例的引用变量名。\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\">\n  <input type=\"text\" name=\"a\" required ng-model=\"a\"  />\n  <span ng-click=\"see()\"></span>\n</form>\n\nvar TestCtrl = function($scope){\n  $scope.see = function(){\n    console.log($scope.test_form);\n    console.log($scope.test_form.a);\n  }\n}\n```\n除去对象的方法与属性， form 这个标签本身有一些动态类可以使用：\n\n- ng-valid 当表单验证通过时的设置\n- ng-invalid 当表单验证失败时的设置\n- ng-pristine 表单的未被动之前拥有\n- ng-dirty 表单被动过之后拥有\n\n#### form 对象的属性有：\n- $pristine 表单是否未被动过\n- $dirty 表单是否被动过\n- $valid 表单是否验证通过\n- $invalid 表单是否验证失败\n- $error 表单的验证错误\n其中的 $error 对象包含有所有字段的验证信息，及对相关字段的 NgModelController 实例的引用。它的结构是一个对象， key 是失败信息， required ， minlength 之类的， value 是对应的字段实例列表。\n\n#### input\ninput 控件的相关可用属性为：\n\n- name 名字\n- ng-model 绑定的数据\n- required 是否必填\n- ng-required 是否必填\n- ng-minlength 最小长度\n- ng-maxlength 最大长度\n- ng-pattern 匹配模式\n- ng-change 值变化时的回调\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\">\n  <input type=\"text\" name=\"a\" ng-model=\"a\" required ng-pattern=\"/abc/\" />\n  <span ng-click=\"see()\"></span>\n</form>\n```\ninput 控件，它还有一些扩展，这些扩展有些有自己的属性：\n\n- input type=\"number\" 多了 number 错误类型，多了 max ， min 属性。\n- input type=\"url\" 多了 url 错误类型。\n- input type=\"email\" 多了 email 错误类型。\n\n#### checkbox\n\n它是 input 的扩展，不过，它没有验证相关的东西，只有选中与不选中两个值：ng-true-value、ng-false-value:\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\">\n  <input type=\"checkbox\" name=\"a\" ng-model=\"a\" ng-true-value=\"AA\" ng-false-value=\"BB\" />\n  <span></span>\n</form>\n```\n#### radio\n\n它也是 input 的扩展。和 checkbox 一样，但它只有一个值：\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\">\n  <input type=\"radio\" name=\"a\" ng-model=\"a\" value=\"AA\" />\n  <input type=\"radio\" name=\"a\" ng-model=\"a\" value=\"BB\" />\n  <span></span>\n</form>\n```\n\n#### textarea  同 input\n\n#### select\n\n它里面的一个叫做 ng-options 的属性用于数据呈现。\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\" ng-init=\"o=[0,1,2,3]; a=o[1];\">\n    <select ng-model=\"a\" ng-options=\"x for x in o\">\n      <option value=\"\">可以加这个空值</option>\n    </select>\n</form>\n```\n在 $scope 中， select 绑定的变量，其值和普通的 value 无关，可以是一个对象：\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\"\n    ng-init=\"o=[{name: 'AA'}, {name: 'BB'}]; a=o[1];\">\n    <select ng-model=\"a\" ng-options=\"x.name for x in o\" />\n</form>\n```\n显示与值分别指定， x.v as x.name for x in o ： as for  in 要理解清楚！\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\"\n    ng-init=\"o=[{name: 'AA', v: '00'}, {name: 'BB', v: '11'}]; a=o[1].v;\">\n    <select ng-model=\"a\" ng-options=\"x.v as x.name for x in o\" />\n</form>\n```\n加入分组的， x.name group by x.g for x in o ：\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\"\n    ng-init=\"o=[{name: 'AA', g: '00'}, {name: 'BB', g: '11'}, {name: 'CC', g: '00'}]; a=o[1];\">\n    <select ng-model=\"a\" ng-options=\"x.name group by x.g for x in o\" />\n</form>\n```\n分组了还分别指定显示与值的， x.v as x.name group by x.g for x in o ：\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\" ng-init=\"o=[{name: 'AA', g: '00', v: '='}, {name: 'BB', g: '11', v: '+'}, {name: 'CC', g: '00', v: '!'}]; a=o[1].v;\">\n    <select ng-model=\"a\" ng-options=\"x.v as x.name group by x.g for x in o\" />\n</form>\n```\n如果参数是对象的话，基本也是一样的，只是把遍历的对象改成 (key, value) ：\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\" ng-init=\"o={a: 0, b: 1}; a=o.a;\">\n\t<select ng-model=\"a\" ng-options=\"k for (k, v) in o\" />\n</form>\n<form name=\"test_form\" ng-controller=\"TestCtrl\"\n\tng-init=\"o={a: {name: 'AA', v: '00'}, b: {name: 'BB', v: '11'}}; a=o.a.v;\">\n\t<select ng-model=\"a\" ng-options=\"v.v as v.name for (k, v) in o\" />\n</form>\n<form name=\"test_form\" ng-controller=\"TestCtrl\"\n\tng-init=\"o={a: {name: 'AA', v: '00', g: '=='}, b: {name: 'BB', v: '11', g: '=='}}; a=o.a;\">\n\t<select ng-model=\"a\" ng-options=\"v.name group by v.g for (k, v) in o\" />\n</form>\n<form name=\"test_form\" ng-controller=\"TestCtrl\"\n\tng-init=\"o={a: {name: 'AA', v: '00', g: '=='}, b: {name: 'BB', v: '11', g: '=='}}; a=o.a.v;\">\n\t<select ng-model=\"a\" ng-options=\"v.v as v.name group by v.g for (k, v) in o\" />\n</form>\n```\n还有一些表单控件功能相关的指令：\n\n- ng-src src 属性\n- ng-href href 属性\n- ng-checked 控制 radio 和 checkbox 的选中状态\n- ng-selected 控制下拉框的选中状态\n- ng-disabled 控制失效状态\n- ng-multiple 控制多选\n- ng-readonly 控制只读状态\n以上指令的取值均为 boolean 类型，当值为 true 时相关状态生效，道理比较简单就不多做解释。\n\n*注意*:上面的这些只是单向绑定，即只是从数据到模板，不能反作用于数据。要双向绑定，还是要使用 ng-model 。\n\n### 3. AngularJS 过滤器\n\n　　过滤器（filter）正如其名，作用就是接收一个输入，通过某个规则进行处理，然后返回处理后的结果。主要用在数据的格式化上，例如获取一个数组中的子集，对数组中的元素进行排序等。过滤器通常是伴随标记来使用的，将你 model 中的数据格式化为需要的格式。表单的控制功能主要涉及到数据验证以及表单控件的增强。\n\n#### 内置过滤器\n\n　　ng 内置了一些过滤器，它们是：currency(货币)、date(日期)、filter(子串匹配)、json(格式化json对象)、limitTo(限制个数)、lowercase(小写)、uppercase(大写)、number(数字)、orderBy(排序)。\n\n过滤器使用示例：\n\n- 使用currency可以将数字格式化为货币，默认是美元符号，你可以自己传入所需的符号\n```\n{{num | currency : '￥'}}\n```\n- 参数用来指定所要的格式，y M d h m s E 分别表示 年 月 日 时 分 秒 星期，你可以自由组合它们。也可以使用不同的个数来限制格式化的位数。另外参数也可以使用特定的描述性字符串，例如“shortTime”将会把时间格式为12:05 pm这样的。\n```\n{{date | date : 'yyyy-MM-dd hh:mm:ss EEEE'}}\n```\n\n- filter 过滤器从数组中选择一个子集：\n```\n{{ childrenArray | filter : 'a' }} //匹配属性值中含有a的\n{{ childrenArray | filter : 4 }}  //匹配属性值中含有4的\n{{ childrenArray | filter : {name : 'i'} }} //参数是对象，匹配name属性中含有i的\n$scope.func = function(e){return e.age>4;}{{ childrenArray | filter : 'a' }}\n{{childrenArray | filter : func }}  //参数是函数　\n```\n- json过滤器可以把一个js对象格式化为json字符串\n```\n{{ jsonTest | json}}\n```\n- 列表截取 limitTo ，支持正负数\n```\n{{ childrenArray | limitTo : 2 }} \n```\n- number过滤器可以为一个数字加上千位分割，像这样，123,456,789。同时接收一个参数，可以指定float类型保留几位小数：\n```\n{{ num | number : 2 }}\n```\n- 大小写 lowercase ， uppercase ：\n```\n{{ 'abc' | uppercase }}\n{{ 'Abc' | lowercase }}\n```\n```\n{{ childrenArray | orderBy : 'age' }}       //按age属性值进行排序，若是-age，则倒序\n{{ childrenArray | orderBy : orderFunc }}   //按照函数的返回值进行排序\n{{ childrenArray | orderBy : ['age','name'] }}  //如果age相同，按照name进行排序\n```\n\n*过滤器使用方式*\n\n在模块中定义过滤器：\n```\nvar app = angular.module('Demo', [], angular.noop);\n  app.filter('map', function(){\n    var filter = function(input){\n      return input + '...';\n    };\n    return filter;\n  });\n ```\n然后，在模板中使用：\n```\n<p>示例数据: {{ a | map }}</p>\n```\n### 4. AngularJS Ajax\n\n　　$http 服务是 AngularJS 的核心服务之一，它帮助我们通过 XMLHttpRequest 对象或 JSONP 与远程 HTTP 服务进行交流。\n\n　　$http 服务是这样一个函数：它接受一个设置对象，其中指定了如何创建 HTTP 请求；它将返回一个 promise 对象，其中提供两个方法： success 方法和 error方法。\n```\n$http.get({url:\"/xxx.action\"}).success(function(data){\n    alert(data);\n}).error(function(){\n    alert(\"error\");\n});\n```\n$http 接受的配置项有：\n\n- method 方法\n- url 路径\n- params GET请求的参数\n- data post请求的参数\n- headers 头\n- transformRequest 请求预处理函数\n- transformResponse 响应预处理函数\n- cache 缓存\n- timeout 超时毫秒，超时的请求会被取消\n- withCredentials 跨域安全策略的一个东西\n　　其中的 transformRequest 和 transformResponse 及 headers 已经有定义的，如果自定义则会覆盖默认定义\n\n对于几个标准的 HTTP 方法，有对应的 shortcut(捷径的意思) ：\n\n- $http.delete(url, config)\n- $http.get(url, config)\n- $http.head(url, config)\n- $http.jsonp(url, config)\n- $http.post(url, data, config)\n- $http.put(url, data, config)\n　　注意其中的 JSONP 方法，在实现上会在页面中添加一个 script 标签，然后放出一个 GET 请求。你自己定义的，匿名回调函数，会被 ng 自已给一个全局变量。在定义请求，作为 GET 参数，你可以使用 JSON_CALLBACK 这个字符串来暂时代替回调函数名，之后 ng 会为你替换成真正的函数名：\n```\nvar p = $http({\n\tmethod: 'JSONP',\n\turl: '/json',\n\tparams: {callback: 'JSON_CALLBACK'}\n});\np.success(function(response, status, headers, config){\n\tconsole.log(response);\n\t$scope.name = response.name;\n});\n```\n$http 有两个属性：\n\n- defaults 请求的全局配置\n- pendingRequests 当前的请求队列状态\n```\n$http.defaults.transformRequest = function(data){\n    console.log('here'); return data;}\nconsole.log($http.pendingRequests);\n```\n\n### 5. AngularJS 控制器\n\n　　AngularJS 应用程序被控制器控制，控制器是 JavaScript 对象，由标准的 JavaScript 对象的构造函数 创建。\n\n　　ng-controller 指令定义了应用程序控制器，给所在的 DOM 元素创建了一个新的 $scope 对象，并将这个 $scope 对象包含进外层 DOM 元素的 $scope 对象里。\n\n示例如下：\n```\n<div ng-app=\"\" ng-controller=\"personController\">\n名： <input type=\"text\" ng-model=\"person.firstName\"><br>\n姓： <input type=\"text\" ng-model=\"person.lastName\"><br>\n<br>\n姓名： {{fullName()}}\n</div>\n<script>\nfunction personController($scope) {\n\t$scope.person = {\n\t\tfirstName: \"John\",\n\t\tlastName: \"Doe\",\n\t };\n\t $scope.fullName = function() {\n\t\t var x;\n\t\t x = $scope.person; \n\t\t return x.firstName + \" \" + x.lastName;\n\t };\n}\n</script>\n```\n　　$scope 是一个把 view（一个DOM元素）连结到 controller 上的对象。在我们的 MVC 结构里，这个 $scope 将成为 model，它提供一个绑定到DOM元素（以及其子元素）上的excecution context。\n\n　　尽管听起来有点复杂，但 $scope 实际上就是一个JavaScript 对象，controller 和 view 都可以访问它，所以我们可以利用它在两者间传递信息。在这个 $scope 对象里，我们既存储数据，又存储将要运行在view上的函数。\n\n　　每一个 Angular 应用都会有一个 $rootScope。这个 $rootScope 是最顶级的 scope，它对应着含有 ng-app 指令属性的那个 DOM 元素\n\n　　所有scope都遵循原型继承（prototypal inheritance），这意味着它们都能访问父scope们。\n\n### 6. AngularJS 模块\n\n　　AngularJS 本身的一个默认模块叫做 ng ，它提供了 $http ， $q 等等服务。\n\n　　服务只是模块提供的多种机制中的一种，其它的还有命令（ directive ），过滤器（ filter ），及其它配置信息。\n\n　　然后在额外的 js 文件中有一个附加的模块叫做 ngResource ， 它提供了一个 $resource 服务。\n\n#### 定义模块\n\n　　定义模块的方法是使用 angular.module 。调用时声明了对其它模块的依赖，并定义了“初始化”函数。\n```\n  var my_module = angular.module('MyModule', [], function(){\n      console.log('here');\n  });\n```\n这段代码定义了一个叫做 MyModule 的模块， my_module 这个引用可以在接下来做其它的一些事，比如定义服务。\n\n#### 定义服务\n\n　　ng的服务是这样定义的：\n\n　　Angular services are singletons objects or functions that carry out specific tasks common to web apps.\n\n　　它是一个单例对象或函数，对外提供特定的功能。\n　　首先是一个单例，即无论这个服务被注入到任何地方，对象始终只有一个实例。\n　　其次这与我们自己定义一个function然后在其他地方调用不同，因为服务被定义在一个模块中，所以其使用范围是可以被我们管理的。ng的避免全局变量污染意识非常强。\n　　ng提供了很多内置的服务，可以到API中查看 http://docs.angularjs.org/api/ 。如同指令一样，系统内置的服务以$开头，我们也可以自己定义一个服务。\n\n　　在这里呢，就要先介绍一下叫 provider 的东西。简单来说， provider 是被 注入控制器 使用的一个对象，注入机制通过调用一个 provider 的 $get() 方法，把得到的东西作为参数进行相关调用（比如把得到的服务作为一个 Controller 的参数）。\n\n　　在这里 服务 的概念就比较不明确，对使用而言，服务仅指 $get() 方法返回的东西，但是在整体机制上，服务又要指提供了 $get() 方法的整个对象。\n\n- 这是一个provider\n```\n  var pp = function(){\n    this.$get = function(){\n      return {'haha': '123'};\n    }\n  }\n```\n- 我在模块的初始化过程当中, 定义了一个叫 PP 的服务\n```\n  var app = angular.module('Demo', [], function($provide){\n    $provide.provider('PP', pp);\n  });\n```\n- PP服务实际上就是 pp 这个 provider 的 $get() 方法返回的东西\n```\n  app.controller('TestCtrl',\n    function($scope, PP){\n      console.log(PP);\n    }\n  );\n ```\n　　ng 还有相关的 shortcut， 第一个是 factory 方法 ，由 $provide 提供， module 的 factory 是一个引用，作用一样。这个方法直接把一个函数当成是一个对象的 $get() 方法，这样你就不用显式地定义一个 provider 了：\n```\nvar app = angular.module('Demo', [], function($provide){\n    $provide.factory('PP', function(){\n        return {'hello': '123'};\n    });\n});\napp.controller('TestCtrl', function($scope, PP){ console.log(PP) });\n```\n在 module 中使用：\n```\nvar app = angular.module('Demo', [], function(){ });\napp.factory('PP', function(){return {'abc': '123'}});\napp.controller('TestCtrl', function($scope, PP){ console.log(PP) });\n```\n　　第二个是 service 方法，也是由 $provide 提供， module 中有对它的同名引用。 service 和 factory 的区别在于，前者是要求提供一个“构造方法”，后者是要求提供 $get() 方法。意思就是，前者一定是得到一个 object ，后者可以是一个数字或字符串。它们的关系大概是：\n```\nvar app = angular.module('Demo', [], function(){ });\napp.service = function(name, constructor){\n    app.factory(name, function(){\n      return (new constructor());\n    });\n}\n```\nservice 方法的使用就很简单了：\n```\nvar app = angular.module('Demo', [], function(){ });\napp.service('PP', function(){\n    this.abc = '123';\n});\napp.controller('TestCtrl', function($scope, PP){ console.log(PP) });\n```\n引入模块并使用服务\n结合上面的 定义模块 和 定义服务 ，我们可以方便地组织自己的额外代码：\n\n- 定义服务\n```\nangular.module('MyModule', [], function($provide){\n    $provide.factory('S1', function(){\n      return 'I am S1';\n    });\n    $provide.factory('S2', function(){\n      return {see: function(){return 'I am S2'}}\n    });\n});\n```\n- 调用服务\n```\nvar app = angular.module('Demo', ['MyModule'], angular.noop);\napp.controller('TestCtrl', function($scope, S1, S2){\n    console.log(S1)\n    console.log(S2.see())\n});\n```\n\n### 7. 附加模块 ngResource\n\n　　ngResource 这个是 ng 官方提供的一个附加模块。 附加 的意思就是，如果你打算用它，那么你需要引入一人单独的 js 文件，然后在声明“根模块”时注明依赖的 ngResource 模块，接着就可以使用它提供的 $resource 服务了。\n\n　　$resource 服务主要是包装了 AJAX 的调用，使用 $resource 需要先定义“资源”，也就是先定义一些 HTTP 请求。\n\n### 8. AngularJS 路由\n\nng的路由(ngRoute)是一个单独的模块，包含以下内容：\n\n服务 $routeProvider 用来定义一个路由表，即地址栏与视图模板的映射\n服务 $routeParams 保存了地址栏中的参数，例如 {id : 1, name : 'tom'}\n服务 $route 完成路由匹配，并且提供路由相关的属性访问及事件，如访问当前路由对应的 controller\n指令 ngView 用来在主视图中指定加载子视图的区域\n\n#### 定义路由\n\n- 第一步：引入文件和依赖\n\nngRoute 也是一个附件模块，故需要在页面上引入 angular-route.min.js 并在模块中注入对 ngRoute 的依赖，如下：\n```\nvar app = angular.module('MyApp', ['ngRoute']);//一切从模块开始\n```\n- 第二步：定义路由表\n\n　　$routeProvider 提供了定义路由表的服务，它有两个核心方法： when(path,route) 和 otherwise(params) ，先看一下核心中的核心 when(path,route)方法。\n\n　　when(path,route) 方法接收两个参数:\n\n　　path 是一个 string 类型，表示该条路由规则所匹配的路径，它将与地址栏的内容($location.path)值进行匹配。如果需要匹配参数，可以在 path 中使用冒号加名称的方式，如：path为 /show/:name ，如果地址栏是 /show/tom ，那么参数 name 和所对应的值 tom 便会被保存在 $routeParams 中，像这样： {name : tom} 。我们也可以用 * 进行模糊匹配，如： /show*/:name 将匹配 /showInfo/tom 。\n\n　　route 参数是一个 object，用来指定当 path 匹配后所需的一系列配置项，包括以下内容：\n　　controller function 或 string 类型。在当前模板上执行的 controller 函数，生成新的 scope；\n　　controllerAs string 类型，为 controller 指定别名；\n　　template string 或 function 类型，视图所用的模板，这部分内容将被 ngView 引用；\n　　templateUrl string 或 function 类型，当视图模板为单独的 html 文件或是使用了 <script type=\"text/ng-template\"> 定义模板时使用；\n　　resolve 指定当前 controller 所依赖的其他模块；\n　　redirectTo 重定向的地址。\n\n- 第三步：在主视图模板中指定加载子视图的位置\n\n只需在模板中简单的使用此 ngView 指令:\n```\n<div ng-view></div>\n```\nTODO UI-ROUTE","source":"_posts/angular-study.md","raw":"---\ntitle: AngularJS基本知识点\ndate: 2016-7-13 13:36:32\ntags: angular\n---\n　　AngularJS 是一个 MVVM框架，最适于开发客户端的单页面应用。它不是个功能库，而是用来开发动态网页的框架。它专注于扩展 HTML 的功能，提供动态数据绑定（data binding），而且它能跟其它框架（如 JQuery 等）合作融洽。\n\n### 1. 一个简单示例\n\n通过下面的示例代码，可以运行一个简单的 AngularJS 应用：\n```\n<!DOCTYPE html>\n<html>\n<body>\n\n<div ng-app=\"\">\n  <p>在输入框中尝试输入：</p>\n  <p>姓名：<input type=\"text\" ng-model=\"name\"></p>\n  <p ng-bind=\"name\"></p>\n</div>\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.3.8/angular.min.js\"></script>\n</body>\n</html>\n```\n通过浏览器访问该页面，在输入框中输入的内容会立即显示在输入框下面。\n\n##### 说明：\n\n当网页加载完毕，AngularJS 自动运行。\nng-app 指令告诉 AngularJS ，div 元素是 AngularJS 应用程序的\"所有者\"，相当于是个作用域的概率。\nng-model 指令把输入域的值绑定到应用程序变量 name。\nng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML。\n### 2. AngularJS 指令\n\nAngularJS 指令是扩展的 HTML 属性，带有前缀 ng- 。\n\nHTML5 允许扩展的（自制的）属性，以 data- 开头。AngularJS 属性以 ng- 开头，但是您可以使用 data-ng- 来让网页对 HTML5 有效。\n\n#### 常见的指令\n\n- ng-app 指令\n \n ng-app 指令初始化一个 AngularJS 应用程序。\n\n- ng-init 指令\n \n ng-init 指令初始化应用程序数据，这个不常使用。通常情况下，不使用 ng-init。您将使用一个控制器或模块来代替它。\n\n- ng-model 指令\n\n ng-model 指令把元素值（比如输入域的值）绑定到应用程序。\n\n- ng-bind 指令\n\n ng-bind 指令把应用程序数据绑定到 HTML 视图。\n\n示例：\n```\n<div ng-app=\"\">\n  <p>在输入框中尝试输入：</p>\n  <p>姓名：<input type=\"text\" ng-model=\"name\"></p>\n  <p ng-bind=\"name\"></p>\n</div>\n```\n- ng-repeat 指令\n\nng-repeat 指令会重复一个 HTML 元素：\n```\n<div ng-app=\"\" ng-init=\"names=[\n{name:'Jani',country:'Norway'},\n{name:'Hege',country:'Sweden'},\n{name:'Kai',country:'Denmark'}]\">\n\n<p>循环对象：</p>\n  <ul>\n    <li ng-repeat=\"x in names\">\n\n    </li>\n  </ul>\n</div>\n```\n除此之外，它还提供了几个变量可供使用：\n\n- index 当前索引\n- first 是否为头元素\n- middle 是否为非头非尾元素\n- last 是否为尾元素\n\n##### 样式相关的指令\n\n- ng-class\n\nng-class用来给元素绑定类名，其表达式的返回值可以是以下三种：\n\n类名字符串，可以用空格分割多个类名，如 ‘class1 class2’；\n类名数组，数组中的每一项都会层叠起来生效；\n一个名值对应的map，其键值为类名，值为boolean类型，当值为true时，该类会被加在元素上。\n与 ng-class 相近的，ng 还提供了ng-class-odd、ng-class-even 两个指令，用来配合 ng-repeat 分别在奇数列和偶数列使用对应的类。这个用来在表格中实现隔行换色再方便不过了。\n\n- ng-style\n\nng-style 用来绑定元素的 css 样式，其表达式的返回值为一个 js 对象，键为 css 样式名，值为该样式对应的合法取值。用法比较简单：\n```\n$scope.style = {color:'red'};　\n\n<div ng-style=\"{color:'red'}\">ng-style测试</div>\n<div ng-style=\"style\">ng-style测试</div>\nng-show、ng-hide、ng-switch\n```\n对于比较常用的元素显隐控制，ng 也做了封装，ng-show 和 ng-hide 的值为 boolean 类型的表达式，当值为 true 时，对应的 show 或 hide 生效。框架会用 display:block 和 display:none 来控制元素的显隐。\n\n示例：\n```\n<div ng-app=\"\">\n\t<div ng-show=\"true\">1</div>\n\t<div ng-show=\"false\">2</div>\n\t<div ng-hide=\"true\">3</div>\n\t<div ng-hide=\"false\">4</div>\n</div>\n```\n后一个 ng-switch 是根据一个值来决定哪个节点显示，其它节点移除：\n```\n<div ng-init=\"a=2\">\n    <ul ng-switch on=\"a\">\n\t    <li ng-switch-when=\"1\">1</li>\n\t    <li ng-switch-when=\"2\">2</li>\n\t    <li ng-switch-default>other</li>\n    </ul>\n</div>\n```\n### 事件指令\n\n事件相关的指令有：\n\n- ng-change\n- ng-click\n- ng-dblclick\n- ng-mousedown\n- ng-mouseenter\n- ng-mouseleave\n- ng-mousemove\n- ng-mouseover\n- ng-mouseup\n- ng-submit\n对于事件对象本身，在函数调用时可以直接使用 $event 进行传递：\n```\n<p ng-click=\"click($event)\">点击</p>\n<p ng-click=\"click($event.target)\">点击</p>\n\n$scope.click = function($event){\n         alert($event.target);\n         //……………………\n}　\n```\n\n### 表单指令\n\n　　表单控件类的模板指令，最大的作用是它预定义了需要绑定的数据的格式。这样，就可以对于既定的数据进行既定的处理。\n\n#### form\n\n　　ng 对 form 这个标签作了包装，对应的指令是 *ng-form*。\n\n　　从 ng 的角度来说， form 标签，是一个模板指令，也创建了一个 FormController 的实例。这个实例就提供了相应的属性和方法。同时，它里面的控件也是一个 NgModelController 实例。\n\n　　*很重要的一点*， form 的相关方法要生效，必须为 form 标签指定 name 和 ng-controller ，并且每个控件都要绑定一个变量。 form 和控件的名字，即是 $scope 中的相关实例的引用变量名。\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\">\n  <input type=\"text\" name=\"a\" required ng-model=\"a\"  />\n  <span ng-click=\"see()\"></span>\n</form>\n\nvar TestCtrl = function($scope){\n  $scope.see = function(){\n    console.log($scope.test_form);\n    console.log($scope.test_form.a);\n  }\n}\n```\n除去对象的方法与属性， form 这个标签本身有一些动态类可以使用：\n\n- ng-valid 当表单验证通过时的设置\n- ng-invalid 当表单验证失败时的设置\n- ng-pristine 表单的未被动之前拥有\n- ng-dirty 表单被动过之后拥有\n\n#### form 对象的属性有：\n- $pristine 表单是否未被动过\n- $dirty 表单是否被动过\n- $valid 表单是否验证通过\n- $invalid 表单是否验证失败\n- $error 表单的验证错误\n其中的 $error 对象包含有所有字段的验证信息，及对相关字段的 NgModelController 实例的引用。它的结构是一个对象， key 是失败信息， required ， minlength 之类的， value 是对应的字段实例列表。\n\n#### input\ninput 控件的相关可用属性为：\n\n- name 名字\n- ng-model 绑定的数据\n- required 是否必填\n- ng-required 是否必填\n- ng-minlength 最小长度\n- ng-maxlength 最大长度\n- ng-pattern 匹配模式\n- ng-change 值变化时的回调\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\">\n  <input type=\"text\" name=\"a\" ng-model=\"a\" required ng-pattern=\"/abc/\" />\n  <span ng-click=\"see()\"></span>\n</form>\n```\ninput 控件，它还有一些扩展，这些扩展有些有自己的属性：\n\n- input type=\"number\" 多了 number 错误类型，多了 max ， min 属性。\n- input type=\"url\" 多了 url 错误类型。\n- input type=\"email\" 多了 email 错误类型。\n\n#### checkbox\n\n它是 input 的扩展，不过，它没有验证相关的东西，只有选中与不选中两个值：ng-true-value、ng-false-value:\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\">\n  <input type=\"checkbox\" name=\"a\" ng-model=\"a\" ng-true-value=\"AA\" ng-false-value=\"BB\" />\n  <span></span>\n</form>\n```\n#### radio\n\n它也是 input 的扩展。和 checkbox 一样，但它只有一个值：\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\">\n  <input type=\"radio\" name=\"a\" ng-model=\"a\" value=\"AA\" />\n  <input type=\"radio\" name=\"a\" ng-model=\"a\" value=\"BB\" />\n  <span></span>\n</form>\n```\n\n#### textarea  同 input\n\n#### select\n\n它里面的一个叫做 ng-options 的属性用于数据呈现。\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\" ng-init=\"o=[0,1,2,3]; a=o[1];\">\n    <select ng-model=\"a\" ng-options=\"x for x in o\">\n      <option value=\"\">可以加这个空值</option>\n    </select>\n</form>\n```\n在 $scope 中， select 绑定的变量，其值和普通的 value 无关，可以是一个对象：\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\"\n    ng-init=\"o=[{name: 'AA'}, {name: 'BB'}]; a=o[1];\">\n    <select ng-model=\"a\" ng-options=\"x.name for x in o\" />\n</form>\n```\n显示与值分别指定， x.v as x.name for x in o ： as for  in 要理解清楚！\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\"\n    ng-init=\"o=[{name: 'AA', v: '00'}, {name: 'BB', v: '11'}]; a=o[1].v;\">\n    <select ng-model=\"a\" ng-options=\"x.v as x.name for x in o\" />\n</form>\n```\n加入分组的， x.name group by x.g for x in o ：\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\"\n    ng-init=\"o=[{name: 'AA', g: '00'}, {name: 'BB', g: '11'}, {name: 'CC', g: '00'}]; a=o[1];\">\n    <select ng-model=\"a\" ng-options=\"x.name group by x.g for x in o\" />\n</form>\n```\n分组了还分别指定显示与值的， x.v as x.name group by x.g for x in o ：\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\" ng-init=\"o=[{name: 'AA', g: '00', v: '='}, {name: 'BB', g: '11', v: '+'}, {name: 'CC', g: '00', v: '!'}]; a=o[1].v;\">\n    <select ng-model=\"a\" ng-options=\"x.v as x.name group by x.g for x in o\" />\n</form>\n```\n如果参数是对象的话，基本也是一样的，只是把遍历的对象改成 (key, value) ：\n```\n<form name=\"test_form\" ng-controller=\"TestCtrl\" ng-init=\"o={a: 0, b: 1}; a=o.a;\">\n\t<select ng-model=\"a\" ng-options=\"k for (k, v) in o\" />\n</form>\n<form name=\"test_form\" ng-controller=\"TestCtrl\"\n\tng-init=\"o={a: {name: 'AA', v: '00'}, b: {name: 'BB', v: '11'}}; a=o.a.v;\">\n\t<select ng-model=\"a\" ng-options=\"v.v as v.name for (k, v) in o\" />\n</form>\n<form name=\"test_form\" ng-controller=\"TestCtrl\"\n\tng-init=\"o={a: {name: 'AA', v: '00', g: '=='}, b: {name: 'BB', v: '11', g: '=='}}; a=o.a;\">\n\t<select ng-model=\"a\" ng-options=\"v.name group by v.g for (k, v) in o\" />\n</form>\n<form name=\"test_form\" ng-controller=\"TestCtrl\"\n\tng-init=\"o={a: {name: 'AA', v: '00', g: '=='}, b: {name: 'BB', v: '11', g: '=='}}; a=o.a.v;\">\n\t<select ng-model=\"a\" ng-options=\"v.v as v.name group by v.g for (k, v) in o\" />\n</form>\n```\n还有一些表单控件功能相关的指令：\n\n- ng-src src 属性\n- ng-href href 属性\n- ng-checked 控制 radio 和 checkbox 的选中状态\n- ng-selected 控制下拉框的选中状态\n- ng-disabled 控制失效状态\n- ng-multiple 控制多选\n- ng-readonly 控制只读状态\n以上指令的取值均为 boolean 类型，当值为 true 时相关状态生效，道理比较简单就不多做解释。\n\n*注意*:上面的这些只是单向绑定，即只是从数据到模板，不能反作用于数据。要双向绑定，还是要使用 ng-model 。\n\n### 3. AngularJS 过滤器\n\n　　过滤器（filter）正如其名，作用就是接收一个输入，通过某个规则进行处理，然后返回处理后的结果。主要用在数据的格式化上，例如获取一个数组中的子集，对数组中的元素进行排序等。过滤器通常是伴随标记来使用的，将你 model 中的数据格式化为需要的格式。表单的控制功能主要涉及到数据验证以及表单控件的增强。\n\n#### 内置过滤器\n\n　　ng 内置了一些过滤器，它们是：currency(货币)、date(日期)、filter(子串匹配)、json(格式化json对象)、limitTo(限制个数)、lowercase(小写)、uppercase(大写)、number(数字)、orderBy(排序)。\n\n过滤器使用示例：\n\n- 使用currency可以将数字格式化为货币，默认是美元符号，你可以自己传入所需的符号\n```\n{{num | currency : '￥'}}\n```\n- 参数用来指定所要的格式，y M d h m s E 分别表示 年 月 日 时 分 秒 星期，你可以自由组合它们。也可以使用不同的个数来限制格式化的位数。另外参数也可以使用特定的描述性字符串，例如“shortTime”将会把时间格式为12:05 pm这样的。\n```\n{{date | date : 'yyyy-MM-dd hh:mm:ss EEEE'}}\n```\n\n- filter 过滤器从数组中选择一个子集：\n```\n{{ childrenArray | filter : 'a' }} //匹配属性值中含有a的\n{{ childrenArray | filter : 4 }}  //匹配属性值中含有4的\n{{ childrenArray | filter : {name : 'i'} }} //参数是对象，匹配name属性中含有i的\n$scope.func = function(e){return e.age>4;}{{ childrenArray | filter : 'a' }}\n{{childrenArray | filter : func }}  //参数是函数　\n```\n- json过滤器可以把一个js对象格式化为json字符串\n```\n{{ jsonTest | json}}\n```\n- 列表截取 limitTo ，支持正负数\n```\n{{ childrenArray | limitTo : 2 }} \n```\n- number过滤器可以为一个数字加上千位分割，像这样，123,456,789。同时接收一个参数，可以指定float类型保留几位小数：\n```\n{{ num | number : 2 }}\n```\n- 大小写 lowercase ， uppercase ：\n```\n{{ 'abc' | uppercase }}\n{{ 'Abc' | lowercase }}\n```\n```\n{{ childrenArray | orderBy : 'age' }}       //按age属性值进行排序，若是-age，则倒序\n{{ childrenArray | orderBy : orderFunc }}   //按照函数的返回值进行排序\n{{ childrenArray | orderBy : ['age','name'] }}  //如果age相同，按照name进行排序\n```\n\n*过滤器使用方式*\n\n在模块中定义过滤器：\n```\nvar app = angular.module('Demo', [], angular.noop);\n  app.filter('map', function(){\n    var filter = function(input){\n      return input + '...';\n    };\n    return filter;\n  });\n ```\n然后，在模板中使用：\n```\n<p>示例数据: {{ a | map }}</p>\n```\n### 4. AngularJS Ajax\n\n　　$http 服务是 AngularJS 的核心服务之一，它帮助我们通过 XMLHttpRequest 对象或 JSONP 与远程 HTTP 服务进行交流。\n\n　　$http 服务是这样一个函数：它接受一个设置对象，其中指定了如何创建 HTTP 请求；它将返回一个 promise 对象，其中提供两个方法： success 方法和 error方法。\n```\n$http.get({url:\"/xxx.action\"}).success(function(data){\n    alert(data);\n}).error(function(){\n    alert(\"error\");\n});\n```\n$http 接受的配置项有：\n\n- method 方法\n- url 路径\n- params GET请求的参数\n- data post请求的参数\n- headers 头\n- transformRequest 请求预处理函数\n- transformResponse 响应预处理函数\n- cache 缓存\n- timeout 超时毫秒，超时的请求会被取消\n- withCredentials 跨域安全策略的一个东西\n　　其中的 transformRequest 和 transformResponse 及 headers 已经有定义的，如果自定义则会覆盖默认定义\n\n对于几个标准的 HTTP 方法，有对应的 shortcut(捷径的意思) ：\n\n- $http.delete(url, config)\n- $http.get(url, config)\n- $http.head(url, config)\n- $http.jsonp(url, config)\n- $http.post(url, data, config)\n- $http.put(url, data, config)\n　　注意其中的 JSONP 方法，在实现上会在页面中添加一个 script 标签，然后放出一个 GET 请求。你自己定义的，匿名回调函数，会被 ng 自已给一个全局变量。在定义请求，作为 GET 参数，你可以使用 JSON_CALLBACK 这个字符串来暂时代替回调函数名，之后 ng 会为你替换成真正的函数名：\n```\nvar p = $http({\n\tmethod: 'JSONP',\n\turl: '/json',\n\tparams: {callback: 'JSON_CALLBACK'}\n});\np.success(function(response, status, headers, config){\n\tconsole.log(response);\n\t$scope.name = response.name;\n});\n```\n$http 有两个属性：\n\n- defaults 请求的全局配置\n- pendingRequests 当前的请求队列状态\n```\n$http.defaults.transformRequest = function(data){\n    console.log('here'); return data;}\nconsole.log($http.pendingRequests);\n```\n\n### 5. AngularJS 控制器\n\n　　AngularJS 应用程序被控制器控制，控制器是 JavaScript 对象，由标准的 JavaScript 对象的构造函数 创建。\n\n　　ng-controller 指令定义了应用程序控制器，给所在的 DOM 元素创建了一个新的 $scope 对象，并将这个 $scope 对象包含进外层 DOM 元素的 $scope 对象里。\n\n示例如下：\n```\n<div ng-app=\"\" ng-controller=\"personController\">\n名： <input type=\"text\" ng-model=\"person.firstName\"><br>\n姓： <input type=\"text\" ng-model=\"person.lastName\"><br>\n<br>\n姓名： {{fullName()}}\n</div>\n<script>\nfunction personController($scope) {\n\t$scope.person = {\n\t\tfirstName: \"John\",\n\t\tlastName: \"Doe\",\n\t };\n\t $scope.fullName = function() {\n\t\t var x;\n\t\t x = $scope.person; \n\t\t return x.firstName + \" \" + x.lastName;\n\t };\n}\n</script>\n```\n　　$scope 是一个把 view（一个DOM元素）连结到 controller 上的对象。在我们的 MVC 结构里，这个 $scope 将成为 model，它提供一个绑定到DOM元素（以及其子元素）上的excecution context。\n\n　　尽管听起来有点复杂，但 $scope 实际上就是一个JavaScript 对象，controller 和 view 都可以访问它，所以我们可以利用它在两者间传递信息。在这个 $scope 对象里，我们既存储数据，又存储将要运行在view上的函数。\n\n　　每一个 Angular 应用都会有一个 $rootScope。这个 $rootScope 是最顶级的 scope，它对应着含有 ng-app 指令属性的那个 DOM 元素\n\n　　所有scope都遵循原型继承（prototypal inheritance），这意味着它们都能访问父scope们。\n\n### 6. AngularJS 模块\n\n　　AngularJS 本身的一个默认模块叫做 ng ，它提供了 $http ， $q 等等服务。\n\n　　服务只是模块提供的多种机制中的一种，其它的还有命令（ directive ），过滤器（ filter ），及其它配置信息。\n\n　　然后在额外的 js 文件中有一个附加的模块叫做 ngResource ， 它提供了一个 $resource 服务。\n\n#### 定义模块\n\n　　定义模块的方法是使用 angular.module 。调用时声明了对其它模块的依赖，并定义了“初始化”函数。\n```\n  var my_module = angular.module('MyModule', [], function(){\n      console.log('here');\n  });\n```\n这段代码定义了一个叫做 MyModule 的模块， my_module 这个引用可以在接下来做其它的一些事，比如定义服务。\n\n#### 定义服务\n\n　　ng的服务是这样定义的：\n\n　　Angular services are singletons objects or functions that carry out specific tasks common to web apps.\n\n　　它是一个单例对象或函数，对外提供特定的功能。\n　　首先是一个单例，即无论这个服务被注入到任何地方，对象始终只有一个实例。\n　　其次这与我们自己定义一个function然后在其他地方调用不同，因为服务被定义在一个模块中，所以其使用范围是可以被我们管理的。ng的避免全局变量污染意识非常强。\n　　ng提供了很多内置的服务，可以到API中查看 http://docs.angularjs.org/api/ 。如同指令一样，系统内置的服务以$开头，我们也可以自己定义一个服务。\n\n　　在这里呢，就要先介绍一下叫 provider 的东西。简单来说， provider 是被 注入控制器 使用的一个对象，注入机制通过调用一个 provider 的 $get() 方法，把得到的东西作为参数进行相关调用（比如把得到的服务作为一个 Controller 的参数）。\n\n　　在这里 服务 的概念就比较不明确，对使用而言，服务仅指 $get() 方法返回的东西，但是在整体机制上，服务又要指提供了 $get() 方法的整个对象。\n\n- 这是一个provider\n```\n  var pp = function(){\n    this.$get = function(){\n      return {'haha': '123'};\n    }\n  }\n```\n- 我在模块的初始化过程当中, 定义了一个叫 PP 的服务\n```\n  var app = angular.module('Demo', [], function($provide){\n    $provide.provider('PP', pp);\n  });\n```\n- PP服务实际上就是 pp 这个 provider 的 $get() 方法返回的东西\n```\n  app.controller('TestCtrl',\n    function($scope, PP){\n      console.log(PP);\n    }\n  );\n ```\n　　ng 还有相关的 shortcut， 第一个是 factory 方法 ，由 $provide 提供， module 的 factory 是一个引用，作用一样。这个方法直接把一个函数当成是一个对象的 $get() 方法，这样你就不用显式地定义一个 provider 了：\n```\nvar app = angular.module('Demo', [], function($provide){\n    $provide.factory('PP', function(){\n        return {'hello': '123'};\n    });\n});\napp.controller('TestCtrl', function($scope, PP){ console.log(PP) });\n```\n在 module 中使用：\n```\nvar app = angular.module('Demo', [], function(){ });\napp.factory('PP', function(){return {'abc': '123'}});\napp.controller('TestCtrl', function($scope, PP){ console.log(PP) });\n```\n　　第二个是 service 方法，也是由 $provide 提供， module 中有对它的同名引用。 service 和 factory 的区别在于，前者是要求提供一个“构造方法”，后者是要求提供 $get() 方法。意思就是，前者一定是得到一个 object ，后者可以是一个数字或字符串。它们的关系大概是：\n```\nvar app = angular.module('Demo', [], function(){ });\napp.service = function(name, constructor){\n    app.factory(name, function(){\n      return (new constructor());\n    });\n}\n```\nservice 方法的使用就很简单了：\n```\nvar app = angular.module('Demo', [], function(){ });\napp.service('PP', function(){\n    this.abc = '123';\n});\napp.controller('TestCtrl', function($scope, PP){ console.log(PP) });\n```\n引入模块并使用服务\n结合上面的 定义模块 和 定义服务 ，我们可以方便地组织自己的额外代码：\n\n- 定义服务\n```\nangular.module('MyModule', [], function($provide){\n    $provide.factory('S1', function(){\n      return 'I am S1';\n    });\n    $provide.factory('S2', function(){\n      return {see: function(){return 'I am S2'}}\n    });\n});\n```\n- 调用服务\n```\nvar app = angular.module('Demo', ['MyModule'], angular.noop);\napp.controller('TestCtrl', function($scope, S1, S2){\n    console.log(S1)\n    console.log(S2.see())\n});\n```\n\n### 7. 附加模块 ngResource\n\n　　ngResource 这个是 ng 官方提供的一个附加模块。 附加 的意思就是，如果你打算用它，那么你需要引入一人单独的 js 文件，然后在声明“根模块”时注明依赖的 ngResource 模块，接着就可以使用它提供的 $resource 服务了。\n\n　　$resource 服务主要是包装了 AJAX 的调用，使用 $resource 需要先定义“资源”，也就是先定义一些 HTTP 请求。\n\n### 8. AngularJS 路由\n\nng的路由(ngRoute)是一个单独的模块，包含以下内容：\n\n服务 $routeProvider 用来定义一个路由表，即地址栏与视图模板的映射\n服务 $routeParams 保存了地址栏中的参数，例如 {id : 1, name : 'tom'}\n服务 $route 完成路由匹配，并且提供路由相关的属性访问及事件，如访问当前路由对应的 controller\n指令 ngView 用来在主视图中指定加载子视图的区域\n\n#### 定义路由\n\n- 第一步：引入文件和依赖\n\nngRoute 也是一个附件模块，故需要在页面上引入 angular-route.min.js 并在模块中注入对 ngRoute 的依赖，如下：\n```\nvar app = angular.module('MyApp', ['ngRoute']);//一切从模块开始\n```\n- 第二步：定义路由表\n\n　　$routeProvider 提供了定义路由表的服务，它有两个核心方法： when(path,route) 和 otherwise(params) ，先看一下核心中的核心 when(path,route)方法。\n\n　　when(path,route) 方法接收两个参数:\n\n　　path 是一个 string 类型，表示该条路由规则所匹配的路径，它将与地址栏的内容($location.path)值进行匹配。如果需要匹配参数，可以在 path 中使用冒号加名称的方式，如：path为 /show/:name ，如果地址栏是 /show/tom ，那么参数 name 和所对应的值 tom 便会被保存在 $routeParams 中，像这样： {name : tom} 。我们也可以用 * 进行模糊匹配，如： /show*/:name 将匹配 /showInfo/tom 。\n\n　　route 参数是一个 object，用来指定当 path 匹配后所需的一系列配置项，包括以下内容：\n　　controller function 或 string 类型。在当前模板上执行的 controller 函数，生成新的 scope；\n　　controllerAs string 类型，为 controller 指定别名；\n　　template string 或 function 类型，视图所用的模板，这部分内容将被 ngView 引用；\n　　templateUrl string 或 function 类型，当视图模板为单独的 html 文件或是使用了 <script type=\"text/ng-template\"> 定义模板时使用；\n　　resolve 指定当前 controller 所依赖的其他模块；\n　　redirectTo 重定向的地址。\n\n- 第三步：在主视图模板中指定加载子视图的位置\n\n只需在模板中简单的使用此 ngView 指令:\n```\n<div ng-view></div>\n```\nTODO UI-ROUTE","slug":"angular-study","published":1,"updated":"2016-12-13T06:38:55.644Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv6u000yjgtuh2fs49wg","content":"<p>　　AngularJS 是一个 MVVM框架，最适于开发客户端的单页面应用。它不是个功能库，而是用来开发动态网页的框架。它专注于扩展 HTML 的功能，提供动态数据绑定（data binding），而且它能跟其它框架（如 JQuery 等）合作融洽。</p>\n<h3 id=\"1-一个简单示例\"><a href=\"#1-一个简单示例\" class=\"headerlink\" title=\"1. 一个简单示例\"></a>1. 一个简单示例</h3><p>通过下面的示例代码，可以运行一个简单的 AngularJS 应用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;div ng-app=&quot;&quot;&gt;</div><div class=\"line\">  &lt;p&gt;在输入框中尝试输入：&lt;/p&gt;</div><div class=\"line\">  &lt;p&gt;姓名：&lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt;</div><div class=\"line\">  &lt;p ng-bind=&quot;name&quot;&gt;&lt;/p&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.3.8/angular.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure></p>\n<p>通过浏览器访问该页面，在输入框中输入的内容会立即显示在输入框下面。</p>\n<h5 id=\"说明：\"><a href=\"#说明：\" class=\"headerlink\" title=\"说明：\"></a>说明：</h5><p>当网页加载完毕，AngularJS 自动运行。<br>ng-app 指令告诉 AngularJS ，div 元素是 AngularJS 应用程序的”所有者”，相当于是个作用域的概率。<br>ng-model 指令把输入域的值绑定到应用程序变量 name。<br>ng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML。</p>\n<h3 id=\"2-AngularJS-指令\"><a href=\"#2-AngularJS-指令\" class=\"headerlink\" title=\"2. AngularJS 指令\"></a>2. AngularJS 指令</h3><p>AngularJS 指令是扩展的 HTML 属性，带有前缀 ng- 。</p>\n<p>HTML5 允许扩展的（自制的）属性，以 data- 开头。AngularJS 属性以 ng- 开头，但是您可以使用 data-ng- 来让网页对 HTML5 有效。</p>\n<h4 id=\"常见的指令\"><a href=\"#常见的指令\" class=\"headerlink\" title=\"常见的指令\"></a>常见的指令</h4><ul>\n<li><p>ng-app 指令</p>\n<p>ng-app 指令初始化一个 AngularJS 应用程序。</p>\n</li>\n<li><p>ng-init 指令</p>\n<p>ng-init 指令初始化应用程序数据，这个不常使用。通常情况下，不使用 ng-init。您将使用一个控制器或模块来代替它。</p>\n</li>\n<li><p>ng-model 指令</p>\n<p>ng-model 指令把元素值（比如输入域的值）绑定到应用程序。</p>\n</li>\n<li><p>ng-bind 指令</p>\n<p>ng-bind 指令把应用程序数据绑定到 HTML 视图。</p>\n</li>\n</ul>\n<p>示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=&quot;&quot;&gt;</div><div class=\"line\">  &lt;p&gt;在输入框中尝试输入：&lt;/p&gt;</div><div class=\"line\">  &lt;p&gt;姓名：&lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt;</div><div class=\"line\">  &lt;p ng-bind=&quot;name&quot;&gt;&lt;/p&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>ng-repeat 指令</li>\n</ul>\n<p>ng-repeat 指令会重复一个 HTML 元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=&quot;&quot; ng-init=&quot;names=[</div><div class=\"line\">&#123;name:&apos;Jani&apos;,country:&apos;Norway&apos;&#125;,</div><div class=\"line\">&#123;name:&apos;Hege&apos;,country:&apos;Sweden&apos;&#125;,</div><div class=\"line\">&#123;name:&apos;Kai&apos;,country:&apos;Denmark&apos;&#125;]&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;p&gt;循环对象：&lt;/p&gt;</div><div class=\"line\">  &lt;ul&gt;</div><div class=\"line\">    &lt;li ng-repeat=&quot;x in names&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">  &lt;/ul&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p>除此之外，它还提供了几个变量可供使用：</p>\n<ul>\n<li>index 当前索引</li>\n<li>first 是否为头元素</li>\n<li>middle 是否为非头非尾元素</li>\n<li>last 是否为尾元素</li>\n</ul>\n<h5 id=\"样式相关的指令\"><a href=\"#样式相关的指令\" class=\"headerlink\" title=\"样式相关的指令\"></a>样式相关的指令</h5><ul>\n<li>ng-class</li>\n</ul>\n<p>ng-class用来给元素绑定类名，其表达式的返回值可以是以下三种：</p>\n<p>类名字符串，可以用空格分割多个类名，如 ‘class1 class2’；<br>类名数组，数组中的每一项都会层叠起来生效；<br>一个名值对应的map，其键值为类名，值为boolean类型，当值为true时，该类会被加在元素上。<br>与 ng-class 相近的，ng 还提供了ng-class-odd、ng-class-even 两个指令，用来配合 ng-repeat 分别在奇数列和偶数列使用对应的类。这个用来在表格中实现隔行换色再方便不过了。</p>\n<ul>\n<li>ng-style</li>\n</ul>\n<p>ng-style 用来绑定元素的 css 样式，其表达式的返回值为一个 js 对象，键为 css 样式名，值为该样式对应的合法取值。用法比较简单：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$scope.style = &#123;color:&apos;red&apos;&#125;;　</div><div class=\"line\"></div><div class=\"line\">&lt;div ng-style=&quot;&#123;color:&apos;red&apos;&#125;&quot;&gt;ng-style测试&lt;/div&gt;</div><div class=\"line\">&lt;div ng-style=&quot;style&quot;&gt;ng-style测试&lt;/div&gt;</div><div class=\"line\">ng-show、ng-hide、ng-switch</div></pre></td></tr></table></figure></p>\n<p>对于比较常用的元素显隐控制，ng 也做了封装，ng-show 和 ng-hide 的值为 boolean 类型的表达式，当值为 true 时，对应的 show 或 hide 生效。框架会用 display:block 和 display:none 来控制元素的显隐。</p>\n<p>示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=&quot;&quot;&gt;</div><div class=\"line\">\t&lt;div ng-show=&quot;true&quot;&gt;1&lt;/div&gt;</div><div class=\"line\">\t&lt;div ng-show=&quot;false&quot;&gt;2&lt;/div&gt;</div><div class=\"line\">\t&lt;div ng-hide=&quot;true&quot;&gt;3&lt;/div&gt;</div><div class=\"line\">\t&lt;div ng-hide=&quot;false&quot;&gt;4&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p>后一个 ng-switch 是根据一个值来决定哪个节点显示，其它节点移除：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-init=&quot;a=2&quot;&gt;</div><div class=\"line\">    &lt;ul ng-switch on=&quot;a&quot;&gt;</div><div class=\"line\">\t    &lt;li ng-switch-when=&quot;1&quot;&gt;1&lt;/li&gt;</div><div class=\"line\">\t    &lt;li ng-switch-when=&quot;2&quot;&gt;2&lt;/li&gt;</div><div class=\"line\">\t    &lt;li ng-switch-default&gt;other&lt;/li&gt;</div><div class=\"line\">    &lt;/ul&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<h3 id=\"事件指令\"><a href=\"#事件指令\" class=\"headerlink\" title=\"事件指令\"></a>事件指令</h3><p>事件相关的指令有：</p>\n<ul>\n<li>ng-change</li>\n<li>ng-click</li>\n<li>ng-dblclick</li>\n<li>ng-mousedown</li>\n<li>ng-mouseenter</li>\n<li>ng-mouseleave</li>\n<li>ng-mousemove</li>\n<li>ng-mouseover</li>\n<li>ng-mouseup</li>\n<li>ng-submit<br>对于事件对象本身，在函数调用时可以直接使用 $event 进行传递：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;p ng-click=&quot;click($event)&quot;&gt;点击&lt;/p&gt;</div><div class=\"line\">&lt;p ng-click=&quot;click($event.target)&quot;&gt;点击&lt;/p&gt;</div><div class=\"line\"></div><div class=\"line\">$scope.click = function($event)&#123;</div><div class=\"line\">         alert($event.target);</div><div class=\"line\">         //……………………</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"表单指令\"><a href=\"#表单指令\" class=\"headerlink\" title=\"表单指令\"></a>表单指令</h3><p>　　表单控件类的模板指令，最大的作用是它预定义了需要绑定的数据的格式。这样，就可以对于既定的数据进行既定的处理。</p>\n<h4 id=\"form\"><a href=\"#form\" class=\"headerlink\" title=\"form\"></a>form</h4><p>　　ng 对 form 这个标签作了包装，对应的指令是 <em>ng-form</em>。</p>\n<p>　　从 ng 的角度来说， form 标签，是一个模板指令，也创建了一个 FormController 的实例。这个实例就提供了相应的属性和方法。同时，它里面的控件也是一个 NgModelController 实例。</p>\n<p>　　<em>很重要的一点</em>， form 的相关方法要生效，必须为 form 标签指定 name 和 ng-controller ，并且每个控件都要绑定一个变量。 form 和控件的名字，即是 $scope 中的相关实例的引用变量名。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;&gt;</div><div class=\"line\">  &lt;input type=&quot;text&quot; name=&quot;a&quot; required ng-model=&quot;a&quot;  /&gt;</div><div class=\"line\">  &lt;span ng-click=&quot;see()&quot;&gt;&lt;/span&gt;</div><div class=\"line\">&lt;/form&gt;</div><div class=\"line\"></div><div class=\"line\">var TestCtrl = function($scope)&#123;</div><div class=\"line\">  $scope.see = function()&#123;</div><div class=\"line\">    console.log($scope.test_form);</div><div class=\"line\">    console.log($scope.test_form.a);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>除去对象的方法与属性， form 这个标签本身有一些动态类可以使用：</p>\n<ul>\n<li>ng-valid 当表单验证通过时的设置</li>\n<li>ng-invalid 当表单验证失败时的设置</li>\n<li>ng-pristine 表单的未被动之前拥有</li>\n<li>ng-dirty 表单被动过之后拥有</li>\n</ul>\n<h4 id=\"form-对象的属性有：\"><a href=\"#form-对象的属性有：\" class=\"headerlink\" title=\"form 对象的属性有：\"></a>form 对象的属性有：</h4><ul>\n<li>$pristine 表单是否未被动过</li>\n<li>$dirty 表单是否被动过</li>\n<li>$valid 表单是否验证通过</li>\n<li>$invalid 表单是否验证失败</li>\n<li>$error 表单的验证错误<br>其中的 $error 对象包含有所有字段的验证信息，及对相关字段的 NgModelController 实例的引用。它的结构是一个对象， key 是失败信息， required ， minlength 之类的， value 是对应的字段实例列表。</li>\n</ul>\n<h4 id=\"input\"><a href=\"#input\" class=\"headerlink\" title=\"input\"></a>input</h4><p>input 控件的相关可用属性为：</p>\n<ul>\n<li>name 名字</li>\n<li>ng-model 绑定的数据</li>\n<li>required 是否必填</li>\n<li>ng-required 是否必填</li>\n<li>ng-minlength 最小长度</li>\n<li>ng-maxlength 最大长度</li>\n<li>ng-pattern 匹配模式</li>\n<li>ng-change 值变化时的回调<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;&gt;</div><div class=\"line\">  &lt;input type=&quot;text&quot; name=&quot;a&quot; ng-model=&quot;a&quot; required ng-pattern=&quot;/abc/&quot; /&gt;</div><div class=\"line\">  &lt;span ng-click=&quot;see()&quot;&gt;&lt;/span&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>input 控件，它还有一些扩展，这些扩展有些有自己的属性：</p>\n<ul>\n<li>input type=”number” 多了 number 错误类型，多了 max ， min 属性。</li>\n<li>input type=”url” 多了 url 错误类型。</li>\n<li>input type=”email” 多了 email 错误类型。</li>\n</ul>\n<h4 id=\"checkbox\"><a href=\"#checkbox\" class=\"headerlink\" title=\"checkbox\"></a>checkbox</h4><p>它是 input 的扩展，不过，它没有验证相关的东西，只有选中与不选中两个值：ng-true-value、ng-false-value:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;&gt;</div><div class=\"line\">  &lt;input type=&quot;checkbox&quot; name=&quot;a&quot; ng-model=&quot;a&quot; ng-true-value=&quot;AA&quot; ng-false-value=&quot;BB&quot; /&gt;</div><div class=\"line\">  &lt;span&gt;&lt;/span&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"radio\"><a href=\"#radio\" class=\"headerlink\" title=\"radio\"></a>radio</h4><p>它也是 input 的扩展。和 checkbox 一样，但它只有一个值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;&gt;</div><div class=\"line\">  &lt;input type=&quot;radio&quot; name=&quot;a&quot; ng-model=&quot;a&quot; value=&quot;AA&quot; /&gt;</div><div class=\"line\">  &lt;input type=&quot;radio&quot; name=&quot;a&quot; ng-model=&quot;a&quot; value=&quot;BB&quot; /&gt;</div><div class=\"line\">  &lt;span&gt;&lt;/span&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"textarea-同-input\"><a href=\"#textarea-同-input\" class=\"headerlink\" title=\"textarea  同 input\"></a>textarea  同 input</h4><h4 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h4><p>它里面的一个叫做 ng-options 的属性用于数据呈现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot; ng-init=&quot;o=[0,1,2,3]; a=o[1];&quot;&gt;</div><div class=\"line\">    &lt;select ng-model=&quot;a&quot; ng-options=&quot;x for x in o&quot;&gt;</div><div class=\"line\">      &lt;option value=&quot;&quot;&gt;可以加这个空值&lt;/option&gt;</div><div class=\"line\">    &lt;/select&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<p>在 $scope 中， select 绑定的变量，其值和普通的 value 无关，可以是一个对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;</div><div class=\"line\">    ng-init=&quot;o=[&#123;name: &apos;AA&apos;&#125;, &#123;name: &apos;BB&apos;&#125;]; a=o[1];&quot;&gt;</div><div class=\"line\">    &lt;select ng-model=&quot;a&quot; ng-options=&quot;x.name for x in o&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<p>显示与值分别指定， x.v as x.name for x in o ： as for  in 要理解清楚！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;</div><div class=\"line\">    ng-init=&quot;o=[&#123;name: &apos;AA&apos;, v: &apos;00&apos;&#125;, &#123;name: &apos;BB&apos;, v: &apos;11&apos;&#125;]; a=o[1].v;&quot;&gt;</div><div class=\"line\">    &lt;select ng-model=&quot;a&quot; ng-options=&quot;x.v as x.name for x in o&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<p>加入分组的， x.name group by x.g for x in o ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;</div><div class=\"line\">    ng-init=&quot;o=[&#123;name: &apos;AA&apos;, g: &apos;00&apos;&#125;, &#123;name: &apos;BB&apos;, g: &apos;11&apos;&#125;, &#123;name: &apos;CC&apos;, g: &apos;00&apos;&#125;]; a=o[1];&quot;&gt;</div><div class=\"line\">    &lt;select ng-model=&quot;a&quot; ng-options=&quot;x.name group by x.g for x in o&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<p>分组了还分别指定显示与值的， x.v as x.name group by x.g for x in o ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot; ng-init=&quot;o=[&#123;name: &apos;AA&apos;, g: &apos;00&apos;, v: &apos;=&apos;&#125;, &#123;name: &apos;BB&apos;, g: &apos;11&apos;, v: &apos;+&apos;&#125;, &#123;name: &apos;CC&apos;, g: &apos;00&apos;, v: &apos;!&apos;&#125;]; a=o[1].v;&quot;&gt;</div><div class=\"line\">    &lt;select ng-model=&quot;a&quot; ng-options=&quot;x.v as x.name group by x.g for x in o&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<p>如果参数是对象的话，基本也是一样的，只是把遍历的对象改成 (key, value) ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot; ng-init=&quot;o=&#123;a: 0, b: 1&#125;; a=o.a;&quot;&gt;</div><div class=\"line\">\t&lt;select ng-model=&quot;a&quot; ng-options=&quot;k for (k, v) in o&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;</div><div class=\"line\">\tng-init=&quot;o=&#123;a: &#123;name: &apos;AA&apos;, v: &apos;00&apos;&#125;, b: &#123;name: &apos;BB&apos;, v: &apos;11&apos;&#125;&#125;; a=o.a.v;&quot;&gt;</div><div class=\"line\">\t&lt;select ng-model=&quot;a&quot; ng-options=&quot;v.v as v.name for (k, v) in o&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;</div><div class=\"line\">\tng-init=&quot;o=&#123;a: &#123;name: &apos;AA&apos;, v: &apos;00&apos;, g: &apos;==&apos;&#125;, b: &#123;name: &apos;BB&apos;, v: &apos;11&apos;, g: &apos;==&apos;&#125;&#125;; a=o.a;&quot;&gt;</div><div class=\"line\">\t&lt;select ng-model=&quot;a&quot; ng-options=&quot;v.name group by v.g for (k, v) in o&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;</div><div class=\"line\">\tng-init=&quot;o=&#123;a: &#123;name: &apos;AA&apos;, v: &apos;00&apos;, g: &apos;==&apos;&#125;, b: &#123;name: &apos;BB&apos;, v: &apos;11&apos;, g: &apos;==&apos;&#125;&#125;; a=o.a.v;&quot;&gt;</div><div class=\"line\">\t&lt;select ng-model=&quot;a&quot; ng-options=&quot;v.v as v.name group by v.g for (k, v) in o&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<p>还有一些表单控件功能相关的指令：</p>\n<ul>\n<li>ng-src src 属性</li>\n<li>ng-href href 属性</li>\n<li>ng-checked 控制 radio 和 checkbox 的选中状态</li>\n<li>ng-selected 控制下拉框的选中状态</li>\n<li>ng-disabled 控制失效状态</li>\n<li>ng-multiple 控制多选</li>\n<li>ng-readonly 控制只读状态<br>以上指令的取值均为 boolean 类型，当值为 true 时相关状态生效，道理比较简单就不多做解释。</li>\n</ul>\n<p><em>注意</em>:上面的这些只是单向绑定，即只是从数据到模板，不能反作用于数据。要双向绑定，还是要使用 ng-model 。</p>\n<h3 id=\"3-AngularJS-过滤器\"><a href=\"#3-AngularJS-过滤器\" class=\"headerlink\" title=\"3. AngularJS 过滤器\"></a>3. AngularJS 过滤器</h3><p>　　过滤器（filter）正如其名，作用就是接收一个输入，通过某个规则进行处理，然后返回处理后的结果。主要用在数据的格式化上，例如获取一个数组中的子集，对数组中的元素进行排序等。过滤器通常是伴随标记来使用的，将你 model 中的数据格式化为需要的格式。表单的控制功能主要涉及到数据验证以及表单控件的增强。</p>\n<h4 id=\"内置过滤器\"><a href=\"#内置过滤器\" class=\"headerlink\" title=\"内置过滤器\"></a>内置过滤器</h4><p>　　ng 内置了一些过滤器，它们是：currency(货币)、date(日期)、filter(子串匹配)、json(格式化json对象)、limitTo(限制个数)、lowercase(小写)、uppercase(大写)、number(数字)、orderBy(排序)。</p>\n<p>过滤器使用示例：</p>\n<ul>\n<li><p>使用currency可以将数字格式化为货币，默认是美元符号，你可以自己传入所需的符号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123;num | currency : &apos;￥&apos;&#125;&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>参数用来指定所要的格式，y M d h m s E 分别表示 年 月 日 时 分 秒 星期，你可以自由组合它们。也可以使用不同的个数来限制格式化的位数。另外参数也可以使用特定的描述性字符串，例如“shortTime”将会把时间格式为12:05 pm这样的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123;date | date : &apos;yyyy-MM-dd hh:mm:ss EEEE&apos;&#125;&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>filter 过滤器从数组中选择一个子集：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; childrenArray | filter : &apos;a&apos; &#125;&#125; //匹配属性值中含有a的</div><div class=\"line\">&#123;&#123; childrenArray | filter : 4 &#125;&#125;  //匹配属性值中含有4的</div><div class=\"line\">&#123;&#123; childrenArray | filter : &#123;name : &apos;i&apos;&#125; &#125;&#125; //参数是对象，匹配name属性中含有i的</div><div class=\"line\">$scope.func = function(e)&#123;return e.age&gt;4;&#125;&#123;&#123; childrenArray | filter : &apos;a&apos; &#125;&#125;</div><div class=\"line\">&#123;&#123;childrenArray | filter : func &#125;&#125;  //参数是函数</div></pre></td></tr></table></figure>\n</li>\n<li><p>json过滤器可以把一个js对象格式化为json字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; jsonTest | json&#125;&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>列表截取 limitTo ，支持正负数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; childrenArray | limitTo : 2 &#125;&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>number过滤器可以为一个数字加上千位分割，像这样，123,456,789。同时接收一个参数，可以指定float类型保留几位小数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; num | number : 2 &#125;&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>大小写 lowercase ， uppercase ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; &apos;abc&apos; | uppercase &#125;&#125;</div><div class=\"line\">&#123;&#123; &apos;Abc&apos; | lowercase &#125;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; childrenArray | orderBy : &apos;age&apos; &#125;&#125;       //按age属性值进行排序，若是-age，则倒序</div><div class=\"line\">&#123;&#123; childrenArray | orderBy : orderFunc &#125;&#125;   //按照函数的返回值进行排序</div><div class=\"line\">&#123;&#123; childrenArray | orderBy : [&apos;age&apos;,&apos;name&apos;] &#125;&#125;  //如果age相同，按照name进行排序</div></pre></td></tr></table></figure>\n<p><em>过滤器使用方式</em></p>\n<p>在模块中定义过滤器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;Demo&apos;, [], angular.noop);</div><div class=\"line\">  app.filter(&apos;map&apos;, function()&#123;</div><div class=\"line\">    var filter = function(input)&#123;</div><div class=\"line\">      return input + &apos;...&apos;;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    return filter;</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<p>然后，在模板中使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;p&gt;示例数据: &#123;&#123; a | map &#125;&#125;&lt;/p&gt;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-AngularJS-Ajax\"><a href=\"#4-AngularJS-Ajax\" class=\"headerlink\" title=\"4. AngularJS Ajax\"></a>4. AngularJS Ajax</h3><p>　　$http 服务是 AngularJS 的核心服务之一，它帮助我们通过 XMLHttpRequest 对象或 JSONP 与远程 HTTP 服务进行交流。</p>\n<p>　　$http 服务是这样一个函数：它接受一个设置对象，其中指定了如何创建 HTTP 请求；它将返回一个 promise 对象，其中提供两个方法： success 方法和 error方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$http.get(&#123;url:&quot;/xxx.action&quot;&#125;).success(function(data)&#123;</div><div class=\"line\">    alert(data);</div><div class=\"line\">&#125;).error(function()&#123;</div><div class=\"line\">    alert(&quot;error&quot;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>$http 接受的配置项有：</p>\n<ul>\n<li>method 方法</li>\n<li>url 路径</li>\n<li>params GET请求的参数</li>\n<li>data post请求的参数</li>\n<li>headers 头</li>\n<li>transformRequest 请求预处理函数</li>\n<li>transformResponse 响应预处理函数</li>\n<li>cache 缓存</li>\n<li>timeout 超时毫秒，超时的请求会被取消</li>\n<li>withCredentials 跨域安全策略的一个东西<br>　　其中的 transformRequest 和 transformResponse 及 headers 已经有定义的，如果自定义则会覆盖默认定义</li>\n</ul>\n<p>对于几个标准的 HTTP 方法，有对应的 shortcut(捷径的意思) ：</p>\n<ul>\n<li>$http.delete(url, config)</li>\n<li>$http.get(url, config)</li>\n<li>$http.head(url, config)</li>\n<li>$http.jsonp(url, config)</li>\n<li>$http.post(url, data, config)</li>\n<li>$http.put(url, data, config)<br>　　注意其中的 JSONP 方法，在实现上会在页面中添加一个 script 标签，然后放出一个 GET 请求。你自己定义的，匿名回调函数，会被 ng 自已给一个全局变量。在定义请求，作为 GET 参数，你可以使用 JSON_CALLBACK 这个字符串来暂时代替回调函数名，之后 ng 会为你替换成真正的函数名：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p = $http(&#123;</div><div class=\"line\">\tmethod: &apos;JSONP&apos;,</div><div class=\"line\">\turl: &apos;/json&apos;,</div><div class=\"line\">\tparams: &#123;callback: &apos;JSON_CALLBACK&apos;&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">p.success(function(response, status, headers, config)&#123;</div><div class=\"line\">\tconsole.log(response);</div><div class=\"line\">\t$scope.name = response.name;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>$http 有两个属性：</p>\n<ul>\n<li>defaults 请求的全局配置</li>\n<li>pendingRequests 当前的请求队列状态<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$http.defaults.transformRequest = function(data)&#123;</div><div class=\"line\">    console.log(&apos;here&apos;); return data;&#125;</div><div class=\"line\">console.log($http.pendingRequests);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"5-AngularJS-控制器\"><a href=\"#5-AngularJS-控制器\" class=\"headerlink\" title=\"5. AngularJS 控制器\"></a>5. AngularJS 控制器</h3><p>　　AngularJS 应用程序被控制器控制，控制器是 JavaScript 对象，由标准的 JavaScript 对象的构造函数 创建。</p>\n<p>　　ng-controller 指令定义了应用程序控制器，给所在的 DOM 元素创建了一个新的 $scope 对象，并将这个 $scope 对象包含进外层 DOM 元素的 $scope 对象里。</p>\n<p>示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=&quot;&quot; ng-controller=&quot;personController&quot;&gt;</div><div class=\"line\">名： &lt;input type=&quot;text&quot; ng-model=&quot;person.firstName&quot;&gt;&lt;br&gt;</div><div class=\"line\">姓： &lt;input type=&quot;text&quot; ng-model=&quot;person.lastName&quot;&gt;&lt;br&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">姓名： &#123;&#123;fullName()&#125;&#125;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">&lt;script&gt;</div><div class=\"line\">function personController($scope) &#123;</div><div class=\"line\">\t$scope.person = &#123;</div><div class=\"line\">\t\tfirstName: &quot;John&quot;,</div><div class=\"line\">\t\tlastName: &quot;Doe&quot;,</div><div class=\"line\">\t &#125;;</div><div class=\"line\">\t $scope.fullName = function() &#123;</div><div class=\"line\">\t\t var x;</div><div class=\"line\">\t\t x = $scope.person; </div><div class=\"line\">\t\t return x.firstName + &quot; &quot; + x.lastName;</div><div class=\"line\">\t &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<p>　　$scope 是一个把 view（一个DOM元素）连结到 controller 上的对象。在我们的 MVC 结构里，这个 $scope 将成为 model，它提供一个绑定到DOM元素（以及其子元素）上的excecution context。</p>\n<p>　　尽管听起来有点复杂，但 $scope 实际上就是一个JavaScript 对象，controller 和 view 都可以访问它，所以我们可以利用它在两者间传递信息。在这个 $scope 对象里，我们既存储数据，又存储将要运行在view上的函数。</p>\n<p>　　每一个 Angular 应用都会有一个 $rootScope。这个 $rootScope 是最顶级的 scope，它对应着含有 ng-app 指令属性的那个 DOM 元素</p>\n<p>　　所有scope都遵循原型继承（prototypal inheritance），这意味着它们都能访问父scope们。</p>\n<h3 id=\"6-AngularJS-模块\"><a href=\"#6-AngularJS-模块\" class=\"headerlink\" title=\"6. AngularJS 模块\"></a>6. AngularJS 模块</h3><p>　　AngularJS 本身的一个默认模块叫做 ng ，它提供了 $http ， $q 等等服务。</p>\n<p>　　服务只是模块提供的多种机制中的一种，其它的还有命令（ directive ），过滤器（ filter ），及其它配置信息。</p>\n<p>　　然后在额外的 js 文件中有一个附加的模块叫做 ngResource ， 它提供了一个 $resource 服务。</p>\n<h4 id=\"定义模块\"><a href=\"#定义模块\" class=\"headerlink\" title=\"定义模块\"></a>定义模块</h4><p>　　定义模块的方法是使用 angular.module 。调用时声明了对其它模块的依赖，并定义了“初始化”函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var my_module = angular.module(&apos;MyModule&apos;, [], function()&#123;</div><div class=\"line\">    console.log(&apos;here&apos;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>这段代码定义了一个叫做 MyModule 的模块， my_module 这个引用可以在接下来做其它的一些事，比如定义服务。</p>\n<h4 id=\"定义服务\"><a href=\"#定义服务\" class=\"headerlink\" title=\"定义服务\"></a>定义服务</h4><p>　　ng的服务是这样定义的：</p>\n<p>　　Angular services are singletons objects or functions that carry out specific tasks common to web apps.</p>\n<p>　　它是一个单例对象或函数，对外提供特定的功能。<br>　　首先是一个单例，即无论这个服务被注入到任何地方，对象始终只有一个实例。<br>　　其次这与我们自己定义一个function然后在其他地方调用不同，因为服务被定义在一个模块中，所以其使用范围是可以被我们管理的。ng的避免全局变量污染意识非常强。<br>　　ng提供了很多内置的服务，可以到API中查看 <a href=\"http://docs.angularjs.org/api/\" target=\"_blank\" rel=\"external\">http://docs.angularjs.org/api/</a> 。如同指令一样，系统内置的服务以$开头，我们也可以自己定义一个服务。</p>\n<p>　　在这里呢，就要先介绍一下叫 provider 的东西。简单来说， provider 是被 注入控制器 使用的一个对象，注入机制通过调用一个 provider 的 $get() 方法，把得到的东西作为参数进行相关调用（比如把得到的服务作为一个 Controller 的参数）。</p>\n<p>　　在这里 服务 的概念就比较不明确，对使用而言，服务仅指 $get() 方法返回的东西，但是在整体机制上，服务又要指提供了 $get() 方法的整个对象。</p>\n<ul>\n<li><p>这是一个provider</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var pp = function()&#123;</div><div class=\"line\">  this.$get = function()&#123;</div><div class=\"line\">    return &#123;&apos;haha&apos;: &apos;123&apos;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>我在模块的初始化过程当中, 定义了一个叫 PP 的服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;Demo&apos;, [], function($provide)&#123;</div><div class=\"line\">  $provide.provider(&apos;PP&apos;, pp);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>PP服务实际上就是 pp 这个 provider 的 $get() 方法返回的东西</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.controller(&apos;TestCtrl&apos;,</div><div class=\"line\">  function($scope, PP)&#123;</div><div class=\"line\">    console.log(PP);</div><div class=\"line\">  &#125;</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>　　ng 还有相关的 shortcut， 第一个是 factory 方法 ，由 $provide 提供， module 的 factory 是一个引用，作用一样。这个方法直接把一个函数当成是一个对象的 $get() 方法，这样你就不用显式地定义一个 provider 了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;Demo&apos;, [], function($provide)&#123;</div><div class=\"line\">    $provide.factory(&apos;PP&apos;, function()&#123;</div><div class=\"line\">        return &#123;&apos;hello&apos;: &apos;123&apos;&#125;;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\">app.controller(&apos;TestCtrl&apos;, function($scope, PP)&#123; console.log(PP) &#125;);</div></pre></td></tr></table></figure></p>\n<p>在 module 中使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;Demo&apos;, [], function()&#123; &#125;);</div><div class=\"line\">app.factory(&apos;PP&apos;, function()&#123;return &#123;&apos;abc&apos;: &apos;123&apos;&#125;&#125;);</div><div class=\"line\">app.controller(&apos;TestCtrl&apos;, function($scope, PP)&#123; console.log(PP) &#125;);</div></pre></td></tr></table></figure></p>\n<p>　　第二个是 service 方法，也是由 $provide 提供， module 中有对它的同名引用。 service 和 factory 的区别在于，前者是要求提供一个“构造方法”，后者是要求提供 $get() 方法。意思就是，前者一定是得到一个 object ，后者可以是一个数字或字符串。它们的关系大概是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;Demo&apos;, [], function()&#123; &#125;);</div><div class=\"line\">app.service = function(name, constructor)&#123;</div><div class=\"line\">    app.factory(name, function()&#123;</div><div class=\"line\">      return (new constructor());</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>service 方法的使用就很简单了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;Demo&apos;, [], function()&#123; &#125;);</div><div class=\"line\">app.service(&apos;PP&apos;, function()&#123;</div><div class=\"line\">    this.abc = &apos;123&apos;;</div><div class=\"line\">&#125;);</div><div class=\"line\">app.controller(&apos;TestCtrl&apos;, function($scope, PP)&#123; console.log(PP) &#125;);</div></pre></td></tr></table></figure></p>\n<p>引入模块并使用服务<br>结合上面的 定义模块 和 定义服务 ，我们可以方便地组织自己的额外代码：</p>\n<ul>\n<li><p>定义服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;MyModule&apos;, [], function($provide)&#123;</div><div class=\"line\">    $provide.factory(&apos;S1&apos;, function()&#123;</div><div class=\"line\">      return &apos;I am S1&apos;;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    $provide.factory(&apos;S2&apos;, function()&#123;</div><div class=\"line\">      return &#123;see: function()&#123;return &apos;I am S2&apos;&#125;&#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>调用服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;Demo&apos;, [&apos;MyModule&apos;], angular.noop);</div><div class=\"line\">app.controller(&apos;TestCtrl&apos;, function($scope, S1, S2)&#123;</div><div class=\"line\">    console.log(S1)</div><div class=\"line\">    console.log(S2.see())</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"7-附加模块-ngResource\"><a href=\"#7-附加模块-ngResource\" class=\"headerlink\" title=\"7. 附加模块 ngResource\"></a>7. 附加模块 ngResource</h3><p>　　ngResource 这个是 ng 官方提供的一个附加模块。 附加 的意思就是，如果你打算用它，那么你需要引入一人单独的 js 文件，然后在声明“根模块”时注明依赖的 ngResource 模块，接着就可以使用它提供的 $resource 服务了。</p>\n<p>　　$resource 服务主要是包装了 AJAX 的调用，使用 $resource 需要先定义“资源”，也就是先定义一些 HTTP 请求。</p>\n<h3 id=\"8-AngularJS-路由\"><a href=\"#8-AngularJS-路由\" class=\"headerlink\" title=\"8. AngularJS 路由\"></a>8. AngularJS 路由</h3><p>ng的路由(ngRoute)是一个单独的模块，包含以下内容：</p>\n<p>服务 $routeProvider 用来定义一个路由表，即地址栏与视图模板的映射<br>服务 $routeParams 保存了地址栏中的参数，例如 {id : 1, name : ‘tom’}<br>服务 $route 完成路由匹配，并且提供路由相关的属性访问及事件，如访问当前路由对应的 controller<br>指令 ngView 用来在主视图中指定加载子视图的区域</p>\n<h4 id=\"定义路由\"><a href=\"#定义路由\" class=\"headerlink\" title=\"定义路由\"></a>定义路由</h4><ul>\n<li>第一步：引入文件和依赖</li>\n</ul>\n<p>ngRoute 也是一个附件模块，故需要在页面上引入 angular-route.min.js 并在模块中注入对 ngRoute 的依赖，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;MyApp&apos;, [&apos;ngRoute&apos;]);//一切从模块开始</div></pre></td></tr></table></figure></p>\n<ul>\n<li>第二步：定义路由表</li>\n</ul>\n<p>　　$routeProvider 提供了定义路由表的服务，它有两个核心方法： when(path,route) 和 otherwise(params) ，先看一下核心中的核心 when(path,route)方法。</p>\n<p>　　when(path,route) 方法接收两个参数:</p>\n<p>　　path 是一个 string 类型，表示该条路由规则所匹配的路径，它将与地址栏的内容($location.path)值进行匹配。如果需要匹配参数，可以在 path 中使用冒号加名称的方式，如：path为 /show/:name ，如果地址栏是 /show/tom ，那么参数 name 和所对应的值 tom 便会被保存在 $routeParams 中，像这样： {name : tom} 。我们也可以用 <em> 进行模糊匹配，如： /show</em>/:name 将匹配 /showInfo/tom 。</p>\n<p>　　route 参数是一个 object，用来指定当 path 匹配后所需的一系列配置项，包括以下内容：<br>　　controller function 或 string 类型。在当前模板上执行的 controller 函数，生成新的 scope；<br>　　controllerAs string 类型，为 controller 指定别名；<br>　　template string 或 function 类型，视图所用的模板，这部分内容将被 ngView 引用；<br>　　templateUrl string 或 function 类型，当视图模板为单独的 html 文件或是使用了 <script type=\"text/ng-template\"> 定义模板时使用；<br>　　resolve 指定当前 controller 所依赖的其他模块；<br>　　redirectTo 重定向的地址。</p>\n<ul>\n<li>第三步：在主视图模板中指定加载子视图的位置</li>\n</ul>\n<p>只需在模板中简单的使用此 ngView 指令:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-view&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p>TODO UI-ROUTE</p>\n</script></p>","excerpt":"","more":"<p>　　AngularJS 是一个 MVVM框架，最适于开发客户端的单页面应用。它不是个功能库，而是用来开发动态网页的框架。它专注于扩展 HTML 的功能，提供动态数据绑定（data binding），而且它能跟其它框架（如 JQuery 等）合作融洽。</p>\n<h3 id=\"1-一个简单示例\"><a href=\"#1-一个简单示例\" class=\"headerlink\" title=\"1. 一个简单示例\"></a>1. 一个简单示例</h3><p>通过下面的示例代码，可以运行一个简单的 AngularJS 应用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;div ng-app=&quot;&quot;&gt;</div><div class=\"line\">  &lt;p&gt;在输入框中尝试输入：&lt;/p&gt;</div><div class=\"line\">  &lt;p&gt;姓名：&lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt;</div><div class=\"line\">  &lt;p ng-bind=&quot;name&quot;&gt;&lt;/p&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.3.8/angular.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure></p>\n<p>通过浏览器访问该页面，在输入框中输入的内容会立即显示在输入框下面。</p>\n<h5 id=\"说明：\"><a href=\"#说明：\" class=\"headerlink\" title=\"说明：\"></a>说明：</h5><p>当网页加载完毕，AngularJS 自动运行。<br>ng-app 指令告诉 AngularJS ，div 元素是 AngularJS 应用程序的”所有者”，相当于是个作用域的概率。<br>ng-model 指令把输入域的值绑定到应用程序变量 name。<br>ng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML。</p>\n<h3 id=\"2-AngularJS-指令\"><a href=\"#2-AngularJS-指令\" class=\"headerlink\" title=\"2. AngularJS 指令\"></a>2. AngularJS 指令</h3><p>AngularJS 指令是扩展的 HTML 属性，带有前缀 ng- 。</p>\n<p>HTML5 允许扩展的（自制的）属性，以 data- 开头。AngularJS 属性以 ng- 开头，但是您可以使用 data-ng- 来让网页对 HTML5 有效。</p>\n<h4 id=\"常见的指令\"><a href=\"#常见的指令\" class=\"headerlink\" title=\"常见的指令\"></a>常见的指令</h4><ul>\n<li><p>ng-app 指令</p>\n<p>ng-app 指令初始化一个 AngularJS 应用程序。</p>\n</li>\n<li><p>ng-init 指令</p>\n<p>ng-init 指令初始化应用程序数据，这个不常使用。通常情况下，不使用 ng-init。您将使用一个控制器或模块来代替它。</p>\n</li>\n<li><p>ng-model 指令</p>\n<p>ng-model 指令把元素值（比如输入域的值）绑定到应用程序。</p>\n</li>\n<li><p>ng-bind 指令</p>\n<p>ng-bind 指令把应用程序数据绑定到 HTML 视图。</p>\n</li>\n</ul>\n<p>示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=&quot;&quot;&gt;</div><div class=\"line\">  &lt;p&gt;在输入框中尝试输入：&lt;/p&gt;</div><div class=\"line\">  &lt;p&gt;姓名：&lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt;</div><div class=\"line\">  &lt;p ng-bind=&quot;name&quot;&gt;&lt;/p&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>ng-repeat 指令</li>\n</ul>\n<p>ng-repeat 指令会重复一个 HTML 元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=&quot;&quot; ng-init=&quot;names=[</div><div class=\"line\">&#123;name:&apos;Jani&apos;,country:&apos;Norway&apos;&#125;,</div><div class=\"line\">&#123;name:&apos;Hege&apos;,country:&apos;Sweden&apos;&#125;,</div><div class=\"line\">&#123;name:&apos;Kai&apos;,country:&apos;Denmark&apos;&#125;]&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;p&gt;循环对象：&lt;/p&gt;</div><div class=\"line\">  &lt;ul&gt;</div><div class=\"line\">    &lt;li ng-repeat=&quot;x in names&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">  &lt;/ul&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p>除此之外，它还提供了几个变量可供使用：</p>\n<ul>\n<li>index 当前索引</li>\n<li>first 是否为头元素</li>\n<li>middle 是否为非头非尾元素</li>\n<li>last 是否为尾元素</li>\n</ul>\n<h5 id=\"样式相关的指令\"><a href=\"#样式相关的指令\" class=\"headerlink\" title=\"样式相关的指令\"></a>样式相关的指令</h5><ul>\n<li>ng-class</li>\n</ul>\n<p>ng-class用来给元素绑定类名，其表达式的返回值可以是以下三种：</p>\n<p>类名字符串，可以用空格分割多个类名，如 ‘class1 class2’；<br>类名数组，数组中的每一项都会层叠起来生效；<br>一个名值对应的map，其键值为类名，值为boolean类型，当值为true时，该类会被加在元素上。<br>与 ng-class 相近的，ng 还提供了ng-class-odd、ng-class-even 两个指令，用来配合 ng-repeat 分别在奇数列和偶数列使用对应的类。这个用来在表格中实现隔行换色再方便不过了。</p>\n<ul>\n<li>ng-style</li>\n</ul>\n<p>ng-style 用来绑定元素的 css 样式，其表达式的返回值为一个 js 对象，键为 css 样式名，值为该样式对应的合法取值。用法比较简单：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$scope.style = &#123;color:&apos;red&apos;&#125;;　</div><div class=\"line\"></div><div class=\"line\">&lt;div ng-style=&quot;&#123;color:&apos;red&apos;&#125;&quot;&gt;ng-style测试&lt;/div&gt;</div><div class=\"line\">&lt;div ng-style=&quot;style&quot;&gt;ng-style测试&lt;/div&gt;</div><div class=\"line\">ng-show、ng-hide、ng-switch</div></pre></td></tr></table></figure></p>\n<p>对于比较常用的元素显隐控制，ng 也做了封装，ng-show 和 ng-hide 的值为 boolean 类型的表达式，当值为 true 时，对应的 show 或 hide 生效。框架会用 display:block 和 display:none 来控制元素的显隐。</p>\n<p>示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=&quot;&quot;&gt;</div><div class=\"line\">\t&lt;div ng-show=&quot;true&quot;&gt;1&lt;/div&gt;</div><div class=\"line\">\t&lt;div ng-show=&quot;false&quot;&gt;2&lt;/div&gt;</div><div class=\"line\">\t&lt;div ng-hide=&quot;true&quot;&gt;3&lt;/div&gt;</div><div class=\"line\">\t&lt;div ng-hide=&quot;false&quot;&gt;4&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p>后一个 ng-switch 是根据一个值来决定哪个节点显示，其它节点移除：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-init=&quot;a=2&quot;&gt;</div><div class=\"line\">    &lt;ul ng-switch on=&quot;a&quot;&gt;</div><div class=\"line\">\t    &lt;li ng-switch-when=&quot;1&quot;&gt;1&lt;/li&gt;</div><div class=\"line\">\t    &lt;li ng-switch-when=&quot;2&quot;&gt;2&lt;/li&gt;</div><div class=\"line\">\t    &lt;li ng-switch-default&gt;other&lt;/li&gt;</div><div class=\"line\">    &lt;/ul&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<h3 id=\"事件指令\"><a href=\"#事件指令\" class=\"headerlink\" title=\"事件指令\"></a>事件指令</h3><p>事件相关的指令有：</p>\n<ul>\n<li>ng-change</li>\n<li>ng-click</li>\n<li>ng-dblclick</li>\n<li>ng-mousedown</li>\n<li>ng-mouseenter</li>\n<li>ng-mouseleave</li>\n<li>ng-mousemove</li>\n<li>ng-mouseover</li>\n<li>ng-mouseup</li>\n<li>ng-submit<br>对于事件对象本身，在函数调用时可以直接使用 $event 进行传递：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;p ng-click=&quot;click($event)&quot;&gt;点击&lt;/p&gt;</div><div class=\"line\">&lt;p ng-click=&quot;click($event.target)&quot;&gt;点击&lt;/p&gt;</div><div class=\"line\"></div><div class=\"line\">$scope.click = function($event)&#123;</div><div class=\"line\">         alert($event.target);</div><div class=\"line\">         //……………………</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"表单指令\"><a href=\"#表单指令\" class=\"headerlink\" title=\"表单指令\"></a>表单指令</h3><p>　　表单控件类的模板指令，最大的作用是它预定义了需要绑定的数据的格式。这样，就可以对于既定的数据进行既定的处理。</p>\n<h4 id=\"form\"><a href=\"#form\" class=\"headerlink\" title=\"form\"></a>form</h4><p>　　ng 对 form 这个标签作了包装，对应的指令是 <em>ng-form</em>。</p>\n<p>　　从 ng 的角度来说， form 标签，是一个模板指令，也创建了一个 FormController 的实例。这个实例就提供了相应的属性和方法。同时，它里面的控件也是一个 NgModelController 实例。</p>\n<p>　　<em>很重要的一点</em>， form 的相关方法要生效，必须为 form 标签指定 name 和 ng-controller ，并且每个控件都要绑定一个变量。 form 和控件的名字，即是 $scope 中的相关实例的引用变量名。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;&gt;</div><div class=\"line\">  &lt;input type=&quot;text&quot; name=&quot;a&quot; required ng-model=&quot;a&quot;  /&gt;</div><div class=\"line\">  &lt;span ng-click=&quot;see()&quot;&gt;&lt;/span&gt;</div><div class=\"line\">&lt;/form&gt;</div><div class=\"line\"></div><div class=\"line\">var TestCtrl = function($scope)&#123;</div><div class=\"line\">  $scope.see = function()&#123;</div><div class=\"line\">    console.log($scope.test_form);</div><div class=\"line\">    console.log($scope.test_form.a);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>除去对象的方法与属性， form 这个标签本身有一些动态类可以使用：</p>\n<ul>\n<li>ng-valid 当表单验证通过时的设置</li>\n<li>ng-invalid 当表单验证失败时的设置</li>\n<li>ng-pristine 表单的未被动之前拥有</li>\n<li>ng-dirty 表单被动过之后拥有</li>\n</ul>\n<h4 id=\"form-对象的属性有：\"><a href=\"#form-对象的属性有：\" class=\"headerlink\" title=\"form 对象的属性有：\"></a>form 对象的属性有：</h4><ul>\n<li>$pristine 表单是否未被动过</li>\n<li>$dirty 表单是否被动过</li>\n<li>$valid 表单是否验证通过</li>\n<li>$invalid 表单是否验证失败</li>\n<li>$error 表单的验证错误<br>其中的 $error 对象包含有所有字段的验证信息，及对相关字段的 NgModelController 实例的引用。它的结构是一个对象， key 是失败信息， required ， minlength 之类的， value 是对应的字段实例列表。</li>\n</ul>\n<h4 id=\"input\"><a href=\"#input\" class=\"headerlink\" title=\"input\"></a>input</h4><p>input 控件的相关可用属性为：</p>\n<ul>\n<li>name 名字</li>\n<li>ng-model 绑定的数据</li>\n<li>required 是否必填</li>\n<li>ng-required 是否必填</li>\n<li>ng-minlength 最小长度</li>\n<li>ng-maxlength 最大长度</li>\n<li>ng-pattern 匹配模式</li>\n<li>ng-change 值变化时的回调<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;&gt;</div><div class=\"line\">  &lt;input type=&quot;text&quot; name=&quot;a&quot; ng-model=&quot;a&quot; required ng-pattern=&quot;/abc/&quot; /&gt;</div><div class=\"line\">  &lt;span ng-click=&quot;see()&quot;&gt;&lt;/span&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>input 控件，它还有一些扩展，这些扩展有些有自己的属性：</p>\n<ul>\n<li>input type=”number” 多了 number 错误类型，多了 max ， min 属性。</li>\n<li>input type=”url” 多了 url 错误类型。</li>\n<li>input type=”email” 多了 email 错误类型。</li>\n</ul>\n<h4 id=\"checkbox\"><a href=\"#checkbox\" class=\"headerlink\" title=\"checkbox\"></a>checkbox</h4><p>它是 input 的扩展，不过，它没有验证相关的东西，只有选中与不选中两个值：ng-true-value、ng-false-value:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;&gt;</div><div class=\"line\">  &lt;input type=&quot;checkbox&quot; name=&quot;a&quot; ng-model=&quot;a&quot; ng-true-value=&quot;AA&quot; ng-false-value=&quot;BB&quot; /&gt;</div><div class=\"line\">  &lt;span&gt;&lt;/span&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"radio\"><a href=\"#radio\" class=\"headerlink\" title=\"radio\"></a>radio</h4><p>它也是 input 的扩展。和 checkbox 一样，但它只有一个值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;&gt;</div><div class=\"line\">  &lt;input type=&quot;radio&quot; name=&quot;a&quot; ng-model=&quot;a&quot; value=&quot;AA&quot; /&gt;</div><div class=\"line\">  &lt;input type=&quot;radio&quot; name=&quot;a&quot; ng-model=&quot;a&quot; value=&quot;BB&quot; /&gt;</div><div class=\"line\">  &lt;span&gt;&lt;/span&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"textarea-同-input\"><a href=\"#textarea-同-input\" class=\"headerlink\" title=\"textarea  同 input\"></a>textarea  同 input</h4><h4 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h4><p>它里面的一个叫做 ng-options 的属性用于数据呈现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot; ng-init=&quot;o=[0,1,2,3]; a=o[1];&quot;&gt;</div><div class=\"line\">    &lt;select ng-model=&quot;a&quot; ng-options=&quot;x for x in o&quot;&gt;</div><div class=\"line\">      &lt;option value=&quot;&quot;&gt;可以加这个空值&lt;/option&gt;</div><div class=\"line\">    &lt;/select&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<p>在 $scope 中， select 绑定的变量，其值和普通的 value 无关，可以是一个对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;</div><div class=\"line\">    ng-init=&quot;o=[&#123;name: &apos;AA&apos;&#125;, &#123;name: &apos;BB&apos;&#125;]; a=o[1];&quot;&gt;</div><div class=\"line\">    &lt;select ng-model=&quot;a&quot; ng-options=&quot;x.name for x in o&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<p>显示与值分别指定， x.v as x.name for x in o ： as for  in 要理解清楚！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;</div><div class=\"line\">    ng-init=&quot;o=[&#123;name: &apos;AA&apos;, v: &apos;00&apos;&#125;, &#123;name: &apos;BB&apos;, v: &apos;11&apos;&#125;]; a=o[1].v;&quot;&gt;</div><div class=\"line\">    &lt;select ng-model=&quot;a&quot; ng-options=&quot;x.v as x.name for x in o&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<p>加入分组的， x.name group by x.g for x in o ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;</div><div class=\"line\">    ng-init=&quot;o=[&#123;name: &apos;AA&apos;, g: &apos;00&apos;&#125;, &#123;name: &apos;BB&apos;, g: &apos;11&apos;&#125;, &#123;name: &apos;CC&apos;, g: &apos;00&apos;&#125;]; a=o[1];&quot;&gt;</div><div class=\"line\">    &lt;select ng-model=&quot;a&quot; ng-options=&quot;x.name group by x.g for x in o&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<p>分组了还分别指定显示与值的， x.v as x.name group by x.g for x in o ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot; ng-init=&quot;o=[&#123;name: &apos;AA&apos;, g: &apos;00&apos;, v: &apos;=&apos;&#125;, &#123;name: &apos;BB&apos;, g: &apos;11&apos;, v: &apos;+&apos;&#125;, &#123;name: &apos;CC&apos;, g: &apos;00&apos;, v: &apos;!&apos;&#125;]; a=o[1].v;&quot;&gt;</div><div class=\"line\">    &lt;select ng-model=&quot;a&quot; ng-options=&quot;x.v as x.name group by x.g for x in o&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<p>如果参数是对象的话，基本也是一样的，只是把遍历的对象改成 (key, value) ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot; ng-init=&quot;o=&#123;a: 0, b: 1&#125;; a=o.a;&quot;&gt;</div><div class=\"line\">\t&lt;select ng-model=&quot;a&quot; ng-options=&quot;k for (k, v) in o&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;</div><div class=\"line\">\tng-init=&quot;o=&#123;a: &#123;name: &apos;AA&apos;, v: &apos;00&apos;&#125;, b: &#123;name: &apos;BB&apos;, v: &apos;11&apos;&#125;&#125;; a=o.a.v;&quot;&gt;</div><div class=\"line\">\t&lt;select ng-model=&quot;a&quot; ng-options=&quot;v.v as v.name for (k, v) in o&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;</div><div class=\"line\">\tng-init=&quot;o=&#123;a: &#123;name: &apos;AA&apos;, v: &apos;00&apos;, g: &apos;==&apos;&#125;, b: &#123;name: &apos;BB&apos;, v: &apos;11&apos;, g: &apos;==&apos;&#125;&#125;; a=o.a;&quot;&gt;</div><div class=\"line\">\t&lt;select ng-model=&quot;a&quot; ng-options=&quot;v.name group by v.g for (k, v) in o&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div><div class=\"line\">&lt;form name=&quot;test_form&quot; ng-controller=&quot;TestCtrl&quot;</div><div class=\"line\">\tng-init=&quot;o=&#123;a: &#123;name: &apos;AA&apos;, v: &apos;00&apos;, g: &apos;==&apos;&#125;, b: &#123;name: &apos;BB&apos;, v: &apos;11&apos;, g: &apos;==&apos;&#125;&#125;; a=o.a.v;&quot;&gt;</div><div class=\"line\">\t&lt;select ng-model=&quot;a&quot; ng-options=&quot;v.v as v.name group by v.g for (k, v) in o&quot; /&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure></p>\n<p>还有一些表单控件功能相关的指令：</p>\n<ul>\n<li>ng-src src 属性</li>\n<li>ng-href href 属性</li>\n<li>ng-checked 控制 radio 和 checkbox 的选中状态</li>\n<li>ng-selected 控制下拉框的选中状态</li>\n<li>ng-disabled 控制失效状态</li>\n<li>ng-multiple 控制多选</li>\n<li>ng-readonly 控制只读状态<br>以上指令的取值均为 boolean 类型，当值为 true 时相关状态生效，道理比较简单就不多做解释。</li>\n</ul>\n<p><em>注意</em>:上面的这些只是单向绑定，即只是从数据到模板，不能反作用于数据。要双向绑定，还是要使用 ng-model 。</p>\n<h3 id=\"3-AngularJS-过滤器\"><a href=\"#3-AngularJS-过滤器\" class=\"headerlink\" title=\"3. AngularJS 过滤器\"></a>3. AngularJS 过滤器</h3><p>　　过滤器（filter）正如其名，作用就是接收一个输入，通过某个规则进行处理，然后返回处理后的结果。主要用在数据的格式化上，例如获取一个数组中的子集，对数组中的元素进行排序等。过滤器通常是伴随标记来使用的，将你 model 中的数据格式化为需要的格式。表单的控制功能主要涉及到数据验证以及表单控件的增强。</p>\n<h4 id=\"内置过滤器\"><a href=\"#内置过滤器\" class=\"headerlink\" title=\"内置过滤器\"></a>内置过滤器</h4><p>　　ng 内置了一些过滤器，它们是：currency(货币)、date(日期)、filter(子串匹配)、json(格式化json对象)、limitTo(限制个数)、lowercase(小写)、uppercase(大写)、number(数字)、orderBy(排序)。</p>\n<p>过滤器使用示例：</p>\n<ul>\n<li><p>使用currency可以将数字格式化为货币，默认是美元符号，你可以自己传入所需的符号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123;num | currency : &apos;￥&apos;&#125;&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>参数用来指定所要的格式，y M d h m s E 分别表示 年 月 日 时 分 秒 星期，你可以自由组合它们。也可以使用不同的个数来限制格式化的位数。另外参数也可以使用特定的描述性字符串，例如“shortTime”将会把时间格式为12:05 pm这样的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123;date | date : &apos;yyyy-MM-dd hh:mm:ss EEEE&apos;&#125;&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>filter 过滤器从数组中选择一个子集：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; childrenArray | filter : &apos;a&apos; &#125;&#125; //匹配属性值中含有a的</div><div class=\"line\">&#123;&#123; childrenArray | filter : 4 &#125;&#125;  //匹配属性值中含有4的</div><div class=\"line\">&#123;&#123; childrenArray | filter : &#123;name : &apos;i&apos;&#125; &#125;&#125; //参数是对象，匹配name属性中含有i的</div><div class=\"line\">$scope.func = function(e)&#123;return e.age&gt;4;&#125;&#123;&#123; childrenArray | filter : &apos;a&apos; &#125;&#125;</div><div class=\"line\">&#123;&#123;childrenArray | filter : func &#125;&#125;  //参数是函数</div></pre></td></tr></table></figure>\n</li>\n<li><p>json过滤器可以把一个js对象格式化为json字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; jsonTest | json&#125;&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>列表截取 limitTo ，支持正负数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; childrenArray | limitTo : 2 &#125;&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>number过滤器可以为一个数字加上千位分割，像这样，123,456,789。同时接收一个参数，可以指定float类型保留几位小数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; num | number : 2 &#125;&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>大小写 lowercase ， uppercase ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; &apos;abc&apos; | uppercase &#125;&#125;</div><div class=\"line\">&#123;&#123; &apos;Abc&apos; | lowercase &#125;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; childrenArray | orderBy : &apos;age&apos; &#125;&#125;       //按age属性值进行排序，若是-age，则倒序</div><div class=\"line\">&#123;&#123; childrenArray | orderBy : orderFunc &#125;&#125;   //按照函数的返回值进行排序</div><div class=\"line\">&#123;&#123; childrenArray | orderBy : [&apos;age&apos;,&apos;name&apos;] &#125;&#125;  //如果age相同，按照name进行排序</div></pre></td></tr></table></figure>\n<p><em>过滤器使用方式</em></p>\n<p>在模块中定义过滤器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;Demo&apos;, [], angular.noop);</div><div class=\"line\">  app.filter(&apos;map&apos;, function()&#123;</div><div class=\"line\">    var filter = function(input)&#123;</div><div class=\"line\">      return input + &apos;...&apos;;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    return filter;</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<p>然后，在模板中使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;p&gt;示例数据: &#123;&#123; a | map &#125;&#125;&lt;/p&gt;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-AngularJS-Ajax\"><a href=\"#4-AngularJS-Ajax\" class=\"headerlink\" title=\"4. AngularJS Ajax\"></a>4. AngularJS Ajax</h3><p>　　$http 服务是 AngularJS 的核心服务之一，它帮助我们通过 XMLHttpRequest 对象或 JSONP 与远程 HTTP 服务进行交流。</p>\n<p>　　$http 服务是这样一个函数：它接受一个设置对象，其中指定了如何创建 HTTP 请求；它将返回一个 promise 对象，其中提供两个方法： success 方法和 error方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$http.get(&#123;url:&quot;/xxx.action&quot;&#125;).success(function(data)&#123;</div><div class=\"line\">    alert(data);</div><div class=\"line\">&#125;).error(function()&#123;</div><div class=\"line\">    alert(&quot;error&quot;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>$http 接受的配置项有：</p>\n<ul>\n<li>method 方法</li>\n<li>url 路径</li>\n<li>params GET请求的参数</li>\n<li>data post请求的参数</li>\n<li>headers 头</li>\n<li>transformRequest 请求预处理函数</li>\n<li>transformResponse 响应预处理函数</li>\n<li>cache 缓存</li>\n<li>timeout 超时毫秒，超时的请求会被取消</li>\n<li>withCredentials 跨域安全策略的一个东西<br>　　其中的 transformRequest 和 transformResponse 及 headers 已经有定义的，如果自定义则会覆盖默认定义</li>\n</ul>\n<p>对于几个标准的 HTTP 方法，有对应的 shortcut(捷径的意思) ：</p>\n<ul>\n<li>$http.delete(url, config)</li>\n<li>$http.get(url, config)</li>\n<li>$http.head(url, config)</li>\n<li>$http.jsonp(url, config)</li>\n<li>$http.post(url, data, config)</li>\n<li>$http.put(url, data, config)<br>　　注意其中的 JSONP 方法，在实现上会在页面中添加一个 script 标签，然后放出一个 GET 请求。你自己定义的，匿名回调函数，会被 ng 自已给一个全局变量。在定义请求，作为 GET 参数，你可以使用 JSON_CALLBACK 这个字符串来暂时代替回调函数名，之后 ng 会为你替换成真正的函数名：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var p = $http(&#123;</div><div class=\"line\">\tmethod: &apos;JSONP&apos;,</div><div class=\"line\">\turl: &apos;/json&apos;,</div><div class=\"line\">\tparams: &#123;callback: &apos;JSON_CALLBACK&apos;&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">p.success(function(response, status, headers, config)&#123;</div><div class=\"line\">\tconsole.log(response);</div><div class=\"line\">\t$scope.name = response.name;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>$http 有两个属性：</p>\n<ul>\n<li>defaults 请求的全局配置</li>\n<li>pendingRequests 当前的请求队列状态<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$http.defaults.transformRequest = function(data)&#123;</div><div class=\"line\">    console.log(&apos;here&apos;); return data;&#125;</div><div class=\"line\">console.log($http.pendingRequests);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"5-AngularJS-控制器\"><a href=\"#5-AngularJS-控制器\" class=\"headerlink\" title=\"5. AngularJS 控制器\"></a>5. AngularJS 控制器</h3><p>　　AngularJS 应用程序被控制器控制，控制器是 JavaScript 对象，由标准的 JavaScript 对象的构造函数 创建。</p>\n<p>　　ng-controller 指令定义了应用程序控制器，给所在的 DOM 元素创建了一个新的 $scope 对象，并将这个 $scope 对象包含进外层 DOM 元素的 $scope 对象里。</p>\n<p>示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=&quot;&quot; ng-controller=&quot;personController&quot;&gt;</div><div class=\"line\">名： &lt;input type=&quot;text&quot; ng-model=&quot;person.firstName&quot;&gt;&lt;br&gt;</div><div class=\"line\">姓： &lt;input type=&quot;text&quot; ng-model=&quot;person.lastName&quot;&gt;&lt;br&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">姓名： &#123;&#123;fullName()&#125;&#125;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">&lt;script&gt;</div><div class=\"line\">function personController($scope) &#123;</div><div class=\"line\">\t$scope.person = &#123;</div><div class=\"line\">\t\tfirstName: &quot;John&quot;,</div><div class=\"line\">\t\tlastName: &quot;Doe&quot;,</div><div class=\"line\">\t &#125;;</div><div class=\"line\">\t $scope.fullName = function() &#123;</div><div class=\"line\">\t\t var x;</div><div class=\"line\">\t\t x = $scope.person; </div><div class=\"line\">\t\t return x.firstName + &quot; &quot; + x.lastName;</div><div class=\"line\">\t &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<p>　　$scope 是一个把 view（一个DOM元素）连结到 controller 上的对象。在我们的 MVC 结构里，这个 $scope 将成为 model，它提供一个绑定到DOM元素（以及其子元素）上的excecution context。</p>\n<p>　　尽管听起来有点复杂，但 $scope 实际上就是一个JavaScript 对象，controller 和 view 都可以访问它，所以我们可以利用它在两者间传递信息。在这个 $scope 对象里，我们既存储数据，又存储将要运行在view上的函数。</p>\n<p>　　每一个 Angular 应用都会有一个 $rootScope。这个 $rootScope 是最顶级的 scope，它对应着含有 ng-app 指令属性的那个 DOM 元素</p>\n<p>　　所有scope都遵循原型继承（prototypal inheritance），这意味着它们都能访问父scope们。</p>\n<h3 id=\"6-AngularJS-模块\"><a href=\"#6-AngularJS-模块\" class=\"headerlink\" title=\"6. AngularJS 模块\"></a>6. AngularJS 模块</h3><p>　　AngularJS 本身的一个默认模块叫做 ng ，它提供了 $http ， $q 等等服务。</p>\n<p>　　服务只是模块提供的多种机制中的一种，其它的还有命令（ directive ），过滤器（ filter ），及其它配置信息。</p>\n<p>　　然后在额外的 js 文件中有一个附加的模块叫做 ngResource ， 它提供了一个 $resource 服务。</p>\n<h4 id=\"定义模块\"><a href=\"#定义模块\" class=\"headerlink\" title=\"定义模块\"></a>定义模块</h4><p>　　定义模块的方法是使用 angular.module 。调用时声明了对其它模块的依赖，并定义了“初始化”函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var my_module = angular.module(&apos;MyModule&apos;, [], function()&#123;</div><div class=\"line\">    console.log(&apos;here&apos;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>这段代码定义了一个叫做 MyModule 的模块， my_module 这个引用可以在接下来做其它的一些事，比如定义服务。</p>\n<h4 id=\"定义服务\"><a href=\"#定义服务\" class=\"headerlink\" title=\"定义服务\"></a>定义服务</h4><p>　　ng的服务是这样定义的：</p>\n<p>　　Angular services are singletons objects or functions that carry out specific tasks common to web apps.</p>\n<p>　　它是一个单例对象或函数，对外提供特定的功能。<br>　　首先是一个单例，即无论这个服务被注入到任何地方，对象始终只有一个实例。<br>　　其次这与我们自己定义一个function然后在其他地方调用不同，因为服务被定义在一个模块中，所以其使用范围是可以被我们管理的。ng的避免全局变量污染意识非常强。<br>　　ng提供了很多内置的服务，可以到API中查看 <a href=\"http://docs.angularjs.org/api/\">http://docs.angularjs.org/api/</a> 。如同指令一样，系统内置的服务以$开头，我们也可以自己定义一个服务。</p>\n<p>　　在这里呢，就要先介绍一下叫 provider 的东西。简单来说， provider 是被 注入控制器 使用的一个对象，注入机制通过调用一个 provider 的 $get() 方法，把得到的东西作为参数进行相关调用（比如把得到的服务作为一个 Controller 的参数）。</p>\n<p>　　在这里 服务 的概念就比较不明确，对使用而言，服务仅指 $get() 方法返回的东西，但是在整体机制上，服务又要指提供了 $get() 方法的整个对象。</p>\n<ul>\n<li><p>这是一个provider</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var pp = function()&#123;</div><div class=\"line\">  this.$get = function()&#123;</div><div class=\"line\">    return &#123;&apos;haha&apos;: &apos;123&apos;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>我在模块的初始化过程当中, 定义了一个叫 PP 的服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;Demo&apos;, [], function($provide)&#123;</div><div class=\"line\">  $provide.provider(&apos;PP&apos;, pp);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>PP服务实际上就是 pp 这个 provider 的 $get() 方法返回的东西</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.controller(&apos;TestCtrl&apos;,</div><div class=\"line\">  function($scope, PP)&#123;</div><div class=\"line\">    console.log(PP);</div><div class=\"line\">  &#125;</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>　　ng 还有相关的 shortcut， 第一个是 factory 方法 ，由 $provide 提供， module 的 factory 是一个引用，作用一样。这个方法直接把一个函数当成是一个对象的 $get() 方法，这样你就不用显式地定义一个 provider 了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;Demo&apos;, [], function($provide)&#123;</div><div class=\"line\">    $provide.factory(&apos;PP&apos;, function()&#123;</div><div class=\"line\">        return &#123;&apos;hello&apos;: &apos;123&apos;&#125;;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\">app.controller(&apos;TestCtrl&apos;, function($scope, PP)&#123; console.log(PP) &#125;);</div></pre></td></tr></table></figure></p>\n<p>在 module 中使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;Demo&apos;, [], function()&#123; &#125;);</div><div class=\"line\">app.factory(&apos;PP&apos;, function()&#123;return &#123;&apos;abc&apos;: &apos;123&apos;&#125;&#125;);</div><div class=\"line\">app.controller(&apos;TestCtrl&apos;, function($scope, PP)&#123; console.log(PP) &#125;);</div></pre></td></tr></table></figure></p>\n<p>　　第二个是 service 方法，也是由 $provide 提供， module 中有对它的同名引用。 service 和 factory 的区别在于，前者是要求提供一个“构造方法”，后者是要求提供 $get() 方法。意思就是，前者一定是得到一个 object ，后者可以是一个数字或字符串。它们的关系大概是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;Demo&apos;, [], function()&#123; &#125;);</div><div class=\"line\">app.service = function(name, constructor)&#123;</div><div class=\"line\">    app.factory(name, function()&#123;</div><div class=\"line\">      return (new constructor());</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>service 方法的使用就很简单了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;Demo&apos;, [], function()&#123; &#125;);</div><div class=\"line\">app.service(&apos;PP&apos;, function()&#123;</div><div class=\"line\">    this.abc = &apos;123&apos;;</div><div class=\"line\">&#125;);</div><div class=\"line\">app.controller(&apos;TestCtrl&apos;, function($scope, PP)&#123; console.log(PP) &#125;);</div></pre></td></tr></table></figure></p>\n<p>引入模块并使用服务<br>结合上面的 定义模块 和 定义服务 ，我们可以方便地组织自己的额外代码：</p>\n<ul>\n<li><p>定义服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;MyModule&apos;, [], function($provide)&#123;</div><div class=\"line\">    $provide.factory(&apos;S1&apos;, function()&#123;</div><div class=\"line\">      return &apos;I am S1&apos;;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    $provide.factory(&apos;S2&apos;, function()&#123;</div><div class=\"line\">      return &#123;see: function()&#123;return &apos;I am S2&apos;&#125;&#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>调用服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;Demo&apos;, [&apos;MyModule&apos;], angular.noop);</div><div class=\"line\">app.controller(&apos;TestCtrl&apos;, function($scope, S1, S2)&#123;</div><div class=\"line\">    console.log(S1)</div><div class=\"line\">    console.log(S2.see())</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"7-附加模块-ngResource\"><a href=\"#7-附加模块-ngResource\" class=\"headerlink\" title=\"7. 附加模块 ngResource\"></a>7. 附加模块 ngResource</h3><p>　　ngResource 这个是 ng 官方提供的一个附加模块。 附加 的意思就是，如果你打算用它，那么你需要引入一人单独的 js 文件，然后在声明“根模块”时注明依赖的 ngResource 模块，接着就可以使用它提供的 $resource 服务了。</p>\n<p>　　$resource 服务主要是包装了 AJAX 的调用，使用 $resource 需要先定义“资源”，也就是先定义一些 HTTP 请求。</p>\n<h3 id=\"8-AngularJS-路由\"><a href=\"#8-AngularJS-路由\" class=\"headerlink\" title=\"8. AngularJS 路由\"></a>8. AngularJS 路由</h3><p>ng的路由(ngRoute)是一个单独的模块，包含以下内容：</p>\n<p>服务 $routeProvider 用来定义一个路由表，即地址栏与视图模板的映射<br>服务 $routeParams 保存了地址栏中的参数，例如 {id : 1, name : ‘tom’}<br>服务 $route 完成路由匹配，并且提供路由相关的属性访问及事件，如访问当前路由对应的 controller<br>指令 ngView 用来在主视图中指定加载子视图的区域</p>\n<h4 id=\"定义路由\"><a href=\"#定义路由\" class=\"headerlink\" title=\"定义路由\"></a>定义路由</h4><ul>\n<li>第一步：引入文件和依赖</li>\n</ul>\n<p>ngRoute 也是一个附件模块，故需要在页面上引入 angular-route.min.js 并在模块中注入对 ngRoute 的依赖，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;MyApp&apos;, [&apos;ngRoute&apos;]);//一切从模块开始</div></pre></td></tr></table></figure></p>\n<ul>\n<li>第二步：定义路由表</li>\n</ul>\n<p>　　$routeProvider 提供了定义路由表的服务，它有两个核心方法： when(path,route) 和 otherwise(params) ，先看一下核心中的核心 when(path,route)方法。</p>\n<p>　　when(path,route) 方法接收两个参数:</p>\n<p>　　path 是一个 string 类型，表示该条路由规则所匹配的路径，它将与地址栏的内容($location.path)值进行匹配。如果需要匹配参数，可以在 path 中使用冒号加名称的方式，如：path为 /show/:name ，如果地址栏是 /show/tom ，那么参数 name 和所对应的值 tom 便会被保存在 $routeParams 中，像这样： {name : tom} 。我们也可以用 <em> 进行模糊匹配，如： /show</em>/:name 将匹配 /showInfo/tom 。</p>\n<p>　　route 参数是一个 object，用来指定当 path 匹配后所需的一系列配置项，包括以下内容：<br>　　controller function 或 string 类型。在当前模板上执行的 controller 函数，生成新的 scope；<br>　　controllerAs string 类型，为 controller 指定别名；<br>　　template string 或 function 类型，视图所用的模板，这部分内容将被 ngView 引用；<br>　　templateUrl string 或 function 类型，当视图模板为单独的 html 文件或是使用了 <script type=\"text/ng-template\"> 定义模板时使用；<br>　　resolve 指定当前 controller 所依赖的其他模块；<br>　　redirectTo 重定向的地址。</p>\n<ul>\n<li>第三步：在主视图模板中指定加载子视图的位置</li>\n</ul>\n<p>只需在模板中简单的使用此 ngView 指令:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-view&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p>TODO UI-ROUTE</p>\n"},{"title":"Angular路由之ui-router","date":"2015-12-05T15:50:58.000Z","_content":"#### ui-router\n   AngularUI库提供的最有用的库之一便是ui-router。它是一个路由框架，允许你通过状态机组织接口，而不是简单的URL路由。ng-router能办的事，ui-router都能做到，所以说会了ui-router，你就可以忘记ng-router,以免浪费脑细胞。哈哈\n   安装：\n   ```\n   $ bower install angular-ui-router --save\n   ```\n   你还要确保在视图中链接这个库：\n   ```\n   <scripttype=\"text/javascript\"\n   src=\"app/bower_components/angular-ui-router/release/angular-ui-router.js\"></script>\n   ```\n   同时还需要将ui.router作为依赖注入到你的应用中：\n   ```\n   angular.module('myApp', ['ui.router']);\n   ```\n   不同于内置的ngRoute服务，由于ui-router基于状态工作，而不是简单的url，因此你可以将它嵌套在视图中。\n   在处理uiRoute服务时我们不再使用ng-view，而改为使用`ui-view`指令。\n   在ui-router内处理路由和状态时，我们主要关心的是应用程序处在哪个状态以及Web应用当前处在哪个路由位置。\n#### 定义路由\n   为了定义路由，你可以使用.config方法，和常见的方式一样，但不是将路由设置在$routeProvider上，而是将状态设置在$stateProvider上。\n   ```\n   .config(function($stateProvider,$urlRouterProvider) {\n   $stateProvider\n   .state('start', {\n   url: '/start',\n   templateUrl: 'partials/start.html'\n   })\n   });\n```\n这一步给状态配置对象分配了一个名为start的状态。这个状态配置对象，或者说这个stateConfig也有一些与路由配置对象相似的选项，让你能够配置应用程序的状态。\n1. template、 templateUrl、 templateProvider\n在每个视图上设置模板的方式有三种。\n template：一个HTML内容字符串或者返回HTML的函数。\n templateUrl：一个模板URL路径字符串或者是返回URL路径字符串的函数。\n templateProvider：一个返回HTML内容字符串的函数。\n例如：\n$stateProvider.state('home',{\n","source":"_posts/angular-ui-router.md","raw":"---\ntitle: Angular路由之ui-router\ndate: 2015-12-05 23:50:58\ntags: angular、ui-router\n---\n#### ui-router\n   AngularUI库提供的最有用的库之一便是ui-router。它是一个路由框架，允许你通过状态机组织接口，而不是简单的URL路由。ng-router能办的事，ui-router都能做到，所以说会了ui-router，你就可以忘记ng-router,以免浪费脑细胞。哈哈\n   安装：\n   ```\n   $ bower install angular-ui-router --save\n   ```\n   你还要确保在视图中链接这个库：\n   ```\n   <scripttype=\"text/javascript\"\n   src=\"app/bower_components/angular-ui-router/release/angular-ui-router.js\"></script>\n   ```\n   同时还需要将ui.router作为依赖注入到你的应用中：\n   ```\n   angular.module('myApp', ['ui.router']);\n   ```\n   不同于内置的ngRoute服务，由于ui-router基于状态工作，而不是简单的url，因此你可以将它嵌套在视图中。\n   在处理uiRoute服务时我们不再使用ng-view，而改为使用`ui-view`指令。\n   在ui-router内处理路由和状态时，我们主要关心的是应用程序处在哪个状态以及Web应用当前处在哪个路由位置。\n#### 定义路由\n   为了定义路由，你可以使用.config方法，和常见的方式一样，但不是将路由设置在$routeProvider上，而是将状态设置在$stateProvider上。\n   ```\n   .config(function($stateProvider,$urlRouterProvider) {\n   $stateProvider\n   .state('start', {\n   url: '/start',\n   templateUrl: 'partials/start.html'\n   })\n   });\n```\n这一步给状态配置对象分配了一个名为start的状态。这个状态配置对象，或者说这个stateConfig也有一些与路由配置对象相似的选项，让你能够配置应用程序的状态。\n1. template、 templateUrl、 templateProvider\n在每个视图上设置模板的方式有三种。\n template：一个HTML内容字符串或者返回HTML的函数。\n templateUrl：一个模板URL路径字符串或者是返回URL路径字符串的函数。\n templateProvider：一个返回HTML内容字符串的函数。\n例如：\n$stateProvider.state('home',{\n","slug":"angular-ui-router","published":1,"updated":"2016-12-22T01:47:35.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv6x0010jgtuxwltzqyh","content":"<h4 id=\"ui-router\"><a href=\"#ui-router\" class=\"headerlink\" title=\"ui-router\"></a>ui-router</h4><p>   AngularUI库提供的最有用的库之一便是ui-router。它是一个路由框架，允许你通过状态机组织接口，而不是简单的URL路由。ng-router能办的事，ui-router都能做到，所以说会了ui-router，你就可以忘记ng-router,以免浪费脑细胞。哈哈<br>   安装：<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ bower install angular-ui-router --save</div></pre></td></tr></table></figure></p>\n<p>   你还要确保在视图中链接这个库：<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;scripttype=&quot;text/javascript&quot;</div><div class=\"line\">src=&quot;app/bower_components/angular-ui-router/release/angular-ui-router.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<p>   同时还需要将ui.router作为依赖注入到你的应用中：<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp&apos;, [&apos;ui.router&apos;]);</div></pre></td></tr></table></figure></p>\n<p>   不同于内置的ngRoute服务，由于ui-router基于状态工作，而不是简单的url，因此你可以将它嵌套在视图中。<br>   在处理uiRoute服务时我们不再使用ng-view，而改为使用<code>ui-view</code>指令。<br>   在ui-router内处理路由和状态时，我们主要关心的是应用程序处在哪个状态以及Web应用当前处在哪个路由位置。</p>\n<h4 id=\"定义路由\"><a href=\"#定义路由\" class=\"headerlink\" title=\"定义路由\"></a>定义路由</h4><p>   为了定义路由，你可以使用.config方法，和常见的方式一样，但不是将路由设置在$routeProvider上，而是将状态设置在$stateProvider上。<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">.config(function($stateProvider,$urlRouterProvider) &#123;</div><div class=\"line\">$stateProvider</div><div class=\"line\">.state(&apos;start&apos;, &#123;</div><div class=\"line\">url: &apos;/start&apos;,</div><div class=\"line\">templateUrl: &apos;partials/start.html&apos;</div><div class=\"line\">&#125;)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>这一步给状态配置对象分配了一个名为start的状态。这个状态配置对象，或者说这个stateConfig也有一些与路由配置对象相似的选项，让你能够配置应用程序的状态。</p>\n<ol>\n<li>template、 templateUrl、 templateProvider<br>在每个视图上设置模板的方式有三种。<br> template：一个HTML内容字符串或者返回HTML的函数。<br> templateUrl：一个模板URL路径字符串或者是返回URL路径字符串的函数。<br> templateProvider：一个返回HTML内容字符串的函数。<br>例如：<br>$stateProvider.state(‘home’,{</li>\n</ol>\n","excerpt":"","more":"<h4 id=\"ui-router\"><a href=\"#ui-router\" class=\"headerlink\" title=\"ui-router\"></a>ui-router</h4><p>   AngularUI库提供的最有用的库之一便是ui-router。它是一个路由框架，允许你通过状态机组织接口，而不是简单的URL路由。ng-router能办的事，ui-router都能做到，所以说会了ui-router，你就可以忘记ng-router,以免浪费脑细胞。哈哈<br>   安装：<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ bower install angular-ui-router --save</div></pre></td></tr></table></figure></p>\n<p>   你还要确保在视图中链接这个库：<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;scripttype=&quot;text/javascript&quot;</div><div class=\"line\">src=&quot;app/bower_components/angular-ui-router/release/angular-ui-router.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<p>   同时还需要将ui.router作为依赖注入到你的应用中：<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myApp&apos;, [&apos;ui.router&apos;]);</div></pre></td></tr></table></figure></p>\n<p>   不同于内置的ngRoute服务，由于ui-router基于状态工作，而不是简单的url，因此你可以将它嵌套在视图中。<br>   在处理uiRoute服务时我们不再使用ng-view，而改为使用<code>ui-view</code>指令。<br>   在ui-router内处理路由和状态时，我们主要关心的是应用程序处在哪个状态以及Web应用当前处在哪个路由位置。</p>\n<h4 id=\"定义路由\"><a href=\"#定义路由\" class=\"headerlink\" title=\"定义路由\"></a>定义路由</h4><p>   为了定义路由，你可以使用.config方法，和常见的方式一样，但不是将路由设置在$routeProvider上，而是将状态设置在$stateProvider上。<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">.config(function($stateProvider,$urlRouterProvider) &#123;</div><div class=\"line\">$stateProvider</div><div class=\"line\">.state(&apos;start&apos;, &#123;</div><div class=\"line\">url: &apos;/start&apos;,</div><div class=\"line\">templateUrl: &apos;partials/start.html&apos;</div><div class=\"line\">&#125;)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>这一步给状态配置对象分配了一个名为start的状态。这个状态配置对象，或者说这个stateConfig也有一些与路由配置对象相似的选项，让你能够配置应用程序的状态。</p>\n<ol>\n<li>template、 templateUrl、 templateProvider<br>在每个视图上设置模板的方式有三种。<br> template：一个HTML内容字符串或者返回HTML的函数。<br> templateUrl：一个模板URL路径字符串或者是返回URL路径字符串的函数。<br> templateProvider：一个返回HTML内容字符串的函数。<br>例如：<br>$stateProvider.state(‘home’,{</li>\n</ol>\n"},{"title":"js 数组中自定义属性的应用","date":"2016-11-13T09:18:52.000Z","_content":"首先要说明的是：数组也是一个object,所以也可以添自定义属性。\n```\nvar arr = [];即可表示一个完整的数组\nconsole.log(arr.length) //0\n```\n就是说数组本身是有属性的，这样一来，我们就可以添加自己需要的属性了\n```\narr.load = false;//查看load\nconsole.log(arr.load);//false\narr.load = true; //修改load的值\nconsole.log(arr.load);//true\n```\n有人会说，这有什么用？就是一个自定义属性而已。请看下面内容便知道了。\n\n前端在通过ajax获取后台数据时，列表通常返回数组形式\n前台展示列表：\n```\n//默认值\nvar showList = [];\najax获取值：\n//获取前，页面会提示正在获取数据\najax(url,function(data){\n    showList = data.list;\n    //获取到数据后，会返回这个list,此时，如果list是空的，那么，showList就没有发生变化\n});\n```\n当返回为空时，那么该如何通过判断showList.length的变化来修改页面提示信息呢？（正在获取数据…/暂无数据）,此时就需要给showList添加一个自定义属性load,\n```\nvar showList = [];\nshowList.load = false;\najax(url,function(data){\n    showList.load = true;\n    showList = data.list;\n});\n```\n前台就可以根据load状态进行判断提示了（showList.load?’正在获取数据…':’暂无数据’）\n\n技巧虽小，但是有时候可以帮大忙。","source":"_posts/arraydeapply.md","raw":"---\ntitle: js 数组中自定义属性的应用\ndate: 2016-11-13 17:18:52\ntags: js Array\n---\n首先要说明的是：数组也是一个object,所以也可以添自定义属性。\n```\nvar arr = [];即可表示一个完整的数组\nconsole.log(arr.length) //0\n```\n就是说数组本身是有属性的，这样一来，我们就可以添加自己需要的属性了\n```\narr.load = false;//查看load\nconsole.log(arr.load);//false\narr.load = true; //修改load的值\nconsole.log(arr.load);//true\n```\n有人会说，这有什么用？就是一个自定义属性而已。请看下面内容便知道了。\n\n前端在通过ajax获取后台数据时，列表通常返回数组形式\n前台展示列表：\n```\n//默认值\nvar showList = [];\najax获取值：\n//获取前，页面会提示正在获取数据\najax(url,function(data){\n    showList = data.list;\n    //获取到数据后，会返回这个list,此时，如果list是空的，那么，showList就没有发生变化\n});\n```\n当返回为空时，那么该如何通过判断showList.length的变化来修改页面提示信息呢？（正在获取数据…/暂无数据）,此时就需要给showList添加一个自定义属性load,\n```\nvar showList = [];\nshowList.load = false;\najax(url,function(data){\n    showList.load = true;\n    showList = data.list;\n});\n```\n前台就可以根据load状态进行判断提示了（showList.load?’正在获取数据…':’暂无数据’）\n\n技巧虽小，但是有时候可以帮大忙。","slug":"arraydeapply","published":1,"updated":"2016-12-13T09:27:02.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv700012jgtul3i43m78","content":"<p>首先要说明的是：数组也是一个object,所以也可以添自定义属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = [];即可表示一个完整的数组</div><div class=\"line\">console.log(arr.length) //0</div></pre></td></tr></table></figure></p>\n<p>就是说数组本身是有属性的，这样一来，我们就可以添加自己需要的属性了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">arr.load = false;//查看load</div><div class=\"line\">console.log(arr.load);//false</div><div class=\"line\">arr.load = true; //修改load的值</div><div class=\"line\">console.log(arr.load);//true</div></pre></td></tr></table></figure></p>\n<p>有人会说，这有什么用？就是一个自定义属性而已。请看下面内容便知道了。</p>\n<p>前端在通过ajax获取后台数据时，列表通常返回数组形式<br>前台展示列表：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//默认值</div><div class=\"line\">var showList = [];</div><div class=\"line\">ajax获取值：</div><div class=\"line\">//获取前，页面会提示正在获取数据</div><div class=\"line\">ajax(url,function(data)&#123;</div><div class=\"line\">    showList = data.list;</div><div class=\"line\">    //获取到数据后，会返回这个list,此时，如果list是空的，那么，showList就没有发生变化</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>当返回为空时，那么该如何通过判断showList.length的变化来修改页面提示信息呢？（正在获取数据…/暂无数据）,此时就需要给showList添加一个自定义属性load,<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var showList = [];</div><div class=\"line\">showList.load = false;</div><div class=\"line\">ajax(url,function(data)&#123;</div><div class=\"line\">    showList.load = true;</div><div class=\"line\">    showList = data.list;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>前台就可以根据load状态进行判断提示了（showList.load?’正在获取数据…’:’暂无数据’）</p>\n<p>技巧虽小，但是有时候可以帮大忙。</p>\n","excerpt":"","more":"<p>首先要说明的是：数组也是一个object,所以也可以添自定义属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = [];即可表示一个完整的数组</div><div class=\"line\">console.log(arr.length) //0</div></pre></td></tr></table></figure></p>\n<p>就是说数组本身是有属性的，这样一来，我们就可以添加自己需要的属性了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">arr.load = false;//查看load</div><div class=\"line\">console.log(arr.load);//false</div><div class=\"line\">arr.load = true; //修改load的值</div><div class=\"line\">console.log(arr.load);//true</div></pre></td></tr></table></figure></p>\n<p>有人会说，这有什么用？就是一个自定义属性而已。请看下面内容便知道了。</p>\n<p>前端在通过ajax获取后台数据时，列表通常返回数组形式<br>前台展示列表：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//默认值</div><div class=\"line\">var showList = [];</div><div class=\"line\">ajax获取值：</div><div class=\"line\">//获取前，页面会提示正在获取数据</div><div class=\"line\">ajax(url,function(data)&#123;</div><div class=\"line\">    showList = data.list;</div><div class=\"line\">    //获取到数据后，会返回这个list,此时，如果list是空的，那么，showList就没有发生变化</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>当返回为空时，那么该如何通过判断showList.length的变化来修改页面提示信息呢？（正在获取数据…/暂无数据）,此时就需要给showList添加一个自定义属性load,<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var showList = [];</div><div class=\"line\">showList.load = false;</div><div class=\"line\">ajax(url,function(data)&#123;</div><div class=\"line\">    showList.load = true;</div><div class=\"line\">    showList = data.list;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>前台就可以根据load状态进行判断提示了（showList.load?’正在获取数据…’:’暂无数据’）</p>\n<p>技巧虽小，但是有时候可以帮大忙。</p>\n"},{"title":"你js这么牛比，你知道++[[]][+[]]+[+[]]的结果么？","date":"2016-12-12T14:26:47.000Z","_content":"　　首先，问这个问题的人是个天才，他怎么会遇到这样的一个问题。其次，回答这个问题的人更是一个天才，我难以想象他会回答这个问题，更难以想象的是，他的回答是如此的详细和丰富和完整，真正称得上诲人不倦。\n　　既然遇到了这个问题，我们不妨也跟着提高一下。\n　　这是一个Javascript语言题目，一个完全有效的等式，不信自己可以试一下，下面看看高人的题解：\n```\n++[[]][+[]]+[+[]]\n```\n　　如果把这段表达式拆分开来，它相等于：\n```\n++[[]][+[]]\n+\n[+[]]\n```\n　　在JavaScript里，+[] === 0 是完全正确的。 + 会把一些字符转化成数字，在这里，这个式子会变成 +”” 或 0。\n　　因此，我们可以简化一下(++ 比 + 有更高的优先级)：\n```\n++[[]][0]\n+\n[0]\n```\n　　因为 [[]][0] 的意思是：获取 [[]] 的第一个元素，这就得出了下面的结果：\n\n[[]][0] 返回内部数组 ([])。根据语言规范，我们说 [[]][0] === [] 是不正确的，但让我们把这个内部数组称作 A，以避免错误的写法。\n```\n++[[]][0] == A + 1， 因为 ++ 的意思是“加一”。\n++[[]][0] === +(A + 1)；换句话说，你得到的永远是个数值( +1 并不一定得到的是个数值，但 ++ 一定是)。\n```\n　　同样，我们可以把这一堆代码简化的更清晰。让我们把 A 换回成 [] :\n```\n+([] + 1)\n+\n[0]\n```\n　　在JavaScript里，这也是正确的：[] + 1 === “1”，因为 [] == “” (这相当于一个空的数组的内部元素连接)，于是：\n```\n+([] + 1) === +(“” + 1)，并且\n+(“” + 1) === +(“1”)，并且\n+(“1”) === 1\n```\n　　让我们再次简化一下：\n```\n1\n+\n[0]\n```\n　　同样，在Javascript里，这是正确的：[0] == “0”，因为这是相当于一个有一个元素的数组的内部元素的连接。各元素会使用，分隔。当只有一个元素时，你可以推论出这个过程的结果就是它自身的第一个元素。\n\n　　所以，最终我们得到(数字 + 字符串 = 字符串)：\n```\n1\n+\n\"0\"\n=== \"10\" // 耶！\n```","source":"_posts/biantaiti.md","raw":"---\ntitle: 你js这么牛比，你知道++[[]][+[]]+[+[]]的结果么？\ndate: 2016-12-12 22:26:47\ntags:  js、变态题\n---\n　　首先，问这个问题的人是个天才，他怎么会遇到这样的一个问题。其次，回答这个问题的人更是一个天才，我难以想象他会回答这个问题，更难以想象的是，他的回答是如此的详细和丰富和完整，真正称得上诲人不倦。\n　　既然遇到了这个问题，我们不妨也跟着提高一下。\n　　这是一个Javascript语言题目，一个完全有效的等式，不信自己可以试一下，下面看看高人的题解：\n```\n++[[]][+[]]+[+[]]\n```\n　　如果把这段表达式拆分开来，它相等于：\n```\n++[[]][+[]]\n+\n[+[]]\n```\n　　在JavaScript里，+[] === 0 是完全正确的。 + 会把一些字符转化成数字，在这里，这个式子会变成 +”” 或 0。\n　　因此，我们可以简化一下(++ 比 + 有更高的优先级)：\n```\n++[[]][0]\n+\n[0]\n```\n　　因为 [[]][0] 的意思是：获取 [[]] 的第一个元素，这就得出了下面的结果：\n\n[[]][0] 返回内部数组 ([])。根据语言规范，我们说 [[]][0] === [] 是不正确的，但让我们把这个内部数组称作 A，以避免错误的写法。\n```\n++[[]][0] == A + 1， 因为 ++ 的意思是“加一”。\n++[[]][0] === +(A + 1)；换句话说，你得到的永远是个数值( +1 并不一定得到的是个数值，但 ++ 一定是)。\n```\n　　同样，我们可以把这一堆代码简化的更清晰。让我们把 A 换回成 [] :\n```\n+([] + 1)\n+\n[0]\n```\n　　在JavaScript里，这也是正确的：[] + 1 === “1”，因为 [] == “” (这相当于一个空的数组的内部元素连接)，于是：\n```\n+([] + 1) === +(“” + 1)，并且\n+(“” + 1) === +(“1”)，并且\n+(“1”) === 1\n```\n　　让我们再次简化一下：\n```\n1\n+\n[0]\n```\n　　同样，在Javascript里，这是正确的：[0] == “0”，因为这是相当于一个有一个元素的数组的内部元素的连接。各元素会使用，分隔。当只有一个元素时，你可以推论出这个过程的结果就是它自身的第一个元素。\n\n　　所以，最终我们得到(数字 + 字符串 = 字符串)：\n```\n1\n+\n\"0\"\n=== \"10\" // 耶！\n```","slug":"biantaiti","published":1,"updated":"2016-12-12T14:33:51.779Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv720014jgtutcl5k1em","content":"<p>　　首先，问这个问题的人是个天才，他怎么会遇到这样的一个问题。其次，回答这个问题的人更是一个天才，我难以想象他会回答这个问题，更难以想象的是，他的回答是如此的详细和丰富和完整，真正称得上诲人不倦。<br>　　既然遇到了这个问题，我们不妨也跟着提高一下。<br>　　这是一个Javascript语言题目，一个完全有效的等式，不信自己可以试一下，下面看看高人的题解：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">++[[]][+[]]+[+[]]</div></pre></td></tr></table></figure></p>\n<p>　　如果把这段表达式拆分开来，它相等于：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">++[[]][+[]]</div><div class=\"line\">+</div><div class=\"line\">[+[]]</div></pre></td></tr></table></figure></p>\n<p>　　在JavaScript里，+[] === 0 是完全正确的。 + 会把一些字符转化成数字，在这里，这个式子会变成 +”” 或 0。<br>　　因此，我们可以简化一下(++ 比 + 有更高的优先级)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">++[[]][0]</div><div class=\"line\">+</div><div class=\"line\">[0]</div></pre></td></tr></table></figure></p>\n<p>　　因为 [[]][0] 的意思是：获取 [[]] 的第一个元素，这就得出了下面的结果：</p>\n<p>[[]][0] 返回内部数组 ([])。根据语言规范，我们说 [[]][0] === [] 是不正确的，但让我们把这个内部数组称作 A，以避免错误的写法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">++[[]][0] == A + 1， 因为 ++ 的意思是“加一”。</div><div class=\"line\">++[[]][0] === +(A + 1)；换句话说，你得到的永远是个数值( +1 并不一定得到的是个数值，但 ++ 一定是)。</div></pre></td></tr></table></figure></p>\n<p>　　同样，我们可以把这一堆代码简化的更清晰。让我们把 A 换回成 [] :<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">+([] + 1)</div><div class=\"line\">+</div><div class=\"line\">[0]</div></pre></td></tr></table></figure></p>\n<p>　　在JavaScript里，这也是正确的：[] + 1 === “1”，因为 [] == “” (这相当于一个空的数组的内部元素连接)，于是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">+([] + 1) === +(“” + 1)，并且</div><div class=\"line\">+(“” + 1) === +(“1”)，并且</div><div class=\"line\">+(“1”) === 1</div></pre></td></tr></table></figure></p>\n<p>　　让我们再次简化一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">1</div><div class=\"line\">+</div><div class=\"line\">[0]</div></pre></td></tr></table></figure></p>\n<p>　　同样，在Javascript里，这是正确的：[0] == “0”，因为这是相当于一个有一个元素的数组的内部元素的连接。各元素会使用，分隔。当只有一个元素时，你可以推论出这个过程的结果就是它自身的第一个元素。</p>\n<p>　　所以，最终我们得到(数字 + 字符串 = 字符串)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">1</div><div class=\"line\">+</div><div class=\"line\">&quot;0&quot;</div><div class=\"line\">=== &quot;10&quot; // 耶！</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>　　首先，问这个问题的人是个天才，他怎么会遇到这样的一个问题。其次，回答这个问题的人更是一个天才，我难以想象他会回答这个问题，更难以想象的是，他的回答是如此的详细和丰富和完整，真正称得上诲人不倦。<br>　　既然遇到了这个问题，我们不妨也跟着提高一下。<br>　　这是一个Javascript语言题目，一个完全有效的等式，不信自己可以试一下，下面看看高人的题解：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">++[[]][+[]]+[+[]]</div></pre></td></tr></table></figure></p>\n<p>　　如果把这段表达式拆分开来，它相等于：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">++[[]][+[]]</div><div class=\"line\">+</div><div class=\"line\">[+[]]</div></pre></td></tr></table></figure></p>\n<p>　　在JavaScript里，+[] === 0 是完全正确的。 + 会把一些字符转化成数字，在这里，这个式子会变成 +”” 或 0。<br>　　因此，我们可以简化一下(++ 比 + 有更高的优先级)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">++[[]][0]</div><div class=\"line\">+</div><div class=\"line\">[0]</div></pre></td></tr></table></figure></p>\n<p>　　因为 [[]][0] 的意思是：获取 [[]] 的第一个元素，这就得出了下面的结果：</p>\n<p>[[]][0] 返回内部数组 ([])。根据语言规范，我们说 [[]][0] === [] 是不正确的，但让我们把这个内部数组称作 A，以避免错误的写法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">++[[]][0] == A + 1， 因为 ++ 的意思是“加一”。</div><div class=\"line\">++[[]][0] === +(A + 1)；换句话说，你得到的永远是个数值( +1 并不一定得到的是个数值，但 ++ 一定是)。</div></pre></td></tr></table></figure></p>\n<p>　　同样，我们可以把这一堆代码简化的更清晰。让我们把 A 换回成 [] :<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">+([] + 1)</div><div class=\"line\">+</div><div class=\"line\">[0]</div></pre></td></tr></table></figure></p>\n<p>　　在JavaScript里，这也是正确的：[] + 1 === “1”，因为 [] == “” (这相当于一个空的数组的内部元素连接)，于是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">+([] + 1) === +(“” + 1)，并且</div><div class=\"line\">+(“” + 1) === +(“1”)，并且</div><div class=\"line\">+(“1”) === 1</div></pre></td></tr></table></figure></p>\n<p>　　让我们再次简化一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">1</div><div class=\"line\">+</div><div class=\"line\">[0]</div></pre></td></tr></table></figure></p>\n<p>　　同样，在Javascript里，这是正确的：[0] == “0”，因为这是相当于一个有一个元素的数组的内部元素的连接。各元素会使用，分隔。当只有一个元素时，你可以推论出这个过程的结果就是它自身的第一个元素。</p>\n<p>　　所以，最终我们得到(数字 + 字符串 = 字符串)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">1</div><div class=\"line\">+</div><div class=\"line\">&quot;0&quot;</div><div class=\"line\">=== &quot;10&quot; // 耶！</div></pre></td></tr></table></figure></p>\n"},{"title":"基于区块链的web前端开发","date":"2016-12-01T06:36:46.000Z","_content":"   最近听同学说区块链技术很火，各大银行及金融企业都在研究，我还以为是后端的技术了，听说前端也可以写，所以有了这篇文章，先记录下来然后后续再补充。\n   区块链是新的热门技术。如果你没听说过它，你可能听说过比特币。区块链是比特币的底层技术。专家说区块链将会和因特网一样掀起一场革命。说到这里，我好期待啊，期待纸币走向灭亡，以后都用电子货币。\n   \n   web技术的发展来源技术驱动力，blockchain技术发展了p2p网络的优点，成为w3c青睐的技术。\n   至于区块链的技术就不写了，只是初步地了解，很多地方理解的不是很到位，以免误导别人。如果你想学习，可以自己查资料。\n\nweb1.0:网络是信息的提供者，可以理解为单向信息，信息是只读的，缺少互动。过去时。\n\nweb2.0:网络是一个平台，用户可以提供信息通过网络来与其他用户进行沟通，此时用户之间可以通过网络互动。现在时。\n\nweb3.0: 网站内的信息可以直接和其他网站相关信息进行交互，能通过第三方信息平台同时对多家网站的信息进行整合使用；用户在互联网上拥有自己的数据，并能在不同网站上使用；完全基于web，用浏览器即可实现复杂系统程序才能实现的系统功能;用户数据审计后，同步于网络数据。将来时。","source":"_posts/blockchain.md","raw":"---\ntitle: 基于区块链的web前端开发\ndate: 2016-12-01 14:36:46\ntags: blockchain\n---\n   最近听同学说区块链技术很火，各大银行及金融企业都在研究，我还以为是后端的技术了，听说前端也可以写，所以有了这篇文章，先记录下来然后后续再补充。\n   区块链是新的热门技术。如果你没听说过它，你可能听说过比特币。区块链是比特币的底层技术。专家说区块链将会和因特网一样掀起一场革命。说到这里，我好期待啊，期待纸币走向灭亡，以后都用电子货币。\n   \n   web技术的发展来源技术驱动力，blockchain技术发展了p2p网络的优点，成为w3c青睐的技术。\n   至于区块链的技术就不写了，只是初步地了解，很多地方理解的不是很到位，以免误导别人。如果你想学习，可以自己查资料。\n\nweb1.0:网络是信息的提供者，可以理解为单向信息，信息是只读的，缺少互动。过去时。\n\nweb2.0:网络是一个平台，用户可以提供信息通过网络来与其他用户进行沟通，此时用户之间可以通过网络互动。现在时。\n\nweb3.0: 网站内的信息可以直接和其他网站相关信息进行交互，能通过第三方信息平台同时对多家网站的信息进行整合使用；用户在互联网上拥有自己的数据，并能在不同网站上使用；完全基于web，用浏览器即可实现复杂系统程序才能实现的系统功能;用户数据审计后，同步于网络数据。将来时。","slug":"blockchain","published":1,"updated":"2016-12-22T07:07:40.531Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv730015jgtuwq70a2xs","content":"<p>   最近听同学说区块链技术很火，各大银行及金融企业都在研究，我还以为是后端的技术了，听说前端也可以写，所以有了这篇文章，先记录下来然后后续再补充。<br>   区块链是新的热门技术。如果你没听说过它，你可能听说过比特币。区块链是比特币的底层技术。专家说区块链将会和因特网一样掀起一场革命。说到这里，我好期待啊，期待纸币走向灭亡，以后都用电子货币。</p>\n<p>   web技术的发展来源技术驱动力，blockchain技术发展了p2p网络的优点，成为w3c青睐的技术。<br>   至于区块链的技术就不写了，只是初步地了解，很多地方理解的不是很到位，以免误导别人。如果你想学习，可以自己查资料。</p>\n<p>web1.0:网络是信息的提供者，可以理解为单向信息，信息是只读的，缺少互动。过去时。</p>\n<p>web2.0:网络是一个平台，用户可以提供信息通过网络来与其他用户进行沟通，此时用户之间可以通过网络互动。现在时。</p>\n<p>web3.0: 网站内的信息可以直接和其他网站相关信息进行交互，能通过第三方信息平台同时对多家网站的信息进行整合使用；用户在互联网上拥有自己的数据，并能在不同网站上使用；完全基于web，用浏览器即可实现复杂系统程序才能实现的系统功能;用户数据审计后，同步于网络数据。将来时。</p>\n","excerpt":"","more":"<p>   最近听同学说区块链技术很火，各大银行及金融企业都在研究，我还以为是后端的技术了，听说前端也可以写，所以有了这篇文章，先记录下来然后后续再补充。<br>   区块链是新的热门技术。如果你没听说过它，你可能听说过比特币。区块链是比特币的底层技术。专家说区块链将会和因特网一样掀起一场革命。说到这里，我好期待啊，期待纸币走向灭亡，以后都用电子货币。</p>\n<p>   web技术的发展来源技术驱动力，blockchain技术发展了p2p网络的优点，成为w3c青睐的技术。<br>   至于区块链的技术就不写了，只是初步地了解，很多地方理解的不是很到位，以免误导别人。如果你想学习，可以自己查资料。</p>\n<p>web1.0:网络是信息的提供者，可以理解为单向信息，信息是只读的，缺少互动。过去时。</p>\n<p>web2.0:网络是一个平台，用户可以提供信息通过网络来与其他用户进行沟通，此时用户之间可以通过网络互动。现在时。</p>\n<p>web3.0: 网站内的信息可以直接和其他网站相关信息进行交互，能通过第三方信息平台同时对多家网站的信息进行整合使用；用户在互联网上拥有自己的数据，并能在不同网站上使用；完全基于web，用浏览器即可实现复杂系统程序才能实现的系统功能;用户数据审计后，同步于网络数据。将来时。</p>\n"},{"title":"致穷逼：不抱怨，就是干！！！","date":"2016-12-16T00:54:37.000Z","_content":"###  文：小日先生\n#### 我们身边有些人叫穷逼,穷逼，就是又穷又苦逼。\n\n　　如果你身边有一个穷逼，请毫无保留地蹂躏他，虐丫。穷逼，是不配给任何尊重和脸面的，而你如果真心想对身边的穷逼好，那请你一定要毫无保留地嘲讽他、欺压他、取笑他，甚至，侮辱他。\n　　写到这，很多人估计又圣母了，会说，靠妖，你怎么是这样的人，~呵呵呵呵呵呵呵呵~~~\n\n　　我身边有不少白手起家的人，更有不少因为陷入某些局倾家荡产最终却逆境跃起的人，他们的反弹能力，让我震惊。\n　　而如果你真的明白做人的道理，真的理解求生的意志，你不会原谅一个穷逼，任何人逼到绝境一定会努力，他不努力，是因为他没有走到绝境。\n　　所以，如果说有些人智商不高，那穷逼就是智商不高人里最低等的生物，注定被嘲笑。\n　　在我看来：穷逼是需要刺激的，只有锥心刺骨的侮辱，才是逼他们脱贫的动力。\n　　而在我眼中，一个穷逼能一直穷下去，其原因就只有一个：丫活的太苟且了。\n　　当一个人被称为穷逼，他一定就是那种世间最懒惰、最不思进取、最自私、最好逸恶劳的人。\n这样的人，是注定要被时代淘汰的。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/no1.png-public)\n</div>\n\n#### 永远不要相信穷逼的眼泪,他只是一时冲动而已\n\n　　我身边也有不少穷人，而我曾经也是穷得在学校没钱去澡堂，天天等宿舍哥们睡着去水房洗冷水澡的人，我也曾用泡面就米饭吃，认识我的人都知道我喜欢辣椒的原因在于用辣椒就馒头吃，在冬天，果腹又保暖，很多人都会惊讶我一个广东人为什么那么能吃辣。\n　　只有很熟悉我这十几年的朋友才知道我哪是能吃辣啊，而是没钱，所以，如果你没住过160元/月的地下室床位，没睡过3平方米只能放一张床的阳台改的宿舍，那你真不能算真正的北漂。\n穷，自然就会难过，穷逼一难过，会流眼泪。\n　　但穷逼的眼泪其实有两种：\n　　第一种是纯他妈发泄性的，就是到泪点了，丫就哭了。这是无意义的眼泪，不管当时他多难过，他觉得自己多没尊严，多愤愤不平，他哭完就算了，最后一切没任何改变。\n　　第二种是有意义的苏醒剂或肾上腺素，奋发性的。\n　　虽然屈辱和苦泪难咽，但他会发誓在有生之年，再也不要受这种屈辱，他的家人和子女，也同样不能受这种屈辱。\n　　我们身边充斥着这两类人。\n　　第一类人就是穷逼，你越帮他，越同情他，越在意他，只会浪费你的时间；而至于第二类人，你需要污蔑他、刺激他，才能激发他的可能。所以，遇见穷逼一定要羞辱它，一是为了分析他是哪类人，二是帮第二类人脱贫。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/no2.png-public)\n</div>\n\n#### 在我看来，穷是一种病,只是很多人以为是命\n\n　　我遇到很多人说自己命不好，包括埋怨自己的原生家庭，他们仿佛自己一点问题都没有，一切都怪父母，怪父母不是当官的，怪父母不是富一代，怪父母没有钱。\n　　但其实你知道吗？如果你研究过中国人口红利和中国社会民生发展规律，你父母那一代，60年代前后的人其实都需要用人生2/3的时间去解决生存问题，所以，你没饿死，你父母能供你读完大学，你能有衣服穿，你父母就很给你面子了。\n　　自己不行，莫怪父母。我们总擅长把问题归结于别人身上，但却不知问题出现在自身。所以，当人们把穷的根源归根于命时，这个人就注定是穷逼了。一旦身边出现这种不孝顺，抱怨父母，不懂感恩，不懂付出，只会抱怨的人，请远离他。\n　　请他滚出我们的朋友圈。因为，这就是我们常说的，垃圾人。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/no3.png-public)\n</div>\n\n#### 穷是一种病，得治,在我看来，穷逼脑残有三点\n\n1. 分不清“贫与穷”的关系。\n　　其实，贫穷贫穷，贫不等于穷，在我看来，贫是一个时间点的概念，而穷是一个时间段的概念。所以我们才有所谓的“劫富济贫”，为什么不说“劫富济穷”是因为，穷的改变是一个系统，和思维有关，和单一时间点的物质多少无关。\n\n2. 认为我穷我有理。\n　　这一点可以理解为“你弱你有理”的深级版，穷逼经常把时间浪费在吐槽社会不公平现象，却不会思考自己如何去接受社会，例如，抱怨头等舱可以先登机的人，他们不知道别人为舒适的买单；穷逼逻辑混乱，看不到别人的付出与收获，而把一切不顺心的事情都归根于社会制度。\n这导致一个结果，他们以为自己被时代抛弃，但其本质是他们首先抛弃了时代。\n\n3. 莫名其妙地仇富。\n　　穷逼有一个很明显的特点在于，任何有钱人他们都不屌，任何人有钱，一定是涉及到权钱交易，一定是涉及到潜规则，一定是涉及到非法生意，穷逼之所以称为穷逼的一个很重要原因在于拒绝学习。\n　　他们一叶蔽目，从不客观去看人家成功地途径。或许，他们压根不愿意、也不可能、更不主动从社会成功人士中学习到一丝半点商业技巧、资源头筹力和未来判断能力。如果说这些能力太大，太有难度，穷逼连最起码的自我管理能力都没有。\n　　很多穷逼你去可怜他，结果你发现他活得比你还随意，日子过得比你还悠闲。\n　　这样的人，你越关心，越操心。所以，我们要远离穷逼。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/no4.png-public)\n</div>\n\n#### 没有天生穷苦的人,只有不思进取的人\n\n　　我特别喜欢古文学的原因是古文把未来N年的道理都用最简单的字词总结完了。例如，温故知新，不耻下问，不思进取。绝大多数穷逼身上都有三个特点。\n\n- 第一点是投机：\n　　都以为上天掉馅饼，把一切希望寄托于横财、偏门和彩票，所以他们一边说自己命不好一边去博彩，这个逻辑就很可笑，你命不好还能中大奖，你是上帝炮友啊？\n\n- 第二点是懒惰：\n　　懒惰不是说你不做事情，而是你浅尝辄止，你压根没想用心好好做，你遇到一些困难就放弃，就后退，就改变策略，就无精打采，这些都是懒惰的体现。\n　　懒惰是自我管理出了问题。因为我们是人，人都有寻找舒适的本能，大家都希望什么都不做，衣来伸手饭来张口，所以，我们的忍耐力和扛击打能力，实在太差。\n\n- 第三点是自欺：\n　　自欺就是自我欺骗自己，不客观。自我感觉良好，其实屁都不是，很多穷逼其实内心并没有意识到自己真正的处境是怎样的，他们把一切问题都归根于社会福利、政府和国家，他们从来没有考虑，国家为什么需要你，你到底给国家做出什么贡献。\n\n#### 以上这些就是我认为的“珍爱生命，远离穷逼”的原因。\n- 穷不是命，而是一种过于狭隘自我的思维模式导致的结果。\n- 之所以远离穷逼是因为：你的时间真的很宝贵；\n- 远离他们，才能把时间放到更有意义的事上和更值得期待或合作的人身上；\n- 不要被穷逼狭隘的思想同化；\n- 不要让原本积极努力的自己成为喋喋不休随意吐槽的怨妇。\n\n　　观后感：首先我认为这篇文章写得挺好，有一定的道理，所以记录下来，与君共勉！当然你不能只看文字的表面，要理解出作者真正想要表达的意图与思想。这里不是歧视穷人怎么怎么着，毕竟每个人的思想都不一样，正是因为这样，才会有丰富多彩的世界，否则世界肯定是枯燥的。个人认为每个人的路自己走出来的，你唯一能做的就是别抱怨，去适应和接纳不完美的自己。明明知道这个社会很多潜规则，比如：公司领导手下两个小秘A和B，A和领导睡了职位提升了，B就别抱怨，有本事你也把领导睡了或者在某方面做地突出超越A，如果要做自己就干好自己的本职工作就好了，不抱怨不羡慕，因为这是你自己选择的路，这也是社会生存法则之一。之前我也抱怨过“握草，好白菜都被猪拱了”，其实是你没有想到猪的优点，虽然人家不帅，但是人家活好啊。谁说妹子都喜欢帅的？所以呢，努力做最好的自己很重要，友情提醒：做一个不抱怨、积极阳光的person,给别人带去正能量。","source":"_posts/bubaoyuan.md","raw":"---\ntitle: 致穷逼：不抱怨，就是干！！！\ndate: 2016-12-16 08:54:37\ntags: 生活\n---\n###  文：小日先生\n#### 我们身边有些人叫穷逼,穷逼，就是又穷又苦逼。\n\n　　如果你身边有一个穷逼，请毫无保留地蹂躏他，虐丫。穷逼，是不配给任何尊重和脸面的，而你如果真心想对身边的穷逼好，那请你一定要毫无保留地嘲讽他、欺压他、取笑他，甚至，侮辱他。\n　　写到这，很多人估计又圣母了，会说，靠妖，你怎么是这样的人，~呵呵呵呵呵呵呵呵~~~\n\n　　我身边有不少白手起家的人，更有不少因为陷入某些局倾家荡产最终却逆境跃起的人，他们的反弹能力，让我震惊。\n　　而如果你真的明白做人的道理，真的理解求生的意志，你不会原谅一个穷逼，任何人逼到绝境一定会努力，他不努力，是因为他没有走到绝境。\n　　所以，如果说有些人智商不高，那穷逼就是智商不高人里最低等的生物，注定被嘲笑。\n　　在我看来：穷逼是需要刺激的，只有锥心刺骨的侮辱，才是逼他们脱贫的动力。\n　　而在我眼中，一个穷逼能一直穷下去，其原因就只有一个：丫活的太苟且了。\n　　当一个人被称为穷逼，他一定就是那种世间最懒惰、最不思进取、最自私、最好逸恶劳的人。\n这样的人，是注定要被时代淘汰的。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/no1.png-public)\n</div>\n\n#### 永远不要相信穷逼的眼泪,他只是一时冲动而已\n\n　　我身边也有不少穷人，而我曾经也是穷得在学校没钱去澡堂，天天等宿舍哥们睡着去水房洗冷水澡的人，我也曾用泡面就米饭吃，认识我的人都知道我喜欢辣椒的原因在于用辣椒就馒头吃，在冬天，果腹又保暖，很多人都会惊讶我一个广东人为什么那么能吃辣。\n　　只有很熟悉我这十几年的朋友才知道我哪是能吃辣啊，而是没钱，所以，如果你没住过160元/月的地下室床位，没睡过3平方米只能放一张床的阳台改的宿舍，那你真不能算真正的北漂。\n穷，自然就会难过，穷逼一难过，会流眼泪。\n　　但穷逼的眼泪其实有两种：\n　　第一种是纯他妈发泄性的，就是到泪点了，丫就哭了。这是无意义的眼泪，不管当时他多难过，他觉得自己多没尊严，多愤愤不平，他哭完就算了，最后一切没任何改变。\n　　第二种是有意义的苏醒剂或肾上腺素，奋发性的。\n　　虽然屈辱和苦泪难咽，但他会发誓在有生之年，再也不要受这种屈辱，他的家人和子女，也同样不能受这种屈辱。\n　　我们身边充斥着这两类人。\n　　第一类人就是穷逼，你越帮他，越同情他，越在意他，只会浪费你的时间；而至于第二类人，你需要污蔑他、刺激他，才能激发他的可能。所以，遇见穷逼一定要羞辱它，一是为了分析他是哪类人，二是帮第二类人脱贫。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/no2.png-public)\n</div>\n\n#### 在我看来，穷是一种病,只是很多人以为是命\n\n　　我遇到很多人说自己命不好，包括埋怨自己的原生家庭，他们仿佛自己一点问题都没有，一切都怪父母，怪父母不是当官的，怪父母不是富一代，怪父母没有钱。\n　　但其实你知道吗？如果你研究过中国人口红利和中国社会民生发展规律，你父母那一代，60年代前后的人其实都需要用人生2/3的时间去解决生存问题，所以，你没饿死，你父母能供你读完大学，你能有衣服穿，你父母就很给你面子了。\n　　自己不行，莫怪父母。我们总擅长把问题归结于别人身上，但却不知问题出现在自身。所以，当人们把穷的根源归根于命时，这个人就注定是穷逼了。一旦身边出现这种不孝顺，抱怨父母，不懂感恩，不懂付出，只会抱怨的人，请远离他。\n　　请他滚出我们的朋友圈。因为，这就是我们常说的，垃圾人。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/no3.png-public)\n</div>\n\n#### 穷是一种病，得治,在我看来，穷逼脑残有三点\n\n1. 分不清“贫与穷”的关系。\n　　其实，贫穷贫穷，贫不等于穷，在我看来，贫是一个时间点的概念，而穷是一个时间段的概念。所以我们才有所谓的“劫富济贫”，为什么不说“劫富济穷”是因为，穷的改变是一个系统，和思维有关，和单一时间点的物质多少无关。\n\n2. 认为我穷我有理。\n　　这一点可以理解为“你弱你有理”的深级版，穷逼经常把时间浪费在吐槽社会不公平现象，却不会思考自己如何去接受社会，例如，抱怨头等舱可以先登机的人，他们不知道别人为舒适的买单；穷逼逻辑混乱，看不到别人的付出与收获，而把一切不顺心的事情都归根于社会制度。\n这导致一个结果，他们以为自己被时代抛弃，但其本质是他们首先抛弃了时代。\n\n3. 莫名其妙地仇富。\n　　穷逼有一个很明显的特点在于，任何有钱人他们都不屌，任何人有钱，一定是涉及到权钱交易，一定是涉及到潜规则，一定是涉及到非法生意，穷逼之所以称为穷逼的一个很重要原因在于拒绝学习。\n　　他们一叶蔽目，从不客观去看人家成功地途径。或许，他们压根不愿意、也不可能、更不主动从社会成功人士中学习到一丝半点商业技巧、资源头筹力和未来判断能力。如果说这些能力太大，太有难度，穷逼连最起码的自我管理能力都没有。\n　　很多穷逼你去可怜他，结果你发现他活得比你还随意，日子过得比你还悠闲。\n　　这样的人，你越关心，越操心。所以，我们要远离穷逼。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/no4.png-public)\n</div>\n\n#### 没有天生穷苦的人,只有不思进取的人\n\n　　我特别喜欢古文学的原因是古文把未来N年的道理都用最简单的字词总结完了。例如，温故知新，不耻下问，不思进取。绝大多数穷逼身上都有三个特点。\n\n- 第一点是投机：\n　　都以为上天掉馅饼，把一切希望寄托于横财、偏门和彩票，所以他们一边说自己命不好一边去博彩，这个逻辑就很可笑，你命不好还能中大奖，你是上帝炮友啊？\n\n- 第二点是懒惰：\n　　懒惰不是说你不做事情，而是你浅尝辄止，你压根没想用心好好做，你遇到一些困难就放弃，就后退，就改变策略，就无精打采，这些都是懒惰的体现。\n　　懒惰是自我管理出了问题。因为我们是人，人都有寻找舒适的本能，大家都希望什么都不做，衣来伸手饭来张口，所以，我们的忍耐力和扛击打能力，实在太差。\n\n- 第三点是自欺：\n　　自欺就是自我欺骗自己，不客观。自我感觉良好，其实屁都不是，很多穷逼其实内心并没有意识到自己真正的处境是怎样的，他们把一切问题都归根于社会福利、政府和国家，他们从来没有考虑，国家为什么需要你，你到底给国家做出什么贡献。\n\n#### 以上这些就是我认为的“珍爱生命，远离穷逼”的原因。\n- 穷不是命，而是一种过于狭隘自我的思维模式导致的结果。\n- 之所以远离穷逼是因为：你的时间真的很宝贵；\n- 远离他们，才能把时间放到更有意义的事上和更值得期待或合作的人身上；\n- 不要被穷逼狭隘的思想同化；\n- 不要让原本积极努力的自己成为喋喋不休随意吐槽的怨妇。\n\n　　观后感：首先我认为这篇文章写得挺好，有一定的道理，所以记录下来，与君共勉！当然你不能只看文字的表面，要理解出作者真正想要表达的意图与思想。这里不是歧视穷人怎么怎么着，毕竟每个人的思想都不一样，正是因为这样，才会有丰富多彩的世界，否则世界肯定是枯燥的。个人认为每个人的路自己走出来的，你唯一能做的就是别抱怨，去适应和接纳不完美的自己。明明知道这个社会很多潜规则，比如：公司领导手下两个小秘A和B，A和领导睡了职位提升了，B就别抱怨，有本事你也把领导睡了或者在某方面做地突出超越A，如果要做自己就干好自己的本职工作就好了，不抱怨不羡慕，因为这是你自己选择的路，这也是社会生存法则之一。之前我也抱怨过“握草，好白菜都被猪拱了”，其实是你没有想到猪的优点，虽然人家不帅，但是人家活好啊。谁说妹子都喜欢帅的？所以呢，努力做最好的自己很重要，友情提醒：做一个不抱怨、积极阳光的person,给别人带去正能量。","slug":"bubaoyuan","published":1,"updated":"2017-01-10T08:23:26.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv760018jgtuz9lk9vwh","content":"<h3 id=\"文：小日先生\"><a href=\"#文：小日先生\" class=\"headerlink\" title=\"文：小日先生\"></a>文：小日先生</h3><h4 id=\"我们身边有些人叫穷逼-穷逼，就是又穷又苦逼。\"><a href=\"#我们身边有些人叫穷逼-穷逼，就是又穷又苦逼。\" class=\"headerlink\" title=\"我们身边有些人叫穷逼,穷逼，就是又穷又苦逼。\"></a>我们身边有些人叫穷逼,穷逼，就是又穷又苦逼。</h4><p>　　如果你身边有一个穷逼，请毫无保留地蹂躏他，虐丫。穷逼，是不配给任何尊重和脸面的，而你如果真心想对身边的穷逼好，那请你一定要毫无保留地嘲讽他、欺压他、取笑他，甚至，侮辱他。<br>　　写到这，很多人估计又圣母了，会说，靠妖，你怎么是这样的人，~呵呵呵呵呵呵呵呵~~~</p>\n<p>　　我身边有不少白手起家的人，更有不少因为陷入某些局倾家荡产最终却逆境跃起的人，他们的反弹能力，让我震惊。<br>　　而如果你真的明白做人的道理，真的理解求生的意志，你不会原谅一个穷逼，任何人逼到绝境一定会努力，他不努力，是因为他没有走到绝境。<br>　　所以，如果说有些人智商不高，那穷逼就是智商不高人里最低等的生物，注定被嘲笑。<br>　　在我看来：穷逼是需要刺激的，只有锥心刺骨的侮辱，才是逼他们脱贫的动力。<br>　　而在我眼中，一个穷逼能一直穷下去，其原因就只有一个：丫活的太苟且了。<br>　　当一个人被称为穷逼，他一定就是那种世间最懒惰、最不思进取、最自私、最好逸恶劳的人。<br>这样的人，是注定要被时代淘汰的。</p>\n<div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/no1.png-public\" alt=\"\"><br></div>\n\n<h4 id=\"永远不要相信穷逼的眼泪-他只是一时冲动而已\"><a href=\"#永远不要相信穷逼的眼泪-他只是一时冲动而已\" class=\"headerlink\" title=\"永远不要相信穷逼的眼泪,他只是一时冲动而已\"></a>永远不要相信穷逼的眼泪,他只是一时冲动而已</h4><p>　　我身边也有不少穷人，而我曾经也是穷得在学校没钱去澡堂，天天等宿舍哥们睡着去水房洗冷水澡的人，我也曾用泡面就米饭吃，认识我的人都知道我喜欢辣椒的原因在于用辣椒就馒头吃，在冬天，果腹又保暖，很多人都会惊讶我一个广东人为什么那么能吃辣。<br>　　只有很熟悉我这十几年的朋友才知道我哪是能吃辣啊，而是没钱，所以，如果你没住过160元/月的地下室床位，没睡过3平方米只能放一张床的阳台改的宿舍，那你真不能算真正的北漂。<br>穷，自然就会难过，穷逼一难过，会流眼泪。<br>　　但穷逼的眼泪其实有两种：<br>　　第一种是纯他妈发泄性的，就是到泪点了，丫就哭了。这是无意义的眼泪，不管当时他多难过，他觉得自己多没尊严，多愤愤不平，他哭完就算了，最后一切没任何改变。<br>　　第二种是有意义的苏醒剂或肾上腺素，奋发性的。<br>　　虽然屈辱和苦泪难咽，但他会发誓在有生之年，再也不要受这种屈辱，他的家人和子女，也同样不能受这种屈辱。<br>　　我们身边充斥着这两类人。<br>　　第一类人就是穷逼，你越帮他，越同情他，越在意他，只会浪费你的时间；而至于第二类人，你需要污蔑他、刺激他，才能激发他的可能。所以，遇见穷逼一定要羞辱它，一是为了分析他是哪类人，二是帮第二类人脱贫。</p>\n<div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/no2.png-public\" alt=\"\"><br></div>\n\n<h4 id=\"在我看来，穷是一种病-只是很多人以为是命\"><a href=\"#在我看来，穷是一种病-只是很多人以为是命\" class=\"headerlink\" title=\"在我看来，穷是一种病,只是很多人以为是命\"></a>在我看来，穷是一种病,只是很多人以为是命</h4><p>　　我遇到很多人说自己命不好，包括埋怨自己的原生家庭，他们仿佛自己一点问题都没有，一切都怪父母，怪父母不是当官的，怪父母不是富一代，怪父母没有钱。<br>　　但其实你知道吗？如果你研究过中国人口红利和中国社会民生发展规律，你父母那一代，60年代前后的人其实都需要用人生2/3的时间去解决生存问题，所以，你没饿死，你父母能供你读完大学，你能有衣服穿，你父母就很给你面子了。<br>　　自己不行，莫怪父母。我们总擅长把问题归结于别人身上，但却不知问题出现在自身。所以，当人们把穷的根源归根于命时，这个人就注定是穷逼了。一旦身边出现这种不孝顺，抱怨父母，不懂感恩，不懂付出，只会抱怨的人，请远离他。<br>　　请他滚出我们的朋友圈。因为，这就是我们常说的，垃圾人。</p>\n<div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/no3.png-public\" alt=\"\"><br></div>\n\n<h4 id=\"穷是一种病，得治-在我看来，穷逼脑残有三点\"><a href=\"#穷是一种病，得治-在我看来，穷逼脑残有三点\" class=\"headerlink\" title=\"穷是一种病，得治,在我看来，穷逼脑残有三点\"></a>穷是一种病，得治,在我看来，穷逼脑残有三点</h4><ol>\n<li><p>分不清“贫与穷”的关系。<br>　　其实，贫穷贫穷，贫不等于穷，在我看来，贫是一个时间点的概念，而穷是一个时间段的概念。所以我们才有所谓的“劫富济贫”，为什么不说“劫富济穷”是因为，穷的改变是一个系统，和思维有关，和单一时间点的物质多少无关。</p>\n</li>\n<li><p>认为我穷我有理。<br>　　这一点可以理解为“你弱你有理”的深级版，穷逼经常把时间浪费在吐槽社会不公平现象，却不会思考自己如何去接受社会，例如，抱怨头等舱可以先登机的人，他们不知道别人为舒适的买单；穷逼逻辑混乱，看不到别人的付出与收获，而把一切不顺心的事情都归根于社会制度。<br>这导致一个结果，他们以为自己被时代抛弃，但其本质是他们首先抛弃了时代。</p>\n</li>\n<li><p>莫名其妙地仇富。<br>　　穷逼有一个很明显的特点在于，任何有钱人他们都不屌，任何人有钱，一定是涉及到权钱交易，一定是涉及到潜规则，一定是涉及到非法生意，穷逼之所以称为穷逼的一个很重要原因在于拒绝学习。<br>　　他们一叶蔽目，从不客观去看人家成功地途径。或许，他们压根不愿意、也不可能、更不主动从社会成功人士中学习到一丝半点商业技巧、资源头筹力和未来判断能力。如果说这些能力太大，太有难度，穷逼连最起码的自我管理能力都没有。<br>　　很多穷逼你去可怜他，结果你发现他活得比你还随意，日子过得比你还悠闲。<br>　　这样的人，你越关心，越操心。所以，我们要远离穷逼。</p>\n<div align=\"center\"><br> <img src=\"http://oi28tswuq.bkt.clouddn.com/images/no4.png-public\" alt=\"\"><br></div>\n\n</li>\n</ol>\n<h4 id=\"没有天生穷苦的人-只有不思进取的人\"><a href=\"#没有天生穷苦的人-只有不思进取的人\" class=\"headerlink\" title=\"没有天生穷苦的人,只有不思进取的人\"></a>没有天生穷苦的人,只有不思进取的人</h4><p>　　我特别喜欢古文学的原因是古文把未来N年的道理都用最简单的字词总结完了。例如，温故知新，不耻下问，不思进取。绝大多数穷逼身上都有三个特点。</p>\n<ul>\n<li><p>第一点是投机：<br>　　都以为上天掉馅饼，把一切希望寄托于横财、偏门和彩票，所以他们一边说自己命不好一边去博彩，这个逻辑就很可笑，你命不好还能中大奖，你是上帝炮友啊？</p>\n</li>\n<li><p>第二点是懒惰：<br>　　懒惰不是说你不做事情，而是你浅尝辄止，你压根没想用心好好做，你遇到一些困难就放弃，就后退，就改变策略，就无精打采，这些都是懒惰的体现。<br>　　懒惰是自我管理出了问题。因为我们是人，人都有寻找舒适的本能，大家都希望什么都不做，衣来伸手饭来张口，所以，我们的忍耐力和扛击打能力，实在太差。</p>\n</li>\n<li><p>第三点是自欺：<br>　　自欺就是自我欺骗自己，不客观。自我感觉良好，其实屁都不是，很多穷逼其实内心并没有意识到自己真正的处境是怎样的，他们把一切问题都归根于社会福利、政府和国家，他们从来没有考虑，国家为什么需要你，你到底给国家做出什么贡献。</p>\n</li>\n</ul>\n<h4 id=\"以上这些就是我认为的“珍爱生命，远离穷逼”的原因。\"><a href=\"#以上这些就是我认为的“珍爱生命，远离穷逼”的原因。\" class=\"headerlink\" title=\"以上这些就是我认为的“珍爱生命，远离穷逼”的原因。\"></a>以上这些就是我认为的“珍爱生命，远离穷逼”的原因。</h4><ul>\n<li>穷不是命，而是一种过于狭隘自我的思维模式导致的结果。</li>\n<li>之所以远离穷逼是因为：你的时间真的很宝贵；</li>\n<li>远离他们，才能把时间放到更有意义的事上和更值得期待或合作的人身上；</li>\n<li>不要被穷逼狭隘的思想同化；</li>\n<li>不要让原本积极努力的自己成为喋喋不休随意吐槽的怨妇。</li>\n</ul>\n<p>　　观后感：首先我认为这篇文章写得挺好，有一定的道理，所以记录下来，与君共勉！当然你不能只看文字的表面，要理解出作者真正想要表达的意图与思想。这里不是歧视穷人怎么怎么着，毕竟每个人的思想都不一样，正是因为这样，才会有丰富多彩的世界，否则世界肯定是枯燥的。个人认为每个人的路自己走出来的，你唯一能做的就是别抱怨，去适应和接纳不完美的自己。明明知道这个社会很多潜规则，比如：公司领导手下两个小秘A和B，A和领导睡了职位提升了，B就别抱怨，有本事你也把领导睡了或者在某方面做地突出超越A，如果要做自己就干好自己的本职工作就好了，不抱怨不羡慕，因为这是你自己选择的路，这也是社会生存法则之一。之前我也抱怨过“握草，好白菜都被猪拱了”，其实是你没有想到猪的优点，虽然人家不帅，但是人家活好啊。谁说妹子都喜欢帅的？所以呢，努力做最好的自己很重要，友情提醒：做一个不抱怨、积极阳光的person,给别人带去正能量。</p>\n","excerpt":"","more":"<h3 id=\"文：小日先生\"><a href=\"#文：小日先生\" class=\"headerlink\" title=\"文：小日先生\"></a>文：小日先生</h3><h4 id=\"我们身边有些人叫穷逼-穷逼，就是又穷又苦逼。\"><a href=\"#我们身边有些人叫穷逼-穷逼，就是又穷又苦逼。\" class=\"headerlink\" title=\"我们身边有些人叫穷逼,穷逼，就是又穷又苦逼。\"></a>我们身边有些人叫穷逼,穷逼，就是又穷又苦逼。</h4><p>　　如果你身边有一个穷逼，请毫无保留地蹂躏他，虐丫。穷逼，是不配给任何尊重和脸面的，而你如果真心想对身边的穷逼好，那请你一定要毫无保留地嘲讽他、欺压他、取笑他，甚至，侮辱他。<br>　　写到这，很多人估计又圣母了，会说，靠妖，你怎么是这样的人，~呵呵呵呵呵呵呵呵~~~</p>\n<p>　　我身边有不少白手起家的人，更有不少因为陷入某些局倾家荡产最终却逆境跃起的人，他们的反弹能力，让我震惊。<br>　　而如果你真的明白做人的道理，真的理解求生的意志，你不会原谅一个穷逼，任何人逼到绝境一定会努力，他不努力，是因为他没有走到绝境。<br>　　所以，如果说有些人智商不高，那穷逼就是智商不高人里最低等的生物，注定被嘲笑。<br>　　在我看来：穷逼是需要刺激的，只有锥心刺骨的侮辱，才是逼他们脱贫的动力。<br>　　而在我眼中，一个穷逼能一直穷下去，其原因就只有一个：丫活的太苟且了。<br>　　当一个人被称为穷逼，他一定就是那种世间最懒惰、最不思进取、最自私、最好逸恶劳的人。<br>这样的人，是注定要被时代淘汰的。</p>\n<div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/no1.png-public\" alt=\"\"><br></div>\n\n<h4 id=\"永远不要相信穷逼的眼泪-他只是一时冲动而已\"><a href=\"#永远不要相信穷逼的眼泪-他只是一时冲动而已\" class=\"headerlink\" title=\"永远不要相信穷逼的眼泪,他只是一时冲动而已\"></a>永远不要相信穷逼的眼泪,他只是一时冲动而已</h4><p>　　我身边也有不少穷人，而我曾经也是穷得在学校没钱去澡堂，天天等宿舍哥们睡着去水房洗冷水澡的人，我也曾用泡面就米饭吃，认识我的人都知道我喜欢辣椒的原因在于用辣椒就馒头吃，在冬天，果腹又保暖，很多人都会惊讶我一个广东人为什么那么能吃辣。<br>　　只有很熟悉我这十几年的朋友才知道我哪是能吃辣啊，而是没钱，所以，如果你没住过160元/月的地下室床位，没睡过3平方米只能放一张床的阳台改的宿舍，那你真不能算真正的北漂。<br>穷，自然就会难过，穷逼一难过，会流眼泪。<br>　　但穷逼的眼泪其实有两种：<br>　　第一种是纯他妈发泄性的，就是到泪点了，丫就哭了。这是无意义的眼泪，不管当时他多难过，他觉得自己多没尊严，多愤愤不平，他哭完就算了，最后一切没任何改变。<br>　　第二种是有意义的苏醒剂或肾上腺素，奋发性的。<br>　　虽然屈辱和苦泪难咽，但他会发誓在有生之年，再也不要受这种屈辱，他的家人和子女，也同样不能受这种屈辱。<br>　　我们身边充斥着这两类人。<br>　　第一类人就是穷逼，你越帮他，越同情他，越在意他，只会浪费你的时间；而至于第二类人，你需要污蔑他、刺激他，才能激发他的可能。所以，遇见穷逼一定要羞辱它，一是为了分析他是哪类人，二是帮第二类人脱贫。</p>\n<div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/no2.png-public\" alt=\"\"><br></div>\n\n<h4 id=\"在我看来，穷是一种病-只是很多人以为是命\"><a href=\"#在我看来，穷是一种病-只是很多人以为是命\" class=\"headerlink\" title=\"在我看来，穷是一种病,只是很多人以为是命\"></a>在我看来，穷是一种病,只是很多人以为是命</h4><p>　　我遇到很多人说自己命不好，包括埋怨自己的原生家庭，他们仿佛自己一点问题都没有，一切都怪父母，怪父母不是当官的，怪父母不是富一代，怪父母没有钱。<br>　　但其实你知道吗？如果你研究过中国人口红利和中国社会民生发展规律，你父母那一代，60年代前后的人其实都需要用人生2/3的时间去解决生存问题，所以，你没饿死，你父母能供你读完大学，你能有衣服穿，你父母就很给你面子了。<br>　　自己不行，莫怪父母。我们总擅长把问题归结于别人身上，但却不知问题出现在自身。所以，当人们把穷的根源归根于命时，这个人就注定是穷逼了。一旦身边出现这种不孝顺，抱怨父母，不懂感恩，不懂付出，只会抱怨的人，请远离他。<br>　　请他滚出我们的朋友圈。因为，这就是我们常说的，垃圾人。</p>\n<div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/no3.png-public\" alt=\"\"><br></div>\n\n<h4 id=\"穷是一种病，得治-在我看来，穷逼脑残有三点\"><a href=\"#穷是一种病，得治-在我看来，穷逼脑残有三点\" class=\"headerlink\" title=\"穷是一种病，得治,在我看来，穷逼脑残有三点\"></a>穷是一种病，得治,在我看来，穷逼脑残有三点</h4><ol>\n<li><p>分不清“贫与穷”的关系。<br>　　其实，贫穷贫穷，贫不等于穷，在我看来，贫是一个时间点的概念，而穷是一个时间段的概念。所以我们才有所谓的“劫富济贫”，为什么不说“劫富济穷”是因为，穷的改变是一个系统，和思维有关，和单一时间点的物质多少无关。</p>\n</li>\n<li><p>认为我穷我有理。<br>　　这一点可以理解为“你弱你有理”的深级版，穷逼经常把时间浪费在吐槽社会不公平现象，却不会思考自己如何去接受社会，例如，抱怨头等舱可以先登机的人，他们不知道别人为舒适的买单；穷逼逻辑混乱，看不到别人的付出与收获，而把一切不顺心的事情都归根于社会制度。<br>这导致一个结果，他们以为自己被时代抛弃，但其本质是他们首先抛弃了时代。</p>\n</li>\n<li><p>莫名其妙地仇富。<br>　　穷逼有一个很明显的特点在于，任何有钱人他们都不屌，任何人有钱，一定是涉及到权钱交易，一定是涉及到潜规则，一定是涉及到非法生意，穷逼之所以称为穷逼的一个很重要原因在于拒绝学习。<br>　　他们一叶蔽目，从不客观去看人家成功地途径。或许，他们压根不愿意、也不可能、更不主动从社会成功人士中学习到一丝半点商业技巧、资源头筹力和未来判断能力。如果说这些能力太大，太有难度，穷逼连最起码的自我管理能力都没有。<br>　　很多穷逼你去可怜他，结果你发现他活得比你还随意，日子过得比你还悠闲。<br>　　这样的人，你越关心，越操心。所以，我们要远离穷逼。</p>\n<div align=center><br> <img src=\"http://oi28tswuq.bkt.clouddn.com/images/no4.png-public\" alt=\"\"><br></div>\n\n</li>\n</ol>\n<h4 id=\"没有天生穷苦的人-只有不思进取的人\"><a href=\"#没有天生穷苦的人-只有不思进取的人\" class=\"headerlink\" title=\"没有天生穷苦的人,只有不思进取的人\"></a>没有天生穷苦的人,只有不思进取的人</h4><p>　　我特别喜欢古文学的原因是古文把未来N年的道理都用最简单的字词总结完了。例如，温故知新，不耻下问，不思进取。绝大多数穷逼身上都有三个特点。</p>\n<ul>\n<li><p>第一点是投机：<br>　　都以为上天掉馅饼，把一切希望寄托于横财、偏门和彩票，所以他们一边说自己命不好一边去博彩，这个逻辑就很可笑，你命不好还能中大奖，你是上帝炮友啊？</p>\n</li>\n<li><p>第二点是懒惰：<br>　　懒惰不是说你不做事情，而是你浅尝辄止，你压根没想用心好好做，你遇到一些困难就放弃，就后退，就改变策略，就无精打采，这些都是懒惰的体现。<br>　　懒惰是自我管理出了问题。因为我们是人，人都有寻找舒适的本能，大家都希望什么都不做，衣来伸手饭来张口，所以，我们的忍耐力和扛击打能力，实在太差。</p>\n</li>\n<li><p>第三点是自欺：<br>　　自欺就是自我欺骗自己，不客观。自我感觉良好，其实屁都不是，很多穷逼其实内心并没有意识到自己真正的处境是怎样的，他们把一切问题都归根于社会福利、政府和国家，他们从来没有考虑，国家为什么需要你，你到底给国家做出什么贡献。</p>\n</li>\n</ul>\n<h4 id=\"以上这些就是我认为的“珍爱生命，远离穷逼”的原因。\"><a href=\"#以上这些就是我认为的“珍爱生命，远离穷逼”的原因。\" class=\"headerlink\" title=\"以上这些就是我认为的“珍爱生命，远离穷逼”的原因。\"></a>以上这些就是我认为的“珍爱生命，远离穷逼”的原因。</h4><ul>\n<li>穷不是命，而是一种过于狭隘自我的思维模式导致的结果。</li>\n<li>之所以远离穷逼是因为：你的时间真的很宝贵；</li>\n<li>远离他们，才能把时间放到更有意义的事上和更值得期待或合作的人身上；</li>\n<li>不要被穷逼狭隘的思想同化；</li>\n<li>不要让原本积极努力的自己成为喋喋不休随意吐槽的怨妇。</li>\n</ul>\n<p>　　观后感：首先我认为这篇文章写得挺好，有一定的道理，所以记录下来，与君共勉！当然你不能只看文字的表面，要理解出作者真正想要表达的意图与思想。这里不是歧视穷人怎么怎么着，毕竟每个人的思想都不一样，正是因为这样，才会有丰富多彩的世界，否则世界肯定是枯燥的。个人认为每个人的路自己走出来的，你唯一能做的就是别抱怨，去适应和接纳不完美的自己。明明知道这个社会很多潜规则，比如：公司领导手下两个小秘A和B，A和领导睡了职位提升了，B就别抱怨，有本事你也把领导睡了或者在某方面做地突出超越A，如果要做自己就干好自己的本职工作就好了，不抱怨不羡慕，因为这是你自己选择的路，这也是社会生存法则之一。之前我也抱怨过“握草，好白菜都被猪拱了”，其实是你没有想到猪的优点，虽然人家不帅，但是人家活好啊。谁说妹子都喜欢帅的？所以呢，努力做最好的自己很重要，友情提醒：做一个不抱怨、积极阳光的person,给别人带去正能量。</p>\n"},{"title":"跨平台APP的构建方式","date":"2016-12-13T05:17:45.000Z","_content":"　　“一次构建，多处运行”，跨平台APP带着这股风潮把火烧到了前端，为开发者带来无尽的遐想。现有的流行跨平台框架有以下:\n\n### 1. 基于单WebView的开发框架。\n　　开发者可以使用现有的最新web技术，开发出单页面web应用。同时利用JSBridge，又能获取原生的API，从而使web应用具有了原生应用的功能。Cordova+IONIC可以说是这个潮流的代表，也是跨平台APP的先锋。然而这类跨平台应用的缺点是不流畅，在安卓手机上体验较差。\n\n### 2. Hybrid方向。\n　　也就是原生应用配合HTML5技术，让APP具有了部分跨平台的功能。Hybrid也是现在各大互联网企业采用较多的跨平台开发方式。这类APP在体验上优于单WebView的APP，并且能够极大提高开发效率。然而这种方式离“一次构建，多处运行”的设想还是有很大距离，毕竟依然需要针对不同的移动平台进行原生开发。\n\n### 3. 使用Javascript开发纯原生应用。\n　　既然单WebView性能有缺憾，Hybrid技术栈又比较高，那么Javascript开发纯原生应用就孕育而生。这个方向的代表有[ReactNative](https://facebook.github.io/react-native/), [Weex](http://alibaba.github.io/weex/)和[Nativescript](https://www.nativescript.org/)。\n\n　　和ReactNative相比，Nativescript最大的特点是可以获得100%的原生API。也就是说，开发者可以通过Javascript获取和原生开发语言同样多的原生接口。通过例子可以体会到“获取所有原生API”带来的巨大好处。NativeScript是一款使用JavaScript语言来构建跨平台原生移动应用的开源框架，支持iOS、Android和Windows Phone。\n　　使用Nativescript和Angular2可以很高效地构建跨平台APP！！！\n    NativeScript一个缺点：无法与原生项目融合，即你只能纯写个NativeScript的应用，不可能把它抽离出来作为某原生应用的一部分来出现。\n\n","source":"_posts/cross-app.md","raw":"---\ntitle: 跨平台APP的构建方式\ndate: 2016-12-13 13:17:45\ntags: app,跨平台\n---\n　　“一次构建，多处运行”，跨平台APP带着这股风潮把火烧到了前端，为开发者带来无尽的遐想。现有的流行跨平台框架有以下:\n\n### 1. 基于单WebView的开发框架。\n　　开发者可以使用现有的最新web技术，开发出单页面web应用。同时利用JSBridge，又能获取原生的API，从而使web应用具有了原生应用的功能。Cordova+IONIC可以说是这个潮流的代表，也是跨平台APP的先锋。然而这类跨平台应用的缺点是不流畅，在安卓手机上体验较差。\n\n### 2. Hybrid方向。\n　　也就是原生应用配合HTML5技术，让APP具有了部分跨平台的功能。Hybrid也是现在各大互联网企业采用较多的跨平台开发方式。这类APP在体验上优于单WebView的APP，并且能够极大提高开发效率。然而这种方式离“一次构建，多处运行”的设想还是有很大距离，毕竟依然需要针对不同的移动平台进行原生开发。\n\n### 3. 使用Javascript开发纯原生应用。\n　　既然单WebView性能有缺憾，Hybrid技术栈又比较高，那么Javascript开发纯原生应用就孕育而生。这个方向的代表有[ReactNative](https://facebook.github.io/react-native/), [Weex](http://alibaba.github.io/weex/)和[Nativescript](https://www.nativescript.org/)。\n\n　　和ReactNative相比，Nativescript最大的特点是可以获得100%的原生API。也就是说，开发者可以通过Javascript获取和原生开发语言同样多的原生接口。通过例子可以体会到“获取所有原生API”带来的巨大好处。NativeScript是一款使用JavaScript语言来构建跨平台原生移动应用的开源框架，支持iOS、Android和Windows Phone。\n　　使用Nativescript和Angular2可以很高效地构建跨平台APP！！！\n    NativeScript一个缺点：无法与原生项目融合，即你只能纯写个NativeScript的应用，不可能把它抽离出来作为某原生应用的一部分来出现。\n\n","slug":"cross-app","published":1,"updated":"2016-12-13T06:46:02.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv780019jgtu2g3j6xpi","content":"<p>　　“一次构建，多处运行”，跨平台APP带着这股风潮把火烧到了前端，为开发者带来无尽的遐想。现有的流行跨平台框架有以下:</p>\n<h3 id=\"1-基于单WebView的开发框架。\"><a href=\"#1-基于单WebView的开发框架。\" class=\"headerlink\" title=\"1. 基于单WebView的开发框架。\"></a>1. 基于单WebView的开发框架。</h3><p>　　开发者可以使用现有的最新web技术，开发出单页面web应用。同时利用JSBridge，又能获取原生的API，从而使web应用具有了原生应用的功能。Cordova+IONIC可以说是这个潮流的代表，也是跨平台APP的先锋。然而这类跨平台应用的缺点是不流畅，在安卓手机上体验较差。</p>\n<h3 id=\"2-Hybrid方向。\"><a href=\"#2-Hybrid方向。\" class=\"headerlink\" title=\"2. Hybrid方向。\"></a>2. Hybrid方向。</h3><p>　　也就是原生应用配合HTML5技术，让APP具有了部分跨平台的功能。Hybrid也是现在各大互联网企业采用较多的跨平台开发方式。这类APP在体验上优于单WebView的APP，并且能够极大提高开发效率。然而这种方式离“一次构建，多处运行”的设想还是有很大距离，毕竟依然需要针对不同的移动平台进行原生开发。</p>\n<h3 id=\"3-使用Javascript开发纯原生应用。\"><a href=\"#3-使用Javascript开发纯原生应用。\" class=\"headerlink\" title=\"3. 使用Javascript开发纯原生应用。\"></a>3. 使用Javascript开发纯原生应用。</h3><p>　　既然单WebView性能有缺憾，Hybrid技术栈又比较高，那么Javascript开发纯原生应用就孕育而生。这个方向的代表有<a href=\"https://facebook.github.io/react-native/\" target=\"_blank\" rel=\"external\">ReactNative</a>, <a href=\"http://alibaba.github.io/weex/\" target=\"_blank\" rel=\"external\">Weex</a>和<a href=\"https://www.nativescript.org/\" target=\"_blank\" rel=\"external\">Nativescript</a>。</p>\n<p>　　和ReactNative相比，Nativescript最大的特点是可以获得100%的原生API。也就是说，开发者可以通过Javascript获取和原生开发语言同样多的原生接口。通过例子可以体会到“获取所有原生API”带来的巨大好处。NativeScript是一款使用JavaScript语言来构建跨平台原生移动应用的开源框架，支持iOS、Android和Windows Phone。<br>　　使用Nativescript和Angular2可以很高效地构建跨平台APP！！！<br>    NativeScript一个缺点：无法与原生项目融合，即你只能纯写个NativeScript的应用，不可能把它抽离出来作为某原生应用的一部分来出现。</p>\n","excerpt":"","more":"<p>　　“一次构建，多处运行”，跨平台APP带着这股风潮把火烧到了前端，为开发者带来无尽的遐想。现有的流行跨平台框架有以下:</p>\n<h3 id=\"1-基于单WebView的开发框架。\"><a href=\"#1-基于单WebView的开发框架。\" class=\"headerlink\" title=\"1. 基于单WebView的开发框架。\"></a>1. 基于单WebView的开发框架。</h3><p>　　开发者可以使用现有的最新web技术，开发出单页面web应用。同时利用JSBridge，又能获取原生的API，从而使web应用具有了原生应用的功能。Cordova+IONIC可以说是这个潮流的代表，也是跨平台APP的先锋。然而这类跨平台应用的缺点是不流畅，在安卓手机上体验较差。</p>\n<h3 id=\"2-Hybrid方向。\"><a href=\"#2-Hybrid方向。\" class=\"headerlink\" title=\"2. Hybrid方向。\"></a>2. Hybrid方向。</h3><p>　　也就是原生应用配合HTML5技术，让APP具有了部分跨平台的功能。Hybrid也是现在各大互联网企业采用较多的跨平台开发方式。这类APP在体验上优于单WebView的APP，并且能够极大提高开发效率。然而这种方式离“一次构建，多处运行”的设想还是有很大距离，毕竟依然需要针对不同的移动平台进行原生开发。</p>\n<h3 id=\"3-使用Javascript开发纯原生应用。\"><a href=\"#3-使用Javascript开发纯原生应用。\" class=\"headerlink\" title=\"3. 使用Javascript开发纯原生应用。\"></a>3. 使用Javascript开发纯原生应用。</h3><p>　　既然单WebView性能有缺憾，Hybrid技术栈又比较高，那么Javascript开发纯原生应用就孕育而生。这个方向的代表有<a href=\"https://facebook.github.io/react-native/\">ReactNative</a>, <a href=\"http://alibaba.github.io/weex/\">Weex</a>和<a href=\"https://www.nativescript.org/\">Nativescript</a>。</p>\n<p>　　和ReactNative相比，Nativescript最大的特点是可以获得100%的原生API。也就是说，开发者可以通过Javascript获取和原生开发语言同样多的原生接口。通过例子可以体会到“获取所有原生API”带来的巨大好处。NativeScript是一款使用JavaScript语言来构建跨平台原生移动应用的开源框架，支持iOS、Android和Windows Phone。<br>　　使用Nativescript和Angular2可以很高效地构建跨平台APP！！！<br>    NativeScript一个缺点：无法与原生项目融合，即你只能纯写个NativeScript的应用，不可能把它抽离出来作为某原生应用的一部分来出现。</p>\n"},{"title":"浅析JavaScript中的柯里化函数","date":"2017-01-03T05:04:42.000Z","_content":"#### 什么是curry function\ncurry 的概念很简单：只传递给函数一部分参数来调用它， 让它返回一个函数去处理剩下的参数.\n柯里化通常也称部分求值，其含义是给函数分步传递参数，每次传递参数后部分应用参数，并返回一个更具体的函数接受剩下的参数，这中间可嵌套多层这样的接受部分参数函数，直至返回最后结果。因此柯里化的过程是逐步传参，逐步缩小函数的适用范围，逐步求解的过程。\n#### 简单的例子\n```\nvar add = function(x) {\nreturn function(y) {\nreturn x + y;\n};\n};\nvar increment = add(1);\nvar addTen = add(10);\nincrement(2);\n// 3\naddTen(2);\n// 12\nadd(1)(2);//3\n```\n这里我们定义了一个 add 函数， 它接受一个参数并返回一个新的函数。 调用 add 之后， 返回的函数就通\n过**闭包**的方式记住了 add 的第一个参数。(ps:这里利用了闭包的特点)\n#### Function.prototype.bind方法是柯里化应用\n与 call/apply 方法直接执行不同，bind 方法 将第一个参数设置为函数执行的上下文，其他参数依次传递给调用方法（函数的主体本身不执行，可以看成是延迟执行），并动态创建返回一个新的函数， 这符合柯里化特点。\n```\nbind方法用法如下：用于改变函数中this关键字的\nvar foo = {x: 888};\nvar bar = function () {\n    console.log(this.x);\n}.bind(foo);               // 绑定\nbar();                     // 888\n```\n下面是一个 bind 函数的模拟，testBind 创建并返回新的函数，在新的函数中将真正要执行业务的函数绑定到实参传入的上下文，延迟执行了。\n```\nFunction.prototype.testBind = function (scope) {\n    var fn = this;                    //// this 指向的是调用 testBind 方法的一个函数， \n    return function () {\n        return fn.apply(scope);\n    }\n};\nvar testBindBar = bar.testBind(foo);  // 绑定 foo，延迟执行\nconsole.log(testBindBar);             // Function (可见，bind之后返回的是一个延迟执行的新函数)\ntestBindBar();                        // 888\n```\n\n\n","source":"_posts/curryfunction.md","raw":"---\ntitle: 浅析JavaScript中的柯里化函数\ndate: 2017-01-03 13:04:42\ntags: js 柯里化\n---\n#### 什么是curry function\ncurry 的概念很简单：只传递给函数一部分参数来调用它， 让它返回一个函数去处理剩下的参数.\n柯里化通常也称部分求值，其含义是给函数分步传递参数，每次传递参数后部分应用参数，并返回一个更具体的函数接受剩下的参数，这中间可嵌套多层这样的接受部分参数函数，直至返回最后结果。因此柯里化的过程是逐步传参，逐步缩小函数的适用范围，逐步求解的过程。\n#### 简单的例子\n```\nvar add = function(x) {\nreturn function(y) {\nreturn x + y;\n};\n};\nvar increment = add(1);\nvar addTen = add(10);\nincrement(2);\n// 3\naddTen(2);\n// 12\nadd(1)(2);//3\n```\n这里我们定义了一个 add 函数， 它接受一个参数并返回一个新的函数。 调用 add 之后， 返回的函数就通\n过**闭包**的方式记住了 add 的第一个参数。(ps:这里利用了闭包的特点)\n#### Function.prototype.bind方法是柯里化应用\n与 call/apply 方法直接执行不同，bind 方法 将第一个参数设置为函数执行的上下文，其他参数依次传递给调用方法（函数的主体本身不执行，可以看成是延迟执行），并动态创建返回一个新的函数， 这符合柯里化特点。\n```\nbind方法用法如下：用于改变函数中this关键字的\nvar foo = {x: 888};\nvar bar = function () {\n    console.log(this.x);\n}.bind(foo);               // 绑定\nbar();                     // 888\n```\n下面是一个 bind 函数的模拟，testBind 创建并返回新的函数，在新的函数中将真正要执行业务的函数绑定到实参传入的上下文，延迟执行了。\n```\nFunction.prototype.testBind = function (scope) {\n    var fn = this;                    //// this 指向的是调用 testBind 方法的一个函数， \n    return function () {\n        return fn.apply(scope);\n    }\n};\nvar testBindBar = bar.testBind(foo);  // 绑定 foo，延迟执行\nconsole.log(testBindBar);             // Function (可见，bind之后返回的是一个延迟执行的新函数)\ntestBindBar();                        // 888\n```\n\n\n","slug":"curryfunction","published":1,"updated":"2017-01-03T05:24:21.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv7c001cjgtu772kepka","content":"<h4 id=\"什么是curry-function\"><a href=\"#什么是curry-function\" class=\"headerlink\" title=\"什么是curry function\"></a>什么是curry function</h4><p>curry 的概念很简单：只传递给函数一部分参数来调用它， 让它返回一个函数去处理剩下的参数.<br>柯里化通常也称部分求值，其含义是给函数分步传递参数，每次传递参数后部分应用参数，并返回一个更具体的函数接受剩下的参数，这中间可嵌套多层这样的接受部分参数函数，直至返回最后结果。因此柯里化的过程是逐步传参，逐步缩小函数的适用范围，逐步求解的过程。</p>\n<h4 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">var add = function(x) &#123;</div><div class=\"line\">return function(y) &#123;</div><div class=\"line\">return x + y;</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\">var increment = add(1);</div><div class=\"line\">var addTen = add(10);</div><div class=\"line\">increment(2);</div><div class=\"line\">// 3</div><div class=\"line\">addTen(2);</div><div class=\"line\">// 12</div><div class=\"line\">add(1)(2);//3</div></pre></td></tr></table></figure>\n<p>这里我们定义了一个 add 函数， 它接受一个参数并返回一个新的函数。 调用 add 之后， 返回的函数就通<br>过<strong>闭包</strong>的方式记住了 add 的第一个参数。(ps:这里利用了闭包的特点)</p>\n<h4 id=\"Function-prototype-bind方法是柯里化应用\"><a href=\"#Function-prototype-bind方法是柯里化应用\" class=\"headerlink\" title=\"Function.prototype.bind方法是柯里化应用\"></a>Function.prototype.bind方法是柯里化应用</h4><p>与 call/apply 方法直接执行不同，bind 方法 将第一个参数设置为函数执行的上下文，其他参数依次传递给调用方法（函数的主体本身不执行，可以看成是延迟执行），并动态创建返回一个新的函数， 这符合柯里化特点。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">bind方法用法如下：用于改变函数中this关键字的</div><div class=\"line\">var foo = &#123;x: 888&#125;;</div><div class=\"line\">var bar = function () &#123;</div><div class=\"line\">    console.log(this.x);</div><div class=\"line\">&#125;.bind(foo);               // 绑定</div><div class=\"line\">bar();                     // 888</div></pre></td></tr></table></figure></p>\n<p>下面是一个 bind 函数的模拟，testBind 创建并返回新的函数，在新的函数中将真正要执行业务的函数绑定到实参传入的上下文，延迟执行了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Function.prototype.testBind = function (scope) &#123;</div><div class=\"line\">    var fn = this;                    //// this 指向的是调用 testBind 方法的一个函数， </div><div class=\"line\">    return function () &#123;</div><div class=\"line\">        return fn.apply(scope);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">var testBindBar = bar.testBind(foo);  // 绑定 foo，延迟执行</div><div class=\"line\">console.log(testBindBar);             // Function (可见，bind之后返回的是一个延迟执行的新函数)</div><div class=\"line\">testBindBar();                        // 888</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<h4 id=\"什么是curry-function\"><a href=\"#什么是curry-function\" class=\"headerlink\" title=\"什么是curry function\"></a>什么是curry function</h4><p>curry 的概念很简单：只传递给函数一部分参数来调用它， 让它返回一个函数去处理剩下的参数.<br>柯里化通常也称部分求值，其含义是给函数分步传递参数，每次传递参数后部分应用参数，并返回一个更具体的函数接受剩下的参数，这中间可嵌套多层这样的接受部分参数函数，直至返回最后结果。因此柯里化的过程是逐步传参，逐步缩小函数的适用范围，逐步求解的过程。</p>\n<h4 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">var add = function(x) &#123;</div><div class=\"line\">return function(y) &#123;</div><div class=\"line\">return x + y;</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\">var increment = add(1);</div><div class=\"line\">var addTen = add(10);</div><div class=\"line\">increment(2);</div><div class=\"line\">// 3</div><div class=\"line\">addTen(2);</div><div class=\"line\">// 12</div><div class=\"line\">add(1)(2);//3</div></pre></td></tr></table></figure>\n<p>这里我们定义了一个 add 函数， 它接受一个参数并返回一个新的函数。 调用 add 之后， 返回的函数就通<br>过<strong>闭包</strong>的方式记住了 add 的第一个参数。(ps:这里利用了闭包的特点)</p>\n<h4 id=\"Function-prototype-bind方法是柯里化应用\"><a href=\"#Function-prototype-bind方法是柯里化应用\" class=\"headerlink\" title=\"Function.prototype.bind方法是柯里化应用\"></a>Function.prototype.bind方法是柯里化应用</h4><p>与 call/apply 方法直接执行不同，bind 方法 将第一个参数设置为函数执行的上下文，其他参数依次传递给调用方法（函数的主体本身不执行，可以看成是延迟执行），并动态创建返回一个新的函数， 这符合柯里化特点。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">bind方法用法如下：用于改变函数中this关键字的</div><div class=\"line\">var foo = &#123;x: 888&#125;;</div><div class=\"line\">var bar = function () &#123;</div><div class=\"line\">    console.log(this.x);</div><div class=\"line\">&#125;.bind(foo);               // 绑定</div><div class=\"line\">bar();                     // 888</div></pre></td></tr></table></figure></p>\n<p>下面是一个 bind 函数的模拟，testBind 创建并返回新的函数，在新的函数中将真正要执行业务的函数绑定到实参传入的上下文，延迟执行了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Function.prototype.testBind = function (scope) &#123;</div><div class=\"line\">    var fn = this;                    //// this 指向的是调用 testBind 方法的一个函数， </div><div class=\"line\">    return function () &#123;</div><div class=\"line\">        return fn.apply(scope);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">var testBindBar = bar.testBind(foo);  // 绑定 foo，延迟执行</div><div class=\"line\">console.log(testBindBar);             // Function (可见，bind之后返回的是一个延迟执行的新函数)</div><div class=\"line\">testBindBar();                        // 888</div></pre></td></tr></table></figure></p>\n"},{"title":"教你从零开始搭建一款前端脚手架工具","date":"2016-06-13T09:32:09.000Z","_content":"*CLI*:command-line interface，命令行界面.\n[文章来源地址](https://segmentfault.com/a/1190000006190814?utm_source=tuicool&utm_medium=referral#articleHeader0)\n## 前言\n　　在实际的开发过程中，从零开始建立项目的结构是一件让人头疼的事情，所以各种各样的脚手架工具应运而生。使用较多koa-generator、yoeman、express-generator和vue-cli便是当中之一。它们功能丰富，但最核心的功能都是能够快速搭建一个完整的项目的结构，开发者只需要在生成的项目结构的基础上进行开发即可，非常简单高效。\n    自己搭建一款叫做SCION的脚手架。现在让我们就以SCION为例，从零开始搭建一款属于我们自己的脚手架工具吧！\n核心原理\nyoeman搭建项目需要提供yoeman-generator。yoeman-generator本质上就是一个具备完整文件结构的项目样板，用户需要手动地把这些generator下载到本地，然后yoeman就会根据这些generator自动生成各种不同的项目。\n\nvue-cli提供了相当丰富的选项和设定功能，但是其本质也是从远程仓库把不同的模版拉取到本地，而并非是什么“本地生成”的黑科技。\n\n这样看来，思路也就有了——首先建立不同的样板项目，然后脚手架根据用户的指令引用样板项目生成实际项目。样板项目可以内置在脚手架当中，也可以部署在远程仓库。为了更广的适用范围，SCION采用的是第二种方式。\n\n技术选型\nnode.js：整个脚手架工具的根本组成部分，推荐使用最新的版本。\nes6：新版本的node.js对于es6的支持度已经非常高，使用es6能够极大地提升开发效率和开发感受。\ncommander：TJ大神开发的工具，能够更好地组织和处理命令行的输入。\nco：TJ大神开发的异步流程控制工具，用更舒服的方式写异步代码。\nco-prompt：还是TJ大神的作品……传统的命令行只能单行一次性地输入所有参数和选项，使用这个工具可以自动提供提示信息，并且分步接收用户的输入，体验类似npm init时的一步一步输入参数的过程。\n整体架构\n国际惯例，着手开发之前得先弄明白整体架构，看图：\n\n\n首先明白模版的概念。一个模版就是一个项目的样板，包含项目的完整结构和信息。\n模版的信息都存放在一个叫做templates.json的文件当中。\n用户可以通过命令行对templates.json进行添加、删除、罗列的操作。\n通过选择不同的模版，SCION会自动从远程仓库把相应的模板拉取到本地，完成项目的搭建。\n\n最终整个脚手架的文件结构如下：\n\n```\n  |__ bin\n    |__ scion\n  |__ command\n    |__ add.js\n    |__ delete.js\n    |__ init.js\n    |__ list.js\n  |__ node_modules\n  |__ package.json\n  |__ templates.json\n入口文件\n首先建立项目，在package.json里面写入依赖并执行npm install：\n\n\"dependencies\": {\n    \"chalk\": \"^1.1.3\",\n    \"co\": \"^4.6.0\",\n    \"co-prompt\": \"^1.0.0\",\n    \"commander\": \"^2.9.0\"\n  }\n在根目录下建立\\bin文件夹，在里面建立一个无后缀名的scion文件。这个bin\\scion文件是整个脚手架的入口文件，所以我们首先对它进行编写。\n\n首先是一些初始化的代码：\n\n#!/usr/bin/env node --harmony\n'use strict'\n // 定义脚手架的文件路径\nprocess.env.NODE_PATH = __dirname + '/../node_modules/'\n\nconst program = require('commander')\n\n // 定义当前版本\nprogram\n    .version(require('../package').version )\n\n// 定义使用方法\nprogram\n    .usage('<command>')\n从前文的架构图中可以知道，脚手架支持用户输入4种不同的命令。现在我们来写处理这4种命令的方法：\n\nprogram\n    .command('add')\n    .description('Add a new template')\n  .alias('a')\n  .action(() => {\n    require('../command/add')()\n  })\n\nprogram\n    .command('list')\n    .description('List all the templates')\n    .alias('l')\n    .action(() => {\n        require('../command/list')()\n    })\n\nprogram\n    .command('init')\n    .description('Generate a new project')\n  .alias('i')\n  .action(() => {\n    require('../command/init')()\n  })\n\nprogram\n    .command('delete')\n    .description('Delete a template')\n    .alias('d')\n    .action(() => {\n        require('../command/delete')()\n    })\ncommander的具体使用方法在这里就不展开了，可以直接到官网去看详细的文档。\n最后别忘了处理参数和提供帮助信息：\n\nprogram.parse(process.argv)\n\nif(!program.args.length){\n  program.help()\n}\n完整的代码请看这里。\n使用node运行这个文件，看到输出如下，证明入口文件已经编写完成了。\n\nUsage: scion <command>\n\n\n  Commands:\n\n    add|a      Add a new template\n    list|l     List all the templates\n    init|i     Generate a new project\n    delete|d   Delete a template\n\n  Options:\n\n    -h, --help     output usage information\n    -V, --version  output the version number\n处理用户输入\n在项目根目录下建立\\command文件夹，专门用来存放命令处理文件。\n在根目录下建立templates.json文件并写入如下内容，用来存放模版信息：\n\n{\"tpl\":{}}\n添加模板\n进入\\command并新建add.js文件：\n\n'use strict'\nconst co = require('co')\nconst prompt = require('co-prompt')\nconst config = require('../templates')\nconst chalk = require('chalk')\nconst fs = require('fs')\n\nmodule.exports = () => {\n co(function *() {\n\n   // 分步接收用户输入的参数\n   let tplName = yield prompt('Template name: ')\n   let gitUrl = yield prompt('Git https link: ')\n   let branch = yield prompt('Branch: ')\n    \n   // 避免重复添加\n   if (!config.tpl[tplName]) {\n     config.tpl[tplName] = {}\n     config.tpl[tplName]['url'] = gitUrl.replace(/[\\u0000-\\u0019]/g, '') // 过滤unicode字符\n     config.tpl[tplName]['branch'] = branch\n   } else {\n     console.log(chalk.red('Template has already existed!'))\n     process.exit()\n   }\n   \n   // 把模板信息写入templates.json\n   fs.writeFile(__dirname + '/../templates.json', JSON.stringify(config), 'utf-8', (err) => {\n     if (err) console.log(err)\n     console.log(chalk.green('New template added!\\n'))\n     console.log(chalk.grey('The last template list is: \\n'))\n     console.log(config)\n     console.log('\\n')\n     process.exit()\n    })\n })\n}\n删除模板\n同样的，在\\command文件夹下建立delete.js文件：\n\n'use strict'\nconst co = require('co')\nconst prompt = require('co-prompt')\nconst config = require('../templates')\nconst chalk = require('chalk')\nconst fs = require('fs')\n\nmodule.exports = () => {\n    co(function *() {\n        // 接收用户输入的参数\n        let tplName = yield prompt('Template name: ')\n\n        // 删除对应的模板\n        if (config.tpl[tplName]) {\n            config.tpl[tplName] = undefined\n        } else {\n            console.log(chalk.red('Template does not exist!'))\n            process.exit()\n        }\n        \n        // 写入template.json\n        fs.writeFile(__dirname + '/../templates.json', JSON.stringify(config),     'utf-8', (err) => {\n            if (err) console.log(err)\n            console.log(chalk.green('Template deleted!'))\n            console.log(chalk.grey('The last template list is: \\n'))\n            console.log(config)\n            console.log('\\n')\n            process.exit()\n        })\n    })\n}\n罗列模板\n建立list.js文件：\n\n'use strict'\nconst config = require('../templates')\n\nmodule.exports = () => {\n     console.log(config.tpl)\n     process.exit()\n}\n构建项目\n现在来到我们最重要的部分——构建项目。同样的，在\\command目录下新建一个叫做init.js的文件：\n\n'use strict'\nconst exec = require('child_process').exec\nconst co = require('co')\nconst prompt = require('co-prompt')\nconst config = require('../templates')\nconst chalk = require('chalk')\n\nmodule.exports = () => {\n co(function *() {\n    // 处理用户输入\n      let tplName = yield prompt('Template name: ')\n      let projectName = yield prompt('Project name: ')\n      let gitUrl\n      let branch\n\n    if (!config.tpl[tplName]) {\n        console.log(chalk.red('\\n × Template does not exit!'))\n        process.exit()\n    }\n    gitUrl = config.tpl[tplName].url\n    branch = config.tpl[tplName].branch\n\n    // git命令，远程拉取项目并自定义项目名\n    let cmdStr = `git clone ${gitUrl} ${projectName} && cd ${projectName} && git checkout ${branch}`\n\n    console.log(chalk.white('\\n Start generating...'))\n\n    exec(cmdStr, (error, stdout, stderr) => {\n      if (error) {\n        console.log(error)\n        process.exit()\n      }\n      console.log(chalk.green('\\n √ Generation completed!'))\n      console.log(`\\n cd ${projectName} && npm install \\n`)\n      process.exit()\n    })\n  })\n}\n```\n可以看到，这一部分代码也非常简单，关键的一句话是\n```\nlet cmdStr = `git clone ${gitUrl} ${projectName} && cd ${projectName} && git checkout ${branch}`\n```\n它的作用正是从远程仓库克隆到自定义目录，并切换到对应的分支。熟悉git命令的同学应该明白，不熟悉的同学是时候补补课啦！\n\n全局使用\n为了可以全局使用，我们需要在package.json里面设置一下：\n```\n\"bin\": {\n    \"scion\": \"bin/scion\"\n  }\n```\n本地调试的时候，在根目录下执行\n\nnpm link\n即可把scion命令绑定到全局，以后就可以直接以scion作为命令开头而无需敲入长长的node scion之类的命令了。\n\n现在我们的脚手架工具已经搭建好了，一起来尝试一下吧！\n\n使用测试\n```\nadd | a 添加模版命令\n\ninit | i 生成项目命令\n\ndelete | d 删除模版命令 和 list | l 罗列模版命令\n```\n   大功告成啦！现在我们的整个脚手架工具已经搭建完成了，以后只需要知道模板的git https地址和branch就可以不断地往SCION上面添加，团队协作的话只需要分享SCION的templates.json文件就可以了。\n\n### 后记\n   看起来并不复杂的东西，实际从零开始搭建也是颇费了一番心思。最大的难题是在开始的时候并不懂得如何像npm init那样可以一步一步地处理用户输入，只懂得一条命令行把所有的参数都带上，这样的用户体验真的很不好。研究了vue-cli和yoeman也没有找到相应的代码，只好不断地google，最后总算找到了一篇文章，可以用co和co-prompt这两个工具实现，再一次膜拜无所不能的TJ大神，也希望能够有小伙伴告诉我vue-cli它们是怎么实现的。","source":"_posts/dajianjiaoshoujia.md","raw":"---\ntitle: 教你从零开始搭建一款前端脚手架工具\ndate: 2016-6-13 17:32:09\ntags: 前端脚手架\n---\n*CLI*:command-line interface，命令行界面.\n[文章来源地址](https://segmentfault.com/a/1190000006190814?utm_source=tuicool&utm_medium=referral#articleHeader0)\n## 前言\n　　在实际的开发过程中，从零开始建立项目的结构是一件让人头疼的事情，所以各种各样的脚手架工具应运而生。使用较多koa-generator、yoeman、express-generator和vue-cli便是当中之一。它们功能丰富，但最核心的功能都是能够快速搭建一个完整的项目的结构，开发者只需要在生成的项目结构的基础上进行开发即可，非常简单高效。\n    自己搭建一款叫做SCION的脚手架。现在让我们就以SCION为例，从零开始搭建一款属于我们自己的脚手架工具吧！\n核心原理\nyoeman搭建项目需要提供yoeman-generator。yoeman-generator本质上就是一个具备完整文件结构的项目样板，用户需要手动地把这些generator下载到本地，然后yoeman就会根据这些generator自动生成各种不同的项目。\n\nvue-cli提供了相当丰富的选项和设定功能，但是其本质也是从远程仓库把不同的模版拉取到本地，而并非是什么“本地生成”的黑科技。\n\n这样看来，思路也就有了——首先建立不同的样板项目，然后脚手架根据用户的指令引用样板项目生成实际项目。样板项目可以内置在脚手架当中，也可以部署在远程仓库。为了更广的适用范围，SCION采用的是第二种方式。\n\n技术选型\nnode.js：整个脚手架工具的根本组成部分，推荐使用最新的版本。\nes6：新版本的node.js对于es6的支持度已经非常高，使用es6能够极大地提升开发效率和开发感受。\ncommander：TJ大神开发的工具，能够更好地组织和处理命令行的输入。\nco：TJ大神开发的异步流程控制工具，用更舒服的方式写异步代码。\nco-prompt：还是TJ大神的作品……传统的命令行只能单行一次性地输入所有参数和选项，使用这个工具可以自动提供提示信息，并且分步接收用户的输入，体验类似npm init时的一步一步输入参数的过程。\n整体架构\n国际惯例，着手开发之前得先弄明白整体架构，看图：\n\n\n首先明白模版的概念。一个模版就是一个项目的样板，包含项目的完整结构和信息。\n模版的信息都存放在一个叫做templates.json的文件当中。\n用户可以通过命令行对templates.json进行添加、删除、罗列的操作。\n通过选择不同的模版，SCION会自动从远程仓库把相应的模板拉取到本地，完成项目的搭建。\n\n最终整个脚手架的文件结构如下：\n\n```\n  |__ bin\n    |__ scion\n  |__ command\n    |__ add.js\n    |__ delete.js\n    |__ init.js\n    |__ list.js\n  |__ node_modules\n  |__ package.json\n  |__ templates.json\n入口文件\n首先建立项目，在package.json里面写入依赖并执行npm install：\n\n\"dependencies\": {\n    \"chalk\": \"^1.1.3\",\n    \"co\": \"^4.6.0\",\n    \"co-prompt\": \"^1.0.0\",\n    \"commander\": \"^2.9.0\"\n  }\n在根目录下建立\\bin文件夹，在里面建立一个无后缀名的scion文件。这个bin\\scion文件是整个脚手架的入口文件，所以我们首先对它进行编写。\n\n首先是一些初始化的代码：\n\n#!/usr/bin/env node --harmony\n'use strict'\n // 定义脚手架的文件路径\nprocess.env.NODE_PATH = __dirname + '/../node_modules/'\n\nconst program = require('commander')\n\n // 定义当前版本\nprogram\n    .version(require('../package').version )\n\n// 定义使用方法\nprogram\n    .usage('<command>')\n从前文的架构图中可以知道，脚手架支持用户输入4种不同的命令。现在我们来写处理这4种命令的方法：\n\nprogram\n    .command('add')\n    .description('Add a new template')\n  .alias('a')\n  .action(() => {\n    require('../command/add')()\n  })\n\nprogram\n    .command('list')\n    .description('List all the templates')\n    .alias('l')\n    .action(() => {\n        require('../command/list')()\n    })\n\nprogram\n    .command('init')\n    .description('Generate a new project')\n  .alias('i')\n  .action(() => {\n    require('../command/init')()\n  })\n\nprogram\n    .command('delete')\n    .description('Delete a template')\n    .alias('d')\n    .action(() => {\n        require('../command/delete')()\n    })\ncommander的具体使用方法在这里就不展开了，可以直接到官网去看详细的文档。\n最后别忘了处理参数和提供帮助信息：\n\nprogram.parse(process.argv)\n\nif(!program.args.length){\n  program.help()\n}\n完整的代码请看这里。\n使用node运行这个文件，看到输出如下，证明入口文件已经编写完成了。\n\nUsage: scion <command>\n\n\n  Commands:\n\n    add|a      Add a new template\n    list|l     List all the templates\n    init|i     Generate a new project\n    delete|d   Delete a template\n\n  Options:\n\n    -h, --help     output usage information\n    -V, --version  output the version number\n处理用户输入\n在项目根目录下建立\\command文件夹，专门用来存放命令处理文件。\n在根目录下建立templates.json文件并写入如下内容，用来存放模版信息：\n\n{\"tpl\":{}}\n添加模板\n进入\\command并新建add.js文件：\n\n'use strict'\nconst co = require('co')\nconst prompt = require('co-prompt')\nconst config = require('../templates')\nconst chalk = require('chalk')\nconst fs = require('fs')\n\nmodule.exports = () => {\n co(function *() {\n\n   // 分步接收用户输入的参数\n   let tplName = yield prompt('Template name: ')\n   let gitUrl = yield prompt('Git https link: ')\n   let branch = yield prompt('Branch: ')\n    \n   // 避免重复添加\n   if (!config.tpl[tplName]) {\n     config.tpl[tplName] = {}\n     config.tpl[tplName]['url'] = gitUrl.replace(/[\\u0000-\\u0019]/g, '') // 过滤unicode字符\n     config.tpl[tplName]['branch'] = branch\n   } else {\n     console.log(chalk.red('Template has already existed!'))\n     process.exit()\n   }\n   \n   // 把模板信息写入templates.json\n   fs.writeFile(__dirname + '/../templates.json', JSON.stringify(config), 'utf-8', (err) => {\n     if (err) console.log(err)\n     console.log(chalk.green('New template added!\\n'))\n     console.log(chalk.grey('The last template list is: \\n'))\n     console.log(config)\n     console.log('\\n')\n     process.exit()\n    })\n })\n}\n删除模板\n同样的，在\\command文件夹下建立delete.js文件：\n\n'use strict'\nconst co = require('co')\nconst prompt = require('co-prompt')\nconst config = require('../templates')\nconst chalk = require('chalk')\nconst fs = require('fs')\n\nmodule.exports = () => {\n    co(function *() {\n        // 接收用户输入的参数\n        let tplName = yield prompt('Template name: ')\n\n        // 删除对应的模板\n        if (config.tpl[tplName]) {\n            config.tpl[tplName] = undefined\n        } else {\n            console.log(chalk.red('Template does not exist!'))\n            process.exit()\n        }\n        \n        // 写入template.json\n        fs.writeFile(__dirname + '/../templates.json', JSON.stringify(config),     'utf-8', (err) => {\n            if (err) console.log(err)\n            console.log(chalk.green('Template deleted!'))\n            console.log(chalk.grey('The last template list is: \\n'))\n            console.log(config)\n            console.log('\\n')\n            process.exit()\n        })\n    })\n}\n罗列模板\n建立list.js文件：\n\n'use strict'\nconst config = require('../templates')\n\nmodule.exports = () => {\n     console.log(config.tpl)\n     process.exit()\n}\n构建项目\n现在来到我们最重要的部分——构建项目。同样的，在\\command目录下新建一个叫做init.js的文件：\n\n'use strict'\nconst exec = require('child_process').exec\nconst co = require('co')\nconst prompt = require('co-prompt')\nconst config = require('../templates')\nconst chalk = require('chalk')\n\nmodule.exports = () => {\n co(function *() {\n    // 处理用户输入\n      let tplName = yield prompt('Template name: ')\n      let projectName = yield prompt('Project name: ')\n      let gitUrl\n      let branch\n\n    if (!config.tpl[tplName]) {\n        console.log(chalk.red('\\n × Template does not exit!'))\n        process.exit()\n    }\n    gitUrl = config.tpl[tplName].url\n    branch = config.tpl[tplName].branch\n\n    // git命令，远程拉取项目并自定义项目名\n    let cmdStr = `git clone ${gitUrl} ${projectName} && cd ${projectName} && git checkout ${branch}`\n\n    console.log(chalk.white('\\n Start generating...'))\n\n    exec(cmdStr, (error, stdout, stderr) => {\n      if (error) {\n        console.log(error)\n        process.exit()\n      }\n      console.log(chalk.green('\\n √ Generation completed!'))\n      console.log(`\\n cd ${projectName} && npm install \\n`)\n      process.exit()\n    })\n  })\n}\n```\n可以看到，这一部分代码也非常简单，关键的一句话是\n```\nlet cmdStr = `git clone ${gitUrl} ${projectName} && cd ${projectName} && git checkout ${branch}`\n```\n它的作用正是从远程仓库克隆到自定义目录，并切换到对应的分支。熟悉git命令的同学应该明白，不熟悉的同学是时候补补课啦！\n\n全局使用\n为了可以全局使用，我们需要在package.json里面设置一下：\n```\n\"bin\": {\n    \"scion\": \"bin/scion\"\n  }\n```\n本地调试的时候，在根目录下执行\n\nnpm link\n即可把scion命令绑定到全局，以后就可以直接以scion作为命令开头而无需敲入长长的node scion之类的命令了。\n\n现在我们的脚手架工具已经搭建好了，一起来尝试一下吧！\n\n使用测试\n```\nadd | a 添加模版命令\n\ninit | i 生成项目命令\n\ndelete | d 删除模版命令 和 list | l 罗列模版命令\n```\n   大功告成啦！现在我们的整个脚手架工具已经搭建完成了，以后只需要知道模板的git https地址和branch就可以不断地往SCION上面添加，团队协作的话只需要分享SCION的templates.json文件就可以了。\n\n### 后记\n   看起来并不复杂的东西，实际从零开始搭建也是颇费了一番心思。最大的难题是在开始的时候并不懂得如何像npm init那样可以一步一步地处理用户输入，只懂得一条命令行把所有的参数都带上，这样的用户体验真的很不好。研究了vue-cli和yoeman也没有找到相应的代码，只好不断地google，最后总算找到了一篇文章，可以用co和co-prompt这两个工具实现，再一次膜拜无所不能的TJ大神，也希望能够有小伙伴告诉我vue-cli它们是怎么实现的。","slug":"dajianjiaoshoujia","published":1,"updated":"2016-12-14T14:58:52.856Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv7e001ejgtugk0jhzxp","content":"<p><em>CLI</em>:command-line interface，命令行界面.<br><a href=\"https://segmentfault.com/a/1190000006190814?utm_source=tuicool&amp;utm_medium=referral#articleHeader0\" target=\"_blank\" rel=\"external\">文章来源地址</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>　　在实际的开发过程中，从零开始建立项目的结构是一件让人头疼的事情，所以各种各样的脚手架工具应运而生。使用较多koa-generator、yoeman、express-generator和vue-cli便是当中之一。它们功能丰富，但最核心的功能都是能够快速搭建一个完整的项目的结构，开发者只需要在生成的项目结构的基础上进行开发即可，非常简单高效。<br>    自己搭建一款叫做SCION的脚手架。现在让我们就以SCION为例，从零开始搭建一款属于我们自己的脚手架工具吧！<br>核心原理<br>yoeman搭建项目需要提供yoeman-generator。yoeman-generator本质上就是一个具备完整文件结构的项目样板，用户需要手动地把这些generator下载到本地，然后yoeman就会根据这些generator自动生成各种不同的项目。</p>\n<p>vue-cli提供了相当丰富的选项和设定功能，但是其本质也是从远程仓库把不同的模版拉取到本地，而并非是什么“本地生成”的黑科技。</p>\n<p>这样看来，思路也就有了——首先建立不同的样板项目，然后脚手架根据用户的指令引用样板项目生成实际项目。样板项目可以内置在脚手架当中，也可以部署在远程仓库。为了更广的适用范围，SCION采用的是第二种方式。</p>\n<p>技术选型<br>node.js：整个脚手架工具的根本组成部分，推荐使用最新的版本。<br>es6：新版本的node.js对于es6的支持度已经非常高，使用es6能够极大地提升开发效率和开发感受。<br>commander：TJ大神开发的工具，能够更好地组织和处理命令行的输入。<br>co：TJ大神开发的异步流程控制工具，用更舒服的方式写异步代码。<br>co-prompt：还是TJ大神的作品……传统的命令行只能单行一次性地输入所有参数和选项，使用这个工具可以自动提供提示信息，并且分步接收用户的输入，体验类似npm init时的一步一步输入参数的过程。<br>整体架构<br>国际惯例，着手开发之前得先弄明白整体架构，看图：</p>\n<p>首先明白模版的概念。一个模版就是一个项目的样板，包含项目的完整结构和信息。<br>模版的信息都存放在一个叫做templates.json的文件当中。<br>用户可以通过命令行对templates.json进行添加、删除、罗列的操作。<br>通过选择不同的模版，SCION会自动从远程仓库把相应的模板拉取到本地，完成项目的搭建。</p>\n<p>最终整个脚手架的文件结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div></pre></td><td class=\"code\"><pre><div class=\"line\">  |__ bin</div><div class=\"line\">    |__ scion</div><div class=\"line\">  |__ command</div><div class=\"line\">    |__ add.js</div><div class=\"line\">    |__ delete.js</div><div class=\"line\">    |__ init.js</div><div class=\"line\">    |__ list.js</div><div class=\"line\">  |__ node_modules</div><div class=\"line\">  |__ package.json</div><div class=\"line\">  |__ templates.json</div><div class=\"line\">入口文件</div><div class=\"line\">首先建立项目，在package.json里面写入依赖并执行npm install：</div><div class=\"line\"></div><div class=\"line\">&quot;dependencies&quot;: &#123;</div><div class=\"line\">    &quot;chalk&quot;: &quot;^1.1.3&quot;,</div><div class=\"line\">    &quot;co&quot;: &quot;^4.6.0&quot;,</div><div class=\"line\">    &quot;co-prompt&quot;: &quot;^1.0.0&quot;,</div><div class=\"line\">    &quot;commander&quot;: &quot;^2.9.0&quot;</div><div class=\"line\">  &#125;</div><div class=\"line\">在根目录下建立\\bin文件夹，在里面建立一个无后缀名的scion文件。这个bin\\scion文件是整个脚手架的入口文件，所以我们首先对它进行编写。</div><div class=\"line\"></div><div class=\"line\">首先是一些初始化的代码：</div><div class=\"line\"></div><div class=\"line\">#!/usr/bin/env node --harmony</div><div class=\"line\">&apos;use strict&apos;</div><div class=\"line\"> // 定义脚手架的文件路径</div><div class=\"line\">process.env.NODE_PATH = __dirname + &apos;/../node_modules/&apos;</div><div class=\"line\"></div><div class=\"line\">const program = require(&apos;commander&apos;)</div><div class=\"line\"></div><div class=\"line\"> // 定义当前版本</div><div class=\"line\">program</div><div class=\"line\">    .version(require(&apos;../package&apos;).version )</div><div class=\"line\"></div><div class=\"line\">// 定义使用方法</div><div class=\"line\">program</div><div class=\"line\">    .usage(&apos;&lt;command&gt;&apos;)</div><div class=\"line\">从前文的架构图中可以知道，脚手架支持用户输入4种不同的命令。现在我们来写处理这4种命令的方法：</div><div class=\"line\"></div><div class=\"line\">program</div><div class=\"line\">    .command(&apos;add&apos;)</div><div class=\"line\">    .description(&apos;Add a new template&apos;)</div><div class=\"line\">  .alias(&apos;a&apos;)</div><div class=\"line\">  .action(() =&gt; &#123;</div><div class=\"line\">    require(&apos;../command/add&apos;)()</div><div class=\"line\">  &#125;)</div><div class=\"line\"></div><div class=\"line\">program</div><div class=\"line\">    .command(&apos;list&apos;)</div><div class=\"line\">    .description(&apos;List all the templates&apos;)</div><div class=\"line\">    .alias(&apos;l&apos;)</div><div class=\"line\">    .action(() =&gt; &#123;</div><div class=\"line\">        require(&apos;../command/list&apos;)()</div><div class=\"line\">    &#125;)</div><div class=\"line\"></div><div class=\"line\">program</div><div class=\"line\">    .command(&apos;init&apos;)</div><div class=\"line\">    .description(&apos;Generate a new project&apos;)</div><div class=\"line\">  .alias(&apos;i&apos;)</div><div class=\"line\">  .action(() =&gt; &#123;</div><div class=\"line\">    require(&apos;../command/init&apos;)()</div><div class=\"line\">  &#125;)</div><div class=\"line\"></div><div class=\"line\">program</div><div class=\"line\">    .command(&apos;delete&apos;)</div><div class=\"line\">    .description(&apos;Delete a template&apos;)</div><div class=\"line\">    .alias(&apos;d&apos;)</div><div class=\"line\">    .action(() =&gt; &#123;</div><div class=\"line\">        require(&apos;../command/delete&apos;)()</div><div class=\"line\">    &#125;)</div><div class=\"line\">commander的具体使用方法在这里就不展开了，可以直接到官网去看详细的文档。</div><div class=\"line\">最后别忘了处理参数和提供帮助信息：</div><div class=\"line\"></div><div class=\"line\">program.parse(process.argv)</div><div class=\"line\"></div><div class=\"line\">if(!program.args.length)&#123;</div><div class=\"line\">  program.help()</div><div class=\"line\">&#125;</div><div class=\"line\">完整的代码请看这里。</div><div class=\"line\">使用node运行这个文件，看到输出如下，证明入口文件已经编写完成了。</div><div class=\"line\"></div><div class=\"line\">Usage: scion &lt;command&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  Commands:</div><div class=\"line\"></div><div class=\"line\">    add|a      Add a new template</div><div class=\"line\">    list|l     List all the templates</div><div class=\"line\">    init|i     Generate a new project</div><div class=\"line\">    delete|d   Delete a template</div><div class=\"line\"></div><div class=\"line\">  Options:</div><div class=\"line\"></div><div class=\"line\">    -h, --help     output usage information</div><div class=\"line\">    -V, --version  output the version number</div><div class=\"line\">处理用户输入</div><div class=\"line\">在项目根目录下建立\\command文件夹，专门用来存放命令处理文件。</div><div class=\"line\">在根目录下建立templates.json文件并写入如下内容，用来存放模版信息：</div><div class=\"line\"></div><div class=\"line\">&#123;&quot;tpl&quot;:&#123;&#125;&#125;</div><div class=\"line\">添加模板</div><div class=\"line\">进入\\command并新建add.js文件：</div><div class=\"line\"></div><div class=\"line\">&apos;use strict&apos;</div><div class=\"line\">const co = require(&apos;co&apos;)</div><div class=\"line\">const prompt = require(&apos;co-prompt&apos;)</div><div class=\"line\">const config = require(&apos;../templates&apos;)</div><div class=\"line\">const chalk = require(&apos;chalk&apos;)</div><div class=\"line\">const fs = require(&apos;fs&apos;)</div><div class=\"line\"></div><div class=\"line\">module.exports = () =&gt; &#123;</div><div class=\"line\"> co(function *() &#123;</div><div class=\"line\"></div><div class=\"line\">   // 分步接收用户输入的参数</div><div class=\"line\">   let tplName = yield prompt(&apos;Template name: &apos;)</div><div class=\"line\">   let gitUrl = yield prompt(&apos;Git https link: &apos;)</div><div class=\"line\">   let branch = yield prompt(&apos;Branch: &apos;)</div><div class=\"line\">    </div><div class=\"line\">   // 避免重复添加</div><div class=\"line\">   if (!config.tpl[tplName]) &#123;</div><div class=\"line\">     config.tpl[tplName] = &#123;&#125;</div><div class=\"line\">     config.tpl[tplName][&apos;url&apos;] = gitUrl.replace(/[\\u0000-\\u0019]/g, &apos;&apos;) // 过滤unicode字符</div><div class=\"line\">     config.tpl[tplName][&apos;branch&apos;] = branch</div><div class=\"line\">   &#125; else &#123;</div><div class=\"line\">     console.log(chalk.red(&apos;Template has already existed!&apos;))</div><div class=\"line\">     process.exit()</div><div class=\"line\">   &#125;</div><div class=\"line\">   </div><div class=\"line\">   // 把模板信息写入templates.json</div><div class=\"line\">   fs.writeFile(__dirname + &apos;/../templates.json&apos;, JSON.stringify(config), &apos;utf-8&apos;, (err) =&gt; &#123;</div><div class=\"line\">     if (err) console.log(err)</div><div class=\"line\">     console.log(chalk.green(&apos;New template added!\\n&apos;))</div><div class=\"line\">     console.log(chalk.grey(&apos;The last template list is: \\n&apos;))</div><div class=\"line\">     console.log(config)</div><div class=\"line\">     console.log(&apos;\\n&apos;)</div><div class=\"line\">     process.exit()</div><div class=\"line\">    &#125;)</div><div class=\"line\"> &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\">删除模板</div><div class=\"line\">同样的，在\\command文件夹下建立delete.js文件：</div><div class=\"line\"></div><div class=\"line\">&apos;use strict&apos;</div><div class=\"line\">const co = require(&apos;co&apos;)</div><div class=\"line\">const prompt = require(&apos;co-prompt&apos;)</div><div class=\"line\">const config = require(&apos;../templates&apos;)</div><div class=\"line\">const chalk = require(&apos;chalk&apos;)</div><div class=\"line\">const fs = require(&apos;fs&apos;)</div><div class=\"line\"></div><div class=\"line\">module.exports = () =&gt; &#123;</div><div class=\"line\">    co(function *() &#123;</div><div class=\"line\">        // 接收用户输入的参数</div><div class=\"line\">        let tplName = yield prompt(&apos;Template name: &apos;)</div><div class=\"line\"></div><div class=\"line\">        // 删除对应的模板</div><div class=\"line\">        if (config.tpl[tplName]) &#123;</div><div class=\"line\">            config.tpl[tplName] = undefined</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            console.log(chalk.red(&apos;Template does not exist!&apos;))</div><div class=\"line\">            process.exit()</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        // 写入template.json</div><div class=\"line\">        fs.writeFile(__dirname + &apos;/../templates.json&apos;, JSON.stringify(config),     &apos;utf-8&apos;, (err) =&gt; &#123;</div><div class=\"line\">            if (err) console.log(err)</div><div class=\"line\">            console.log(chalk.green(&apos;Template deleted!&apos;))</div><div class=\"line\">            console.log(chalk.grey(&apos;The last template list is: \\n&apos;))</div><div class=\"line\">            console.log(config)</div><div class=\"line\">            console.log(&apos;\\n&apos;)</div><div class=\"line\">            process.exit()</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\">罗列模板</div><div class=\"line\">建立list.js文件：</div><div class=\"line\"></div><div class=\"line\">&apos;use strict&apos;</div><div class=\"line\">const config = require(&apos;../templates&apos;)</div><div class=\"line\"></div><div class=\"line\">module.exports = () =&gt; &#123;</div><div class=\"line\">     console.log(config.tpl)</div><div class=\"line\">     process.exit()</div><div class=\"line\">&#125;</div><div class=\"line\">构建项目</div><div class=\"line\">现在来到我们最重要的部分——构建项目。同样的，在\\command目录下新建一个叫做init.js的文件：</div><div class=\"line\"></div><div class=\"line\">&apos;use strict&apos;</div><div class=\"line\">const exec = require(&apos;child_process&apos;).exec</div><div class=\"line\">const co = require(&apos;co&apos;)</div><div class=\"line\">const prompt = require(&apos;co-prompt&apos;)</div><div class=\"line\">const config = require(&apos;../templates&apos;)</div><div class=\"line\">const chalk = require(&apos;chalk&apos;)</div><div class=\"line\"></div><div class=\"line\">module.exports = () =&gt; &#123;</div><div class=\"line\"> co(function *() &#123;</div><div class=\"line\">    // 处理用户输入</div><div class=\"line\">      let tplName = yield prompt(&apos;Template name: &apos;)</div><div class=\"line\">      let projectName = yield prompt(&apos;Project name: &apos;)</div><div class=\"line\">      let gitUrl</div><div class=\"line\">      let branch</div><div class=\"line\"></div><div class=\"line\">    if (!config.tpl[tplName]) &#123;</div><div class=\"line\">        console.log(chalk.red(&apos;\\n × Template does not exit!&apos;))</div><div class=\"line\">        process.exit()</div><div class=\"line\">    &#125;</div><div class=\"line\">    gitUrl = config.tpl[tplName].url</div><div class=\"line\">    branch = config.tpl[tplName].branch</div><div class=\"line\"></div><div class=\"line\">    // git命令，远程拉取项目并自定义项目名</div><div class=\"line\">    let cmdStr = `git clone $&#123;gitUrl&#125; $&#123;projectName&#125; &amp;&amp; cd $&#123;projectName&#125; &amp;&amp; git checkout $&#123;branch&#125;`</div><div class=\"line\"></div><div class=\"line\">    console.log(chalk.white(&apos;\\n Start generating...&apos;))</div><div class=\"line\"></div><div class=\"line\">    exec(cmdStr, (error, stdout, stderr) =&gt; &#123;</div><div class=\"line\">      if (error) &#123;</div><div class=\"line\">        console.log(error)</div><div class=\"line\">        process.exit()</div><div class=\"line\">      &#125;</div><div class=\"line\">      console.log(chalk.green(&apos;\\n √ Generation completed!&apos;))</div><div class=\"line\">      console.log(`\\n cd $&#123;projectName&#125; &amp;&amp; npm install \\n`)</div><div class=\"line\">      process.exit()</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，这一部分代码也非常简单，关键的一句话是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let cmdStr = `git clone $&#123;gitUrl&#125; $&#123;projectName&#125; &amp;&amp; cd $&#123;projectName&#125; &amp;&amp; git checkout $&#123;branch&#125;`</div></pre></td></tr></table></figure></p>\n<p>它的作用正是从远程仓库克隆到自定义目录，并切换到对应的分支。熟悉git命令的同学应该明白，不熟悉的同学是时候补补课啦！</p>\n<p>全局使用<br>为了可以全局使用，我们需要在package.json里面设置一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;bin&quot;: &#123;</div><div class=\"line\">    &quot;scion&quot;: &quot;bin/scion&quot;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>本地调试的时候，在根目录下执行</p>\n<p>npm link<br>即可把scion命令绑定到全局，以后就可以直接以scion作为命令开头而无需敲入长长的node scion之类的命令了。</p>\n<p>现在我们的脚手架工具已经搭建好了，一起来尝试一下吧！</p>\n<p>使用测试<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">add | a 添加模版命令</div><div class=\"line\"></div><div class=\"line\">init | i 生成项目命令</div><div class=\"line\"></div><div class=\"line\">delete | d 删除模版命令 和 list | l 罗列模版命令</div></pre></td></tr></table></figure></p>\n<p>   大功告成啦！现在我们的整个脚手架工具已经搭建完成了，以后只需要知道模板的git https地址和branch就可以不断地往SCION上面添加，团队协作的话只需要分享SCION的templates.json文件就可以了。</p>\n<h3 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h3><p>   看起来并不复杂的东西，实际从零开始搭建也是颇费了一番心思。最大的难题是在开始的时候并不懂得如何像npm init那样可以一步一步地处理用户输入，只懂得一条命令行把所有的参数都带上，这样的用户体验真的很不好。研究了vue-cli和yoeman也没有找到相应的代码，只好不断地google，最后总算找到了一篇文章，可以用co和co-prompt这两个工具实现，再一次膜拜无所不能的TJ大神，也希望能够有小伙伴告诉我vue-cli它们是怎么实现的。</p>\n","excerpt":"","more":"<p><em>CLI</em>:command-line interface，命令行界面.<br><a href=\"https://segmentfault.com/a/1190000006190814?utm_source=tuicool&amp;utm_medium=referral#articleHeader0\">文章来源地址</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>　　在实际的开发过程中，从零开始建立项目的结构是一件让人头疼的事情，所以各种各样的脚手架工具应运而生。使用较多koa-generator、yoeman、express-generator和vue-cli便是当中之一。它们功能丰富，但最核心的功能都是能够快速搭建一个完整的项目的结构，开发者只需要在生成的项目结构的基础上进行开发即可，非常简单高效。<br>    自己搭建一款叫做SCION的脚手架。现在让我们就以SCION为例，从零开始搭建一款属于我们自己的脚手架工具吧！<br>核心原理<br>yoeman搭建项目需要提供yoeman-generator。yoeman-generator本质上就是一个具备完整文件结构的项目样板，用户需要手动地把这些generator下载到本地，然后yoeman就会根据这些generator自动生成各种不同的项目。</p>\n<p>vue-cli提供了相当丰富的选项和设定功能，但是其本质也是从远程仓库把不同的模版拉取到本地，而并非是什么“本地生成”的黑科技。</p>\n<p>这样看来，思路也就有了——首先建立不同的样板项目，然后脚手架根据用户的指令引用样板项目生成实际项目。样板项目可以内置在脚手架当中，也可以部署在远程仓库。为了更广的适用范围，SCION采用的是第二种方式。</p>\n<p>技术选型<br>node.js：整个脚手架工具的根本组成部分，推荐使用最新的版本。<br>es6：新版本的node.js对于es6的支持度已经非常高，使用es6能够极大地提升开发效率和开发感受。<br>commander：TJ大神开发的工具，能够更好地组织和处理命令行的输入。<br>co：TJ大神开发的异步流程控制工具，用更舒服的方式写异步代码。<br>co-prompt：还是TJ大神的作品……传统的命令行只能单行一次性地输入所有参数和选项，使用这个工具可以自动提供提示信息，并且分步接收用户的输入，体验类似npm init时的一步一步输入参数的过程。<br>整体架构<br>国际惯例，着手开发之前得先弄明白整体架构，看图：</p>\n<p>首先明白模版的概念。一个模版就是一个项目的样板，包含项目的完整结构和信息。<br>模版的信息都存放在一个叫做templates.json的文件当中。<br>用户可以通过命令行对templates.json进行添加、删除、罗列的操作。<br>通过选择不同的模版，SCION会自动从远程仓库把相应的模板拉取到本地，完成项目的搭建。</p>\n<p>最终整个脚手架的文件结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div></pre></td><td class=\"code\"><pre><div class=\"line\">  |__ bin</div><div class=\"line\">    |__ scion</div><div class=\"line\">  |__ command</div><div class=\"line\">    |__ add.js</div><div class=\"line\">    |__ delete.js</div><div class=\"line\">    |__ init.js</div><div class=\"line\">    |__ list.js</div><div class=\"line\">  |__ node_modules</div><div class=\"line\">  |__ package.json</div><div class=\"line\">  |__ templates.json</div><div class=\"line\">入口文件</div><div class=\"line\">首先建立项目，在package.json里面写入依赖并执行npm install：</div><div class=\"line\"></div><div class=\"line\">&quot;dependencies&quot;: &#123;</div><div class=\"line\">    &quot;chalk&quot;: &quot;^1.1.3&quot;,</div><div class=\"line\">    &quot;co&quot;: &quot;^4.6.0&quot;,</div><div class=\"line\">    &quot;co-prompt&quot;: &quot;^1.0.0&quot;,</div><div class=\"line\">    &quot;commander&quot;: &quot;^2.9.0&quot;</div><div class=\"line\">  &#125;</div><div class=\"line\">在根目录下建立\\bin文件夹，在里面建立一个无后缀名的scion文件。这个bin\\scion文件是整个脚手架的入口文件，所以我们首先对它进行编写。</div><div class=\"line\"></div><div class=\"line\">首先是一些初始化的代码：</div><div class=\"line\"></div><div class=\"line\">#!/usr/bin/env node --harmony</div><div class=\"line\">&apos;use strict&apos;</div><div class=\"line\"> // 定义脚手架的文件路径</div><div class=\"line\">process.env.NODE_PATH = __dirname + &apos;/../node_modules/&apos;</div><div class=\"line\"></div><div class=\"line\">const program = require(&apos;commander&apos;)</div><div class=\"line\"></div><div class=\"line\"> // 定义当前版本</div><div class=\"line\">program</div><div class=\"line\">    .version(require(&apos;../package&apos;).version )</div><div class=\"line\"></div><div class=\"line\">// 定义使用方法</div><div class=\"line\">program</div><div class=\"line\">    .usage(&apos;&lt;command&gt;&apos;)</div><div class=\"line\">从前文的架构图中可以知道，脚手架支持用户输入4种不同的命令。现在我们来写处理这4种命令的方法：</div><div class=\"line\"></div><div class=\"line\">program</div><div class=\"line\">    .command(&apos;add&apos;)</div><div class=\"line\">    .description(&apos;Add a new template&apos;)</div><div class=\"line\">  .alias(&apos;a&apos;)</div><div class=\"line\">  .action(() =&gt; &#123;</div><div class=\"line\">    require(&apos;../command/add&apos;)()</div><div class=\"line\">  &#125;)</div><div class=\"line\"></div><div class=\"line\">program</div><div class=\"line\">    .command(&apos;list&apos;)</div><div class=\"line\">    .description(&apos;List all the templates&apos;)</div><div class=\"line\">    .alias(&apos;l&apos;)</div><div class=\"line\">    .action(() =&gt; &#123;</div><div class=\"line\">        require(&apos;../command/list&apos;)()</div><div class=\"line\">    &#125;)</div><div class=\"line\"></div><div class=\"line\">program</div><div class=\"line\">    .command(&apos;init&apos;)</div><div class=\"line\">    .description(&apos;Generate a new project&apos;)</div><div class=\"line\">  .alias(&apos;i&apos;)</div><div class=\"line\">  .action(() =&gt; &#123;</div><div class=\"line\">    require(&apos;../command/init&apos;)()</div><div class=\"line\">  &#125;)</div><div class=\"line\"></div><div class=\"line\">program</div><div class=\"line\">    .command(&apos;delete&apos;)</div><div class=\"line\">    .description(&apos;Delete a template&apos;)</div><div class=\"line\">    .alias(&apos;d&apos;)</div><div class=\"line\">    .action(() =&gt; &#123;</div><div class=\"line\">        require(&apos;../command/delete&apos;)()</div><div class=\"line\">    &#125;)</div><div class=\"line\">commander的具体使用方法在这里就不展开了，可以直接到官网去看详细的文档。</div><div class=\"line\">最后别忘了处理参数和提供帮助信息：</div><div class=\"line\"></div><div class=\"line\">program.parse(process.argv)</div><div class=\"line\"></div><div class=\"line\">if(!program.args.length)&#123;</div><div class=\"line\">  program.help()</div><div class=\"line\">&#125;</div><div class=\"line\">完整的代码请看这里。</div><div class=\"line\">使用node运行这个文件，看到输出如下，证明入口文件已经编写完成了。</div><div class=\"line\"></div><div class=\"line\">Usage: scion &lt;command&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  Commands:</div><div class=\"line\"></div><div class=\"line\">    add|a      Add a new template</div><div class=\"line\">    list|l     List all the templates</div><div class=\"line\">    init|i     Generate a new project</div><div class=\"line\">    delete|d   Delete a template</div><div class=\"line\"></div><div class=\"line\">  Options:</div><div class=\"line\"></div><div class=\"line\">    -h, --help     output usage information</div><div class=\"line\">    -V, --version  output the version number</div><div class=\"line\">处理用户输入</div><div class=\"line\">在项目根目录下建立\\command文件夹，专门用来存放命令处理文件。</div><div class=\"line\">在根目录下建立templates.json文件并写入如下内容，用来存放模版信息：</div><div class=\"line\"></div><div class=\"line\">&#123;&quot;tpl&quot;:&#123;&#125;&#125;</div><div class=\"line\">添加模板</div><div class=\"line\">进入\\command并新建add.js文件：</div><div class=\"line\"></div><div class=\"line\">&apos;use strict&apos;</div><div class=\"line\">const co = require(&apos;co&apos;)</div><div class=\"line\">const prompt = require(&apos;co-prompt&apos;)</div><div class=\"line\">const config = require(&apos;../templates&apos;)</div><div class=\"line\">const chalk = require(&apos;chalk&apos;)</div><div class=\"line\">const fs = require(&apos;fs&apos;)</div><div class=\"line\"></div><div class=\"line\">module.exports = () =&gt; &#123;</div><div class=\"line\"> co(function *() &#123;</div><div class=\"line\"></div><div class=\"line\">   // 分步接收用户输入的参数</div><div class=\"line\">   let tplName = yield prompt(&apos;Template name: &apos;)</div><div class=\"line\">   let gitUrl = yield prompt(&apos;Git https link: &apos;)</div><div class=\"line\">   let branch = yield prompt(&apos;Branch: &apos;)</div><div class=\"line\">    </div><div class=\"line\">   // 避免重复添加</div><div class=\"line\">   if (!config.tpl[tplName]) &#123;</div><div class=\"line\">     config.tpl[tplName] = &#123;&#125;</div><div class=\"line\">     config.tpl[tplName][&apos;url&apos;] = gitUrl.replace(/[\\u0000-\\u0019]/g, &apos;&apos;) // 过滤unicode字符</div><div class=\"line\">     config.tpl[tplName][&apos;branch&apos;] = branch</div><div class=\"line\">   &#125; else &#123;</div><div class=\"line\">     console.log(chalk.red(&apos;Template has already existed!&apos;))</div><div class=\"line\">     process.exit()</div><div class=\"line\">   &#125;</div><div class=\"line\">   </div><div class=\"line\">   // 把模板信息写入templates.json</div><div class=\"line\">   fs.writeFile(__dirname + &apos;/../templates.json&apos;, JSON.stringify(config), &apos;utf-8&apos;, (err) =&gt; &#123;</div><div class=\"line\">     if (err) console.log(err)</div><div class=\"line\">     console.log(chalk.green(&apos;New template added!\\n&apos;))</div><div class=\"line\">     console.log(chalk.grey(&apos;The last template list is: \\n&apos;))</div><div class=\"line\">     console.log(config)</div><div class=\"line\">     console.log(&apos;\\n&apos;)</div><div class=\"line\">     process.exit()</div><div class=\"line\">    &#125;)</div><div class=\"line\"> &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\">删除模板</div><div class=\"line\">同样的，在\\command文件夹下建立delete.js文件：</div><div class=\"line\"></div><div class=\"line\">&apos;use strict&apos;</div><div class=\"line\">const co = require(&apos;co&apos;)</div><div class=\"line\">const prompt = require(&apos;co-prompt&apos;)</div><div class=\"line\">const config = require(&apos;../templates&apos;)</div><div class=\"line\">const chalk = require(&apos;chalk&apos;)</div><div class=\"line\">const fs = require(&apos;fs&apos;)</div><div class=\"line\"></div><div class=\"line\">module.exports = () =&gt; &#123;</div><div class=\"line\">    co(function *() &#123;</div><div class=\"line\">        // 接收用户输入的参数</div><div class=\"line\">        let tplName = yield prompt(&apos;Template name: &apos;)</div><div class=\"line\"></div><div class=\"line\">        // 删除对应的模板</div><div class=\"line\">        if (config.tpl[tplName]) &#123;</div><div class=\"line\">            config.tpl[tplName] = undefined</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            console.log(chalk.red(&apos;Template does not exist!&apos;))</div><div class=\"line\">            process.exit()</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        // 写入template.json</div><div class=\"line\">        fs.writeFile(__dirname + &apos;/../templates.json&apos;, JSON.stringify(config),     &apos;utf-8&apos;, (err) =&gt; &#123;</div><div class=\"line\">            if (err) console.log(err)</div><div class=\"line\">            console.log(chalk.green(&apos;Template deleted!&apos;))</div><div class=\"line\">            console.log(chalk.grey(&apos;The last template list is: \\n&apos;))</div><div class=\"line\">            console.log(config)</div><div class=\"line\">            console.log(&apos;\\n&apos;)</div><div class=\"line\">            process.exit()</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\">罗列模板</div><div class=\"line\">建立list.js文件：</div><div class=\"line\"></div><div class=\"line\">&apos;use strict&apos;</div><div class=\"line\">const config = require(&apos;../templates&apos;)</div><div class=\"line\"></div><div class=\"line\">module.exports = () =&gt; &#123;</div><div class=\"line\">     console.log(config.tpl)</div><div class=\"line\">     process.exit()</div><div class=\"line\">&#125;</div><div class=\"line\">构建项目</div><div class=\"line\">现在来到我们最重要的部分——构建项目。同样的，在\\command目录下新建一个叫做init.js的文件：</div><div class=\"line\"></div><div class=\"line\">&apos;use strict&apos;</div><div class=\"line\">const exec = require(&apos;child_process&apos;).exec</div><div class=\"line\">const co = require(&apos;co&apos;)</div><div class=\"line\">const prompt = require(&apos;co-prompt&apos;)</div><div class=\"line\">const config = require(&apos;../templates&apos;)</div><div class=\"line\">const chalk = require(&apos;chalk&apos;)</div><div class=\"line\"></div><div class=\"line\">module.exports = () =&gt; &#123;</div><div class=\"line\"> co(function *() &#123;</div><div class=\"line\">    // 处理用户输入</div><div class=\"line\">      let tplName = yield prompt(&apos;Template name: &apos;)</div><div class=\"line\">      let projectName = yield prompt(&apos;Project name: &apos;)</div><div class=\"line\">      let gitUrl</div><div class=\"line\">      let branch</div><div class=\"line\"></div><div class=\"line\">    if (!config.tpl[tplName]) &#123;</div><div class=\"line\">        console.log(chalk.red(&apos;\\n × Template does not exit!&apos;))</div><div class=\"line\">        process.exit()</div><div class=\"line\">    &#125;</div><div class=\"line\">    gitUrl = config.tpl[tplName].url</div><div class=\"line\">    branch = config.tpl[tplName].branch</div><div class=\"line\"></div><div class=\"line\">    // git命令，远程拉取项目并自定义项目名</div><div class=\"line\">    let cmdStr = `git clone $&#123;gitUrl&#125; $&#123;projectName&#125; &amp;&amp; cd $&#123;projectName&#125; &amp;&amp; git checkout $&#123;branch&#125;`</div><div class=\"line\"></div><div class=\"line\">    console.log(chalk.white(&apos;\\n Start generating...&apos;))</div><div class=\"line\"></div><div class=\"line\">    exec(cmdStr, (error, stdout, stderr) =&gt; &#123;</div><div class=\"line\">      if (error) &#123;</div><div class=\"line\">        console.log(error)</div><div class=\"line\">        process.exit()</div><div class=\"line\">      &#125;</div><div class=\"line\">      console.log(chalk.green(&apos;\\n √ Generation completed!&apos;))</div><div class=\"line\">      console.log(`\\n cd $&#123;projectName&#125; &amp;&amp; npm install \\n`)</div><div class=\"line\">      process.exit()</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，这一部分代码也非常简单，关键的一句话是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let cmdStr = `git clone $&#123;gitUrl&#125; $&#123;projectName&#125; &amp;&amp; cd $&#123;projectName&#125; &amp;&amp; git checkout $&#123;branch&#125;`</div></pre></td></tr></table></figure></p>\n<p>它的作用正是从远程仓库克隆到自定义目录，并切换到对应的分支。熟悉git命令的同学应该明白，不熟悉的同学是时候补补课啦！</p>\n<p>全局使用<br>为了可以全局使用，我们需要在package.json里面设置一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;bin&quot;: &#123;</div><div class=\"line\">    &quot;scion&quot;: &quot;bin/scion&quot;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>本地调试的时候，在根目录下执行</p>\n<p>npm link<br>即可把scion命令绑定到全局，以后就可以直接以scion作为命令开头而无需敲入长长的node scion之类的命令了。</p>\n<p>现在我们的脚手架工具已经搭建好了，一起来尝试一下吧！</p>\n<p>使用测试<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">add | a 添加模版命令</div><div class=\"line\"></div><div class=\"line\">init | i 生成项目命令</div><div class=\"line\"></div><div class=\"line\">delete | d 删除模版命令 和 list | l 罗列模版命令</div></pre></td></tr></table></figure></p>\n<p>   大功告成啦！现在我们的整个脚手架工具已经搭建完成了，以后只需要知道模板的git https地址和branch就可以不断地往SCION上面添加，团队协作的话只需要分享SCION的templates.json文件就可以了。</p>\n<h3 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h3><p>   看起来并不复杂的东西，实际从零开始搭建也是颇费了一番心思。最大的难题是在开始的时候并不懂得如何像npm init那样可以一步一步地处理用户输入，只懂得一条命令行把所有的参数都带上，这样的用户体验真的很不好。研究了vue-cli和yoeman也没有找到相应的代码，只好不断地google，最后总算找到了一篇文章，可以用co和co-prompt这两个工具实现，再一次膜拜无所不能的TJ大神，也希望能够有小伙伴告诉我vue-cli它们是怎么实现的。</p>\n"},{"title":"非关系型数据库和关系型数据库比较","date":"2016-12-10T03:22:45.000Z","_content":"### 关系型数据库的特点\n![database-compare](http://oi28tswuq.bkt.clouddn.com/images/relative.png)\n常见的关系型数据库:Microsoft SQLServer,   Oracle, MySQL，  Microsoft Access.\nNot Only SQL简称NoSQL，泛指非关系型的数据库。\n常见NoSQL有那些？MongoDB,Hbase（HadoopDatabase） ,Redis.\n### Nosql数据库的分类：\n![Nosql](http://oi28tswuq.bkt.clouddn.com/images/Nosql.png)\n\n## NoSQL的优点/缺点\n### 优点:\n- 高可扩展性\n- 分布式计算\n- 低成本\n- 架构的灵活性，半结构化数据\n- 没有复杂的关系\n### 缺点:\n- 没有标准化\n- 有限的查询功能（到目前为止）\n- 最终一致性是不直观的程序 ","source":"_posts/data-compare.md","raw":"---\ntitle: 非关系型数据库和关系型数据库比较\ndate: 2016-12-10 11:22:45\ntags: mongoDB 数据库\n---\n### 关系型数据库的特点\n![database-compare](http://oi28tswuq.bkt.clouddn.com/images/relative.png)\n常见的关系型数据库:Microsoft SQLServer,   Oracle, MySQL，  Microsoft Access.\nNot Only SQL简称NoSQL，泛指非关系型的数据库。\n常见NoSQL有那些？MongoDB,Hbase（HadoopDatabase） ,Redis.\n### Nosql数据库的分类：\n![Nosql](http://oi28tswuq.bkt.clouddn.com/images/Nosql.png)\n\n## NoSQL的优点/缺点\n### 优点:\n- 高可扩展性\n- 分布式计算\n- 低成本\n- 架构的灵活性，半结构化数据\n- 没有复杂的关系\n### 缺点:\n- 没有标准化\n- 有限的查询功能（到目前为止）\n- 最终一致性是不直观的程序 ","slug":"data-compare","published":1,"updated":"2016-12-12T07:13:55.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv7h001gjgtu2bcced8r","content":"<h3 id=\"关系型数据库的特点\"><a href=\"#关系型数据库的特点\" class=\"headerlink\" title=\"关系型数据库的特点\"></a>关系型数据库的特点</h3><p><img src=\"http://oi28tswuq.bkt.clouddn.com/images/relative.png\" alt=\"database-compare\"><br>常见的关系型数据库:Microsoft SQLServer,   Oracle, MySQL，  Microsoft Access.<br>Not Only SQL简称NoSQL，泛指非关系型的数据库。<br>常见NoSQL有那些？MongoDB,Hbase（HadoopDatabase） ,Redis.</p>\n<h3 id=\"Nosql数据库的分类：\"><a href=\"#Nosql数据库的分类：\" class=\"headerlink\" title=\"Nosql数据库的分类：\"></a>Nosql数据库的分类：</h3><p><img src=\"http://oi28tswuq.bkt.clouddn.com/images/Nosql.png\" alt=\"Nosql\"></p>\n<h2 id=\"NoSQL的优点-缺点\"><a href=\"#NoSQL的优点-缺点\" class=\"headerlink\" title=\"NoSQL的优点/缺点\"></a>NoSQL的优点/缺点</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点:\"></a>优点:</h3><ul>\n<li>高可扩展性</li>\n<li>分布式计算</li>\n<li>低成本</li>\n<li>架构的灵活性，半结构化数据</li>\n<li>没有复杂的关系<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点:\"></a>缺点:</h3></li>\n<li>没有标准化</li>\n<li>有限的查询功能（到目前为止）</li>\n<li>最终一致性是不直观的程序 </li>\n</ul>\n","excerpt":"","more":"<h3 id=\"关系型数据库的特点\"><a href=\"#关系型数据库的特点\" class=\"headerlink\" title=\"关系型数据库的特点\"></a>关系型数据库的特点</h3><p><img src=\"http://oi28tswuq.bkt.clouddn.com/images/relative.png\" alt=\"database-compare\"><br>常见的关系型数据库:Microsoft SQLServer,   Oracle, MySQL，  Microsoft Access.<br>Not Only SQL简称NoSQL，泛指非关系型的数据库。<br>常见NoSQL有那些？MongoDB,Hbase（HadoopDatabase） ,Redis.</p>\n<h3 id=\"Nosql数据库的分类：\"><a href=\"#Nosql数据库的分类：\" class=\"headerlink\" title=\"Nosql数据库的分类：\"></a>Nosql数据库的分类：</h3><p><img src=\"http://oi28tswuq.bkt.clouddn.com/images/Nosql.png\" alt=\"Nosql\"></p>\n<h2 id=\"NoSQL的优点-缺点\"><a href=\"#NoSQL的优点-缺点\" class=\"headerlink\" title=\"NoSQL的优点/缺点\"></a>NoSQL的优点/缺点</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点:\"></a>优点:</h3><ul>\n<li>高可扩展性</li>\n<li>分布式计算</li>\n<li>低成本</li>\n<li>架构的灵活性，半结构化数据</li>\n<li>没有复杂的关系<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点:\"></a>缺点:</h3></li>\n<li>没有标准化</li>\n<li>有限的查询功能（到目前为止）</li>\n<li>最终一致性是不直观的程序 </li>\n</ul>\n"},{"title":"如何在本地进行微信公众号的开发调试","date":"2017-01-10T09:43:54.000Z","_content":"在进行微信公众号开发时，以前必须要有外网域名才能收到微信服务器的推送，这给开发和调试带来很大的不便。\n\n现在方便了，QQ浏览器提供了微信公众号调试工具，开发者可以在自己的开发机上进行开发和调试，不再需要外网IP和域名。不仅可以直观看到已接收和已发送的消息内容和事件，方便开发和问题定位，还可以重复发送已接收的微信报文，避免调试时频繁操作手机\n\n原理如下图：\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/debugwechat.png-public)\n</div>\n调试工具内置了一个server，监听你本地运行的程序，并为你生成一个外网的url，你只需要在公众号的开发信息中配置上这个url，公众号收到消息后，就会通过这个url转发到调试工具上，调试工具再转给你的本地运行程序。\n\n#### 使用方法：\n\n（1）在本机启动运行自己程序的server\n\n（2）打开qq浏览器，在应用中心中安装“微信调试工具”，安装完成后，选择“服务器端调试”\n\n（3）填写本地server的ip和端口号，调试工具会返回一个外部URL\n\n（4）到公众号后台开发者配置信息中填写这个URL\n\n（5）用微信向公众号发送消息测试\n\n注：QQ浏览器这种调试方式已经不更新了，推荐使用其他调试工具如下：\n[推荐工具](http://blog.qqbrowser.cc/)http://blog.qqbrowser.cc/\n","source":"_posts/debugwechat.md","raw":"---\ntitle: 如何在本地进行微信公众号的开发调试\ndate: 2017-01-10 17:43:54\ntags: wechat\n---\n在进行微信公众号开发时，以前必须要有外网域名才能收到微信服务器的推送，这给开发和调试带来很大的不便。\n\n现在方便了，QQ浏览器提供了微信公众号调试工具，开发者可以在自己的开发机上进行开发和调试，不再需要外网IP和域名。不仅可以直观看到已接收和已发送的消息内容和事件，方便开发和问题定位，还可以重复发送已接收的微信报文，避免调试时频繁操作手机\n\n原理如下图：\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/debugwechat.png-public)\n</div>\n调试工具内置了一个server，监听你本地运行的程序，并为你生成一个外网的url，你只需要在公众号的开发信息中配置上这个url，公众号收到消息后，就会通过这个url转发到调试工具上，调试工具再转给你的本地运行程序。\n\n#### 使用方法：\n\n（1）在本机启动运行自己程序的server\n\n（2）打开qq浏览器，在应用中心中安装“微信调试工具”，安装完成后，选择“服务器端调试”\n\n（3）填写本地server的ip和端口号，调试工具会返回一个外部URL\n\n（4）到公众号后台开发者配置信息中填写这个URL\n\n（5）用微信向公众号发送消息测试\n\n注：QQ浏览器这种调试方式已经不更新了，推荐使用其他调试工具如下：\n[推荐工具](http://blog.qqbrowser.cc/)http://blog.qqbrowser.cc/\n","slug":"debugwechat","published":1,"updated":"2017-01-10T09:51:02.447Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv7j001ijgtuuqtq2vvf","content":"<p>在进行微信公众号开发时，以前必须要有外网域名才能收到微信服务器的推送，这给开发和调试带来很大的不便。</p>\n<p>现在方便了，QQ浏览器提供了微信公众号调试工具，开发者可以在自己的开发机上进行开发和调试，不再需要外网IP和域名。不仅可以直观看到已接收和已发送的消息内容和事件，方便开发和问题定位，还可以重复发送已接收的微信报文，避免调试时频繁操作手机</p>\n<p>原理如下图：</p>\n<p><div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/debugwechat.png-public\" alt=\"\"><br></div><br>调试工具内置了一个server，监听你本地运行的程序，并为你生成一个外网的url，你只需要在公众号的开发信息中配置上这个url，公众号收到消息后，就会通过这个url转发到调试工具上，调试工具再转给你的本地运行程序。</p>\n<h4 id=\"使用方法：\"><a href=\"#使用方法：\" class=\"headerlink\" title=\"使用方法：\"></a>使用方法：</h4><p>（1）在本机启动运行自己程序的server</p>\n<p>（2）打开qq浏览器，在应用中心中安装“微信调试工具”，安装完成后，选择“服务器端调试”</p>\n<p>（3）填写本地server的ip和端口号，调试工具会返回一个外部URL</p>\n<p>（4）到公众号后台开发者配置信息中填写这个URL</p>\n<p>（5）用微信向公众号发送消息测试</p>\n<p>注：QQ浏览器这种调试方式已经不更新了，推荐使用其他调试工具如下：<br><a href=\"http://blog.qqbrowser.cc/\" target=\"_blank\" rel=\"external\">推荐工具</a><a href=\"http://blog.qqbrowser.cc/\" target=\"_blank\" rel=\"external\">http://blog.qqbrowser.cc/</a></p>\n","excerpt":"","more":"<p>在进行微信公众号开发时，以前必须要有外网域名才能收到微信服务器的推送，这给开发和调试带来很大的不便。</p>\n<p>现在方便了，QQ浏览器提供了微信公众号调试工具，开发者可以在自己的开发机上进行开发和调试，不再需要外网IP和域名。不仅可以直观看到已接收和已发送的消息内容和事件，方便开发和问题定位，还可以重复发送已接收的微信报文，避免调试时频繁操作手机</p>\n<p>原理如下图：</p>\n<p><div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/debugwechat.png-public\" alt=\"\"><br></div><br>调试工具内置了一个server，监听你本地运行的程序，并为你生成一个外网的url，你只需要在公众号的开发信息中配置上这个url，公众号收到消息后，就会通过这个url转发到调试工具上，调试工具再转给你的本地运行程序。</p>\n<h4 id=\"使用方法：\"><a href=\"#使用方法：\" class=\"headerlink\" title=\"使用方法：\"></a>使用方法：</h4><p>（1）在本机启动运行自己程序的server</p>\n<p>（2）打开qq浏览器，在应用中心中安装“微信调试工具”，安装完成后，选择“服务器端调试”</p>\n<p>（3）填写本地server的ip和端口号，调试工具会返回一个外部URL</p>\n<p>（4）到公众号后台开发者配置信息中填写这个URL</p>\n<p>（5）用微信向公众号发送消息测试</p>\n<p>注：QQ浏览器这种调试方式已经不更新了，推荐使用其他调试工具如下：<br><a href=\"http://blog.qqbrowser.cc/\">推荐工具</a><a href=\"http://blog.qqbrowser.cc/\">http://blog.qqbrowser.cc/</a></p>\n"},{"title":"简述angular自定义过滤器在页面和控制器中的使用","date":"2016-05-26T02:06:02.000Z","_content":"AngularJS另一个特点就是提供了过滤器，可以通过操作UNIX下管道的方式，操作数据结果。\n通过使用管道，可以便于双向的数据绑定中视图的展现。\n过滤器在处理过程中，将数据变成新的格式，而且可以使用管道这种链式风格，还能接受附加的参数。\n##### 首先设置自定义过滤器\n```\napp..module('myApp')\n    　　　　　　　.filter('filterName',function(){\n    　　　　　　　　　return function(要过滤的对象,参数1,参数2,...){\n                            // ...做一些事情\n    　　　　　　　　　　　return Obj; //这里返回的是过滤后的对象\n    　　　　　　　　　}\n    　　　　　　　});\n```\n##### 在页面中使用：\n```\n{{obj | filterName}} ====> obj是要过滤的对象\n```\n\\｜这里的竖线是一种管道功能，如果对linux比较熟悉的话，这块的｜根linux的管道功能，基本是一样的\n\n##### 在控制器中使用：\n```\n//首先要注入$filter,使用的时候\n$filter(\"filterName\")(要过滤的对象,参数1,参数2,...);\n```\nfilter过滤器主要用来过滤一个数组数据并返回一个包含子数组数据的新数组。\n比如，在客户端搜索时，我们可以快速的从数组中过滤出我们想要的结果。\n这个filter方法接收一个string，object，或者function参数用来选择/移除数组元素。\n我们也可以在JavaScript中使用$filter服务来调用过滤器，还拿字符串大写来举例:\n```\napp.controller('DemoController', ['$scope', '$filter', \n function($scope, $filter) {\n  \n  $scope.name = $filter('lowercase')('Ari');\n}]);\n\n```\n如何传递参数到filter呢？只需要把参数放在filter之后，中间加个冒号（如果有多个参数要传递，在每个参数后加上冒号）比如，数字过滤器可以帮助我们限制数字的位数，如果想显示两位小数，加上number:2就可以了\n```\n{{ 123.456789 | number:2 }}\n\n```\n注： 意：| lowercase |uppercase管道命令可以有多个\n```\n{{ name |uppercase | lowercase  }}\n\n```\n\n \n\n\n\n","source":"_posts/defined-filter.md","raw":"---\ntitle: 简述angular自定义过滤器在页面和控制器中的使用\ndate: 2016-05-26 10:06:02\ntags: angular filter\n---\nAngularJS另一个特点就是提供了过滤器，可以通过操作UNIX下管道的方式，操作数据结果。\n通过使用管道，可以便于双向的数据绑定中视图的展现。\n过滤器在处理过程中，将数据变成新的格式，而且可以使用管道这种链式风格，还能接受附加的参数。\n##### 首先设置自定义过滤器\n```\napp..module('myApp')\n    　　　　　　　.filter('filterName',function(){\n    　　　　　　　　　return function(要过滤的对象,参数1,参数2,...){\n                            // ...做一些事情\n    　　　　　　　　　　　return Obj; //这里返回的是过滤后的对象\n    　　　　　　　　　}\n    　　　　　　　});\n```\n##### 在页面中使用：\n```\n{{obj | filterName}} ====> obj是要过滤的对象\n```\n\\｜这里的竖线是一种管道功能，如果对linux比较熟悉的话，这块的｜根linux的管道功能，基本是一样的\n\n##### 在控制器中使用：\n```\n//首先要注入$filter,使用的时候\n$filter(\"filterName\")(要过滤的对象,参数1,参数2,...);\n```\nfilter过滤器主要用来过滤一个数组数据并返回一个包含子数组数据的新数组。\n比如，在客户端搜索时，我们可以快速的从数组中过滤出我们想要的结果。\n这个filter方法接收一个string，object，或者function参数用来选择/移除数组元素。\n我们也可以在JavaScript中使用$filter服务来调用过滤器，还拿字符串大写来举例:\n```\napp.controller('DemoController', ['$scope', '$filter', \n function($scope, $filter) {\n  \n  $scope.name = $filter('lowercase')('Ari');\n}]);\n\n```\n如何传递参数到filter呢？只需要把参数放在filter之后，中间加个冒号（如果有多个参数要传递，在每个参数后加上冒号）比如，数字过滤器可以帮助我们限制数字的位数，如果想显示两位小数，加上number:2就可以了\n```\n{{ 123.456789 | number:2 }}\n\n```\n注： 意：| lowercase |uppercase管道命令可以有多个\n```\n{{ name |uppercase | lowercase  }}\n\n```\n\n \n\n\n\n","slug":"defined-filter","published":1,"updated":"2016-12-26T08:24:04.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv7k001kjgtukb42eebn","content":"<p>AngularJS另一个特点就是提供了过滤器，可以通过操作UNIX下管道的方式，操作数据结果。<br>通过使用管道，可以便于双向的数据绑定中视图的展现。<br>过滤器在处理过程中，将数据变成新的格式，而且可以使用管道这种链式风格，还能接受附加的参数。</p>\n<h5 id=\"首先设置自定义过滤器\"><a href=\"#首先设置自定义过滤器\" class=\"headerlink\" title=\"首先设置自定义过滤器\"></a>首先设置自定义过滤器</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">app..module(&apos;myApp&apos;)</div><div class=\"line\">    　　　　　　　.filter(&apos;filterName&apos;,function()&#123;</div><div class=\"line\">    　　　　　　　　　return function(要过滤的对象,参数1,参数2,...)&#123;</div><div class=\"line\">                            // ...做一些事情</div><div class=\"line\">    　　　　　　　　　　　return Obj; //这里返回的是过滤后的对象</div><div class=\"line\">    　　　　　　　　　&#125;</div><div class=\"line\">    　　　　　　　&#125;);</div></pre></td></tr></table></figure>\n<h5 id=\"在页面中使用：\"><a href=\"#在页面中使用：\" class=\"headerlink\" title=\"在页面中使用：\"></a>在页面中使用：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123;obj | filterName&#125;&#125; ====&gt; obj是要过滤的对象</div></pre></td></tr></table></figure>\n<p>\\｜这里的竖线是一种管道功能，如果对linux比较熟悉的话，这块的｜根linux的管道功能，基本是一样的</p>\n<h5 id=\"在控制器中使用：\"><a href=\"#在控制器中使用：\" class=\"headerlink\" title=\"在控制器中使用：\"></a>在控制器中使用：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//首先要注入$filter,使用的时候</div><div class=\"line\">$filter(&quot;filterName&quot;)(要过滤的对象,参数1,参数2,...);</div></pre></td></tr></table></figure>\n<p>filter过滤器主要用来过滤一个数组数据并返回一个包含子数组数据的新数组。<br>比如，在客户端搜索时，我们可以快速的从数组中过滤出我们想要的结果。<br>这个filter方法接收一个string，object，或者function参数用来选择/移除数组元素。<br>我们也可以在JavaScript中使用$filter服务来调用过滤器，还拿字符串大写来举例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.controller(&apos;DemoController&apos;, [&apos;$scope&apos;, &apos;$filter&apos;, </div><div class=\"line\"> function($scope, $filter) &#123;</div><div class=\"line\">  </div><div class=\"line\">  $scope.name = $filter(&apos;lowercase&apos;)(&apos;Ari&apos;);</div><div class=\"line\">&#125;]);</div></pre></td></tr></table></figure></p>\n<p>如何传递参数到filter呢？只需要把参数放在filter之后，中间加个冒号（如果有多个参数要传递，在每个参数后加上冒号）比如，数字过滤器可以帮助我们限制数字的位数，如果想显示两位小数，加上number:2就可以了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; 123.456789 | number:2 &#125;&#125;</div></pre></td></tr></table></figure></p>\n<p>注： 意：| lowercase |uppercase管道命令可以有多个<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; name |uppercase | lowercase  &#125;&#125;</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>AngularJS另一个特点就是提供了过滤器，可以通过操作UNIX下管道的方式，操作数据结果。<br>通过使用管道，可以便于双向的数据绑定中视图的展现。<br>过滤器在处理过程中，将数据变成新的格式，而且可以使用管道这种链式风格，还能接受附加的参数。</p>\n<h5 id=\"首先设置自定义过滤器\"><a href=\"#首先设置自定义过滤器\" class=\"headerlink\" title=\"首先设置自定义过滤器\"></a>首先设置自定义过滤器</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">app..module(&apos;myApp&apos;)</div><div class=\"line\">    　　　　　　　.filter(&apos;filterName&apos;,function()&#123;</div><div class=\"line\">    　　　　　　　　　return function(要过滤的对象,参数1,参数2,...)&#123;</div><div class=\"line\">                            // ...做一些事情</div><div class=\"line\">    　　　　　　　　　　　return Obj; //这里返回的是过滤后的对象</div><div class=\"line\">    　　　　　　　　　&#125;</div><div class=\"line\">    　　　　　　　&#125;);</div></pre></td></tr></table></figure>\n<h5 id=\"在页面中使用：\"><a href=\"#在页面中使用：\" class=\"headerlink\" title=\"在页面中使用：\"></a>在页面中使用：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123;obj | filterName&#125;&#125; ====&gt; obj是要过滤的对象</div></pre></td></tr></table></figure>\n<p>\\｜这里的竖线是一种管道功能，如果对linux比较熟悉的话，这块的｜根linux的管道功能，基本是一样的</p>\n<h5 id=\"在控制器中使用：\"><a href=\"#在控制器中使用：\" class=\"headerlink\" title=\"在控制器中使用：\"></a>在控制器中使用：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//首先要注入$filter,使用的时候</div><div class=\"line\">$filter(&quot;filterName&quot;)(要过滤的对象,参数1,参数2,...);</div></pre></td></tr></table></figure>\n<p>filter过滤器主要用来过滤一个数组数据并返回一个包含子数组数据的新数组。<br>比如，在客户端搜索时，我们可以快速的从数组中过滤出我们想要的结果。<br>这个filter方法接收一个string，object，或者function参数用来选择/移除数组元素。<br>我们也可以在JavaScript中使用$filter服务来调用过滤器，还拿字符串大写来举例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.controller(&apos;DemoController&apos;, [&apos;$scope&apos;, &apos;$filter&apos;, </div><div class=\"line\"> function($scope, $filter) &#123;</div><div class=\"line\">  </div><div class=\"line\">  $scope.name = $filter(&apos;lowercase&apos;)(&apos;Ari&apos;);</div><div class=\"line\">&#125;]);</div></pre></td></tr></table></figure></p>\n<p>如何传递参数到filter呢？只需要把参数放在filter之后，中间加个冒号（如果有多个参数要传递，在每个参数后加上冒号）比如，数字过滤器可以帮助我们限制数字的位数，如果想显示两位小数，加上number:2就可以了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; 123.456789 | number:2 &#125;&#125;</div></pre></td></tr></table></figure></p>\n<p>注： 意：| lowercase |uppercase管道命令可以有多个<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123; name |uppercase | lowercase  &#125;&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"使用Docker快速发布nodejs应用","date":"2016-12-04T02:47:19.000Z","_content":"使用docker发布一个nginx+nodejs(express,koa)项目，然后使用jenkins进行简单地持续集成发布工作，nodejs配合docker和jenkins可以更加方便地管理我们的应用！\n对docker的理解：未完待更新。。。临时有事。。","source":"_posts/docker.md","raw":"---\ntitle: 使用Docker快速发布nodejs应用\ndate: 2016-12-04 10:47:19\ntags:\n---\n使用docker发布一个nginx+nodejs(express,koa)项目，然后使用jenkins进行简单地持续集成发布工作，nodejs配合docker和jenkins可以更加方便地管理我们的应用！\n对docker的理解：未完待更新。。。临时有事。。","slug":"docker","published":1,"updated":"2016-12-12T09:04:34.810Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv7m001mjgtukd22clij","content":"<p>使用docker发布一个nginx+nodejs(express,koa)项目，然后使用jenkins进行简单地持续集成发布工作，nodejs配合docker和jenkins可以更加方便地管理我们的应用！<br>对docker的理解：未完待更新。。。临时有事。。</p>\n","excerpt":"","more":"<p>使用docker发布一个nginx+nodejs(express,koa)项目，然后使用jenkins进行简单地持续集成发布工作，nodejs配合docker和jenkins可以更加方便地管理我们的应用！<br>对docker的理解：未完待更新。。。临时有事。。</p>\n"},{"title":"js设置document.domain实现跨域的相关注意事项","date":"2016-12-13T01:54:28.000Z","_content":"　　对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。具体的做法是可以在http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上document.domain = ‘a.com’；\n　　本文实例分析了js设置document.domain实现跨域的注意点,仅供参考，具体分析如下：\n```\n　　document.domain\n```\n　　用来得到当前网页的域名。\n　　比如在控制台输入：\n　　代码如下:\n　　```\n    console.log(document.domain);//www.webywx.com\n    ```\n　　我们也可以给document.domain属性赋值，不过是有限制的，你只能赋成当前的域名或者基础域名。\n　　例如：代码如下:\n```\n    document.domain=\"webywx.com\";\n    document.domain=\"www.webywx.com\";\n```\n　　上面的赋值都是成功的，因为www.webywx.com是当前的域名，而webywx.com是基础域名。\n　　但是下面的赋值就会出来\"参数无效\"的错误：\n　　```\n　　document.domain=\"yanwenxi.site\"\n    document.domain=\"www.yanwenxi.site\"\n    ```\n　　因为yanwenxi.site与www.yanwenxi.site不是当前的域名也不是当前域名的基础域名，所以会有参数错误出现。\n　　这是为了防止有人恶意修改document.domain来实现跨域偷取数据。\n### 利用document.domain 实现跨域：\n　　*前提条件*：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域\n　　Javascript出于对安全性的考虑，而禁止两个或者多个不同域的页面进行互相操作。\n　　相同域的页面在相互操作的时候不会有任何问题。\n　　比如在：aaa.com的一个网页(a.html)里面 利用iframe引入了一个bbb.com里的一个网页(b.html)。\n　　这时在a.html里面可以看到b.html里的内容，但是却不能利用javascript来操作它。因为这两个页面属于不同的域，在操作之前，js会检测两个页面的域是否相等，如果相等，就允许其操作，如果不相等，就会拒绝操作。\n　　这里不可能把a.html与b.html利用JS改成同一个域的。因为它们的基础域名不相等。(强制用JS将它们改成相等的域的话会报跟上面一样的\"参数无效错误。\")\n　　所以如果在a.html里引入aaa.com里的另一个网页，是不会有这个问题的，因为域相等。\n　　有另一种情况，两个子域名：\n```\n　　aaa.xxx.com\n　　bbb.xxx.com\n```\n　　aaa里的一个网页(a.html)引入了bbb 里的一个网页(b.html)，\n　　这时a.html里同样是不能操作b.html里面的内容的。\n　　因为document.domain不一样，一个是aaa.xxx.com，另一个是bbb.xxx.com。\n　　这时我们就可以通过Javascript，将两个页面的domain改成一样的，\n　　需要在a.html里与b.html里都加入：\n　　```\n　　document.domain = \"xxx.com\";\n    ```\n　　这样这两个页面就可以互相操作了。也就是实现了同一基础域名之间的\"跨域\"。\n　　备注：这种方式适用于{www.webywx.com, webywx.com, script.webywx.com, css.webywx.com}中的任何页面相互通信。某一页面的domain默认等于window.location.hostname。主域名是不带www的域名，例如webywx.com，主域名前面带前缀的通常都为二级域名或多级域名，例如www.a.com其实是二级域名.","source":"_posts/document-domain.md","raw":"---\ntitle: js设置document.domain实现跨域的相关注意事项\ndate: 2016-12-13 09:54:28\ntags: js、跨域、document.domain\n---\n　　对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。具体的做法是可以在http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上document.domain = ‘a.com’；\n　　本文实例分析了js设置document.domain实现跨域的注意点,仅供参考，具体分析如下：\n```\n　　document.domain\n```\n　　用来得到当前网页的域名。\n　　比如在控制台输入：\n　　代码如下:\n　　```\n    console.log(document.domain);//www.webywx.com\n    ```\n　　我们也可以给document.domain属性赋值，不过是有限制的，你只能赋成当前的域名或者基础域名。\n　　例如：代码如下:\n```\n    document.domain=\"webywx.com\";\n    document.domain=\"www.webywx.com\";\n```\n　　上面的赋值都是成功的，因为www.webywx.com是当前的域名，而webywx.com是基础域名。\n　　但是下面的赋值就会出来\"参数无效\"的错误：\n　　```\n　　document.domain=\"yanwenxi.site\"\n    document.domain=\"www.yanwenxi.site\"\n    ```\n　　因为yanwenxi.site与www.yanwenxi.site不是当前的域名也不是当前域名的基础域名，所以会有参数错误出现。\n　　这是为了防止有人恶意修改document.domain来实现跨域偷取数据。\n### 利用document.domain 实现跨域：\n　　*前提条件*：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域\n　　Javascript出于对安全性的考虑，而禁止两个或者多个不同域的页面进行互相操作。\n　　相同域的页面在相互操作的时候不会有任何问题。\n　　比如在：aaa.com的一个网页(a.html)里面 利用iframe引入了一个bbb.com里的一个网页(b.html)。\n　　这时在a.html里面可以看到b.html里的内容，但是却不能利用javascript来操作它。因为这两个页面属于不同的域，在操作之前，js会检测两个页面的域是否相等，如果相等，就允许其操作，如果不相等，就会拒绝操作。\n　　这里不可能把a.html与b.html利用JS改成同一个域的。因为它们的基础域名不相等。(强制用JS将它们改成相等的域的话会报跟上面一样的\"参数无效错误。\")\n　　所以如果在a.html里引入aaa.com里的另一个网页，是不会有这个问题的，因为域相等。\n　　有另一种情况，两个子域名：\n```\n　　aaa.xxx.com\n　　bbb.xxx.com\n```\n　　aaa里的一个网页(a.html)引入了bbb 里的一个网页(b.html)，\n　　这时a.html里同样是不能操作b.html里面的内容的。\n　　因为document.domain不一样，一个是aaa.xxx.com，另一个是bbb.xxx.com。\n　　这时我们就可以通过Javascript，将两个页面的domain改成一样的，\n　　需要在a.html里与b.html里都加入：\n　　```\n　　document.domain = \"xxx.com\";\n    ```\n　　这样这两个页面就可以互相操作了。也就是实现了同一基础域名之间的\"跨域\"。\n　　备注：这种方式适用于{www.webywx.com, webywx.com, script.webywx.com, css.webywx.com}中的任何页面相互通信。某一页面的domain默认等于window.location.hostname。主域名是不带www的域名，例如webywx.com，主域名前面带前缀的通常都为二级域名或多级域名，例如www.a.com其实是二级域名.","slug":"document-domain","published":1,"updated":"2016-12-13T02:18:30.068Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv7p001njgtuon9tatt1","content":"<p>　　对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。具体的做法是可以在<a href=\"http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上document.domain\" target=\"_blank\" rel=\"external\">http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上document.domain</a> = ‘a.com’；<br>　　本文实例分析了js设置document.domain实现跨域的注意点,仅供参考，具体分析如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　document.domain</div></pre></td></tr></table></figure></p>\n<p>　　用来得到当前网页的域名。<br>　　比如在控制台输入：<br>　　代码如下:<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log(document.domain);//www.webywx.com</div></pre></td></tr></table></figure></p>\n<p>　　我们也可以给document.domain属性赋值，不过是有限制的，你只能赋成当前的域名或者基础域名。<br>　　例如：代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">document.domain=&quot;webywx.com&quot;;</div><div class=\"line\">document.domain=&quot;www.webywx.com&quot;;</div></pre></td></tr></table></figure></p>\n<p>　　上面的赋值都是成功的，因为www.webywx.com是当前的域名，而webywx.com是基础域名。<br>　　但是下面的赋值就会出来”参数无效”的错误：<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　document.domain=&quot;yanwenxi.site&quot;</div><div class=\"line\">document.domain=&quot;www.yanwenxi.site&quot;</div></pre></td></tr></table></figure></p>\n<p>　　因为yanwenxi.site与www.yanwenxi.site不是当前的域名也不是当前域名的基础域名，所以会有参数错误出现。<br>　　这是为了防止有人恶意修改document.domain来实现跨域偷取数据。</p>\n<h3 id=\"利用document-domain-实现跨域：\"><a href=\"#利用document-domain-实现跨域：\" class=\"headerlink\" title=\"利用document.domain 实现跨域：\"></a>利用document.domain 实现跨域：</h3><p>　　<em>前提条件</em>：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域<br>　　Javascript出于对安全性的考虑，而禁止两个或者多个不同域的页面进行互相操作。<br>　　相同域的页面在相互操作的时候不会有任何问题。<br>　　比如在：aaa.com的一个网页(a.html)里面 利用iframe引入了一个bbb.com里的一个网页(b.html)。<br>　　这时在a.html里面可以看到b.html里的内容，但是却不能利用javascript来操作它。因为这两个页面属于不同的域，在操作之前，js会检测两个页面的域是否相等，如果相等，就允许其操作，如果不相等，就会拒绝操作。<br>　　这里不可能把a.html与b.html利用JS改成同一个域的。因为它们的基础域名不相等。(强制用JS将它们改成相等的域的话会报跟上面一样的”参数无效错误。”)<br>　　所以如果在a.html里引入aaa.com里的另一个网页，是不会有这个问题的，因为域相等。<br>　　有另一种情况，两个子域名：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　aaa.xxx.com</div><div class=\"line\">　　bbb.xxx.com</div></pre></td></tr></table></figure></p>\n<p>　　aaa里的一个网页(a.html)引入了bbb 里的一个网页(b.html)，<br>　　这时a.html里同样是不能操作b.html里面的内容的。<br>　　因为document.domain不一样，一个是aaa.xxx.com，另一个是bbb.xxx.com。<br>　　这时我们就可以通过Javascript，将两个页面的domain改成一样的，<br>　　需要在a.html里与b.html里都加入：<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　document.domain = &quot;xxx.com&quot;;</div></pre></td></tr></table></figure></p>\n<p>　　这样这两个页面就可以互相操作了。也就是实现了同一基础域名之间的”跨域”。<br>　　备注：这种方式适用于{www.webywx.com, webywx.com, script.webywx.com, css.webywx.com}中的任何页面相互通信。某一页面的domain默认等于window.location.hostname。主域名是不带www的域名，例如webywx.com，主域名前面带前缀的通常都为二级域名或多级域名，例如www.a.com其实是二级域名.</p>\n","excerpt":"","more":"<p>　　对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。具体的做法是可以在<a href=\"http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上document.domain\">http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上document.domain</a> = ‘a.com’；<br>　　本文实例分析了js设置document.domain实现跨域的注意点,仅供参考，具体分析如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　document.domain</div></pre></td></tr></table></figure></p>\n<p>　　用来得到当前网页的域名。<br>　　比如在控制台输入：<br>　　代码如下:<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log(document.domain);//www.webywx.com</div></pre></td></tr></table></figure></p>\n<p>　　我们也可以给document.domain属性赋值，不过是有限制的，你只能赋成当前的域名或者基础域名。<br>　　例如：代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">document.domain=&quot;webywx.com&quot;;</div><div class=\"line\">document.domain=&quot;www.webywx.com&quot;;</div></pre></td></tr></table></figure></p>\n<p>　　上面的赋值都是成功的，因为www.webywx.com是当前的域名，而webywx.com是基础域名。<br>　　但是下面的赋值就会出来”参数无效”的错误：<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　document.domain=&quot;yanwenxi.site&quot;</div><div class=\"line\">document.domain=&quot;www.yanwenxi.site&quot;</div></pre></td></tr></table></figure></p>\n<p>　　因为yanwenxi.site与www.yanwenxi.site不是当前的域名也不是当前域名的基础域名，所以会有参数错误出现。<br>　　这是为了防止有人恶意修改document.domain来实现跨域偷取数据。</p>\n<h3 id=\"利用document-domain-实现跨域：\"><a href=\"#利用document-domain-实现跨域：\" class=\"headerlink\" title=\"利用document.domain 实现跨域：\"></a>利用document.domain 实现跨域：</h3><p>　　<em>前提条件</em>：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域<br>　　Javascript出于对安全性的考虑，而禁止两个或者多个不同域的页面进行互相操作。<br>　　相同域的页面在相互操作的时候不会有任何问题。<br>　　比如在：aaa.com的一个网页(a.html)里面 利用iframe引入了一个bbb.com里的一个网页(b.html)。<br>　　这时在a.html里面可以看到b.html里的内容，但是却不能利用javascript来操作它。因为这两个页面属于不同的域，在操作之前，js会检测两个页面的域是否相等，如果相等，就允许其操作，如果不相等，就会拒绝操作。<br>　　这里不可能把a.html与b.html利用JS改成同一个域的。因为它们的基础域名不相等。(强制用JS将它们改成相等的域的话会报跟上面一样的”参数无效错误。”)<br>　　所以如果在a.html里引入aaa.com里的另一个网页，是不会有这个问题的，因为域相等。<br>　　有另一种情况，两个子域名：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　aaa.xxx.com</div><div class=\"line\">　　bbb.xxx.com</div></pre></td></tr></table></figure></p>\n<p>　　aaa里的一个网页(a.html)引入了bbb 里的一个网页(b.html)，<br>　　这时a.html里同样是不能操作b.html里面的内容的。<br>　　因为document.domain不一样，一个是aaa.xxx.com，另一个是bbb.xxx.com。<br>　　这时我们就可以通过Javascript，将两个页面的domain改成一样的，<br>　　需要在a.html里与b.html里都加入：<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　document.domain = &quot;xxx.com&quot;;</div></pre></td></tr></table></figure></p>\n<p>　　这样这两个页面就可以互相操作了。也就是实现了同一基础域名之间的”跨域”。<br>　　备注：这种方式适用于{www.webywx.com, webywx.com, script.webywx.com, css.webywx.com}中的任何页面相互通信。某一页面的domain默认等于window.location.hostname。主域名是不带www的域名，例如webywx.com，主域名前面带前缀的通常都为二级域名或多级域名，例如www.a.com其实是二级域名.</p>\n"},{"title":"js中的高阶函数","date":"2017-01-03T05:30:49.000Z","_content":"高阶函数英文叫Higher-order function。\n高阶函数是指操作函数的函数，它接收一个或者多个函数作为参数，或者返回一个新函数。此外，还依赖与闭包的特性，来保存中间过程中输入的参数。\n#### 高阶函数是至少满足下列一个条件的函数：\n1.接受函数作为输入 2.返回一个函数\n#### 应用场景\n1.函数作为参数传递，这种情况在需要callback的地方非常多，另外尤其是在ajax异步请求和绑定事件中，举一个简单的array方法sort的例子\n\narray的sort方法拥有自己的默认方法，但是如果你以为他是万能的那就错了，他实现的是按照字符编码来进行排序，在最常见的数字排序使用中我们一般都是使用自己定义的方法作为参数覆盖默认方法：\n```\n[1,3,2,4].sort( function( a, b ){  \n   return a-b;  \n});  \n//[1,2,3,4]\n```\n以上代码实现的就是基于sort函数的最简单的数字升序自定义方法，其将一整个自定义方法作为了参数传递给了sort方法。\n\n2.函数作为返回值输出，实现闭包时经常有函数返回值作为闭包私有变量访问的接口.\n\n","source":"_posts/gaojiefunction.md","raw":"---\ntitle: js中的高阶函数\ndate: 2017-01-03 13:30:49\ntags: js Higher-order-function\n---\n高阶函数英文叫Higher-order function。\n高阶函数是指操作函数的函数，它接收一个或者多个函数作为参数，或者返回一个新函数。此外，还依赖与闭包的特性，来保存中间过程中输入的参数。\n#### 高阶函数是至少满足下列一个条件的函数：\n1.接受函数作为输入 2.返回一个函数\n#### 应用场景\n1.函数作为参数传递，这种情况在需要callback的地方非常多，另外尤其是在ajax异步请求和绑定事件中，举一个简单的array方法sort的例子\n\narray的sort方法拥有自己的默认方法，但是如果你以为他是万能的那就错了，他实现的是按照字符编码来进行排序，在最常见的数字排序使用中我们一般都是使用自己定义的方法作为参数覆盖默认方法：\n```\n[1,3,2,4].sort( function( a, b ){  \n   return a-b;  \n});  \n//[1,2,3,4]\n```\n以上代码实现的就是基于sort函数的最简单的数字升序自定义方法，其将一整个自定义方法作为了参数传递给了sort方法。\n\n2.函数作为返回值输出，实现闭包时经常有函数返回值作为闭包私有变量访问的接口.\n\n","slug":"gaojiefunction","published":1,"updated":"2017-01-03T05:48:46.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv7s001qjgtumny39byr","content":"<p>高阶函数英文叫Higher-order function。<br>高阶函数是指操作函数的函数，它接收一个或者多个函数作为参数，或者返回一个新函数。此外，还依赖与闭包的特性，来保存中间过程中输入的参数。</p>\n<h4 id=\"高阶函数是至少满足下列一个条件的函数：\"><a href=\"#高阶函数是至少满足下列一个条件的函数：\" class=\"headerlink\" title=\"高阶函数是至少满足下列一个条件的函数：\"></a>高阶函数是至少满足下列一个条件的函数：</h4><p>1.接受函数作为输入 2.返回一个函数</p>\n<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p>1.函数作为参数传递，这种情况在需要callback的地方非常多，另外尤其是在ajax异步请求和绑定事件中，举一个简单的array方法sort的例子</p>\n<p>array的sort方法拥有自己的默认方法，但是如果你以为他是万能的那就错了，他实现的是按照字符编码来进行排序，在最常见的数字排序使用中我们一般都是使用自己定义的方法作为参数覆盖默认方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[1,3,2,4].sort( function( a, b )&#123;  </div><div class=\"line\">   return a-b;  </div><div class=\"line\">&#125;);  </div><div class=\"line\">//[1,2,3,4]</div></pre></td></tr></table></figure></p>\n<p>以上代码实现的就是基于sort函数的最简单的数字升序自定义方法，其将一整个自定义方法作为了参数传递给了sort方法。</p>\n<p>2.函数作为返回值输出，实现闭包时经常有函数返回值作为闭包私有变量访问的接口.</p>\n","excerpt":"","more":"<p>高阶函数英文叫Higher-order function。<br>高阶函数是指操作函数的函数，它接收一个或者多个函数作为参数，或者返回一个新函数。此外，还依赖与闭包的特性，来保存中间过程中输入的参数。</p>\n<h4 id=\"高阶函数是至少满足下列一个条件的函数：\"><a href=\"#高阶函数是至少满足下列一个条件的函数：\" class=\"headerlink\" title=\"高阶函数是至少满足下列一个条件的函数：\"></a>高阶函数是至少满足下列一个条件的函数：</h4><p>1.接受函数作为输入 2.返回一个函数</p>\n<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p>1.函数作为参数传递，这种情况在需要callback的地方非常多，另外尤其是在ajax异步请求和绑定事件中，举一个简单的array方法sort的例子</p>\n<p>array的sort方法拥有自己的默认方法，但是如果你以为他是万能的那就错了，他实现的是按照字符编码来进行排序，在最常见的数字排序使用中我们一般都是使用自己定义的方法作为参数覆盖默认方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[1,3,2,4].sort( function( a, b )&#123;  </div><div class=\"line\">   return a-b;  </div><div class=\"line\">&#125;);  </div><div class=\"line\">//[1,2,3,4]</div></pre></td></tr></table></figure></p>\n<p>以上代码实现的就是基于sort函数的最简单的数字升序自定义方法，其将一整个自定义方法作为了参数传递给了sort方法。</p>\n<p>2.函数作为返回值输出，实现闭包时经常有函数返回值作为闭包私有变量访问的接口.</p>\n"},{"title":"如何在github上下载单个文件夹？","date":"2016-03-12T07:19:07.000Z","_content":"### 第一种方式：\nGit1.7.0以后加入了Sparse Checkout模式，这使得Check Out指定文件或者文件夹成为可能。\n\n具体实现如下：\n```\n$mkdir project_folder\n$cd project_folder\n$git init\n$git remote add -f origin <url>   url要为https格式的。\n```\n上面的代码会帮助你创建一个空的本地仓库，同时将远程Git Server URL加入到Git Config文件中。\n\n接下来，我们在Config中允许使用Sparse Checkout模式：\n```\n$git config core.sparsecheckout true\n```\n\n接下来你需要告诉Git哪些文件或者文件夹是你真正想Check Out的，你可以将它们作为一个列表保存在 .git/info/sparse-checkout 文件中。 \n例如：\n```\n$echo “libs” >> .git/info/sparse-checkout\n$echo “apps/register.go” >> .git/info/sparse-checkout\n$echo “resource/css” >> .git/info/sparse-checkout\n```\n最后，你只要以正常方式从你想要的分支中将你的项目拉下来就可以了：\n```\n$git pull origin master\n```\n### 第二种方式：\n可以用谷歌的一款插件——Octotree,安装上此插件，当打开github页面时，页面的左上角会出现一个小箭头，即左侧的工具栏 , 它相当于一个文件浏览器 , 可以看到整个项目的文件目录 , 在鼠标移动到相应文件下还会出现下载按钮 , 也很方便下载文件。如下图\n![github](http://oi28tswuq.bkt.clouddn.com/images/git-single.png)","source":"_posts/gitsinglefile.md","raw":"---\ntitle: 如何在github上下载单个文件夹？\ndate: 2016-3-12 15:19:07\ntags: git github\n---\n### 第一种方式：\nGit1.7.0以后加入了Sparse Checkout模式，这使得Check Out指定文件或者文件夹成为可能。\n\n具体实现如下：\n```\n$mkdir project_folder\n$cd project_folder\n$git init\n$git remote add -f origin <url>   url要为https格式的。\n```\n上面的代码会帮助你创建一个空的本地仓库，同时将远程Git Server URL加入到Git Config文件中。\n\n接下来，我们在Config中允许使用Sparse Checkout模式：\n```\n$git config core.sparsecheckout true\n```\n\n接下来你需要告诉Git哪些文件或者文件夹是你真正想Check Out的，你可以将它们作为一个列表保存在 .git/info/sparse-checkout 文件中。 \n例如：\n```\n$echo “libs” >> .git/info/sparse-checkout\n$echo “apps/register.go” >> .git/info/sparse-checkout\n$echo “resource/css” >> .git/info/sparse-checkout\n```\n最后，你只要以正常方式从你想要的分支中将你的项目拉下来就可以了：\n```\n$git pull origin master\n```\n### 第二种方式：\n可以用谷歌的一款插件——Octotree,安装上此插件，当打开github页面时，页面的左上角会出现一个小箭头，即左侧的工具栏 , 它相当于一个文件浏览器 , 可以看到整个项目的文件目录 , 在鼠标移动到相应文件下还会出现下载按钮 , 也很方便下载文件。如下图\n![github](http://oi28tswuq.bkt.clouddn.com/images/git-single.png)","slug":"gitsinglefile","published":1,"updated":"2016-12-12T07:23:52.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv7t001rjgtu7r3vn5x8","content":"<h3 id=\"第一种方式：\"><a href=\"#第一种方式：\" class=\"headerlink\" title=\"第一种方式：\"></a>第一种方式：</h3><p>Git1.7.0以后加入了Sparse Checkout模式，这使得Check Out指定文件或者文件夹成为可能。</p>\n<p>具体实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$mkdir project_folder</div><div class=\"line\">$cd project_folder</div><div class=\"line\">$git init</div><div class=\"line\">$git remote add -f origin &lt;url&gt;   url要为https格式的。</div></pre></td></tr></table></figure></p>\n<p>上面的代码会帮助你创建一个空的本地仓库，同时将远程Git Server URL加入到Git Config文件中。</p>\n<p>接下来，我们在Config中允许使用Sparse Checkout模式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$git config core.sparsecheckout true</div></pre></td></tr></table></figure></p>\n<p>接下来你需要告诉Git哪些文件或者文件夹是你真正想Check Out的，你可以将它们作为一个列表保存在 .git/info/sparse-checkout 文件中。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$echo “libs” &gt;&gt; .git/info/sparse-checkout</div><div class=\"line\">$echo “apps/register.go” &gt;&gt; .git/info/sparse-checkout</div><div class=\"line\">$echo “resource/css” &gt;&gt; .git/info/sparse-checkout</div></pre></td></tr></table></figure></p>\n<p>最后，你只要以正常方式从你想要的分支中将你的项目拉下来就可以了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$git pull origin master</div></pre></td></tr></table></figure></p>\n<h3 id=\"第二种方式：\"><a href=\"#第二种方式：\" class=\"headerlink\" title=\"第二种方式：\"></a>第二种方式：</h3><p>可以用谷歌的一款插件——Octotree,安装上此插件，当打开github页面时，页面的左上角会出现一个小箭头，即左侧的工具栏 , 它相当于一个文件浏览器 , 可以看到整个项目的文件目录 , 在鼠标移动到相应文件下还会出现下载按钮 , 也很方便下载文件。如下图<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/git-single.png\" alt=\"github\"></p>\n","excerpt":"","more":"<h3 id=\"第一种方式：\"><a href=\"#第一种方式：\" class=\"headerlink\" title=\"第一种方式：\"></a>第一种方式：</h3><p>Git1.7.0以后加入了Sparse Checkout模式，这使得Check Out指定文件或者文件夹成为可能。</p>\n<p>具体实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$mkdir project_folder</div><div class=\"line\">$cd project_folder</div><div class=\"line\">$git init</div><div class=\"line\">$git remote add -f origin &lt;url&gt;   url要为https格式的。</div></pre></td></tr></table></figure></p>\n<p>上面的代码会帮助你创建一个空的本地仓库，同时将远程Git Server URL加入到Git Config文件中。</p>\n<p>接下来，我们在Config中允许使用Sparse Checkout模式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$git config core.sparsecheckout true</div></pre></td></tr></table></figure></p>\n<p>接下来你需要告诉Git哪些文件或者文件夹是你真正想Check Out的，你可以将它们作为一个列表保存在 .git/info/sparse-checkout 文件中。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$echo “libs” &gt;&gt; .git/info/sparse-checkout</div><div class=\"line\">$echo “apps/register.go” &gt;&gt; .git/info/sparse-checkout</div><div class=\"line\">$echo “resource/css” &gt;&gt; .git/info/sparse-checkout</div></pre></td></tr></table></figure></p>\n<p>最后，你只要以正常方式从你想要的分支中将你的项目拉下来就可以了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$git pull origin master</div></pre></td></tr></table></figure></p>\n<h3 id=\"第二种方式：\"><a href=\"#第二种方式：\" class=\"headerlink\" title=\"第二种方式：\"></a>第二种方式：</h3><p>可以用谷歌的一款插件——Octotree,安装上此插件，当打开github页面时，页面的左上角会出现一个小箭头，即左侧的工具栏 , 它相当于一个文件浏览器 , 可以看到整个项目的文件目录 , 在鼠标移动到相应文件下还会出现下载按钮 , 也很方便下载文件。如下图<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/git-single.png\" alt=\"github\"></p>\n"},{"title":"AngularJS使用ng-repeat和ng-if实现数据的筛选显示，多适用于表单数据的显示","date":"2016-06-05T02:22:15.000Z","_content":"这篇文章主要介绍了AngularJS使用ng-repeat和ng-if实现数据的删选显示效果,非常适用于表单数据的显示使用,涉及ng-repeat和ng-if命令的相关使用技巧,在项目中用到过，特此记录下，遇到问题要多尝试！总会找到最好的方法。\n#### ng-repeat可以实现内容的重复显示\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n  <script src=\"https://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"></script>\n</head>\n<body>\n<div ng-app=\"myApp\" ng-controller=\"myCtrl\">\n  <ul>\n    <li ng-repeat=\"x in names\">\n      {{ x.name }}我的年龄：{{x.age}}\n    </li>\n  </ul>\n</div>\n\n<script>\n  angular.module('myApp', []).controller('myCtrl', function($scope) {\n    $scope.names = [\n      {name:'',age:'20'},\n      {name:'Hege',age:'21'},\n      {name:'Kai',age:'22'}\n    ];\n  });\n</script>\n</body>\n</html>\n```\n上述例子名字显示为空，怎么让名字为空的不显示呢？\n#### 可以使用ng-repeat+ng-if的方法，这样可以实现简单的前端筛选\n```\n <li ng-repeat=\"x in names\" ng-if=\"x.name'\">\n      {{ x.name }}{{x.age}}\n    </li>\n```\n这样就可以只显示名字不为空的了。如果只想显示名字为Kai的，代码如下：\n```\n <li ng-repeat=\"x in names\" ng-if=\"x.name=='Kai'\">\n      {{ x.name }}{{x.age}}\n    </li>\n```\n#### 实现过滤的另一种思路：在controller里直接过滤空值数据，页面直接ng-repeat过滤后的数据即可。\n代码如下：\n```\n<li ng-repeat=\"x in names\">\n      {{ x.name }}我的年龄：{{x.age}}\n    </li>\nangular.module('myApp', []).controller('myCtrl', function($scope) {\n    $scope.names = [\n      {name:'',age:'20'},\n      {name:'Hege',age:'21'},\n      {name:'Kai',age:'22'}\n    ];\n    $scope.names=$scope.names.filter(function(item){\n    \treturn item.name != '';\n    })\n  });\n```\n这种方式也能只显示有值的名字。\n\n","source":"_posts/filternull.md","raw":"---\ntitle: AngularJS使用ng-repeat和ng-if实现数据的筛选显示，多适用于表单数据的显示\ndate: 2016-06-05 10:22:15\ntags: angularjs \n---\n这篇文章主要介绍了AngularJS使用ng-repeat和ng-if实现数据的删选显示效果,非常适用于表单数据的显示使用,涉及ng-repeat和ng-if命令的相关使用技巧,在项目中用到过，特此记录下，遇到问题要多尝试！总会找到最好的方法。\n#### ng-repeat可以实现内容的重复显示\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n  <script src=\"https://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"></script>\n</head>\n<body>\n<div ng-app=\"myApp\" ng-controller=\"myCtrl\">\n  <ul>\n    <li ng-repeat=\"x in names\">\n      {{ x.name }}我的年龄：{{x.age}}\n    </li>\n  </ul>\n</div>\n\n<script>\n  angular.module('myApp', []).controller('myCtrl', function($scope) {\n    $scope.names = [\n      {name:'',age:'20'},\n      {name:'Hege',age:'21'},\n      {name:'Kai',age:'22'}\n    ];\n  });\n</script>\n</body>\n</html>\n```\n上述例子名字显示为空，怎么让名字为空的不显示呢？\n#### 可以使用ng-repeat+ng-if的方法，这样可以实现简单的前端筛选\n```\n <li ng-repeat=\"x in names\" ng-if=\"x.name'\">\n      {{ x.name }}{{x.age}}\n    </li>\n```\n这样就可以只显示名字不为空的了。如果只想显示名字为Kai的，代码如下：\n```\n <li ng-repeat=\"x in names\" ng-if=\"x.name=='Kai'\">\n      {{ x.name }}{{x.age}}\n    </li>\n```\n#### 实现过滤的另一种思路：在controller里直接过滤空值数据，页面直接ng-repeat过滤后的数据即可。\n代码如下：\n```\n<li ng-repeat=\"x in names\">\n      {{ x.name }}我的年龄：{{x.age}}\n    </li>\nangular.module('myApp', []).controller('myCtrl', function($scope) {\n    $scope.names = [\n      {name:'',age:'20'},\n      {name:'Hege',age:'21'},\n      {name:'Kai',age:'22'}\n    ];\n    $scope.names=$scope.names.filter(function(item){\n    \treturn item.name != '';\n    })\n  });\n```\n这种方式也能只显示有值的名字。\n\n","slug":"filternull","published":1,"updated":"2017-01-05T02:40:08.508Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv7v001tjgtuwa3mbvyw","content":"<p>这篇文章主要介绍了AngularJS使用ng-repeat和ng-if实现数据的删选显示效果,非常适用于表单数据的显示使用,涉及ng-repeat和ng-if命令的相关使用技巧,在项目中用到过，特此记录下，遇到问题要多尝试！总会找到最好的方法。</p>\n<h4 id=\"ng-repeat可以实现内容的重复显示\"><a href=\"#ng-repeat可以实现内容的重复显示\" class=\"headerlink\" title=\"ng-repeat可以实现内容的重复显示\"></a>ng-repeat可以实现内容的重复显示</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;Title&lt;/title&gt;</div><div class=\"line\">  &lt;script src=&quot;https://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt;</div><div class=\"line\">  &lt;ul&gt;</div><div class=\"line\">    &lt;li ng-repeat=&quot;x in names&quot;&gt;</div><div class=\"line\">      &#123;&#123; x.name &#125;&#125;我的年龄：&#123;&#123;x.age&#125;&#125;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">  &lt;/ul&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;script&gt;</div><div class=\"line\">  angular.module(&apos;myApp&apos;, []).controller(&apos;myCtrl&apos;, function($scope) &#123;</div><div class=\"line\">    $scope.names = [</div><div class=\"line\">      &#123;name:&apos;&apos;,age:&apos;20&apos;&#125;,</div><div class=\"line\">      &#123;name:&apos;Hege&apos;,age:&apos;21&apos;&#125;,</div><div class=\"line\">      &#123;name:&apos;Kai&apos;,age:&apos;22&apos;&#125;</div><div class=\"line\">    ];</div><div class=\"line\">  &#125;);</div><div class=\"line\">&lt;/script&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>上述例子名字显示为空，怎么让名字为空的不显示呢？</p>\n<h4 id=\"可以使用ng-repeat-ng-if的方法，这样可以实现简单的前端筛选\"><a href=\"#可以使用ng-repeat-ng-if的方法，这样可以实现简单的前端筛选\" class=\"headerlink\" title=\"可以使用ng-repeat+ng-if的方法，这样可以实现简单的前端筛选\"></a>可以使用ng-repeat+ng-if的方法，这样可以实现简单的前端筛选</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;li ng-repeat=&quot;x in names&quot; ng-if=&quot;x.name&apos;&quot;&gt;</div><div class=\"line\">     &#123;&#123; x.name &#125;&#125;&#123;&#123;x.age&#125;&#125;</div><div class=\"line\">   &lt;/li&gt;</div></pre></td></tr></table></figure>\n<p>这样就可以只显示名字不为空的了。如果只想显示名字为Kai的，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;li ng-repeat=&quot;x in names&quot; ng-if=&quot;x.name==&apos;Kai&apos;&quot;&gt;</div><div class=\"line\">     &#123;&#123; x.name &#125;&#125;&#123;&#123;x.age&#125;&#125;</div><div class=\"line\">   &lt;/li&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"实现过滤的另一种思路：在controller里直接过滤空值数据，页面直接ng-repeat过滤后的数据即可。\"><a href=\"#实现过滤的另一种思路：在controller里直接过滤空值数据，页面直接ng-repeat过滤后的数据即可。\" class=\"headerlink\" title=\"实现过滤的另一种思路：在controller里直接过滤空值数据，页面直接ng-repeat过滤后的数据即可。\"></a>实现过滤的另一种思路：在controller里直接过滤空值数据，页面直接ng-repeat过滤后的数据即可。</h4><p>代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;li ng-repeat=&quot;x in names&quot;&gt;</div><div class=\"line\">      &#123;&#123; x.name &#125;&#125;我的年龄：&#123;&#123;x.age&#125;&#125;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">angular.module(&apos;myApp&apos;, []).controller(&apos;myCtrl&apos;, function($scope) &#123;</div><div class=\"line\">    $scope.names = [</div><div class=\"line\">      &#123;name:&apos;&apos;,age:&apos;20&apos;&#125;,</div><div class=\"line\">      &#123;name:&apos;Hege&apos;,age:&apos;21&apos;&#125;,</div><div class=\"line\">      &#123;name:&apos;Kai&apos;,age:&apos;22&apos;&#125;</div><div class=\"line\">    ];</div><div class=\"line\">    $scope.names=$scope.names.filter(function(item)&#123;</div><div class=\"line\">    \treturn item.name != &apos;&apos;;</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<p>这种方式也能只显示有值的名字。</p>\n","excerpt":"","more":"<p>这篇文章主要介绍了AngularJS使用ng-repeat和ng-if实现数据的删选显示效果,非常适用于表单数据的显示使用,涉及ng-repeat和ng-if命令的相关使用技巧,在项目中用到过，特此记录下，遇到问题要多尝试！总会找到最好的方法。</p>\n<h4 id=\"ng-repeat可以实现内容的重复显示\"><a href=\"#ng-repeat可以实现内容的重复显示\" class=\"headerlink\" title=\"ng-repeat可以实现内容的重复显示\"></a>ng-repeat可以实现内容的重复显示</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;Title&lt;/title&gt;</div><div class=\"line\">  &lt;script src=&quot;https://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt;</div><div class=\"line\">  &lt;ul&gt;</div><div class=\"line\">    &lt;li ng-repeat=&quot;x in names&quot;&gt;</div><div class=\"line\">      &#123;&#123; x.name &#125;&#125;我的年龄：&#123;&#123;x.age&#125;&#125;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">  &lt;/ul&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;script&gt;</div><div class=\"line\">  angular.module(&apos;myApp&apos;, []).controller(&apos;myCtrl&apos;, function($scope) &#123;</div><div class=\"line\">    $scope.names = [</div><div class=\"line\">      &#123;name:&apos;&apos;,age:&apos;20&apos;&#125;,</div><div class=\"line\">      &#123;name:&apos;Hege&apos;,age:&apos;21&apos;&#125;,</div><div class=\"line\">      &#123;name:&apos;Kai&apos;,age:&apos;22&apos;&#125;</div><div class=\"line\">    ];</div><div class=\"line\">  &#125;);</div><div class=\"line\">&lt;/script&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>上述例子名字显示为空，怎么让名字为空的不显示呢？</p>\n<h4 id=\"可以使用ng-repeat-ng-if的方法，这样可以实现简单的前端筛选\"><a href=\"#可以使用ng-repeat-ng-if的方法，这样可以实现简单的前端筛选\" class=\"headerlink\" title=\"可以使用ng-repeat+ng-if的方法，这样可以实现简单的前端筛选\"></a>可以使用ng-repeat+ng-if的方法，这样可以实现简单的前端筛选</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;li ng-repeat=&quot;x in names&quot; ng-if=&quot;x.name&apos;&quot;&gt;</div><div class=\"line\">     &#123;&#123; x.name &#125;&#125;&#123;&#123;x.age&#125;&#125;</div><div class=\"line\">   &lt;/li&gt;</div></pre></td></tr></table></figure>\n<p>这样就可以只显示名字不为空的了。如果只想显示名字为Kai的，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;li ng-repeat=&quot;x in names&quot; ng-if=&quot;x.name==&apos;Kai&apos;&quot;&gt;</div><div class=\"line\">     &#123;&#123; x.name &#125;&#125;&#123;&#123;x.age&#125;&#125;</div><div class=\"line\">   &lt;/li&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"实现过滤的另一种思路：在controller里直接过滤空值数据，页面直接ng-repeat过滤后的数据即可。\"><a href=\"#实现过滤的另一种思路：在controller里直接过滤空值数据，页面直接ng-repeat过滤后的数据即可。\" class=\"headerlink\" title=\"实现过滤的另一种思路：在controller里直接过滤空值数据，页面直接ng-repeat过滤后的数据即可。\"></a>实现过滤的另一种思路：在controller里直接过滤空值数据，页面直接ng-repeat过滤后的数据即可。</h4><p>代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;li ng-repeat=&quot;x in names&quot;&gt;</div><div class=\"line\">      &#123;&#123; x.name &#125;&#125;我的年龄：&#123;&#123;x.age&#125;&#125;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">angular.module(&apos;myApp&apos;, []).controller(&apos;myCtrl&apos;, function($scope) &#123;</div><div class=\"line\">    $scope.names = [</div><div class=\"line\">      &#123;name:&apos;&apos;,age:&apos;20&apos;&#125;,</div><div class=\"line\">      &#123;name:&apos;Hege&apos;,age:&apos;21&apos;&#125;,</div><div class=\"line\">      &#123;name:&apos;Kai&apos;,age:&apos;22&apos;&#125;</div><div class=\"line\">    ];</div><div class=\"line\">    $scope.names=$scope.names.filter(function(item)&#123;</div><div class=\"line\">    \treturn item.name != &apos;&apos;;</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<p>这种方式也能只显示有值的名字。</p>\n"},{"title":"前端路由的两种实现原理及相关api介绍","date":"2016-08-16T07:01:06.000Z","_content":"   早期的路由都是后端实现的，直接根据 url 来 reload 页面，页面变得越来越复杂服务器端压力变大，随着 ajax 的出现，页面实现非 reload 就能刷新数据，也给前端路由的出现奠定了基础。我们可以通过记录 url 来记录 ajax 的变化，从而实现前端路由。\n\n   本文主要讲两种主流方式实现前端路由。\n#### History API\n   不细说每一个 API 的用法，重点说其中的两个新增的API history.pushState 和 history.replaceState\n   \n   这两个 API 都接收三个参数，分别是\n   \n   - 状态对象（state object） — 一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝。\n   - 标题（title） — FireFox浏览器目前会忽略该参数，虽然以后可能会用上。考虑到未来可能会对该方法进行修改，传一个空字符串会比较安全。或者，你也可以传入一个简短的标题，标明将要进入的状态。\n   -  地址（URL） — 新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。\n   相同之处是两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新。\n   \n   不同之处在于，pushState会增加一条新的历史记录，而replaceState则会替换当前的历史记录。\n   \n   我们在控制台输入\n   ```\n   window.history.pushState(null, null, \"https://www.baidu.com/?name=orange\");\n   好，我们观察此时的 url 变成了这样\n   https://www.baidu.com/?name=orange\n   ```\n   其他的用法如下：\n   ```\n   window.history.pushState(null, null, \"https://www.baidu.com/name/orange\");\n   //url: https://www.baidu.com/name/orange\n   \n   window.history.pushState(null, null, \"?name=orange\");\n   //url: https://www.baidu.com?name=orange\n   \n   window.history.pushState(null, null, \"name=orange\");\n   //url: https://www.baidu.com/name=orange\n   \n   window.history.pushState(null, null, \"/name/orange\");\n   //url: https://www.baidu.com/name/orange\n   \n   window.history.pushState(null, null, \"name/orange\");\n   //url: https://www.baidu.com/name/orange\n   ```\n   注：注意:这里的 url 不支持跨域，当我们把 www.baidu.com 换成 baidu.com 时就会报错。\n   接上文说，每次改变 url 页面并没有刷新，同样根据上文所述，浏览器会产生历史记录，这就是实现页面无刷新情况下改变 url 的前提。\n\n#### hash\n   我们经常在 url 中看到 #，这个 # 有两种情况，一个是我们所谓的锚点，比如典型的回到顶部按钮原理等，路由里的 # 不叫锚点，我们称之为 hash，大型框架的路由系统大多都是哈希实现的。\n    \n   同样我们需要一个根据监听哈希变化触发的事件 —— hashchange 事件\n    \n   我们用 window.location 处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。","source":"_posts/h5api-router.md","raw":"---\ntitle: 前端路由的两种实现原理及相关api介绍\ndate: 2016-08-16 15:01:06\ntags:  路由 html5\n---\n   早期的路由都是后端实现的，直接根据 url 来 reload 页面，页面变得越来越复杂服务器端压力变大，随着 ajax 的出现，页面实现非 reload 就能刷新数据，也给前端路由的出现奠定了基础。我们可以通过记录 url 来记录 ajax 的变化，从而实现前端路由。\n\n   本文主要讲两种主流方式实现前端路由。\n#### History API\n   不细说每一个 API 的用法，重点说其中的两个新增的API history.pushState 和 history.replaceState\n   \n   这两个 API 都接收三个参数，分别是\n   \n   - 状态对象（state object） — 一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝。\n   - 标题（title） — FireFox浏览器目前会忽略该参数，虽然以后可能会用上。考虑到未来可能会对该方法进行修改，传一个空字符串会比较安全。或者，你也可以传入一个简短的标题，标明将要进入的状态。\n   -  地址（URL） — 新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。\n   相同之处是两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新。\n   \n   不同之处在于，pushState会增加一条新的历史记录，而replaceState则会替换当前的历史记录。\n   \n   我们在控制台输入\n   ```\n   window.history.pushState(null, null, \"https://www.baidu.com/?name=orange\");\n   好，我们观察此时的 url 变成了这样\n   https://www.baidu.com/?name=orange\n   ```\n   其他的用法如下：\n   ```\n   window.history.pushState(null, null, \"https://www.baidu.com/name/orange\");\n   //url: https://www.baidu.com/name/orange\n   \n   window.history.pushState(null, null, \"?name=orange\");\n   //url: https://www.baidu.com?name=orange\n   \n   window.history.pushState(null, null, \"name=orange\");\n   //url: https://www.baidu.com/name=orange\n   \n   window.history.pushState(null, null, \"/name/orange\");\n   //url: https://www.baidu.com/name/orange\n   \n   window.history.pushState(null, null, \"name/orange\");\n   //url: https://www.baidu.com/name/orange\n   ```\n   注：注意:这里的 url 不支持跨域，当我们把 www.baidu.com 换成 baidu.com 时就会报错。\n   接上文说，每次改变 url 页面并没有刷新，同样根据上文所述，浏览器会产生历史记录，这就是实现页面无刷新情况下改变 url 的前提。\n\n#### hash\n   我们经常在 url 中看到 #，这个 # 有两种情况，一个是我们所谓的锚点，比如典型的回到顶部按钮原理等，路由里的 # 不叫锚点，我们称之为 hash，大型框架的路由系统大多都是哈希实现的。\n    \n   同样我们需要一个根据监听哈希变化触发的事件 —— hashchange 事件\n    \n   我们用 window.location 处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。","slug":"h5api-router","published":1,"updated":"2016-12-16T07:12:41.636Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv7x001vjgtufe0ikjod","content":"<p>   早期的路由都是后端实现的，直接根据 url 来 reload 页面，页面变得越来越复杂服务器端压力变大，随着 ajax 的出现，页面实现非 reload 就能刷新数据，也给前端路由的出现奠定了基础。我们可以通过记录 url 来记录 ajax 的变化，从而实现前端路由。</p>\n<p>   本文主要讲两种主流方式实现前端路由。</p>\n<h4 id=\"History-API\"><a href=\"#History-API\" class=\"headerlink\" title=\"History API\"></a>History API</h4><p>   不细说每一个 API 的用法，重点说其中的两个新增的API history.pushState 和 history.replaceState</p>\n<p>   这两个 API 都接收三个参数，分别是</p>\n<ul>\n<li>状态对象（state object） — 一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝。</li>\n<li>标题（title） — FireFox浏览器目前会忽略该参数，虽然以后可能会用上。考虑到未来可能会对该方法进行修改，传一个空字符串会比较安全。或者，你也可以传入一个简短的标题，标明将要进入的状态。</li>\n<li><p>地址（URL） — 新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。<br>相同之处是两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新。</p>\n<p>不同之处在于，pushState会增加一条新的历史记录，而replaceState则会替换当前的历史记录。</p>\n<p>我们在控制台输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">window.history.pushState(null, null, &quot;https://www.baidu.com/?name=orange&quot;);</div><div class=\"line\">好，我们观察此时的 url 变成了这样</div><div class=\"line\">https://www.baidu.com/?name=orange</div></pre></td></tr></table></figure>\n<p>其他的用法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">window.history.pushState(null, null, &quot;https://www.baidu.com/name/orange&quot;);</div><div class=\"line\">//url: https://www.baidu.com/name/orange</div><div class=\"line\"></div><div class=\"line\">window.history.pushState(null, null, &quot;?name=orange&quot;);</div><div class=\"line\">//url: https://www.baidu.com?name=orange</div><div class=\"line\"></div><div class=\"line\">window.history.pushState(null, null, &quot;name=orange&quot;);</div><div class=\"line\">//url: https://www.baidu.com/name=orange</div><div class=\"line\"></div><div class=\"line\">window.history.pushState(null, null, &quot;/name/orange&quot;);</div><div class=\"line\">//url: https://www.baidu.com/name/orange</div><div class=\"line\"></div><div class=\"line\">window.history.pushState(null, null, &quot;name/orange&quot;);</div><div class=\"line\">//url: https://www.baidu.com/name/orange</div></pre></td></tr></table></figure>\n<p>注：注意:这里的 url 不支持跨域，当我们把 www.baidu.com 换成 baidu.com 时就会报错。<br>接上文说，每次改变 url 页面并没有刷新，同样根据上文所述，浏览器会产生历史记录，这就是实现页面无刷新情况下改变 url 的前提。</p>\n</li>\n</ul>\n<h4 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h4><p>   我们经常在 url 中看到 #，这个 # 有两种情况，一个是我们所谓的锚点，比如典型的回到顶部按钮原理等，路由里的 # 不叫锚点，我们称之为 hash，大型框架的路由系统大多都是哈希实现的。</p>\n<p>   同样我们需要一个根据监听哈希变化触发的事件 —— hashchange 事件</p>\n<p>   我们用 window.location 处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。</p>\n","excerpt":"","more":"<p>   早期的路由都是后端实现的，直接根据 url 来 reload 页面，页面变得越来越复杂服务器端压力变大，随着 ajax 的出现，页面实现非 reload 就能刷新数据，也给前端路由的出现奠定了基础。我们可以通过记录 url 来记录 ajax 的变化，从而实现前端路由。</p>\n<p>   本文主要讲两种主流方式实现前端路由。</p>\n<h4 id=\"History-API\"><a href=\"#History-API\" class=\"headerlink\" title=\"History API\"></a>History API</h4><p>   不细说每一个 API 的用法，重点说其中的两个新增的API history.pushState 和 history.replaceState</p>\n<p>   这两个 API 都接收三个参数，分别是</p>\n<ul>\n<li>状态对象（state object） — 一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝。</li>\n<li>标题（title） — FireFox浏览器目前会忽略该参数，虽然以后可能会用上。考虑到未来可能会对该方法进行修改，传一个空字符串会比较安全。或者，你也可以传入一个简短的标题，标明将要进入的状态。</li>\n<li><p>地址（URL） — 新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。<br>相同之处是两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新。</p>\n<p>不同之处在于，pushState会增加一条新的历史记录，而replaceState则会替换当前的历史记录。</p>\n<p>我们在控制台输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">window.history.pushState(null, null, &quot;https://www.baidu.com/?name=orange&quot;);</div><div class=\"line\">好，我们观察此时的 url 变成了这样</div><div class=\"line\">https://www.baidu.com/?name=orange</div></pre></td></tr></table></figure>\n<p>其他的用法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">window.history.pushState(null, null, &quot;https://www.baidu.com/name/orange&quot;);</div><div class=\"line\">//url: https://www.baidu.com/name/orange</div><div class=\"line\"></div><div class=\"line\">window.history.pushState(null, null, &quot;?name=orange&quot;);</div><div class=\"line\">//url: https://www.baidu.com?name=orange</div><div class=\"line\"></div><div class=\"line\">window.history.pushState(null, null, &quot;name=orange&quot;);</div><div class=\"line\">//url: https://www.baidu.com/name=orange</div><div class=\"line\"></div><div class=\"line\">window.history.pushState(null, null, &quot;/name/orange&quot;);</div><div class=\"line\">//url: https://www.baidu.com/name/orange</div><div class=\"line\"></div><div class=\"line\">window.history.pushState(null, null, &quot;name/orange&quot;);</div><div class=\"line\">//url: https://www.baidu.com/name/orange</div></pre></td></tr></table></figure>\n<p>注：注意:这里的 url 不支持跨域，当我们把 www.baidu.com 换成 baidu.com 时就会报错。<br>接上文说，每次改变 url 页面并没有刷新，同样根据上文所述，浏览器会产生历史记录，这就是实现页面无刷新情况下改变 url 的前提。</p>\n</li>\n</ul>\n<h4 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h4><p>   我们经常在 url 中看到 #，这个 # 有两种情况，一个是我们所谓的锚点，比如典型的回到顶部按钮原理等，路由里的 # 不叫锚点，我们称之为 hash，大型框架的路由系统大多都是哈希实现的。</p>\n<p>   同样我们需要一个根据监听哈希变化触发的事件 —— hashchange 事件</p>\n<p>   我们用 window.location 处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。</p>\n"},{"title":"JS之发布订-阅模式","date":"2016-08-12T14:10:58.000Z","_content":"#### js设计模式——发布订阅模式\n发布订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有的依赖于它的对象都将得到通知。在js开发中，我们一般用事件模型来代替传统的发布-订阅模式。\n##### 现实中的发布—订阅模式\n1、烧水例子：只有等水烧开了，才能做后续的事件，比如洗脚，泡茶，泡面等一系列之前安排好的事情。\n2、售楼例子：买房者在售楼处留下电话号码，等楼开售时，售楼处会依依通知预留手机号码的人。\n##### 发布-订阅模式的作用\n一：发布-订阅模式可以广泛地应用在异步编程中，这是一种替代传递回调函数的方案。\n二：可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。\n优点：一是时间上的解耦，二是对象之间的解耦;\n缺点：创建订阅者本身要消耗一定的时间和内存，而且当你订阅一个消息后，也许此消息最后都未发生，但是这个订阅者会始终存在于内存中。另处，虽然发布-订阅模式可以弱化对象之间的联系，但是如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一起的时候，要跟踪一个bug是很困难的。\n#### dom事件\n实际上，只要我们曾经在dom节点上面绑过事件函数，那我们就曾经使用过发布-订阅模式\n```\ndocument.body.addEventListener('click',function () {\n    alert(2);\n},false);\ndocument.body.click();//模拟用户点击\n//我们订阅document.body上的click事件，当body节点被点击的时候，body节点会向订阅者发布这个消息。\n```\n```\n//当然我们还可以随意增加或者删除订阅者，增加任何订阅者都不会影响发布者代码的编写：\ndocument.body.addEventListener('click',function () {\n    alert(3);\n},false);\ndocument.body.click();\n```\n注：手动触发事件更好的做法是IE下用fireEvent,标准浏览器下用dispatchEvent实现。\n##### 自定义事件\n除了dom事件，还可以实现一些自定义事件，这种靠自定义事件完成的发布-订阅模式可以用于任何js代码中。\n如何实现发布-订阅模式？\n1.首先要指定好谁充当发布者（如售楼处）\n2.然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者（如售楼处的花名册)。\n3.最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）\n另外，可以在回调函数里填入一些参数，订阅者可以接收这些参数。这是很有必要的，比如售楼处可以在发给订阅者的短信里面加上房子的一些信息，订阅者收到这些信息之后可以各自处理。\n#### 真实例子——网站登录\n假如正在开发一个商城网站，网站里面有header头部，nav导航，消息列表，购物车等模块。这几个模块的渲染有一个共同的前提条件，就必须先用ajax异步请求获取用户的登录信息。比如用户的名字和头像要显示在header模块里，而这两个字段都来自用户登录后返回的信息。\n至于ajax请求什么时候能成功返回用户信息，这点我们不能确定。\n用发布-订阅模式来写，有关用户信息业务的模块将自行订阅登录成功的消息事件，当登录成功时，登录模块只需要发布登录成功的消息，而业务方接受到消息之后，就会开始各自的业务处理，登录模块并不关心业务方究竟要做什么，也不想去了解他们的内部细节。\n","source":"_posts/guanchazhemoshi.md","raw":"---\ntitle: JS之发布订-阅模式\ndate: 2016-8-12 22:10:58\ntags: js、设计模式\n---\n#### js设计模式——发布订阅模式\n发布订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有的依赖于它的对象都将得到通知。在js开发中，我们一般用事件模型来代替传统的发布-订阅模式。\n##### 现实中的发布—订阅模式\n1、烧水例子：只有等水烧开了，才能做后续的事件，比如洗脚，泡茶，泡面等一系列之前安排好的事情。\n2、售楼例子：买房者在售楼处留下电话号码，等楼开售时，售楼处会依依通知预留手机号码的人。\n##### 发布-订阅模式的作用\n一：发布-订阅模式可以广泛地应用在异步编程中，这是一种替代传递回调函数的方案。\n二：可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。\n优点：一是时间上的解耦，二是对象之间的解耦;\n缺点：创建订阅者本身要消耗一定的时间和内存，而且当你订阅一个消息后，也许此消息最后都未发生，但是这个订阅者会始终存在于内存中。另处，虽然发布-订阅模式可以弱化对象之间的联系，但是如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一起的时候，要跟踪一个bug是很困难的。\n#### dom事件\n实际上，只要我们曾经在dom节点上面绑过事件函数，那我们就曾经使用过发布-订阅模式\n```\ndocument.body.addEventListener('click',function () {\n    alert(2);\n},false);\ndocument.body.click();//模拟用户点击\n//我们订阅document.body上的click事件，当body节点被点击的时候，body节点会向订阅者发布这个消息。\n```\n```\n//当然我们还可以随意增加或者删除订阅者，增加任何订阅者都不会影响发布者代码的编写：\ndocument.body.addEventListener('click',function () {\n    alert(3);\n},false);\ndocument.body.click();\n```\n注：手动触发事件更好的做法是IE下用fireEvent,标准浏览器下用dispatchEvent实现。\n##### 自定义事件\n除了dom事件，还可以实现一些自定义事件，这种靠自定义事件完成的发布-订阅模式可以用于任何js代码中。\n如何实现发布-订阅模式？\n1.首先要指定好谁充当发布者（如售楼处）\n2.然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者（如售楼处的花名册)。\n3.最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）\n另外，可以在回调函数里填入一些参数，订阅者可以接收这些参数。这是很有必要的，比如售楼处可以在发给订阅者的短信里面加上房子的一些信息，订阅者收到这些信息之后可以各自处理。\n#### 真实例子——网站登录\n假如正在开发一个商城网站，网站里面有header头部，nav导航，消息列表，购物车等模块。这几个模块的渲染有一个共同的前提条件，就必须先用ajax异步请求获取用户的登录信息。比如用户的名字和头像要显示在header模块里，而这两个字段都来自用户登录后返回的信息。\n至于ajax请求什么时候能成功返回用户信息，这点我们不能确定。\n用发布-订阅模式来写，有关用户信息业务的模块将自行订阅登录成功的消息事件，当登录成功时，登录模块只需要发布登录成功的消息，而业务方接受到消息之后，就会开始各自的业务处理，登录模块并不关心业务方究竟要做什么，也不想去了解他们的内部细节。\n","slug":"guanchazhemoshi","published":1,"updated":"2016-12-22T01:47:35.984Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv7z001xjgtu7xanvyfg","content":"<h4 id=\"js设计模式——发布订阅模式\"><a href=\"#js设计模式——发布订阅模式\" class=\"headerlink\" title=\"js设计模式——发布订阅模式\"></a>js设计模式——发布订阅模式</h4><p>发布订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有的依赖于它的对象都将得到通知。在js开发中，我们一般用事件模型来代替传统的发布-订阅模式。</p>\n<h5 id=\"现实中的发布—订阅模式\"><a href=\"#现实中的发布—订阅模式\" class=\"headerlink\" title=\"现实中的发布—订阅模式\"></a>现实中的发布—订阅模式</h5><p>1、烧水例子：只有等水烧开了，才能做后续的事件，比如洗脚，泡茶，泡面等一系列之前安排好的事情。<br>2、售楼例子：买房者在售楼处留下电话号码，等楼开售时，售楼处会依依通知预留手机号码的人。</p>\n<h5 id=\"发布-订阅模式的作用\"><a href=\"#发布-订阅模式的作用\" class=\"headerlink\" title=\"发布-订阅模式的作用\"></a>发布-订阅模式的作用</h5><p>一：发布-订阅模式可以广泛地应用在异步编程中，这是一种替代传递回调函数的方案。<br>二：可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。<br>优点：一是时间上的解耦，二是对象之间的解耦;<br>缺点：创建订阅者本身要消耗一定的时间和内存，而且当你订阅一个消息后，也许此消息最后都未发生，但是这个订阅者会始终存在于内存中。另处，虽然发布-订阅模式可以弱化对象之间的联系，但是如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一起的时候，要跟踪一个bug是很困难的。</p>\n<h4 id=\"dom事件\"><a href=\"#dom事件\" class=\"headerlink\" title=\"dom事件\"></a>dom事件</h4><p>实际上，只要我们曾经在dom节点上面绑过事件函数，那我们就曾经使用过发布-订阅模式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">document.body.addEventListener(&apos;click&apos;,function () &#123;</div><div class=\"line\">    alert(2);</div><div class=\"line\">&#125;,false);</div><div class=\"line\">document.body.click();//模拟用户点击</div><div class=\"line\">//我们订阅document.body上的click事件，当body节点被点击的时候，body节点会向订阅者发布这个消息。</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//当然我们还可以随意增加或者删除订阅者，增加任何订阅者都不会影响发布者代码的编写：</div><div class=\"line\">document.body.addEventListener(&apos;click&apos;,function () &#123;</div><div class=\"line\">    alert(3);</div><div class=\"line\">&#125;,false);</div><div class=\"line\">document.body.click();</div></pre></td></tr></table></figure>\n<p>注：手动触发事件更好的做法是IE下用fireEvent,标准浏览器下用dispatchEvent实现。</p>\n<h5 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h5><p>除了dom事件，还可以实现一些自定义事件，这种靠自定义事件完成的发布-订阅模式可以用于任何js代码中。<br>如何实现发布-订阅模式？<br>1.首先要指定好谁充当发布者（如售楼处）<br>2.然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者（如售楼处的花名册)。<br>3.最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）<br>另外，可以在回调函数里填入一些参数，订阅者可以接收这些参数。这是很有必要的，比如售楼处可以在发给订阅者的短信里面加上房子的一些信息，订阅者收到这些信息之后可以各自处理。</p>\n<h4 id=\"真实例子——网站登录\"><a href=\"#真实例子——网站登录\" class=\"headerlink\" title=\"真实例子——网站登录\"></a>真实例子——网站登录</h4><p>假如正在开发一个商城网站，网站里面有header头部，nav导航，消息列表，购物车等模块。这几个模块的渲染有一个共同的前提条件，就必须先用ajax异步请求获取用户的登录信息。比如用户的名字和头像要显示在header模块里，而这两个字段都来自用户登录后返回的信息。<br>至于ajax请求什么时候能成功返回用户信息，这点我们不能确定。<br>用发布-订阅模式来写，有关用户信息业务的模块将自行订阅登录成功的消息事件，当登录成功时，登录模块只需要发布登录成功的消息，而业务方接受到消息之后，就会开始各自的业务处理，登录模块并不关心业务方究竟要做什么，也不想去了解他们的内部细节。</p>\n","excerpt":"","more":"<h4 id=\"js设计模式——发布订阅模式\"><a href=\"#js设计模式——发布订阅模式\" class=\"headerlink\" title=\"js设计模式——发布订阅模式\"></a>js设计模式——发布订阅模式</h4><p>发布订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有的依赖于它的对象都将得到通知。在js开发中，我们一般用事件模型来代替传统的发布-订阅模式。</p>\n<h5 id=\"现实中的发布—订阅模式\"><a href=\"#现实中的发布—订阅模式\" class=\"headerlink\" title=\"现实中的发布—订阅模式\"></a>现实中的发布—订阅模式</h5><p>1、烧水例子：只有等水烧开了，才能做后续的事件，比如洗脚，泡茶，泡面等一系列之前安排好的事情。<br>2、售楼例子：买房者在售楼处留下电话号码，等楼开售时，售楼处会依依通知预留手机号码的人。</p>\n<h5 id=\"发布-订阅模式的作用\"><a href=\"#发布-订阅模式的作用\" class=\"headerlink\" title=\"发布-订阅模式的作用\"></a>发布-订阅模式的作用</h5><p>一：发布-订阅模式可以广泛地应用在异步编程中，这是一种替代传递回调函数的方案。<br>二：可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。<br>优点：一是时间上的解耦，二是对象之间的解耦;<br>缺点：创建订阅者本身要消耗一定的时间和内存，而且当你订阅一个消息后，也许此消息最后都未发生，但是这个订阅者会始终存在于内存中。另处，虽然发布-订阅模式可以弱化对象之间的联系，但是如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一起的时候，要跟踪一个bug是很困难的。</p>\n<h4 id=\"dom事件\"><a href=\"#dom事件\" class=\"headerlink\" title=\"dom事件\"></a>dom事件</h4><p>实际上，只要我们曾经在dom节点上面绑过事件函数，那我们就曾经使用过发布-订阅模式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">document.body.addEventListener(&apos;click&apos;,function () &#123;</div><div class=\"line\">    alert(2);</div><div class=\"line\">&#125;,false);</div><div class=\"line\">document.body.click();//模拟用户点击</div><div class=\"line\">//我们订阅document.body上的click事件，当body节点被点击的时候，body节点会向订阅者发布这个消息。</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//当然我们还可以随意增加或者删除订阅者，增加任何订阅者都不会影响发布者代码的编写：</div><div class=\"line\">document.body.addEventListener(&apos;click&apos;,function () &#123;</div><div class=\"line\">    alert(3);</div><div class=\"line\">&#125;,false);</div><div class=\"line\">document.body.click();</div></pre></td></tr></table></figure>\n<p>注：手动触发事件更好的做法是IE下用fireEvent,标准浏览器下用dispatchEvent实现。</p>\n<h5 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h5><p>除了dom事件，还可以实现一些自定义事件，这种靠自定义事件完成的发布-订阅模式可以用于任何js代码中。<br>如何实现发布-订阅模式？<br>1.首先要指定好谁充当发布者（如售楼处）<br>2.然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者（如售楼处的花名册)。<br>3.最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）<br>另外，可以在回调函数里填入一些参数，订阅者可以接收这些参数。这是很有必要的，比如售楼处可以在发给订阅者的短信里面加上房子的一些信息，订阅者收到这些信息之后可以各自处理。</p>\n<h4 id=\"真实例子——网站登录\"><a href=\"#真实例子——网站登录\" class=\"headerlink\" title=\"真实例子——网站登录\"></a>真实例子——网站登录</h4><p>假如正在开发一个商城网站，网站里面有header头部，nav导航，消息列表，购物车等模块。这几个模块的渲染有一个共同的前提条件，就必须先用ajax异步请求获取用户的登录信息。比如用户的名字和头像要显示在header模块里，而这两个字段都来自用户登录后返回的信息。<br>至于ajax请求什么时候能成功返回用户信息，这点我们不能确定。<br>用发布-订阅模式来写，有关用户信息业务的模块将自行订阅登录成功的消息事件，当登录成功时，登录模块只需要发布登录成功的消息，而业务方接受到消息之后，就会开始各自的业务处理，登录模块并不关心业务方究竟要做什么，也不想去了解他们的内部细节。</p>\n"},{"title":"H5项目常见问题汇总及解决方案(摘抄学习)","date":"2016-11-22T08:28:41.000Z","_content":"**1.Meta基础知识：**\n   - H5页面窗口自动调整到设备宽度，并禁止用户缩放页面\n   ```\n   //一、HTML页面结构\n   <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" />\n   // width    设置viewport宽度，为一个正整数，或字符串‘device-width’\n   // height   设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置\n   // initial-scale    默认缩放比例，为一个数字，可以带小数\n   // minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数\n   // maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数\n   // user-scalable    是否允许手动缩放\n    \n   //二、JS动态判断\n   var phoneWidth =  parseInt(window.screen.width);\n   var phoneScale = phoneWidth/640;\n   var ua = navigator.userAgent;\n   if (/Android (\\d+\\.\\d+)/.test(ua)){\n       var version = parseFloat(RegExp.$1);\n       if(version>2.3){\n           document.write('<meta name=\"viewport\" content=\"width=640, minimum-scale = '+phoneScale+', maximum-scale = '+phoneScale+', target-densitydpi=device-dpi\">');\n       }else{\n           document.write('<meta name=\"viewport\" content=\"width=640, target-densitydpi=device-dpi\">');\n       }\n   } else {\n       document.write('<meta name=\"viewport\" content=\"width=640, user-scalable=no, target-densitydpi=device-dpi\">');\n   }\n   ```\n   - 空白页基本meta标签\n   ```\n   <!-- 设置缩放 -->\n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no, minimal-ui\" />\n   <!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果） -->\n   <meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n   <!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） -->\n   <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" />\n   <!-- IOS中禁用将数字识别为电话号码/忽略Android平台中对邮箱地址的识别 -->\n   <meta name=\"format-detection\"content=\"telephone=no, email=no\" />\n   ```\n   - 其他meta标签\n   ```\n   <!-- 启用360浏览器的极速模式(webkit) -->\n   <meta name=\"renderer\" content=\"webkit\">\n   <!-- 避免IE使用兼容模式 -->\n   <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n   <!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 -->\n   <meta name=\"HandheldFriendly\" content=\"true\">\n   <!-- 微软的老式浏览器 -->\n   <meta name=\"MobileOptimized\" content=\"320\">\n   <!-- uc强制竖屏 -->\n   <meta name=\"screen-orientation\" content=\"portrait\">\n   <!-- QQ强制竖屏 -->\n   <meta name=\"x5-orientation\" content=\"portrait\">\n   <!-- UC强制全屏 -->\n   <meta name=\"full-screen\" content=\"yes\">\n   <!-- QQ强制全屏 -->\n   <meta name=\"x5-fullscreen\" content=\"true\">\n   <!-- UC应用模式 -->\n   <meta name=\"browsermode\" content=\"application\">\n   <!-- QQ应用模式 -->\n   <meta name=\"x5-page-mode\" content=\"app\">\n   <!-- windows phone 点击无高光 -->\n   <meta name=\"msapplication-tap-highlight\" content=\"no\">\n   ```\n**常见问题：**\n   - 移动端如何定义字体font-family\n   ```\n   @ --------------------------------------中文字体的英文名称\n   @ 宋体      SimSun\n   @ 黑体      SimHei\n   @ 微信雅黑   Microsoft Yahei\n   @ 微软正黑体 Microsoft JhengHei\n   @ 新宋体    NSimSun\n   @ 新细明体  MingLiU\n   @ 细明体    MingLiU\n   @ 标楷体    DFKai-SB\n   @ 仿宋     FangSong\n   @ 楷体     KaiTi\n   @ 仿宋_GB2312  FangSong_GB2312\n   @ 楷体_GB2312  KaiTi_GB2312  \n   @\n   @ 说明：中文字体多数使用宋体、雅黑，英文用Helvetica\n   body { font-family: Microsoft Yahei,SimSun,Helvetica; } \n   ```\n   - 打电话发短信写邮件怎么实现\n   ```\n   // 一、打电话\n   <a href=\"tel:0755-10086\">打电话给:0755-10086</a>\n    \n   //  二、发短信，winphone系统无效\n   <a href=\"sms:10086\">发短信给: 10086</a>\n    \n   // 三、写邮件\n   //注：在添加这些功能时，第一个功能以\"?\"开头，后面的以\"&\"开头\n   //1.普通邮件\n   <a href=\"mailto:863139978@qq.com\">点击我发邮件</a>\n   //2.收件地址后添加?cc=开头，可添加抄送地址（Android存在兼容问题）\n   <a href=\"mailto:863139978@qq.com?cc=zhangqian0406@yeah.net\">点击我发邮件</a>\n   //3.跟着抄送地址后，写上&bcc=,可添加密件抄送地址（Android存在兼容问题）\n   <a href=\"mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&bcc=384900096@qq.com\">点击我发邮件</a>\n   //4.包含多个收件人、抄送、密件抄送人，用分号(;)隔开多个邮件人的地址\n   <a href=\"mailto:863139978@qq.com;384900096@qq.com\">点击我发邮件</a>\n   //5.包含主题，用?subject=\n   <a href=\"mailto:863139978@qq.com?subject=邮件主题\">点击我发邮件</a>\n   //6.包含内容，用?body=;如内容包含文本，使用%0A给文本换行 \n   <a href=\"mailto:863139978@qq.com?body=邮件主题内容%0A腾讯诚信%0A期待您的到来\">点击我发邮件</a>\n   //7.内容包含链接，含http(s)://等的文本自动转化为链接\n   <a href=\"mailto:863139978@qq.com?body=http://www.baidu.com\">点击我发邮件</a>\n   //8.内容包含图片（PC不支持）\n   <a href=\"mailto:863139978@qq.com?body=<img src='images/1.jpg' />\">点击我发邮件</a>\n   //9.完整示例\n   <a href=\"mailto:863139978@qq.com;384900096@qq.com?cc=zhangqian0406@yeah.net&bcc=993233461@qq.com&subject=[邮件主题]&body=腾讯诚邀您参与%0A%0Ahttp://www.baidu.com%0A%0A<img src='images/1.jpg' />\">点击我发邮件</a>\n   ```\n   - 移动端touch事件（区分webkit和winphone）\n   ```\n   /* 当用户手指放在移动设备在屏幕上滑动会触发的touch事件 */\n   // 以下支持webkit\n   touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指\n   touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动\n   touchend——当手指离开屏幕时触发\n   touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用\n    \n   //TouchEvent说明：\n   touches：屏幕上所有手指的信息\n   targetTouches：手指在目标区域的手指信息\n   changedTouches：最近一次触发该事件的手指信息\n   touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息\n    \n   //参数信息(changedTouches[0])\n   clientX、clientY在显示区的坐标\n   target：当前元素\n    \n   //事件响应顺序\n   ontouchstart  > ontouchmove  > ontouchend > onclick\n    \n   // 以下支持winphone 8\n   MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指\n   MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action: none;}可以阻止默认情况的发生：阻止页面滚动\n   MSPointerUp——当手指离开屏幕时触发\n   ```\n   - 移动端click屏幕产生200-300ms的延时响应\n   ```\n   说明：移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。\n    \n   以下是历史原因，来源一个公司内一个同事的分享：\n   2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。\n    \n   双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。\n    \n   原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接<a href=\"#\"></a>，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。\n    \n   //解决方案：\n   fastclick可以解决在手机上点击事件的300ms延迟\n   zepto的touch模块，tap事件也是为了解决在click的延迟问题\n   ```\n   - Rentina显示屏原理及设计方案 \n   ```\n   说明：retina屏是一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个。 \n   在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍。 \n   那么，前端的应对方案是：设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2\n   //例如图片宽高为：200px*200px，那么写法如下\n   .css{width:100px;height:100px;background-size:100px 100px;}\n   //其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px\n   .css{font-size:20px}\n    \n   //image-set设计Rentina背景图\n   image-set,webkit私有属性，也是CSS4的属性，为解决Rentina屏幕下的图像而生。\n   .css {\n       background: url(images/bg.jpg) no-repeat center;\n       background: -webkit-image-set(\n       url(images/bg.jpg) 1x,     //支持image-set普通屏\n       url(images/bg-2x.jpg) 2x); //支持image-set的Rentinan\n   }\n   ```\n   - 点击元素产生背景或边框怎么去掉\n   ```\n   /ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0去除灰色半透明遮罩；\n   //android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果；\n   //winphone系统,点击标签产生的灰色半透明背景，能通过设置<meta name=\"msapplication-tap-highlight\" content=\"no\">去掉；\n   //特殊说明：有些机型去除不了，如小米2。对于按钮类还有个办法，不使用a或者input标签，直接用div标签\n   a,button,input,textarea { \n       -webkit-tap-highlight-color: rgba(0,0,0,0); \n       -webkit-user-modify:read-write-plaintext-only; //-webkit-user-modify有个副作用，就是输入法不再能够输入多个字符\n   }   \n   // 也可以 \n   * { -webkit-tap-highlight-color: rgba(0,0,0,0); }\n   //winphone下\n   <meta name=\"msapplication-tap-highlight\" content=\"no\">\n   ```\n   - 美化表单元素\n   ```\n   //一、使用appearance改变webkit浏览器的默认外观\n   input,select { -webkit-appearance:none; appearance: none; }\n    \n   //二、winphone下，使用伪元素改变表单元素默认外观\n   //1.禁用select默认箭头，::-ms-expand修改表单控件下拉箭头，设置隐藏并使用背景图片来修饰\n   select::-ms-expand { display:none; }\n    \n   //2.禁用radio和checkbox默认样式，::-ms-check修改表单复选框或单选框默认图标，设置隐藏并使用背景图片来修饰\n   input[type=radio]::-ms-check,\n   input[type=checkbox]::-ms-check { display:none; }\n    \n   //3.禁用pc端表单输入框默认清除按钮，::-ms-clear修改清除按钮，设置隐藏并使用背景图片来修饰\n   input[type=text]::-ms-clear,\n   input[type=tel]::-ms-clear,\n   input[type=number]::-ms-clear { display:none; }\n   ```\n   - 移动端字体单位font-size选择px还是rem\n   ```\n   // 如需适配多种移动设备，建议使用rem。以下为参考值：\n   html { font-size: 62.5%; }   //10*16 = 62.5%\n   //设置12px字体   这里注意在rem前要加上对应的px值，解决不支持rem的浏览器的兼容问题，做到优雅降级\n   body { font-size:12px; font-size:1.2rem; }\n   ```\n   - 超实用的CSS样式\n   ```\n   //去掉webkit的滚动条——display: none;\n   //其他参数\n   ::-webkit-scrollba //滚动条整体部分\n   ::-webkit-scrollbar-thumb   //滚动条内的小方块\n   ::-webkit-scrollbar-track   //滚动条轨道\n   ::-webkit-scrollbar-button  //滚动条轨道两端按钮\n   ::-webkit-scrollbar-track-piece  //滚动条中间部分，内置轨道\n   ::-webkit-scrollbar-corner       //边角，两个滚动条交汇处\n   ::-webkit-resizer            //两个滚动条的交汇处上用于通过拖动调整元素大小的小控件\n    \n   // 禁止长按链接与图片弹出菜单\n   a,img { -webkit-touch-callout: none }    \n    \n   // 禁止ios和android用户选中文字\n   html,body {-webkit-user-select:none; user-select: none; }\n    \n   // 改变输入框placeholder的颜色值\n   ::-webkit-input-placeholder { /* WebKit browsers */\n   color: #999; }\n   :-moz-placeholder { /* Mozilla Firefox 4 to 18 */\n   color: #999; }\n   ::-moz-placeholder { /* Mozilla Firefox 19+ */\n   color: #999; }\n   :-ms-input-placeholder { /* Internet Explorer 10+ */\n   color: #999; }\n   input:focus::-webkit-input-placeholder{ color:#999; }\n    \n   // android上去掉语音输入按钮\n   input::-webkit-input-speech-button {display: none}\n    \n   // 阻止windows Phone的默认触摸事件\n   /*说明：winphone下默认触摸事件事件使用e.preventDefault是无效的，可通过样式来禁用，如：*/\n   html { -ms-touch-action:none; } //禁止winphone默认触摸事件\n   取消input在ios下，输入的时候英文首字母的默认大写\n   <input autocapitalize=\"off\" autocorrect=\"off\" />\n   ```\n   - 手机拍照和上传图片\n   ```\n   //IOS有拍照、录像、选取本地图片功能，部分Android只有选择本地图片功能。Winphone不支持\n   <input type=\"file\" accept=\"images/*\" />\n   <input type=\"file\" accept=\"video/*\" />\n   ```\n   - 屏幕旋转的事件和样式\n   ```\n   //JS处理\n   function orientInit(){\n       var orientChk = document.documentElement.clientWidth > document.documentElement.clientHeight?'landscape':'portrait';\n       if(orientChk =='lapdscape'){\n           //这里是横屏下需要执行的事件\n       }else{\n           //这里是竖屏下需要执行的事件\n       }\n   }\n    \n   orientInit();\n   window.addEventListener('onorientationchange' in window?'orientationchange':'resize', function(){\n       setTimeout(orientInit, 100);\n   },false)    \n    \n   //CSS处理\n   //竖屏时样式\n   @media all and (orientation:portrait){   }\n   //横屏时样式\n   @media all and (orientation:landscape){   }\n   audio元素和video元素在ios和andriod中无法自动播放\n   //音频，写法一\n   <audio src=\"music/bg.mp3\" autoplay loop controls>你的浏览器还不支持哦</audio>\n    \n   //音频，写法二\n   <audio controls=\"controls\"> \n       <source src=\"music/bg.ogg\" type=\"audio/ogg\"></source>\n       <source src=\"music/bg.mp3\" type=\"audio/mpeg\"></source>\n       优先播放音乐bg.ogg，不支持在播放bg.mp3\n   </audio>\n    \n   //JS绑定自动播放（操作window时，播放音乐）\n   $(window).one('touchstart', function(){\n       music.play();\n   })\n    \n   //微信下兼容处理\n   document.addEventListener(\"WeixinJSBridgeReady\", function () {\n       music.play();\n   }, false);\n    \n   //小结\n   //1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常\n   //2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间\n   ```\n   - 重力感应事件\n   ```\n   // 运用HTML5的deviceMotion，调用重力感应事件\n   if(window.DeviceMotionEvent){\n       document.addEventListener('devicemotion', deviceMotionHandler, false)\n   }   \n    \n   var speed = 30;\n   var x = y = z = lastX = lastY = lastZ = 0;\n   function deviceMotionHandler(eventData){\n       var acceleration = event.accelerationIncludingGravity;\n       x = acceleration.x;\n       y = acceleration.y; \n       z = acceleration.z;\n       if(Math.abs(x-lastX)>speed || Math.abs(y-lastY)>speed || Math.abs(z-lastZ)>speed ){\n           //这里是摇动后要执行的方法 \n           yaoAfter();\n       }\n       lastX = x;\n       lastY = y;\n       lastZ = z;\n   }\n    \n   function yaoAfter(){\n       //do something\n   }\n   ```\n   - 微信浏览器用户调整字体大小后页面矬了，怎么阻止用户调整\n   ```\n   //以下代码可使Android机页面不再受用户字体缩放强制改变大小，但是会有1S左右延时，期间可以考虑loading来处理\n   if (typeof(WeixinJSBridge) == \"undefined\") {\n       document.addEventListener(\"WeixinJSBridgeReady\", function (e) {\n           setTimeout(function(){\n               WeixinJSBridge.invoke('setFontSizeCallback', { 'fontSize':0}, function(res){\n                   alert(JSON.stringify(res));\n               })\n           }, 0)\n       });\n   }else{  \n       setTimeout(function(){\n           WeixinJSBridge.invoke('setFontSizeCallback', { 'fontSize':0}, function(res){\n               alert(JSON.stringify(res));\n           })\n       }, 0)   \n   }\n    \n   //IOS下可使用 -webkit-text-size-adjust禁止用户调整字体大小\n   body { -webkit-text-size-adjust:100%!important; }\n    \n   //最好的解决方案：最好使用rem或百分比布局\n   ```\n   - 定位的坑\n   ```\n   //fixed定位\n   //1.ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位\n   //2.android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位\n   //3.ios4下不支持position:fixed\n   //解决方案：使用[Iscroll](http://cubiq.org/iscroll-5)，如：\n   <div id=\"wrapper\">\n           <ul>\n                  <li></li>\n                  .....\n           </ul>\n   </div>\n   <script src=\"iscroll.js\"></script>\n   <script>\n       var myscroll;\n       function loaded(){\n           myscroll=new iScroll(\"wrapper\");\n       }\n       window.addEventListener(\"DOMContentLoaded\",loaded,false);\n   </script>\n    \n    \n   //position定位\n   //Android下弹出软键盘弹出时，影响absolute元素定位\n   //解决方案:\n   var ua = navigator.userAgent.indexOf('Android');\n   if(ua>-1){\n       $('.ipt').on('focus', function(){\n           $('.css').css({'visibility':'hidden'})\n       }).on('blur', function(){\n           $('.css').css({'visibility':'visible'})\n       })\n   }\n   ```\n   - 播放视频不全屏\n   ```\n   <!--\n   1.ios7+支持自动播放\n   2.支持Airplay的设备（如：音箱、Apple TV)播放\n   x-webkit-airplay=\"true\" \n   3.播放视频不全屏\n   webkit-playsinline=\"true\" \n   -->\n   <video x-webkit-airplay=\"true\" webkit-playsinline=\"true\" preload=\"auto\" autoplay src=\"http://\"></video>\n   JS判断设备\n   function deviceType(){\n       var ua = navigator.userAgent;\n       var agent = [\"Android\", \"iPhone\", \"SymbianOS\", \"Windows Phone\", \"iPad\", \"iPod\"];    \n       for(var i=0; i<len,len = agent.length; i++){\n           if(ua.indexOf(agent[i])>0){         \n               break;\n           }\n       }\n   }\n   deviceType();\n   window.addEventListener('resize', function(){\n       deviceType();\n   })\n   ```\n   - JS判断微信浏览器\n   ```\n   function isWeixin(){\n       var ua = navigator.userAgent.toLowerCase();\n       if(ua.match(/MicroMessenger/i)=='micromessenger'){\n           return true;\n       }else{\n           return false;\n       }\n   }\n   ```\n   - android 2.3 bug\n   ```\n   //1.@-webkit-keyframes 需要以0%开始100%结束，0%的百分号不能去掉\n   //2.after和before伪类无法使用动画animation\n   //3.border-radius不支持%单位，如要兼容，可以给radius设置一下较大的值\n   //4.translate百分比的写法和scale在一起会导致失效，例如：\n   -webkit-transform: translate(-50%,-50%) scale(-0.5, 1)\n   android 4.x bug\n   //1.三星 Galaxy S4中自带浏览器不支持border-radius缩写\n   //2.同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分\n   //3.部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色\n   //4.android无法同时播放多音频audio\n   消除transition闪屏\n   .css {\n       -webkit-transform-style: preserve-3d;\n       -webkit-backface-visibility: hidden;\n       -webkit-perspective: 1000;\n   }\n   ```\n   - 开启硬件加速\n   ```\n   //目前，像Chrome/Filefox/Safari/IE9+以及最新版本Opera都支持硬件加速，当检测到某个DOM元素应用了某些CSS规则时就会自动开启，从而解决页面闪白，保证动画流畅。\n   .css {\n       -webkit-transform: translate3d(0,0,0);\n       -moz-transform: translate3d(0,0,0);\n       -ms-transform: translate3d(0,0,0);\n       transform: translate3d(0,0,0);\n   }\n   ```\n   - 渲染优化\n   ```\n    //1.禁止使用iframe（阻塞父文档onload事件）\n    //2.禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能）\n    //使用CSS3代码代替JS动画；\n    //开启GPU加速；\n    //使用base64位编码图片(不小图而言，大图不建议使用)\n        // 对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费CPU。小图标优势在于：\n        //1.减少HTTP请求；\n        //2.避免文件跨域；\n        //3.修改及时生效；\n   ```  \n[文章参考来源](https://github.com/FrontEndZQ/HTML5-FAQ)","source":"_posts/h5bug.md","raw":"---\ntitle: H5项目常见问题汇总及解决方案(摘抄学习)\ndate: 2016-11-22 16:28:41\ntags: H5、bug\n---\n**1.Meta基础知识：**\n   - H5页面窗口自动调整到设备宽度，并禁止用户缩放页面\n   ```\n   //一、HTML页面结构\n   <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" />\n   // width    设置viewport宽度，为一个正整数，或字符串‘device-width’\n   // height   设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置\n   // initial-scale    默认缩放比例，为一个数字，可以带小数\n   // minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数\n   // maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数\n   // user-scalable    是否允许手动缩放\n    \n   //二、JS动态判断\n   var phoneWidth =  parseInt(window.screen.width);\n   var phoneScale = phoneWidth/640;\n   var ua = navigator.userAgent;\n   if (/Android (\\d+\\.\\d+)/.test(ua)){\n       var version = parseFloat(RegExp.$1);\n       if(version>2.3){\n           document.write('<meta name=\"viewport\" content=\"width=640, minimum-scale = '+phoneScale+', maximum-scale = '+phoneScale+', target-densitydpi=device-dpi\">');\n       }else{\n           document.write('<meta name=\"viewport\" content=\"width=640, target-densitydpi=device-dpi\">');\n       }\n   } else {\n       document.write('<meta name=\"viewport\" content=\"width=640, user-scalable=no, target-densitydpi=device-dpi\">');\n   }\n   ```\n   - 空白页基本meta标签\n   ```\n   <!-- 设置缩放 -->\n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no, minimal-ui\" />\n   <!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果） -->\n   <meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n   <!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） -->\n   <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" />\n   <!-- IOS中禁用将数字识别为电话号码/忽略Android平台中对邮箱地址的识别 -->\n   <meta name=\"format-detection\"content=\"telephone=no, email=no\" />\n   ```\n   - 其他meta标签\n   ```\n   <!-- 启用360浏览器的极速模式(webkit) -->\n   <meta name=\"renderer\" content=\"webkit\">\n   <!-- 避免IE使用兼容模式 -->\n   <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n   <!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 -->\n   <meta name=\"HandheldFriendly\" content=\"true\">\n   <!-- 微软的老式浏览器 -->\n   <meta name=\"MobileOptimized\" content=\"320\">\n   <!-- uc强制竖屏 -->\n   <meta name=\"screen-orientation\" content=\"portrait\">\n   <!-- QQ强制竖屏 -->\n   <meta name=\"x5-orientation\" content=\"portrait\">\n   <!-- UC强制全屏 -->\n   <meta name=\"full-screen\" content=\"yes\">\n   <!-- QQ强制全屏 -->\n   <meta name=\"x5-fullscreen\" content=\"true\">\n   <!-- UC应用模式 -->\n   <meta name=\"browsermode\" content=\"application\">\n   <!-- QQ应用模式 -->\n   <meta name=\"x5-page-mode\" content=\"app\">\n   <!-- windows phone 点击无高光 -->\n   <meta name=\"msapplication-tap-highlight\" content=\"no\">\n   ```\n**常见问题：**\n   - 移动端如何定义字体font-family\n   ```\n   @ --------------------------------------中文字体的英文名称\n   @ 宋体      SimSun\n   @ 黑体      SimHei\n   @ 微信雅黑   Microsoft Yahei\n   @ 微软正黑体 Microsoft JhengHei\n   @ 新宋体    NSimSun\n   @ 新细明体  MingLiU\n   @ 细明体    MingLiU\n   @ 标楷体    DFKai-SB\n   @ 仿宋     FangSong\n   @ 楷体     KaiTi\n   @ 仿宋_GB2312  FangSong_GB2312\n   @ 楷体_GB2312  KaiTi_GB2312  \n   @\n   @ 说明：中文字体多数使用宋体、雅黑，英文用Helvetica\n   body { font-family: Microsoft Yahei,SimSun,Helvetica; } \n   ```\n   - 打电话发短信写邮件怎么实现\n   ```\n   // 一、打电话\n   <a href=\"tel:0755-10086\">打电话给:0755-10086</a>\n    \n   //  二、发短信，winphone系统无效\n   <a href=\"sms:10086\">发短信给: 10086</a>\n    \n   // 三、写邮件\n   //注：在添加这些功能时，第一个功能以\"?\"开头，后面的以\"&\"开头\n   //1.普通邮件\n   <a href=\"mailto:863139978@qq.com\">点击我发邮件</a>\n   //2.收件地址后添加?cc=开头，可添加抄送地址（Android存在兼容问题）\n   <a href=\"mailto:863139978@qq.com?cc=zhangqian0406@yeah.net\">点击我发邮件</a>\n   //3.跟着抄送地址后，写上&bcc=,可添加密件抄送地址（Android存在兼容问题）\n   <a href=\"mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&bcc=384900096@qq.com\">点击我发邮件</a>\n   //4.包含多个收件人、抄送、密件抄送人，用分号(;)隔开多个邮件人的地址\n   <a href=\"mailto:863139978@qq.com;384900096@qq.com\">点击我发邮件</a>\n   //5.包含主题，用?subject=\n   <a href=\"mailto:863139978@qq.com?subject=邮件主题\">点击我发邮件</a>\n   //6.包含内容，用?body=;如内容包含文本，使用%0A给文本换行 \n   <a href=\"mailto:863139978@qq.com?body=邮件主题内容%0A腾讯诚信%0A期待您的到来\">点击我发邮件</a>\n   //7.内容包含链接，含http(s)://等的文本自动转化为链接\n   <a href=\"mailto:863139978@qq.com?body=http://www.baidu.com\">点击我发邮件</a>\n   //8.内容包含图片（PC不支持）\n   <a href=\"mailto:863139978@qq.com?body=<img src='images/1.jpg' />\">点击我发邮件</a>\n   //9.完整示例\n   <a href=\"mailto:863139978@qq.com;384900096@qq.com?cc=zhangqian0406@yeah.net&bcc=993233461@qq.com&subject=[邮件主题]&body=腾讯诚邀您参与%0A%0Ahttp://www.baidu.com%0A%0A<img src='images/1.jpg' />\">点击我发邮件</a>\n   ```\n   - 移动端touch事件（区分webkit和winphone）\n   ```\n   /* 当用户手指放在移动设备在屏幕上滑动会触发的touch事件 */\n   // 以下支持webkit\n   touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指\n   touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动\n   touchend——当手指离开屏幕时触发\n   touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用\n    \n   //TouchEvent说明：\n   touches：屏幕上所有手指的信息\n   targetTouches：手指在目标区域的手指信息\n   changedTouches：最近一次触发该事件的手指信息\n   touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息\n    \n   //参数信息(changedTouches[0])\n   clientX、clientY在显示区的坐标\n   target：当前元素\n    \n   //事件响应顺序\n   ontouchstart  > ontouchmove  > ontouchend > onclick\n    \n   // 以下支持winphone 8\n   MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指\n   MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action: none;}可以阻止默认情况的发生：阻止页面滚动\n   MSPointerUp——当手指离开屏幕时触发\n   ```\n   - 移动端click屏幕产生200-300ms的延时响应\n   ```\n   说明：移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。\n    \n   以下是历史原因，来源一个公司内一个同事的分享：\n   2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。\n    \n   双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。\n    \n   原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接<a href=\"#\"></a>，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。\n    \n   //解决方案：\n   fastclick可以解决在手机上点击事件的300ms延迟\n   zepto的touch模块，tap事件也是为了解决在click的延迟问题\n   ```\n   - Rentina显示屏原理及设计方案 \n   ```\n   说明：retina屏是一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个。 \n   在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍。 \n   那么，前端的应对方案是：设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2\n   //例如图片宽高为：200px*200px，那么写法如下\n   .css{width:100px;height:100px;background-size:100px 100px;}\n   //其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px\n   .css{font-size:20px}\n    \n   //image-set设计Rentina背景图\n   image-set,webkit私有属性，也是CSS4的属性，为解决Rentina屏幕下的图像而生。\n   .css {\n       background: url(images/bg.jpg) no-repeat center;\n       background: -webkit-image-set(\n       url(images/bg.jpg) 1x,     //支持image-set普通屏\n       url(images/bg-2x.jpg) 2x); //支持image-set的Rentinan\n   }\n   ```\n   - 点击元素产生背景或边框怎么去掉\n   ```\n   /ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0去除灰色半透明遮罩；\n   //android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果；\n   //winphone系统,点击标签产生的灰色半透明背景，能通过设置<meta name=\"msapplication-tap-highlight\" content=\"no\">去掉；\n   //特殊说明：有些机型去除不了，如小米2。对于按钮类还有个办法，不使用a或者input标签，直接用div标签\n   a,button,input,textarea { \n       -webkit-tap-highlight-color: rgba(0,0,0,0); \n       -webkit-user-modify:read-write-plaintext-only; //-webkit-user-modify有个副作用，就是输入法不再能够输入多个字符\n   }   \n   // 也可以 \n   * { -webkit-tap-highlight-color: rgba(0,0,0,0); }\n   //winphone下\n   <meta name=\"msapplication-tap-highlight\" content=\"no\">\n   ```\n   - 美化表单元素\n   ```\n   //一、使用appearance改变webkit浏览器的默认外观\n   input,select { -webkit-appearance:none; appearance: none; }\n    \n   //二、winphone下，使用伪元素改变表单元素默认外观\n   //1.禁用select默认箭头，::-ms-expand修改表单控件下拉箭头，设置隐藏并使用背景图片来修饰\n   select::-ms-expand { display:none; }\n    \n   //2.禁用radio和checkbox默认样式，::-ms-check修改表单复选框或单选框默认图标，设置隐藏并使用背景图片来修饰\n   input[type=radio]::-ms-check,\n   input[type=checkbox]::-ms-check { display:none; }\n    \n   //3.禁用pc端表单输入框默认清除按钮，::-ms-clear修改清除按钮，设置隐藏并使用背景图片来修饰\n   input[type=text]::-ms-clear,\n   input[type=tel]::-ms-clear,\n   input[type=number]::-ms-clear { display:none; }\n   ```\n   - 移动端字体单位font-size选择px还是rem\n   ```\n   // 如需适配多种移动设备，建议使用rem。以下为参考值：\n   html { font-size: 62.5%; }   //10*16 = 62.5%\n   //设置12px字体   这里注意在rem前要加上对应的px值，解决不支持rem的浏览器的兼容问题，做到优雅降级\n   body { font-size:12px; font-size:1.2rem; }\n   ```\n   - 超实用的CSS样式\n   ```\n   //去掉webkit的滚动条——display: none;\n   //其他参数\n   ::-webkit-scrollba //滚动条整体部分\n   ::-webkit-scrollbar-thumb   //滚动条内的小方块\n   ::-webkit-scrollbar-track   //滚动条轨道\n   ::-webkit-scrollbar-button  //滚动条轨道两端按钮\n   ::-webkit-scrollbar-track-piece  //滚动条中间部分，内置轨道\n   ::-webkit-scrollbar-corner       //边角，两个滚动条交汇处\n   ::-webkit-resizer            //两个滚动条的交汇处上用于通过拖动调整元素大小的小控件\n    \n   // 禁止长按链接与图片弹出菜单\n   a,img { -webkit-touch-callout: none }    \n    \n   // 禁止ios和android用户选中文字\n   html,body {-webkit-user-select:none; user-select: none; }\n    \n   // 改变输入框placeholder的颜色值\n   ::-webkit-input-placeholder { /* WebKit browsers */\n   color: #999; }\n   :-moz-placeholder { /* Mozilla Firefox 4 to 18 */\n   color: #999; }\n   ::-moz-placeholder { /* Mozilla Firefox 19+ */\n   color: #999; }\n   :-ms-input-placeholder { /* Internet Explorer 10+ */\n   color: #999; }\n   input:focus::-webkit-input-placeholder{ color:#999; }\n    \n   // android上去掉语音输入按钮\n   input::-webkit-input-speech-button {display: none}\n    \n   // 阻止windows Phone的默认触摸事件\n   /*说明：winphone下默认触摸事件事件使用e.preventDefault是无效的，可通过样式来禁用，如：*/\n   html { -ms-touch-action:none; } //禁止winphone默认触摸事件\n   取消input在ios下，输入的时候英文首字母的默认大写\n   <input autocapitalize=\"off\" autocorrect=\"off\" />\n   ```\n   - 手机拍照和上传图片\n   ```\n   //IOS有拍照、录像、选取本地图片功能，部分Android只有选择本地图片功能。Winphone不支持\n   <input type=\"file\" accept=\"images/*\" />\n   <input type=\"file\" accept=\"video/*\" />\n   ```\n   - 屏幕旋转的事件和样式\n   ```\n   //JS处理\n   function orientInit(){\n       var orientChk = document.documentElement.clientWidth > document.documentElement.clientHeight?'landscape':'portrait';\n       if(orientChk =='lapdscape'){\n           //这里是横屏下需要执行的事件\n       }else{\n           //这里是竖屏下需要执行的事件\n       }\n   }\n    \n   orientInit();\n   window.addEventListener('onorientationchange' in window?'orientationchange':'resize', function(){\n       setTimeout(orientInit, 100);\n   },false)    \n    \n   //CSS处理\n   //竖屏时样式\n   @media all and (orientation:portrait){   }\n   //横屏时样式\n   @media all and (orientation:landscape){   }\n   audio元素和video元素在ios和andriod中无法自动播放\n   //音频，写法一\n   <audio src=\"music/bg.mp3\" autoplay loop controls>你的浏览器还不支持哦</audio>\n    \n   //音频，写法二\n   <audio controls=\"controls\"> \n       <source src=\"music/bg.ogg\" type=\"audio/ogg\"></source>\n       <source src=\"music/bg.mp3\" type=\"audio/mpeg\"></source>\n       优先播放音乐bg.ogg，不支持在播放bg.mp3\n   </audio>\n    \n   //JS绑定自动播放（操作window时，播放音乐）\n   $(window).one('touchstart', function(){\n       music.play();\n   })\n    \n   //微信下兼容处理\n   document.addEventListener(\"WeixinJSBridgeReady\", function () {\n       music.play();\n   }, false);\n    \n   //小结\n   //1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常\n   //2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间\n   ```\n   - 重力感应事件\n   ```\n   // 运用HTML5的deviceMotion，调用重力感应事件\n   if(window.DeviceMotionEvent){\n       document.addEventListener('devicemotion', deviceMotionHandler, false)\n   }   \n    \n   var speed = 30;\n   var x = y = z = lastX = lastY = lastZ = 0;\n   function deviceMotionHandler(eventData){\n       var acceleration = event.accelerationIncludingGravity;\n       x = acceleration.x;\n       y = acceleration.y; \n       z = acceleration.z;\n       if(Math.abs(x-lastX)>speed || Math.abs(y-lastY)>speed || Math.abs(z-lastZ)>speed ){\n           //这里是摇动后要执行的方法 \n           yaoAfter();\n       }\n       lastX = x;\n       lastY = y;\n       lastZ = z;\n   }\n    \n   function yaoAfter(){\n       //do something\n   }\n   ```\n   - 微信浏览器用户调整字体大小后页面矬了，怎么阻止用户调整\n   ```\n   //以下代码可使Android机页面不再受用户字体缩放强制改变大小，但是会有1S左右延时，期间可以考虑loading来处理\n   if (typeof(WeixinJSBridge) == \"undefined\") {\n       document.addEventListener(\"WeixinJSBridgeReady\", function (e) {\n           setTimeout(function(){\n               WeixinJSBridge.invoke('setFontSizeCallback', { 'fontSize':0}, function(res){\n                   alert(JSON.stringify(res));\n               })\n           }, 0)\n       });\n   }else{  \n       setTimeout(function(){\n           WeixinJSBridge.invoke('setFontSizeCallback', { 'fontSize':0}, function(res){\n               alert(JSON.stringify(res));\n           })\n       }, 0)   \n   }\n    \n   //IOS下可使用 -webkit-text-size-adjust禁止用户调整字体大小\n   body { -webkit-text-size-adjust:100%!important; }\n    \n   //最好的解决方案：最好使用rem或百分比布局\n   ```\n   - 定位的坑\n   ```\n   //fixed定位\n   //1.ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位\n   //2.android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位\n   //3.ios4下不支持position:fixed\n   //解决方案：使用[Iscroll](http://cubiq.org/iscroll-5)，如：\n   <div id=\"wrapper\">\n           <ul>\n                  <li></li>\n                  .....\n           </ul>\n   </div>\n   <script src=\"iscroll.js\"></script>\n   <script>\n       var myscroll;\n       function loaded(){\n           myscroll=new iScroll(\"wrapper\");\n       }\n       window.addEventListener(\"DOMContentLoaded\",loaded,false);\n   </script>\n    \n    \n   //position定位\n   //Android下弹出软键盘弹出时，影响absolute元素定位\n   //解决方案:\n   var ua = navigator.userAgent.indexOf('Android');\n   if(ua>-1){\n       $('.ipt').on('focus', function(){\n           $('.css').css({'visibility':'hidden'})\n       }).on('blur', function(){\n           $('.css').css({'visibility':'visible'})\n       })\n   }\n   ```\n   - 播放视频不全屏\n   ```\n   <!--\n   1.ios7+支持自动播放\n   2.支持Airplay的设备（如：音箱、Apple TV)播放\n   x-webkit-airplay=\"true\" \n   3.播放视频不全屏\n   webkit-playsinline=\"true\" \n   -->\n   <video x-webkit-airplay=\"true\" webkit-playsinline=\"true\" preload=\"auto\" autoplay src=\"http://\"></video>\n   JS判断设备\n   function deviceType(){\n       var ua = navigator.userAgent;\n       var agent = [\"Android\", \"iPhone\", \"SymbianOS\", \"Windows Phone\", \"iPad\", \"iPod\"];    \n       for(var i=0; i<len,len = agent.length; i++){\n           if(ua.indexOf(agent[i])>0){         \n               break;\n           }\n       }\n   }\n   deviceType();\n   window.addEventListener('resize', function(){\n       deviceType();\n   })\n   ```\n   - JS判断微信浏览器\n   ```\n   function isWeixin(){\n       var ua = navigator.userAgent.toLowerCase();\n       if(ua.match(/MicroMessenger/i)=='micromessenger'){\n           return true;\n       }else{\n           return false;\n       }\n   }\n   ```\n   - android 2.3 bug\n   ```\n   //1.@-webkit-keyframes 需要以0%开始100%结束，0%的百分号不能去掉\n   //2.after和before伪类无法使用动画animation\n   //3.border-radius不支持%单位，如要兼容，可以给radius设置一下较大的值\n   //4.translate百分比的写法和scale在一起会导致失效，例如：\n   -webkit-transform: translate(-50%,-50%) scale(-0.5, 1)\n   android 4.x bug\n   //1.三星 Galaxy S4中自带浏览器不支持border-radius缩写\n   //2.同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分\n   //3.部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色\n   //4.android无法同时播放多音频audio\n   消除transition闪屏\n   .css {\n       -webkit-transform-style: preserve-3d;\n       -webkit-backface-visibility: hidden;\n       -webkit-perspective: 1000;\n   }\n   ```\n   - 开启硬件加速\n   ```\n   //目前，像Chrome/Filefox/Safari/IE9+以及最新版本Opera都支持硬件加速，当检测到某个DOM元素应用了某些CSS规则时就会自动开启，从而解决页面闪白，保证动画流畅。\n   .css {\n       -webkit-transform: translate3d(0,0,0);\n       -moz-transform: translate3d(0,0,0);\n       -ms-transform: translate3d(0,0,0);\n       transform: translate3d(0,0,0);\n   }\n   ```\n   - 渲染优化\n   ```\n    //1.禁止使用iframe（阻塞父文档onload事件）\n    //2.禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能）\n    //使用CSS3代码代替JS动画；\n    //开启GPU加速；\n    //使用base64位编码图片(不小图而言，大图不建议使用)\n        // 对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费CPU。小图标优势在于：\n        //1.减少HTTP请求；\n        //2.避免文件跨域；\n        //3.修改及时生效；\n   ```  \n[文章参考来源](https://github.com/FrontEndZQ/HTML5-FAQ)","slug":"h5bug","published":1,"updated":"2016-12-22T08:48:39.780Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv81001zjgtu1gqbyt6f","content":"<p><strong>1.Meta基础知识：</strong></p>\n<ul>\n<li><p>H5页面窗口自动调整到设备宽度，并禁止用户缩放页面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">//一、HTML页面结构</div><div class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;</div><div class=\"line\">// width    设置viewport宽度，为一个正整数，或字符串‘device-width’</div><div class=\"line\">// height   设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置</div><div class=\"line\">// initial-scale    默认缩放比例，为一个数字，可以带小数</div><div class=\"line\">// minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数</div><div class=\"line\">// maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数</div><div class=\"line\">// user-scalable    是否允许手动缩放</div><div class=\"line\"> </div><div class=\"line\">//二、JS动态判断</div><div class=\"line\">var phoneWidth =  parseInt(window.screen.width);</div><div class=\"line\">var phoneScale = phoneWidth/640;</div><div class=\"line\">var ua = navigator.userAgent;</div><div class=\"line\">if (/Android (\\d+\\.\\d+)/.test(ua))&#123;</div><div class=\"line\">    var version = parseFloat(RegExp.$1);</div><div class=\"line\">    if(version&gt;2.3)&#123;</div><div class=\"line\">        document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, minimum-scale = &apos;+phoneScale+&apos;, maximum-scale = &apos;+phoneScale+&apos;, target-densitydpi=device-dpi&quot;&gt;&apos;);</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">        document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, target-densitydpi=device-dpi&quot;&gt;&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, user-scalable=no, target-densitydpi=device-dpi&quot;&gt;&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>空白页基本meta标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 设置缩放 --&gt;</div><div class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no, minimal-ui&quot; /&gt;</div><div class=\"line\">&lt;!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果） --&gt;</div><div class=\"line\">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;</div><div class=\"line\">&lt;!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） --&gt;</div><div class=\"line\">&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;</div><div class=\"line\">&lt;!-- IOS中禁用将数字识别为电话号码/忽略Android平台中对邮箱地址的识别 --&gt;</div><div class=\"line\">&lt;meta name=&quot;format-detection&quot;content=&quot;telephone=no, email=no&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>其他meta标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;</div><div class=\"line\">&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</div><div class=\"line\">&lt;!-- 避免IE使用兼容模式 --&gt;</div><div class=\"line\">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</div><div class=\"line\">&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;</div><div class=\"line\">&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;</div><div class=\"line\">&lt;!-- 微软的老式浏览器 --&gt;</div><div class=\"line\">&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;</div><div class=\"line\">&lt;!-- uc强制竖屏 --&gt;</div><div class=\"line\">&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;</div><div class=\"line\">&lt;!-- QQ强制竖屏 --&gt;</div><div class=\"line\">&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;</div><div class=\"line\">&lt;!-- UC强制全屏 --&gt;</div><div class=\"line\">&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;</div><div class=\"line\">&lt;!-- QQ强制全屏 --&gt;</div><div class=\"line\">&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;</div><div class=\"line\">&lt;!-- UC应用模式 --&gt;</div><div class=\"line\">&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;</div><div class=\"line\">&lt;!-- QQ应用模式 --&gt;</div><div class=\"line\">&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;</div><div class=\"line\">&lt;!-- windows phone 点击无高光 --&gt;</div><div class=\"line\">&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>常见问题：</strong></p>\n<ul>\n<li><p>移动端如何定义字体font-family</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@ --------------------------------------中文字体的英文名称</div><div class=\"line\">@ 宋体      SimSun</div><div class=\"line\">@ 黑体      SimHei</div><div class=\"line\">@ 微信雅黑   Microsoft Yahei</div><div class=\"line\">@ 微软正黑体 Microsoft JhengHei</div><div class=\"line\">@ 新宋体    NSimSun</div><div class=\"line\">@ 新细明体  MingLiU</div><div class=\"line\">@ 细明体    MingLiU</div><div class=\"line\">@ 标楷体    DFKai-SB</div><div class=\"line\">@ 仿宋     FangSong</div><div class=\"line\">@ 楷体     KaiTi</div><div class=\"line\">@ 仿宋_GB2312  FangSong_GB2312</div><div class=\"line\">@ 楷体_GB2312  KaiTi_GB2312  </div><div class=\"line\">@</div><div class=\"line\">@ 说明：中文字体多数使用宋体、雅黑，英文用Helvetica</div><div class=\"line\">body &#123; font-family: Microsoft Yahei,SimSun,Helvetica; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>打电话发短信写邮件怎么实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 一、打电话</div><div class=\"line\">&lt;a href=&quot;tel:0755-10086&quot;&gt;打电话给:0755-10086&lt;/a&gt;</div><div class=\"line\"> </div><div class=\"line\">//  二、发短信，winphone系统无效</div><div class=\"line\">&lt;a href=&quot;sms:10086&quot;&gt;发短信给: 10086&lt;/a&gt;</div><div class=\"line\"> </div><div class=\"line\">// 三、写邮件</div><div class=\"line\">//注：在添加这些功能时，第一个功能以&quot;?&quot;开头，后面的以&quot;&amp;&quot;开头</div><div class=\"line\">//1.普通邮件</div><div class=\"line\">&lt;a href=&quot;mailto:863139978@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;</div><div class=\"line\">//2.收件地址后添加?cc=开头，可添加抄送地址（Android存在兼容问题）</div><div class=\"line\">&lt;a href=&quot;mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&quot;&gt;点击我发邮件&lt;/a&gt;</div><div class=\"line\">//3.跟着抄送地址后，写上&amp;bcc=,可添加密件抄送地址（Android存在兼容问题）</div><div class=\"line\">&lt;a href=&quot;mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=384900096@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;</div><div class=\"line\">//4.包含多个收件人、抄送、密件抄送人，用分号(;)隔开多个邮件人的地址</div><div class=\"line\">&lt;a href=&quot;mailto:863139978@qq.com;384900096@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;</div><div class=\"line\">//5.包含主题，用?subject=</div><div class=\"line\">&lt;a href=&quot;mailto:863139978@qq.com?subject=邮件主题&quot;&gt;点击我发邮件&lt;/a&gt;</div><div class=\"line\">//6.包含内容，用?body=;如内容包含文本，使用%0A给文本换行 </div><div class=\"line\">&lt;a href=&quot;mailto:863139978@qq.com?body=邮件主题内容%0A腾讯诚信%0A期待您的到来&quot;&gt;点击我发邮件&lt;/a&gt;</div><div class=\"line\">//7.内容包含链接，含http(s)://等的文本自动转化为链接</div><div class=\"line\">&lt;a href=&quot;mailto:863139978@qq.com?body=http://www.baidu.com&quot;&gt;点击我发邮件&lt;/a&gt;</div><div class=\"line\">//8.内容包含图片（PC不支持）</div><div class=\"line\">&lt;a href=&quot;mailto:863139978@qq.com?body=&lt;img src=&apos;images/1.jpg&apos; /&gt;&quot;&gt;点击我发邮件&lt;/a&gt;</div><div class=\"line\">//9.完整示例</div><div class=\"line\">&lt;a href=&quot;mailto:863139978@qq.com;384900096@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=993233461@qq.com&amp;subject=[邮件主题]&amp;body=腾讯诚邀您参与%0A%0Ahttp://www.baidu.com%0A%0A&lt;img src=&apos;images/1.jpg&apos; /&gt;&quot;&gt;点击我发邮件&lt;/a&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>移动端touch事件（区分webkit和winphone）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* 当用户手指放在移动设备在屏幕上滑动会触发的touch事件 */</div><div class=\"line\">// 以下支持webkit</div><div class=\"line\">touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指</div><div class=\"line\">touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动</div><div class=\"line\">touchend——当手指离开屏幕时触发</div><div class=\"line\">touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用</div><div class=\"line\"> </div><div class=\"line\">//TouchEvent说明：</div><div class=\"line\">touches：屏幕上所有手指的信息</div><div class=\"line\">targetTouches：手指在目标区域的手指信息</div><div class=\"line\">changedTouches：最近一次触发该事件的手指信息</div><div class=\"line\">touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息</div><div class=\"line\"> </div><div class=\"line\">//参数信息(changedTouches[0])</div><div class=\"line\">clientX、clientY在显示区的坐标</div><div class=\"line\">target：当前元素</div><div class=\"line\"> </div><div class=\"line\">//事件响应顺序</div><div class=\"line\">ontouchstart  &gt; ontouchmove  &gt; ontouchend &gt; onclick</div><div class=\"line\"> </div><div class=\"line\">// 以下支持winphone 8</div><div class=\"line\">MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指</div><div class=\"line\">MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html&#123;-ms-touch-action: none;&#125;可以阻止默认情况的发生：阻止页面滚动</div><div class=\"line\">MSPointerUp——当手指离开屏幕时触发</div></pre></td></tr></table></figure>\n</li>\n<li><p>移动端click屏幕产生200-300ms的延时响应</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">说明：移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。</div><div class=\"line\"> </div><div class=\"line\">以下是历史原因，来源一个公司内一个同事的分享：</div><div class=\"line\">2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。</div><div class=\"line\"> </div><div class=\"line\">双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。</div><div class=\"line\"> </div><div class=\"line\">原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。</div><div class=\"line\"> </div><div class=\"line\">//解决方案：</div><div class=\"line\">fastclick可以解决在手机上点击事件的300ms延迟</div><div class=\"line\">zepto的touch模块，tap事件也是为了解决在click的延迟问题</div></pre></td></tr></table></figure>\n</li>\n<li><p>Rentina显示屏原理及设计方案 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">说明：retina屏是一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个。 </div><div class=\"line\">在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍。 </div><div class=\"line\">那么，前端的应对方案是：设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2</div><div class=\"line\">//例如图片宽高为：200px*200px，那么写法如下</div><div class=\"line\">.css&#123;width:100px;height:100px;background-size:100px 100px;&#125;</div><div class=\"line\">//其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px</div><div class=\"line\">.css&#123;font-size:20px&#125;</div><div class=\"line\"> </div><div class=\"line\">//image-set设计Rentina背景图</div><div class=\"line\">image-set,webkit私有属性，也是CSS4的属性，为解决Rentina屏幕下的图像而生。</div><div class=\"line\">.css &#123;</div><div class=\"line\">    background: url(images/bg.jpg) no-repeat center;</div><div class=\"line\">    background: -webkit-image-set(</div><div class=\"line\">    url(images/bg.jpg) 1x,     //支持image-set普通屏</div><div class=\"line\">    url(images/bg-2x.jpg) 2x); //支持image-set的Rentinan</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>点击元素产生背景或边框怎么去掉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">/ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0去除灰色半透明遮罩；</div><div class=\"line\">//android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果；</div><div class=\"line\">//winphone系统,点击标签产生的灰色半透明背景，能通过设置&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;去掉；</div><div class=\"line\">//特殊说明：有些机型去除不了，如小米2。对于按钮类还有个办法，不使用a或者input标签，直接用div标签</div><div class=\"line\">a,button,input,textarea &#123; </div><div class=\"line\">    -webkit-tap-highlight-color: rgba(0,0,0,0); </div><div class=\"line\">    -webkit-user-modify:read-write-plaintext-only; //-webkit-user-modify有个副作用，就是输入法不再能够输入多个字符</div><div class=\"line\">&#125;   </div><div class=\"line\">// 也可以 </div><div class=\"line\">* &#123; -webkit-tap-highlight-color: rgba(0,0,0,0); &#125;</div><div class=\"line\">//winphone下</div><div class=\"line\">&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>美化表单元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">//一、使用appearance改变webkit浏览器的默认外观</div><div class=\"line\">input,select &#123; -webkit-appearance:none; appearance: none; &#125;</div><div class=\"line\"> </div><div class=\"line\">//二、winphone下，使用伪元素改变表单元素默认外观</div><div class=\"line\">//1.禁用select默认箭头，::-ms-expand修改表单控件下拉箭头，设置隐藏并使用背景图片来修饰</div><div class=\"line\">select::-ms-expand &#123; display:none; &#125;</div><div class=\"line\"> </div><div class=\"line\">//2.禁用radio和checkbox默认样式，::-ms-check修改表单复选框或单选框默认图标，设置隐藏并使用背景图片来修饰</div><div class=\"line\">input[type=radio]::-ms-check,</div><div class=\"line\">input[type=checkbox]::-ms-check &#123; display:none; &#125;</div><div class=\"line\"> </div><div class=\"line\">//3.禁用pc端表单输入框默认清除按钮，::-ms-clear修改清除按钮，设置隐藏并使用背景图片来修饰</div><div class=\"line\">input[type=text]::-ms-clear,</div><div class=\"line\">input[type=tel]::-ms-clear,</div><div class=\"line\">input[type=number]::-ms-clear &#123; display:none; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>移动端字体单位font-size选择px还是rem</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 如需适配多种移动设备，建议使用rem。以下为参考值：</div><div class=\"line\">html &#123; font-size: 62.5%; &#125;   //10*16 = 62.5%</div><div class=\"line\">//设置12px字体   这里注意在rem前要加上对应的px值，解决不支持rem的浏览器的兼容问题，做到优雅降级</div><div class=\"line\">body &#123; font-size:12px; font-size:1.2rem; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>超实用的CSS样式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">//去掉webkit的滚动条——display: none;</div><div class=\"line\">//其他参数</div><div class=\"line\">::-webkit-scrollba //滚动条整体部分</div><div class=\"line\">::-webkit-scrollbar-thumb   //滚动条内的小方块</div><div class=\"line\">::-webkit-scrollbar-track   //滚动条轨道</div><div class=\"line\">::-webkit-scrollbar-button  //滚动条轨道两端按钮</div><div class=\"line\">::-webkit-scrollbar-track-piece  //滚动条中间部分，内置轨道</div><div class=\"line\">::-webkit-scrollbar-corner       //边角，两个滚动条交汇处</div><div class=\"line\">::-webkit-resizer            //两个滚动条的交汇处上用于通过拖动调整元素大小的小控件</div><div class=\"line\"> </div><div class=\"line\">// 禁止长按链接与图片弹出菜单</div><div class=\"line\">a,img &#123; -webkit-touch-callout: none &#125;    </div><div class=\"line\"> </div><div class=\"line\">// 禁止ios和android用户选中文字</div><div class=\"line\">html,body &#123;-webkit-user-select:none; user-select: none; &#125;</div><div class=\"line\"> </div><div class=\"line\">// 改变输入框placeholder的颜色值</div><div class=\"line\">::-webkit-input-placeholder &#123; /* WebKit browsers */</div><div class=\"line\">color: #999; &#125;</div><div class=\"line\">:-moz-placeholder &#123; /* Mozilla Firefox 4 to 18 */</div><div class=\"line\">color: #999; &#125;</div><div class=\"line\">::-moz-placeholder &#123; /* Mozilla Firefox 19+ */</div><div class=\"line\">color: #999; &#125;</div><div class=\"line\">:-ms-input-placeholder &#123; /* Internet Explorer 10+ */</div><div class=\"line\">color: #999; &#125;</div><div class=\"line\">input:focus::-webkit-input-placeholder&#123; color:#999; &#125;</div><div class=\"line\"> </div><div class=\"line\">// android上去掉语音输入按钮</div><div class=\"line\">input::-webkit-input-speech-button &#123;display: none&#125;</div><div class=\"line\"> </div><div class=\"line\">// 阻止windows Phone的默认触摸事件</div><div class=\"line\">/*说明：winphone下默认触摸事件事件使用e.preventDefault是无效的，可通过样式来禁用，如：*/</div><div class=\"line\">html &#123; -ms-touch-action:none; &#125; //禁止winphone默认触摸事件</div><div class=\"line\">取消input在ios下，输入的时候英文首字母的默认大写</div><div class=\"line\">&lt;input autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>手机拍照和上传图片</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//IOS有拍照、录像、选取本地图片功能，部分Android只有选择本地图片功能。Winphone不支持</div><div class=\"line\">&lt;input type=&quot;file&quot; accept=&quot;images/*&quot; /&gt;</div><div class=\"line\">&lt;input type=&quot;file&quot; accept=&quot;video/*&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>屏幕旋转的事件和样式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">//JS处理</div><div class=\"line\">function orientInit()&#123;</div><div class=\"line\">    var orientChk = document.documentElement.clientWidth &gt; document.documentElement.clientHeight?&apos;landscape&apos;:&apos;portrait&apos;;</div><div class=\"line\">    if(orientChk ==&apos;lapdscape&apos;)&#123;</div><div class=\"line\">        //这里是横屏下需要执行的事件</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">        //这里是竖屏下需要执行的事件</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">orientInit();</div><div class=\"line\">window.addEventListener(&apos;onorientationchange&apos; in window?&apos;orientationchange&apos;:&apos;resize&apos;, function()&#123;</div><div class=\"line\">    setTimeout(orientInit, 100);</div><div class=\"line\">&#125;,false)    </div><div class=\"line\"> </div><div class=\"line\">//CSS处理</div><div class=\"line\">//竖屏时样式</div><div class=\"line\">@media all and (orientation:portrait)&#123;   &#125;</div><div class=\"line\">//横屏时样式</div><div class=\"line\">@media all and (orientation:landscape)&#123;   &#125;</div><div class=\"line\">audio元素和video元素在ios和andriod中无法自动播放</div><div class=\"line\">//音频，写法一</div><div class=\"line\">&lt;audio src=&quot;music/bg.mp3&quot; autoplay loop controls&gt;你的浏览器还不支持哦&lt;/audio&gt;</div><div class=\"line\"> </div><div class=\"line\">//音频，写法二</div><div class=\"line\">&lt;audio controls=&quot;controls&quot;&gt; </div><div class=\"line\">    &lt;source src=&quot;music/bg.ogg&quot; type=&quot;audio/ogg&quot;&gt;&lt;/source&gt;</div><div class=\"line\">    &lt;source src=&quot;music/bg.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/source&gt;</div><div class=\"line\">    优先播放音乐bg.ogg，不支持在播放bg.mp3</div><div class=\"line\">&lt;/audio&gt;</div><div class=\"line\"> </div><div class=\"line\">//JS绑定自动播放（操作window时，播放音乐）</div><div class=\"line\">$(window).one(&apos;touchstart&apos;, function()&#123;</div><div class=\"line\">    music.play();</div><div class=\"line\">&#125;)</div><div class=\"line\"> </div><div class=\"line\">//微信下兼容处理</div><div class=\"line\">document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () &#123;</div><div class=\"line\">    music.play();</div><div class=\"line\">&#125;, false);</div><div class=\"line\"> </div><div class=\"line\">//小结</div><div class=\"line\">//1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常</div><div class=\"line\">//2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间</div></pre></td></tr></table></figure>\n</li>\n<li><p>重力感应事件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 运用HTML5的deviceMotion，调用重力感应事件</div><div class=\"line\">if(window.DeviceMotionEvent)&#123;</div><div class=\"line\">    document.addEventListener(&apos;devicemotion&apos;, deviceMotionHandler, false)</div><div class=\"line\">&#125;   </div><div class=\"line\"> </div><div class=\"line\">var speed = 30;</div><div class=\"line\">var x = y = z = lastX = lastY = lastZ = 0;</div><div class=\"line\">function deviceMotionHandler(eventData)&#123;</div><div class=\"line\">    var acceleration = event.accelerationIncludingGravity;</div><div class=\"line\">    x = acceleration.x;</div><div class=\"line\">    y = acceleration.y; </div><div class=\"line\">    z = acceleration.z;</div><div class=\"line\">    if(Math.abs(x-lastX)&gt;speed || Math.abs(y-lastY)&gt;speed || Math.abs(z-lastZ)&gt;speed )&#123;</div><div class=\"line\">        //这里是摇动后要执行的方法 </div><div class=\"line\">        yaoAfter();</div><div class=\"line\">    &#125;</div><div class=\"line\">    lastX = x;</div><div class=\"line\">    lastY = y;</div><div class=\"line\">    lastZ = z;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">function yaoAfter()&#123;</div><div class=\"line\">    //do something</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>微信浏览器用户调整字体大小后页面矬了，怎么阻止用户调整</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以下代码可使Android机页面不再受用户字体缩放强制改变大小，但是会有1S左右延时，期间可以考虑loading来处理</div><div class=\"line\">if (typeof(WeixinJSBridge) == &quot;undefined&quot;) &#123;</div><div class=\"line\">    document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function (e) &#123;</div><div class=\"line\">        setTimeout(function()&#123;</div><div class=\"line\">            WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;, &#123; &apos;fontSize&apos;:0&#125;, function(res)&#123;</div><div class=\"line\">                alert(JSON.stringify(res));</div><div class=\"line\">            &#125;)</div><div class=\"line\">        &#125;, 0)</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;else&#123;  </div><div class=\"line\">    setTimeout(function()&#123;</div><div class=\"line\">        WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;, &#123; &apos;fontSize&apos;:0&#125;, function(res)&#123;</div><div class=\"line\">            alert(JSON.stringify(res));</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;, 0)   </div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">//IOS下可使用 -webkit-text-size-adjust禁止用户调整字体大小</div><div class=\"line\">body &#123; -webkit-text-size-adjust:100%!important; &#125;</div><div class=\"line\"> </div><div class=\"line\">//最好的解决方案：最好使用rem或百分比布局</div></pre></td></tr></table></figure>\n</li>\n<li><p>定位的坑</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">//fixed定位</div><div class=\"line\">//1.ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位</div><div class=\"line\">//2.android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位</div><div class=\"line\">//3.ios4下不支持position:fixed</div><div class=\"line\">//解决方案：使用[Iscroll](http://cubiq.org/iscroll-5)，如：</div><div class=\"line\">&lt;div id=&quot;wrapper&quot;&gt;</div><div class=\"line\">        &lt;ul&gt;</div><div class=\"line\">               &lt;li&gt;&lt;/li&gt;</div><div class=\"line\">               .....</div><div class=\"line\">        &lt;/ul&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">&lt;script src=&quot;iscroll.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script&gt;</div><div class=\"line\">    var myscroll;</div><div class=\"line\">    function loaded()&#123;</div><div class=\"line\">        myscroll=new iScroll(&quot;wrapper&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    window.addEventListener(&quot;DOMContentLoaded&quot;,loaded,false);</div><div class=\"line\">&lt;/script&gt;</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\">//position定位</div><div class=\"line\">//Android下弹出软键盘弹出时，影响absolute元素定位</div><div class=\"line\">//解决方案:</div><div class=\"line\">var ua = navigator.userAgent.indexOf(&apos;Android&apos;);</div><div class=\"line\">if(ua&gt;-1)&#123;</div><div class=\"line\">    $(&apos;.ipt&apos;).on(&apos;focus&apos;, function()&#123;</div><div class=\"line\">        $(&apos;.css&apos;).css(&#123;&apos;visibility&apos;:&apos;hidden&apos;&#125;)</div><div class=\"line\">    &#125;).on(&apos;blur&apos;, function()&#123;</div><div class=\"line\">        $(&apos;.css&apos;).css(&#123;&apos;visibility&apos;:&apos;visible&apos;&#125;)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>播放视频不全屏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!--</div><div class=\"line\">1.ios7+支持自动播放</div><div class=\"line\">2.支持Airplay的设备（如：音箱、Apple TV)播放</div><div class=\"line\">x-webkit-airplay=&quot;true&quot; </div><div class=\"line\">3.播放视频不全屏</div><div class=\"line\">webkit-playsinline=&quot;true&quot; </div><div class=\"line\">--&gt;</div><div class=\"line\">&lt;video x-webkit-airplay=&quot;true&quot; webkit-playsinline=&quot;true&quot; preload=&quot;auto&quot; autoplay src=&quot;http://&quot;&gt;&lt;/video&gt;</div><div class=\"line\">JS判断设备</div><div class=\"line\">function deviceType()&#123;</div><div class=\"line\">    var ua = navigator.userAgent;</div><div class=\"line\">    var agent = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;];    </div><div class=\"line\">    for(var i=0; i&lt;len,len = agent.length; i++)&#123;</div><div class=\"line\">        if(ua.indexOf(agent[i])&gt;0)&#123;         </div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">deviceType();</div><div class=\"line\">window.addEventListener(&apos;resize&apos;, function()&#123;</div><div class=\"line\">    deviceType();</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p>JS判断微信浏览器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function isWeixin()&#123;</div><div class=\"line\">    var ua = navigator.userAgent.toLowerCase();</div><div class=\"line\">    if(ua.match(/MicroMessenger/i)==&apos;micromessenger&apos;)&#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>android 2.3 bug</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//1.@-webkit-keyframes 需要以0%开始100%结束，0%的百分号不能去掉</div><div class=\"line\">//2.after和before伪类无法使用动画animation</div><div class=\"line\">//3.border-radius不支持%单位，如要兼容，可以给radius设置一下较大的值</div><div class=\"line\">//4.translate百分比的写法和scale在一起会导致失效，例如：</div><div class=\"line\">-webkit-transform: translate(-50%,-50%) scale(-0.5, 1)</div><div class=\"line\">android 4.x bug</div><div class=\"line\">//1.三星 Galaxy S4中自带浏览器不支持border-radius缩写</div><div class=\"line\">//2.同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分</div><div class=\"line\">//3.部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色</div><div class=\"line\">//4.android无法同时播放多音频audio</div><div class=\"line\">消除transition闪屏</div><div class=\"line\">.css &#123;</div><div class=\"line\">    -webkit-transform-style: preserve-3d;</div><div class=\"line\">    -webkit-backface-visibility: hidden;</div><div class=\"line\">    -webkit-perspective: 1000;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>开启硬件加速</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//目前，像Chrome/Filefox/Safari/IE9+以及最新版本Opera都支持硬件加速，当检测到某个DOM元素应用了某些CSS规则时就会自动开启，从而解决页面闪白，保证动画流畅。</div><div class=\"line\">.css &#123;</div><div class=\"line\">    -webkit-transform: translate3d(0,0,0);</div><div class=\"line\">    -moz-transform: translate3d(0,0,0);</div><div class=\"line\">    -ms-transform: translate3d(0,0,0);</div><div class=\"line\">    transform: translate3d(0,0,0);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>渲染优化</p>\n<pre><code>//1.禁止使用iframe（阻塞父文档onload事件）\n//2.禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能）\n//使用CSS3代码代替JS动画；\n//开启GPU加速；\n//使用base64位编码图片(不小图而言，大图不建议使用)\n   // 对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费CPU。小图标优势在于：\n   //1.减少HTTP请求；\n   //2.避免文件跨域；\n   //3.修改及时生效；\n</code></pre><p><a href=\"https://github.com/FrontEndZQ/HTML5-FAQ\" target=\"_blank\" rel=\"external\">文章参考来源</a></p>\n</li>\n</ul>\n","excerpt":"","more":"<p><strong>1.Meta基础知识：</strong></p>\n<ul>\n<li><p>H5页面窗口自动调整到设备宽度，并禁止用户缩放页面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">//一、HTML页面结构</div><div class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;</div><div class=\"line\">// width    设置viewport宽度，为一个正整数，或字符串‘device-width’</div><div class=\"line\">// height   设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置</div><div class=\"line\">// initial-scale    默认缩放比例，为一个数字，可以带小数</div><div class=\"line\">// minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数</div><div class=\"line\">// maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数</div><div class=\"line\">// user-scalable    是否允许手动缩放</div><div class=\"line\"> </div><div class=\"line\">//二、JS动态判断</div><div class=\"line\">var phoneWidth =  parseInt(window.screen.width);</div><div class=\"line\">var phoneScale = phoneWidth/640;</div><div class=\"line\">var ua = navigator.userAgent;</div><div class=\"line\">if (/Android (\\d+\\.\\d+)/.test(ua))&#123;</div><div class=\"line\">    var version = parseFloat(RegExp.$1);</div><div class=\"line\">    if(version&gt;2.3)&#123;</div><div class=\"line\">        document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, minimum-scale = &apos;+phoneScale+&apos;, maximum-scale = &apos;+phoneScale+&apos;, target-densitydpi=device-dpi&quot;&gt;&apos;);</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">        document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, target-densitydpi=device-dpi&quot;&gt;&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, user-scalable=no, target-densitydpi=device-dpi&quot;&gt;&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>空白页基本meta标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 设置缩放 --&gt;</div><div class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no, minimal-ui&quot; /&gt;</div><div class=\"line\">&lt;!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果） --&gt;</div><div class=\"line\">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;</div><div class=\"line\">&lt;!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） --&gt;</div><div class=\"line\">&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;</div><div class=\"line\">&lt;!-- IOS中禁用将数字识别为电话号码/忽略Android平台中对邮箱地址的识别 --&gt;</div><div class=\"line\">&lt;meta name=&quot;format-detection&quot;content=&quot;telephone=no, email=no&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>其他meta标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;</div><div class=\"line\">&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</div><div class=\"line\">&lt;!-- 避免IE使用兼容模式 --&gt;</div><div class=\"line\">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</div><div class=\"line\">&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;</div><div class=\"line\">&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;</div><div class=\"line\">&lt;!-- 微软的老式浏览器 --&gt;</div><div class=\"line\">&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;</div><div class=\"line\">&lt;!-- uc强制竖屏 --&gt;</div><div class=\"line\">&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;</div><div class=\"line\">&lt;!-- QQ强制竖屏 --&gt;</div><div class=\"line\">&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;</div><div class=\"line\">&lt;!-- UC强制全屏 --&gt;</div><div class=\"line\">&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;</div><div class=\"line\">&lt;!-- QQ强制全屏 --&gt;</div><div class=\"line\">&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;</div><div class=\"line\">&lt;!-- UC应用模式 --&gt;</div><div class=\"line\">&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;</div><div class=\"line\">&lt;!-- QQ应用模式 --&gt;</div><div class=\"line\">&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;</div><div class=\"line\">&lt;!-- windows phone 点击无高光 --&gt;</div><div class=\"line\">&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>常见问题：</strong></p>\n<ul>\n<li><p>移动端如何定义字体font-family</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@ --------------------------------------中文字体的英文名称</div><div class=\"line\">@ 宋体      SimSun</div><div class=\"line\">@ 黑体      SimHei</div><div class=\"line\">@ 微信雅黑   Microsoft Yahei</div><div class=\"line\">@ 微软正黑体 Microsoft JhengHei</div><div class=\"line\">@ 新宋体    NSimSun</div><div class=\"line\">@ 新细明体  MingLiU</div><div class=\"line\">@ 细明体    MingLiU</div><div class=\"line\">@ 标楷体    DFKai-SB</div><div class=\"line\">@ 仿宋     FangSong</div><div class=\"line\">@ 楷体     KaiTi</div><div class=\"line\">@ 仿宋_GB2312  FangSong_GB2312</div><div class=\"line\">@ 楷体_GB2312  KaiTi_GB2312  </div><div class=\"line\">@</div><div class=\"line\">@ 说明：中文字体多数使用宋体、雅黑，英文用Helvetica</div><div class=\"line\">body &#123; font-family: Microsoft Yahei,SimSun,Helvetica; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>打电话发短信写邮件怎么实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 一、打电话</div><div class=\"line\">&lt;a href=&quot;tel:0755-10086&quot;&gt;打电话给:0755-10086&lt;/a&gt;</div><div class=\"line\"> </div><div class=\"line\">//  二、发短信，winphone系统无效</div><div class=\"line\">&lt;a href=&quot;sms:10086&quot;&gt;发短信给: 10086&lt;/a&gt;</div><div class=\"line\"> </div><div class=\"line\">// 三、写邮件</div><div class=\"line\">//注：在添加这些功能时，第一个功能以&quot;?&quot;开头，后面的以&quot;&amp;&quot;开头</div><div class=\"line\">//1.普通邮件</div><div class=\"line\">&lt;a href=&quot;mailto:863139978@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;</div><div class=\"line\">//2.收件地址后添加?cc=开头，可添加抄送地址（Android存在兼容问题）</div><div class=\"line\">&lt;a href=&quot;mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&quot;&gt;点击我发邮件&lt;/a&gt;</div><div class=\"line\">//3.跟着抄送地址后，写上&amp;bcc=,可添加密件抄送地址（Android存在兼容问题）</div><div class=\"line\">&lt;a href=&quot;mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=384900096@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;</div><div class=\"line\">//4.包含多个收件人、抄送、密件抄送人，用分号(;)隔开多个邮件人的地址</div><div class=\"line\">&lt;a href=&quot;mailto:863139978@qq.com;384900096@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;</div><div class=\"line\">//5.包含主题，用?subject=</div><div class=\"line\">&lt;a href=&quot;mailto:863139978@qq.com?subject=邮件主题&quot;&gt;点击我发邮件&lt;/a&gt;</div><div class=\"line\">//6.包含内容，用?body=;如内容包含文本，使用%0A给文本换行 </div><div class=\"line\">&lt;a href=&quot;mailto:863139978@qq.com?body=邮件主题内容%0A腾讯诚信%0A期待您的到来&quot;&gt;点击我发邮件&lt;/a&gt;</div><div class=\"line\">//7.内容包含链接，含http(s)://等的文本自动转化为链接</div><div class=\"line\">&lt;a href=&quot;mailto:863139978@qq.com?body=http://www.baidu.com&quot;&gt;点击我发邮件&lt;/a&gt;</div><div class=\"line\">//8.内容包含图片（PC不支持）</div><div class=\"line\">&lt;a href=&quot;mailto:863139978@qq.com?body=&lt;img src=&apos;images/1.jpg&apos; /&gt;&quot;&gt;点击我发邮件&lt;/a&gt;</div><div class=\"line\">//9.完整示例</div><div class=\"line\">&lt;a href=&quot;mailto:863139978@qq.com;384900096@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=993233461@qq.com&amp;subject=[邮件主题]&amp;body=腾讯诚邀您参与%0A%0Ahttp://www.baidu.com%0A%0A&lt;img src=&apos;images/1.jpg&apos; /&gt;&quot;&gt;点击我发邮件&lt;/a&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>移动端touch事件（区分webkit和winphone）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* 当用户手指放在移动设备在屏幕上滑动会触发的touch事件 */</div><div class=\"line\">// 以下支持webkit</div><div class=\"line\">touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指</div><div class=\"line\">touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动</div><div class=\"line\">touchend——当手指离开屏幕时触发</div><div class=\"line\">touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用</div><div class=\"line\"> </div><div class=\"line\">//TouchEvent说明：</div><div class=\"line\">touches：屏幕上所有手指的信息</div><div class=\"line\">targetTouches：手指在目标区域的手指信息</div><div class=\"line\">changedTouches：最近一次触发该事件的手指信息</div><div class=\"line\">touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息</div><div class=\"line\"> </div><div class=\"line\">//参数信息(changedTouches[0])</div><div class=\"line\">clientX、clientY在显示区的坐标</div><div class=\"line\">target：当前元素</div><div class=\"line\"> </div><div class=\"line\">//事件响应顺序</div><div class=\"line\">ontouchstart  &gt; ontouchmove  &gt; ontouchend &gt; onclick</div><div class=\"line\"> </div><div class=\"line\">// 以下支持winphone 8</div><div class=\"line\">MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指</div><div class=\"line\">MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html&#123;-ms-touch-action: none;&#125;可以阻止默认情况的发生：阻止页面滚动</div><div class=\"line\">MSPointerUp——当手指离开屏幕时触发</div></pre></td></tr></table></figure>\n</li>\n<li><p>移动端click屏幕产生200-300ms的延时响应</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">说明：移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。</div><div class=\"line\"> </div><div class=\"line\">以下是历史原因，来源一个公司内一个同事的分享：</div><div class=\"line\">2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。</div><div class=\"line\"> </div><div class=\"line\">双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。</div><div class=\"line\"> </div><div class=\"line\">原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。</div><div class=\"line\"> </div><div class=\"line\">//解决方案：</div><div class=\"line\">fastclick可以解决在手机上点击事件的300ms延迟</div><div class=\"line\">zepto的touch模块，tap事件也是为了解决在click的延迟问题</div></pre></td></tr></table></figure>\n</li>\n<li><p>Rentina显示屏原理及设计方案 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">说明：retina屏是一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个。 </div><div class=\"line\">在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍。 </div><div class=\"line\">那么，前端的应对方案是：设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2</div><div class=\"line\">//例如图片宽高为：200px*200px，那么写法如下</div><div class=\"line\">.css&#123;width:100px;height:100px;background-size:100px 100px;&#125;</div><div class=\"line\">//其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px</div><div class=\"line\">.css&#123;font-size:20px&#125;</div><div class=\"line\"> </div><div class=\"line\">//image-set设计Rentina背景图</div><div class=\"line\">image-set,webkit私有属性，也是CSS4的属性，为解决Rentina屏幕下的图像而生。</div><div class=\"line\">.css &#123;</div><div class=\"line\">    background: url(images/bg.jpg) no-repeat center;</div><div class=\"line\">    background: -webkit-image-set(</div><div class=\"line\">    url(images/bg.jpg) 1x,     //支持image-set普通屏</div><div class=\"line\">    url(images/bg-2x.jpg) 2x); //支持image-set的Rentinan</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>点击元素产生背景或边框怎么去掉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">/ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0去除灰色半透明遮罩；</div><div class=\"line\">//android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果；</div><div class=\"line\">//winphone系统,点击标签产生的灰色半透明背景，能通过设置&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;去掉；</div><div class=\"line\">//特殊说明：有些机型去除不了，如小米2。对于按钮类还有个办法，不使用a或者input标签，直接用div标签</div><div class=\"line\">a,button,input,textarea &#123; </div><div class=\"line\">    -webkit-tap-highlight-color: rgba(0,0,0,0); </div><div class=\"line\">    -webkit-user-modify:read-write-plaintext-only; //-webkit-user-modify有个副作用，就是输入法不再能够输入多个字符</div><div class=\"line\">&#125;   </div><div class=\"line\">// 也可以 </div><div class=\"line\">* &#123; -webkit-tap-highlight-color: rgba(0,0,0,0); &#125;</div><div class=\"line\">//winphone下</div><div class=\"line\">&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>美化表单元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">//一、使用appearance改变webkit浏览器的默认外观</div><div class=\"line\">input,select &#123; -webkit-appearance:none; appearance: none; &#125;</div><div class=\"line\"> </div><div class=\"line\">//二、winphone下，使用伪元素改变表单元素默认外观</div><div class=\"line\">//1.禁用select默认箭头，::-ms-expand修改表单控件下拉箭头，设置隐藏并使用背景图片来修饰</div><div class=\"line\">select::-ms-expand &#123; display:none; &#125;</div><div class=\"line\"> </div><div class=\"line\">//2.禁用radio和checkbox默认样式，::-ms-check修改表单复选框或单选框默认图标，设置隐藏并使用背景图片来修饰</div><div class=\"line\">input[type=radio]::-ms-check,</div><div class=\"line\">input[type=checkbox]::-ms-check &#123; display:none; &#125;</div><div class=\"line\"> </div><div class=\"line\">//3.禁用pc端表单输入框默认清除按钮，::-ms-clear修改清除按钮，设置隐藏并使用背景图片来修饰</div><div class=\"line\">input[type=text]::-ms-clear,</div><div class=\"line\">input[type=tel]::-ms-clear,</div><div class=\"line\">input[type=number]::-ms-clear &#123; display:none; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>移动端字体单位font-size选择px还是rem</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 如需适配多种移动设备，建议使用rem。以下为参考值：</div><div class=\"line\">html &#123; font-size: 62.5%; &#125;   //10*16 = 62.5%</div><div class=\"line\">//设置12px字体   这里注意在rem前要加上对应的px值，解决不支持rem的浏览器的兼容问题，做到优雅降级</div><div class=\"line\">body &#123; font-size:12px; font-size:1.2rem; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>超实用的CSS样式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">//去掉webkit的滚动条——display: none;</div><div class=\"line\">//其他参数</div><div class=\"line\">::-webkit-scrollba //滚动条整体部分</div><div class=\"line\">::-webkit-scrollbar-thumb   //滚动条内的小方块</div><div class=\"line\">::-webkit-scrollbar-track   //滚动条轨道</div><div class=\"line\">::-webkit-scrollbar-button  //滚动条轨道两端按钮</div><div class=\"line\">::-webkit-scrollbar-track-piece  //滚动条中间部分，内置轨道</div><div class=\"line\">::-webkit-scrollbar-corner       //边角，两个滚动条交汇处</div><div class=\"line\">::-webkit-resizer            //两个滚动条的交汇处上用于通过拖动调整元素大小的小控件</div><div class=\"line\"> </div><div class=\"line\">// 禁止长按链接与图片弹出菜单</div><div class=\"line\">a,img &#123; -webkit-touch-callout: none &#125;    </div><div class=\"line\"> </div><div class=\"line\">// 禁止ios和android用户选中文字</div><div class=\"line\">html,body &#123;-webkit-user-select:none; user-select: none; &#125;</div><div class=\"line\"> </div><div class=\"line\">// 改变输入框placeholder的颜色值</div><div class=\"line\">::-webkit-input-placeholder &#123; /* WebKit browsers */</div><div class=\"line\">color: #999; &#125;</div><div class=\"line\">:-moz-placeholder &#123; /* Mozilla Firefox 4 to 18 */</div><div class=\"line\">color: #999; &#125;</div><div class=\"line\">::-moz-placeholder &#123; /* Mozilla Firefox 19+ */</div><div class=\"line\">color: #999; &#125;</div><div class=\"line\">:-ms-input-placeholder &#123; /* Internet Explorer 10+ */</div><div class=\"line\">color: #999; &#125;</div><div class=\"line\">input:focus::-webkit-input-placeholder&#123; color:#999; &#125;</div><div class=\"line\"> </div><div class=\"line\">// android上去掉语音输入按钮</div><div class=\"line\">input::-webkit-input-speech-button &#123;display: none&#125;</div><div class=\"line\"> </div><div class=\"line\">// 阻止windows Phone的默认触摸事件</div><div class=\"line\">/*说明：winphone下默认触摸事件事件使用e.preventDefault是无效的，可通过样式来禁用，如：*/</div><div class=\"line\">html &#123; -ms-touch-action:none; &#125; //禁止winphone默认触摸事件</div><div class=\"line\">取消input在ios下，输入的时候英文首字母的默认大写</div><div class=\"line\">&lt;input autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>手机拍照和上传图片</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//IOS有拍照、录像、选取本地图片功能，部分Android只有选择本地图片功能。Winphone不支持</div><div class=\"line\">&lt;input type=&quot;file&quot; accept=&quot;images/*&quot; /&gt;</div><div class=\"line\">&lt;input type=&quot;file&quot; accept=&quot;video/*&quot; /&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>屏幕旋转的事件和样式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">//JS处理</div><div class=\"line\">function orientInit()&#123;</div><div class=\"line\">    var orientChk = document.documentElement.clientWidth &gt; document.documentElement.clientHeight?&apos;landscape&apos;:&apos;portrait&apos;;</div><div class=\"line\">    if(orientChk ==&apos;lapdscape&apos;)&#123;</div><div class=\"line\">        //这里是横屏下需要执行的事件</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">        //这里是竖屏下需要执行的事件</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">orientInit();</div><div class=\"line\">window.addEventListener(&apos;onorientationchange&apos; in window?&apos;orientationchange&apos;:&apos;resize&apos;, function()&#123;</div><div class=\"line\">    setTimeout(orientInit, 100);</div><div class=\"line\">&#125;,false)    </div><div class=\"line\"> </div><div class=\"line\">//CSS处理</div><div class=\"line\">//竖屏时样式</div><div class=\"line\">@media all and (orientation:portrait)&#123;   &#125;</div><div class=\"line\">//横屏时样式</div><div class=\"line\">@media all and (orientation:landscape)&#123;   &#125;</div><div class=\"line\">audio元素和video元素在ios和andriod中无法自动播放</div><div class=\"line\">//音频，写法一</div><div class=\"line\">&lt;audio src=&quot;music/bg.mp3&quot; autoplay loop controls&gt;你的浏览器还不支持哦&lt;/audio&gt;</div><div class=\"line\"> </div><div class=\"line\">//音频，写法二</div><div class=\"line\">&lt;audio controls=&quot;controls&quot;&gt; </div><div class=\"line\">    &lt;source src=&quot;music/bg.ogg&quot; type=&quot;audio/ogg&quot;&gt;&lt;/source&gt;</div><div class=\"line\">    &lt;source src=&quot;music/bg.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/source&gt;</div><div class=\"line\">    优先播放音乐bg.ogg，不支持在播放bg.mp3</div><div class=\"line\">&lt;/audio&gt;</div><div class=\"line\"> </div><div class=\"line\">//JS绑定自动播放（操作window时，播放音乐）</div><div class=\"line\">$(window).one(&apos;touchstart&apos;, function()&#123;</div><div class=\"line\">    music.play();</div><div class=\"line\">&#125;)</div><div class=\"line\"> </div><div class=\"line\">//微信下兼容处理</div><div class=\"line\">document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () &#123;</div><div class=\"line\">    music.play();</div><div class=\"line\">&#125;, false);</div><div class=\"line\"> </div><div class=\"line\">//小结</div><div class=\"line\">//1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常</div><div class=\"line\">//2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间</div></pre></td></tr></table></figure>\n</li>\n<li><p>重力感应事件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 运用HTML5的deviceMotion，调用重力感应事件</div><div class=\"line\">if(window.DeviceMotionEvent)&#123;</div><div class=\"line\">    document.addEventListener(&apos;devicemotion&apos;, deviceMotionHandler, false)</div><div class=\"line\">&#125;   </div><div class=\"line\"> </div><div class=\"line\">var speed = 30;</div><div class=\"line\">var x = y = z = lastX = lastY = lastZ = 0;</div><div class=\"line\">function deviceMotionHandler(eventData)&#123;</div><div class=\"line\">    var acceleration = event.accelerationIncludingGravity;</div><div class=\"line\">    x = acceleration.x;</div><div class=\"line\">    y = acceleration.y; </div><div class=\"line\">    z = acceleration.z;</div><div class=\"line\">    if(Math.abs(x-lastX)&gt;speed || Math.abs(y-lastY)&gt;speed || Math.abs(z-lastZ)&gt;speed )&#123;</div><div class=\"line\">        //这里是摇动后要执行的方法 </div><div class=\"line\">        yaoAfter();</div><div class=\"line\">    &#125;</div><div class=\"line\">    lastX = x;</div><div class=\"line\">    lastY = y;</div><div class=\"line\">    lastZ = z;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">function yaoAfter()&#123;</div><div class=\"line\">    //do something</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>微信浏览器用户调整字体大小后页面矬了，怎么阻止用户调整</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以下代码可使Android机页面不再受用户字体缩放强制改变大小，但是会有1S左右延时，期间可以考虑loading来处理</div><div class=\"line\">if (typeof(WeixinJSBridge) == &quot;undefined&quot;) &#123;</div><div class=\"line\">    document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function (e) &#123;</div><div class=\"line\">        setTimeout(function()&#123;</div><div class=\"line\">            WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;, &#123; &apos;fontSize&apos;:0&#125;, function(res)&#123;</div><div class=\"line\">                alert(JSON.stringify(res));</div><div class=\"line\">            &#125;)</div><div class=\"line\">        &#125;, 0)</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;else&#123;  </div><div class=\"line\">    setTimeout(function()&#123;</div><div class=\"line\">        WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;, &#123; &apos;fontSize&apos;:0&#125;, function(res)&#123;</div><div class=\"line\">            alert(JSON.stringify(res));</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;, 0)   </div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">//IOS下可使用 -webkit-text-size-adjust禁止用户调整字体大小</div><div class=\"line\">body &#123; -webkit-text-size-adjust:100%!important; &#125;</div><div class=\"line\"> </div><div class=\"line\">//最好的解决方案：最好使用rem或百分比布局</div></pre></td></tr></table></figure>\n</li>\n<li><p>定位的坑</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">//fixed定位</div><div class=\"line\">//1.ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位</div><div class=\"line\">//2.android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位</div><div class=\"line\">//3.ios4下不支持position:fixed</div><div class=\"line\">//解决方案：使用[Iscroll](http://cubiq.org/iscroll-5)，如：</div><div class=\"line\">&lt;div id=&quot;wrapper&quot;&gt;</div><div class=\"line\">        &lt;ul&gt;</div><div class=\"line\">               &lt;li&gt;&lt;/li&gt;</div><div class=\"line\">               .....</div><div class=\"line\">        &lt;/ul&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">&lt;script src=&quot;iscroll.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script&gt;</div><div class=\"line\">    var myscroll;</div><div class=\"line\">    function loaded()&#123;</div><div class=\"line\">        myscroll=new iScroll(&quot;wrapper&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    window.addEventListener(&quot;DOMContentLoaded&quot;,loaded,false);</div><div class=\"line\">&lt;/script&gt;</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\">//position定位</div><div class=\"line\">//Android下弹出软键盘弹出时，影响absolute元素定位</div><div class=\"line\">//解决方案:</div><div class=\"line\">var ua = navigator.userAgent.indexOf(&apos;Android&apos;);</div><div class=\"line\">if(ua&gt;-1)&#123;</div><div class=\"line\">    $(&apos;.ipt&apos;).on(&apos;focus&apos;, function()&#123;</div><div class=\"line\">        $(&apos;.css&apos;).css(&#123;&apos;visibility&apos;:&apos;hidden&apos;&#125;)</div><div class=\"line\">    &#125;).on(&apos;blur&apos;, function()&#123;</div><div class=\"line\">        $(&apos;.css&apos;).css(&#123;&apos;visibility&apos;:&apos;visible&apos;&#125;)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>播放视频不全屏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!--</div><div class=\"line\">1.ios7+支持自动播放</div><div class=\"line\">2.支持Airplay的设备（如：音箱、Apple TV)播放</div><div class=\"line\">x-webkit-airplay=&quot;true&quot; </div><div class=\"line\">3.播放视频不全屏</div><div class=\"line\">webkit-playsinline=&quot;true&quot; </div><div class=\"line\">--&gt;</div><div class=\"line\">&lt;video x-webkit-airplay=&quot;true&quot; webkit-playsinline=&quot;true&quot; preload=&quot;auto&quot; autoplay src=&quot;http://&quot;&gt;&lt;/video&gt;</div><div class=\"line\">JS判断设备</div><div class=\"line\">function deviceType()&#123;</div><div class=\"line\">    var ua = navigator.userAgent;</div><div class=\"line\">    var agent = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;];    </div><div class=\"line\">    for(var i=0; i&lt;len,len = agent.length; i++)&#123;</div><div class=\"line\">        if(ua.indexOf(agent[i])&gt;0)&#123;         </div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">deviceType();</div><div class=\"line\">window.addEventListener(&apos;resize&apos;, function()&#123;</div><div class=\"line\">    deviceType();</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p>JS判断微信浏览器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function isWeixin()&#123;</div><div class=\"line\">    var ua = navigator.userAgent.toLowerCase();</div><div class=\"line\">    if(ua.match(/MicroMessenger/i)==&apos;micromessenger&apos;)&#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>android 2.3 bug</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//1.@-webkit-keyframes 需要以0%开始100%结束，0%的百分号不能去掉</div><div class=\"line\">//2.after和before伪类无法使用动画animation</div><div class=\"line\">//3.border-radius不支持%单位，如要兼容，可以给radius设置一下较大的值</div><div class=\"line\">//4.translate百分比的写法和scale在一起会导致失效，例如：</div><div class=\"line\">-webkit-transform: translate(-50%,-50%) scale(-0.5, 1)</div><div class=\"line\">android 4.x bug</div><div class=\"line\">//1.三星 Galaxy S4中自带浏览器不支持border-radius缩写</div><div class=\"line\">//2.同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分</div><div class=\"line\">//3.部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色</div><div class=\"line\">//4.android无法同时播放多音频audio</div><div class=\"line\">消除transition闪屏</div><div class=\"line\">.css &#123;</div><div class=\"line\">    -webkit-transform-style: preserve-3d;</div><div class=\"line\">    -webkit-backface-visibility: hidden;</div><div class=\"line\">    -webkit-perspective: 1000;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>开启硬件加速</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//目前，像Chrome/Filefox/Safari/IE9+以及最新版本Opera都支持硬件加速，当检测到某个DOM元素应用了某些CSS规则时就会自动开启，从而解决页面闪白，保证动画流畅。</div><div class=\"line\">.css &#123;</div><div class=\"line\">    -webkit-transform: translate3d(0,0,0);</div><div class=\"line\">    -moz-transform: translate3d(0,0,0);</div><div class=\"line\">    -ms-transform: translate3d(0,0,0);</div><div class=\"line\">    transform: translate3d(0,0,0);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>渲染优化</p>\n<pre><code>//1.禁止使用iframe（阻塞父文档onload事件）\n//2.禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能）\n//使用CSS3代码代替JS动画；\n//开启GPU加速；\n//使用base64位编码图片(不小图而言，大图不建议使用)\n   // 对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费CPU。小图标优势在于：\n   //1.减少HTTP请求；\n   //2.避免文件跨域；\n   //3.修改及时生效；\n</code></pre><p><a href=\"https://github.com/FrontEndZQ/HTML5-FAQ\">文章参考来源</a></p>\n</li>\n</ul>\n"},{"title":"使用iframe嵌入优酷视频的方法","date":"2016-09-30T07:25:16.000Z","_content":"\n   优酷是知名的视频共享网站,不少人会将自己拍摄或制作的视频上传到优酷上,当然也有不少客户会把公司的企业宣传片放上去,那么如果在我们自己的网站里调用到优酷上的企业宣传片呢.\n    共享过优酷的用户会发现嵌入视频的语法已经从原来的<object>改为使用<iframe>来嵌入视频.\n新的嵌入视频语法以<iframe>标记来播放视频,通过新的视频嵌入语法,优酷会自动按照浏览者的设置,使用AS3 Flash或HTML5来播放视频.\n#### 首先我们看一下<iframe>标记的用法.\n <iframe>标记属于框架语法,它能够将要链接的网页与组件直接内嵌在当前的风页中,其代码如下:\n```\n <iframe name=\"f1\" src=\"newpage.html\" width=500 height=300>webywx</iframe>\n```\n 我们在优酷里找到相应的代码加入到SRC中就可以调用出来了.","source":"_posts/iframe-video.md","raw":"---\ntitle: 使用iframe嵌入优酷视频的方法\ndate: 2016-09-30 15:25:16\ntags: iframe\n---\n\n   优酷是知名的视频共享网站,不少人会将自己拍摄或制作的视频上传到优酷上,当然也有不少客户会把公司的企业宣传片放上去,那么如果在我们自己的网站里调用到优酷上的企业宣传片呢.\n    共享过优酷的用户会发现嵌入视频的语法已经从原来的<object>改为使用<iframe>来嵌入视频.\n新的嵌入视频语法以<iframe>标记来播放视频,通过新的视频嵌入语法,优酷会自动按照浏览者的设置,使用AS3 Flash或HTML5来播放视频.\n#### 首先我们看一下<iframe>标记的用法.\n <iframe>标记属于框架语法,它能够将要链接的网页与组件直接内嵌在当前的风页中,其代码如下:\n```\n <iframe name=\"f1\" src=\"newpage.html\" width=500 height=300>webywx</iframe>\n```\n 我们在优酷里找到相应的代码加入到SRC中就可以调用出来了.","slug":"iframe-video","published":1,"updated":"2016-12-30T07:28:35.579Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv830021jgturgel8i3i","content":"<p>   优酷是知名的视频共享网站,不少人会将自己拍摄或制作的视频上传到优酷上,当然也有不少客户会把公司的企业宣传片放上去,那么如果在我们自己的网站里调用到优酷上的企业宣传片呢.<br>    共享过优酷的用户会发现嵌入视频的语法已经从原来的<object>改为使用<iframe>来嵌入视频.<br>新的嵌入视频语法以<iframe>标记来播放视频,通过新的视频嵌入语法,优酷会自动按照浏览者的设置,使用AS3 Flash或HTML5来播放视频.</iframe></iframe></object></p>\n<h4 id=\"首先我们看一下标记的用法\"><a href=\"#首先我们看一下标记的用法\" class=\"headerlink\" title=\"首先我们看一下标记的用法.\"></a>首先我们看一下<iframe>标记的用法.</iframe></h4><p> <iframe>标记属于框架语法,它能够将要链接的网页与组件直接内嵌在当前的风页中,其代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"> &lt;iframe name=&quot;f1&quot; src=&quot;newpage.html&quot; width=500 height=300&gt;webywx&lt;/iframe&gt;</div></pre></td></tr></table></figure></iframe></p>\n<p> 我们在优酷里找到相应的代码加入到SRC中就可以调用出来了.</p>\n","excerpt":"","more":"<p>   优酷是知名的视频共享网站,不少人会将自己拍摄或制作的视频上传到优酷上,当然也有不少客户会把公司的企业宣传片放上去,那么如果在我们自己的网站里调用到优酷上的企业宣传片呢.<br>    共享过优酷的用户会发现嵌入视频的语法已经从原来的<object>改为使用<iframe>来嵌入视频.<br>新的嵌入视频语法以<iframe>标记来播放视频,通过新的视频嵌入语法,优酷会自动按照浏览者的设置,使用AS3 Flash或HTML5来播放视频.</p>\n<h4 id=\"首先我们看一下标记的用法\"><a href=\"#首先我们看一下标记的用法\" class=\"headerlink\" title=\"首先我们看一下标记的用法.\"></a>首先我们看一下<iframe>标记的用法.</h4><p> <iframe>标记属于框架语法,它能够将要链接的网页与组件直接内嵌在当前的风页中,其代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"> &lt;iframe name=&quot;f1&quot; src=&quot;newpage.html&quot; width=500 height=300&gt;webywx&lt;/iframe&gt;</div></pre></td></tr></table></figure></p>\n<p> 我们在优酷里找到相应的代码加入到SRC中就可以调用出来了.</p>\n"},{"title":"移动端遇到的坑-fixed不兼容","date":"2015-12-16T04:41:23.000Z","_content":"### fixed不兼容，解决办法用iscroll.js\n\n移动端大多数浏览器不兼容position:fixed，而pc端只有ie6不兼容position:fixed    \n在移动端开发中，使用position:fixed固定定位，很多手机支持不好，尤其是在定位的区域还需要输入内容调取虚拟键盘的时候会出现很多很多的问题\n解决这个问题，就不能使用固定定位了，而是使用局部滚动处理（isScroll.js）\n实现竖向局部滚动，需要把局部滚动的最外层容器的高度设定好。\n实现横向局部滚动，需要把局部滚动的最外层容器的宽度设定好。\n实现局部滚动：\n```\nvar   实例=new IScroll（需要局部滚动的区域，{参数配置}）;\n```\n初始化成功后，只对当前容器中的第一个子元素实现了滚动操作。\n为了让滚动条只显示在局部滚动的区域，需要给局部滚动的最外层容器加上position:relative;\n```\nvar myscroll=new IScroll(要实现局部滚动区域的类名，{\n    scrollbars:true，\n    fadeScrollbars:true,//滚动时显示滚动条，否则滚动条隐藏。\n    mouseWheel:true,\n    bounce:false  //禁止运动到边界反弹。\n    click:true //为了防止滑动过程中的误操作，默认把点击事件关闭了，想让点击时需要开启。\n});\n```\n\n* myScroll.refresh:当滚动区域的内容发生改变的时候,我们让当前的实例刷新一下,这样的话滚动区域的相关值都会跟着重新计算\n* myScroll.scrollToElement([ele],[time]):用多长的时间滚动到具体的某一个元素位置\n* myScroll.scrollTo(x,y,time):滚动到具体的坐标位置\n\n以上常用 ，下面的可以看文档了解学习下，毕竟艺多不压人，哈哈！！！\n```\noptions.useTransform     true\noptions.useTransition      true\noptions.HWCompositing  true\n\noptions.bounce  true\noptions.click  false\noptions.mouseWheel  false\noptions.scrollX、options.scrollY\n\noptions.tap  element.addEventListener('tap', doSomething, false); \\\\ Native or tap: 'myCustomTapEvent'\n\nscrollbars  flase\nfadeScrollbars  false\n\nmyScroll.destroy();\nmyScroll = null;\n```\n\nbeforeScrollStart，在用户触摸屏幕但还没有开始滚动时触发。\nscrollCancel，滚动初始化完成，但没有执行。\nscrollStart，开始滚动\nscroll，内容滚动时触发，只有在scroll-probe.js版本中有效，请参考onScroll event。\nscrollEnd，停止滚动时触发。\nflick，用户打开左/右。\nzoomStart，开始缩放。\nzoomEnd，缩放结束。\n","source":"_posts/iscroll.md","raw":"---\ntitle: 移动端遇到的坑-fixed不兼容\ndate: 2015-12-16 12:41:23\ntags: 移动端、fixed\n---\n### fixed不兼容，解决办法用iscroll.js\n\n移动端大多数浏览器不兼容position:fixed，而pc端只有ie6不兼容position:fixed    \n在移动端开发中，使用position:fixed固定定位，很多手机支持不好，尤其是在定位的区域还需要输入内容调取虚拟键盘的时候会出现很多很多的问题\n解决这个问题，就不能使用固定定位了，而是使用局部滚动处理（isScroll.js）\n实现竖向局部滚动，需要把局部滚动的最外层容器的高度设定好。\n实现横向局部滚动，需要把局部滚动的最外层容器的宽度设定好。\n实现局部滚动：\n```\nvar   实例=new IScroll（需要局部滚动的区域，{参数配置}）;\n```\n初始化成功后，只对当前容器中的第一个子元素实现了滚动操作。\n为了让滚动条只显示在局部滚动的区域，需要给局部滚动的最外层容器加上position:relative;\n```\nvar myscroll=new IScroll(要实现局部滚动区域的类名，{\n    scrollbars:true，\n    fadeScrollbars:true,//滚动时显示滚动条，否则滚动条隐藏。\n    mouseWheel:true,\n    bounce:false  //禁止运动到边界反弹。\n    click:true //为了防止滑动过程中的误操作，默认把点击事件关闭了，想让点击时需要开启。\n});\n```\n\n* myScroll.refresh:当滚动区域的内容发生改变的时候,我们让当前的实例刷新一下,这样的话滚动区域的相关值都会跟着重新计算\n* myScroll.scrollToElement([ele],[time]):用多长的时间滚动到具体的某一个元素位置\n* myScroll.scrollTo(x,y,time):滚动到具体的坐标位置\n\n以上常用 ，下面的可以看文档了解学习下，毕竟艺多不压人，哈哈！！！\n```\noptions.useTransform     true\noptions.useTransition      true\noptions.HWCompositing  true\n\noptions.bounce  true\noptions.click  false\noptions.mouseWheel  false\noptions.scrollX、options.scrollY\n\noptions.tap  element.addEventListener('tap', doSomething, false); \\\\ Native or tap: 'myCustomTapEvent'\n\nscrollbars  flase\nfadeScrollbars  false\n\nmyScroll.destroy();\nmyScroll = null;\n```\n\nbeforeScrollStart，在用户触摸屏幕但还没有开始滚动时触发。\nscrollCancel，滚动初始化完成，但没有执行。\nscrollStart，开始滚动\nscroll，内容滚动时触发，只有在scroll-probe.js版本中有效，请参考onScroll event。\nscrollEnd，停止滚动时触发。\nflick，用户打开左/右。\nzoomStart，开始缩放。\nzoomEnd，缩放结束。\n","slug":"iscroll","published":1,"updated":"2016-12-12T09:04:34.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv870023jgtu91kbl7jw","content":"<h3 id=\"fixed不兼容，解决办法用iscroll-js\"><a href=\"#fixed不兼容，解决办法用iscroll-js\" class=\"headerlink\" title=\"fixed不兼容，解决办法用iscroll.js\"></a>fixed不兼容，解决办法用iscroll.js</h3><p>移动端大多数浏览器不兼容position:fixed，而pc端只有ie6不兼容position:fixed<br>在移动端开发中，使用position:fixed固定定位，很多手机支持不好，尤其是在定位的区域还需要输入内容调取虚拟键盘的时候会出现很多很多的问题<br>解决这个问题，就不能使用固定定位了，而是使用局部滚动处理（isScroll.js）<br>实现竖向局部滚动，需要把局部滚动的最外层容器的高度设定好。<br>实现横向局部滚动，需要把局部滚动的最外层容器的宽度设定好。<br>实现局部滚动：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var   实例=new IScroll（需要局部滚动的区域，&#123;参数配置&#125;）;</div></pre></td></tr></table></figure></p>\n<p>初始化成功后，只对当前容器中的第一个子元素实现了滚动操作。<br>为了让滚动条只显示在局部滚动的区域，需要给局部滚动的最外层容器加上position:relative;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myscroll=new IScroll(要实现局部滚动区域的类名，&#123;</div><div class=\"line\">    scrollbars:true，</div><div class=\"line\">    fadeScrollbars:true,//滚动时显示滚动条，否则滚动条隐藏。</div><div class=\"line\">    mouseWheel:true,</div><div class=\"line\">    bounce:false  //禁止运动到边界反弹。</div><div class=\"line\">    click:true //为了防止滑动过程中的误操作，默认把点击事件关闭了，想让点击时需要开启。</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<ul>\n<li>myScroll.refresh:当滚动区域的内容发生改变的时候,我们让当前的实例刷新一下,这样的话滚动区域的相关值都会跟着重新计算</li>\n<li>myScroll.scrollToElement([ele],[time]):用多长的时间滚动到具体的某一个元素位置</li>\n<li>myScroll.scrollTo(x,y,time):滚动到具体的坐标位置</li>\n</ul>\n<p>以上常用 ，下面的可以看文档了解学习下，毕竟艺多不压人，哈哈！！！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">options.useTransform     true</div><div class=\"line\">options.useTransition      true</div><div class=\"line\">options.HWCompositing  true</div><div class=\"line\"></div><div class=\"line\">options.bounce  true</div><div class=\"line\">options.click  false</div><div class=\"line\">options.mouseWheel  false</div><div class=\"line\">options.scrollX、options.scrollY</div><div class=\"line\"></div><div class=\"line\">options.tap  element.addEventListener(&apos;tap&apos;, doSomething, false); \\\\ Native or tap: &apos;myCustomTapEvent&apos;</div><div class=\"line\"></div><div class=\"line\">scrollbars  flase</div><div class=\"line\">fadeScrollbars  false</div><div class=\"line\"></div><div class=\"line\">myScroll.destroy();</div><div class=\"line\">myScroll = null;</div></pre></td></tr></table></figure></p>\n<p>beforeScrollStart，在用户触摸屏幕但还没有开始滚动时触发。<br>scrollCancel，滚动初始化完成，但没有执行。<br>scrollStart，开始滚动<br>scroll，内容滚动时触发，只有在scroll-probe.js版本中有效，请参考onScroll event。<br>scrollEnd，停止滚动时触发。<br>flick，用户打开左/右。<br>zoomStart，开始缩放。<br>zoomEnd，缩放结束。</p>\n","excerpt":"","more":"<h3 id=\"fixed不兼容，解决办法用iscroll-js\"><a href=\"#fixed不兼容，解决办法用iscroll-js\" class=\"headerlink\" title=\"fixed不兼容，解决办法用iscroll.js\"></a>fixed不兼容，解决办法用iscroll.js</h3><p>移动端大多数浏览器不兼容position:fixed，而pc端只有ie6不兼容position:fixed<br>在移动端开发中，使用position:fixed固定定位，很多手机支持不好，尤其是在定位的区域还需要输入内容调取虚拟键盘的时候会出现很多很多的问题<br>解决这个问题，就不能使用固定定位了，而是使用局部滚动处理（isScroll.js）<br>实现竖向局部滚动，需要把局部滚动的最外层容器的高度设定好。<br>实现横向局部滚动，需要把局部滚动的最外层容器的宽度设定好。<br>实现局部滚动：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var   实例=new IScroll（需要局部滚动的区域，&#123;参数配置&#125;）;</div></pre></td></tr></table></figure></p>\n<p>初始化成功后，只对当前容器中的第一个子元素实现了滚动操作。<br>为了让滚动条只显示在局部滚动的区域，需要给局部滚动的最外层容器加上position:relative;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myscroll=new IScroll(要实现局部滚动区域的类名，&#123;</div><div class=\"line\">    scrollbars:true，</div><div class=\"line\">    fadeScrollbars:true,//滚动时显示滚动条，否则滚动条隐藏。</div><div class=\"line\">    mouseWheel:true,</div><div class=\"line\">    bounce:false  //禁止运动到边界反弹。</div><div class=\"line\">    click:true //为了防止滑动过程中的误操作，默认把点击事件关闭了，想让点击时需要开启。</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<ul>\n<li>myScroll.refresh:当滚动区域的内容发生改变的时候,我们让当前的实例刷新一下,这样的话滚动区域的相关值都会跟着重新计算</li>\n<li>myScroll.scrollToElement([ele],[time]):用多长的时间滚动到具体的某一个元素位置</li>\n<li>myScroll.scrollTo(x,y,time):滚动到具体的坐标位置</li>\n</ul>\n<p>以上常用 ，下面的可以看文档了解学习下，毕竟艺多不压人，哈哈！！！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">options.useTransform     true</div><div class=\"line\">options.useTransition      true</div><div class=\"line\">options.HWCompositing  true</div><div class=\"line\"></div><div class=\"line\">options.bounce  true</div><div class=\"line\">options.click  false</div><div class=\"line\">options.mouseWheel  false</div><div class=\"line\">options.scrollX、options.scrollY</div><div class=\"line\"></div><div class=\"line\">options.tap  element.addEventListener(&apos;tap&apos;, doSomething, false); \\\\ Native or tap: &apos;myCustomTapEvent&apos;</div><div class=\"line\"></div><div class=\"line\">scrollbars  flase</div><div class=\"line\">fadeScrollbars  false</div><div class=\"line\"></div><div class=\"line\">myScroll.destroy();</div><div class=\"line\">myScroll = null;</div></pre></td></tr></table></figure></p>\n<p>beforeScrollStart，在用户触摸屏幕但还没有开始滚动时触发。<br>scrollCancel，滚动初始化完成，但没有执行。<br>scrollStart，开始滚动<br>scroll，内容滚动时触发，只有在scroll-probe.js版本中有效，请参考onScroll event。<br>scrollEnd，停止滚动时触发。<br>flick，用户打开左/右。<br>zoomStart，开始缩放。<br>zoomEnd，缩放结束。</p>\n"},{"title":"ES6学习-变量的解构赋值用途","date":"2016-02-10T14:47:14.000Z","_content":"### （1）交换变量的值\n```\n[x, y] = [y, x];\n```\n上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。\n\n### （2）从函数返回多个值\n函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。\n```\n// 返回一个数组\nfunction example() {return [1, 2, 3];}var [a, b, c] = example();\n// 返回一个对象\nfunction example() {return {\n    foo: 1,\n    bar: 2};}var { foo, bar } = example();\n```  \n### （3）函数参数的定义\n解构赋值可以方便地将一组参数与变量名对应起来。\n```\n// 参数是一组有次序的值\nfunction f([x, y, z]) { ... }f([1, 2, 3]);\n// 参数是一组无次序的值\nfunction f({x, y, z}) { ... }f({z: 3, y: 2, x: 1});\n```\n### （4）提取JSON数据\n解构赋值对提取JSON对象中的数据，尤其有用。\n```\nvar jsonData = {\n  id: 42,\n  status: \"OK\",\n  data: [867, 5309]};let { id, status, data: number } = jsonData;\n\nconsole.log(id, status, number);\n// 42, \"OK\", [867, 5309]\n```\n上面代码可以快速提取JSON数据的值。\n### （5）函数参数的默认值\n```\njQuery.ajax = function (url, {\n  async = true,\n  beforeSend = function () {},\n  cache = true,\n  complete = function () {},\n  crossDomain = false,\n  global = true, // ... more config\n}) { // ... do stuff\n};\n```\n指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。\n### （6）遍历Map结构\n任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。\n```\nvar map = new Map();\nmap.set('first', 'hello');\nmap.set('second', 'world');for (let [key, value] of map) {\n  console.log(key + \" is \" + value);}\n// first is hello\n// second is world\n如果只想获取键名，或者只想获取键值，可以写成下面这样。\n// 获取键名\nfor (let [key] of map) { // ...\n}\n// 获取键值\nfor (let [,value] of map) { // ...\n}\n```\n### （7）输入模块的指定方法\n加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。\n```\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n```","source":"_posts/jigou.md","raw":"---\ntitle: ES6学习-变量的解构赋值用途\ndate: 2016-2-10 22:47:14\ntags: 解构赋值 es6\n---\n### （1）交换变量的值\n```\n[x, y] = [y, x];\n```\n上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。\n\n### （2）从函数返回多个值\n函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。\n```\n// 返回一个数组\nfunction example() {return [1, 2, 3];}var [a, b, c] = example();\n// 返回一个对象\nfunction example() {return {\n    foo: 1,\n    bar: 2};}var { foo, bar } = example();\n```  \n### （3）函数参数的定义\n解构赋值可以方便地将一组参数与变量名对应起来。\n```\n// 参数是一组有次序的值\nfunction f([x, y, z]) { ... }f([1, 2, 3]);\n// 参数是一组无次序的值\nfunction f({x, y, z}) { ... }f({z: 3, y: 2, x: 1});\n```\n### （4）提取JSON数据\n解构赋值对提取JSON对象中的数据，尤其有用。\n```\nvar jsonData = {\n  id: 42,\n  status: \"OK\",\n  data: [867, 5309]};let { id, status, data: number } = jsonData;\n\nconsole.log(id, status, number);\n// 42, \"OK\", [867, 5309]\n```\n上面代码可以快速提取JSON数据的值。\n### （5）函数参数的默认值\n```\njQuery.ajax = function (url, {\n  async = true,\n  beforeSend = function () {},\n  cache = true,\n  complete = function () {},\n  crossDomain = false,\n  global = true, // ... more config\n}) { // ... do stuff\n};\n```\n指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。\n### （6）遍历Map结构\n任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。\n```\nvar map = new Map();\nmap.set('first', 'hello');\nmap.set('second', 'world');for (let [key, value] of map) {\n  console.log(key + \" is \" + value);}\n// first is hello\n// second is world\n如果只想获取键名，或者只想获取键值，可以写成下面这样。\n// 获取键名\nfor (let [key] of map) { // ...\n}\n// 获取键值\nfor (let [,value] of map) { // ...\n}\n```\n### （7）输入模块的指定方法\n加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。\n```\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n```","slug":"jigou","published":1,"updated":"2016-12-12T09:04:34.823Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv880024jgtuy7hgn8mh","content":"<h3 id=\"（1）交换变量的值\"><a href=\"#（1）交换变量的值\" class=\"headerlink\" title=\"（1）交换变量的值\"></a>（1）交换变量的值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[x, y] = [y, x];</div></pre></td></tr></table></figure>\n<p>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>\n<h3 id=\"（2）从函数返回多个值\"><a href=\"#（2）从函数返回多个值\" class=\"headerlink\" title=\"（2）从函数返回多个值\"></a>（2）从函数返回多个值</h3><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 返回一个数组</div><div class=\"line\">function example() &#123;return [1, 2, 3];&#125;var [a, b, c] = example();</div><div class=\"line\">// 返回一个对象</div><div class=\"line\">function example() &#123;return &#123;</div><div class=\"line\">    foo: 1,</div><div class=\"line\">    bar: 2&#125;;&#125;var &#123; foo, bar &#125; = example();</div><div class=\"line\">```  </div><div class=\"line\">### （3）函数参数的定义</div><div class=\"line\">解构赋值可以方便地将一组参数与变量名对应起来。</div></pre></td></tr></table></figure></p>\n<p>// 参数是一组有次序的值<br>function f([x, y, z]) { … }f([1, 2, 3]);<br>// 参数是一组无次序的值<br>function f({x, y, z}) { … }f({z: 3, y: 2, x: 1});<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">### （4）提取JSON数据</div><div class=\"line\">解构赋值对提取JSON对象中的数据，尤其有用。</div></pre></td></tr></table></figure></p>\n<p>var jsonData = {<br>  id: 42,<br>  status: “OK”,<br>  data: [867, 5309]};let { id, status, data: number } = jsonData;</p>\n<p>console.log(id, status, number);<br>// 42, “OK”, [867, 5309]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">上面代码可以快速提取JSON数据的值。</div><div class=\"line\">### （5）函数参数的默认值</div></pre></td></tr></table></figure></p>\n<p>jQuery.ajax = function (url, {<br>  async = true,<br>  beforeSend = function () {},<br>  cache = true,<br>  complete = function () {},<br>  crossDomain = false,<br>  global = true, // … more config<br>}) { // … do stuff<br>};<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &apos;default foo&apos;;这样的语句。</div><div class=\"line\">### （6）遍历Map结构</div><div class=\"line\">任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。</div></pre></td></tr></table></figure></p>\n<p>var map = new Map();<br>map.set(‘first’, ‘hello’);<br>map.set(‘second’, ‘world’);for (let [key, value] of map) {<br>  console.log(key + “ is “ + value);}<br>// first is hello<br>// second is world<br>如果只想获取键名，或者只想获取键值，可以写成下面这样。<br>// 获取键名<br>for (let [key] of map) { // …<br>}<br>// 获取键值<br>for (let [,value] of map) { // …<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">### （7）输入模块的指定方法</div><div class=\"line\">加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。</div></pre></td></tr></table></figure></p>\n<p>const { SourceMapConsumer, SourceNode } = require(“source-map”);<br>```</p>\n","excerpt":"","more":"<h3 id=\"（1）交换变量的值\"><a href=\"#（1）交换变量的值\" class=\"headerlink\" title=\"（1）交换变量的值\"></a>（1）交换变量的值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[x, y] = [y, x];</div></pre></td></tr></table></figure>\n<p>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>\n<h3 id=\"（2）从函数返回多个值\"><a href=\"#（2）从函数返回多个值\" class=\"headerlink\" title=\"（2）从函数返回多个值\"></a>（2）从函数返回多个值</h3><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 返回一个数组</div><div class=\"line\">function example() &#123;return [1, 2, 3];&#125;var [a, b, c] = example();</div><div class=\"line\">// 返回一个对象</div><div class=\"line\">function example() &#123;return &#123;</div><div class=\"line\">    foo: 1,</div><div class=\"line\">    bar: 2&#125;;&#125;var &#123; foo, bar &#125; = example();</div><div class=\"line\">```  </div><div class=\"line\">### （3）函数参数的定义</div><div class=\"line\">解构赋值可以方便地将一组参数与变量名对应起来。</div></pre></td></tr></table></figure></p>\n<p>// 参数是一组有次序的值<br>function f([x, y, z]) { … }f([1, 2, 3]);<br>// 参数是一组无次序的值<br>function f({x, y, z}) { … }f({z: 3, y: 2, x: 1});<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">### （4）提取JSON数据</div><div class=\"line\">解构赋值对提取JSON对象中的数据，尤其有用。</div></pre></td></tr></table></figure></p>\n<p>var jsonData = {<br>  id: 42,<br>  status: “OK”,<br>  data: [867, 5309]};let { id, status, data: number } = jsonData;</p>\n<p>console.log(id, status, number);<br>// 42, “OK”, [867, 5309]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">上面代码可以快速提取JSON数据的值。</div><div class=\"line\">### （5）函数参数的默认值</div></pre></td></tr></table></figure></p>\n<p>jQuery.ajax = function (url, {<br>  async = true,<br>  beforeSend = function () {},<br>  cache = true,<br>  complete = function () {},<br>  crossDomain = false,<br>  global = true, // … more config<br>}) { // … do stuff<br>};<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &apos;default foo&apos;;这样的语句。</div><div class=\"line\">### （6）遍历Map结构</div><div class=\"line\">任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。</div></pre></td></tr></table></figure></p>\n<p>var map = new Map();<br>map.set(‘first’, ‘hello’);<br>map.set(‘second’, ‘world’);for (let [key, value] of map) {<br>  console.log(key + “ is “ + value);}<br>// first is hello<br>// second is world<br>如果只想获取键名，或者只想获取键值，可以写成下面这样。<br>// 获取键名<br>for (let [key] of map) { // …<br>}<br>// 获取键值<br>for (let [,value] of map) { // …<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">### （7）输入模块的指定方法</div><div class=\"line\">加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。</div></pre></td></tr></table></figure></p>\n<p>const { SourceMapConsumer, SourceNode } = require(“source-map”);<br>```</p>\n"},{"title":"高效的jQuery代码编写技巧总结(收藏转)","date":"2014-12-30T06:50:35.000Z","_content":"**当你准备使用jQuery,强烈建议你遵循下面这些指南:**\n\n#### 缓存变量\nDOM遍历是昂贵的，所以尽量将会重用的元素缓存。\n```\n// 糟糕\nh = $('#element').height();\n$('#element').css('height',h-20);\n\n// 建议\n$element = $('#element');\nh = $element.height();\n$element.css('height',h-20);\n```\n#### 避免全局变量\njQuery与javascript一样，一般来说,最好确保你的变量在函数作用域内。\n```\n// 糟糕\n$element = $('#element');\nh = $element.height();\n$element.css('height',h-20);\n\n// 建议\nvar $element = $('#element');\nvar h = $element.height();\n$element.css('height',h-20);\n```\n#### 使用匈牙利命名法\n在变量前加$前缀，便于识别出jQuery对象。\n```\n// 糟糕\nvar first = $('#first');\nvar second = $('#second');\nvar value = $first.val();\n\n// 建议 - 在jQuery对象前加$前缀\nvar $first = $('#first');\nvar $second = $('#second'),\nvar value = $first.val();\n```\n#### 使用var链（单 Var 模式）\n将多条var语句合并为一条语句，建议将未赋值的变量放到后面。\n```\nvar\n  $first = $('#first'),\n  $second = $('#second'),\n  value = $first.val(),\n  k = 3,\n  cookiestring = 'SOMECOOKIESPLEASE',\n  i,\n  j,\n  myArray = {};\n```\n#### 请使用’On’\n在新版jQuery中，更短的 on(“click”) 用来取代类似 click() 这样的函数。在之前的版本中 on() 就是 bind()。自从jQuery 1.7版本后，on() 附加事件处理程序的首选方法。然而，出于一致性考虑，你可以简单的全部使用 on()方法。\n```\n// 糟糕\n$first.click(function(){\n    $first.css('border','1px solid red');\n    $first.css('color','blue');\n});\n\n$first.hover(function(){\n    $first.css('border','1px solid red');\n})\n\n// 建议\n$first.on('click',function(){\n    $first.css('border','1px solid red');\n    $first.css('color','blue');\n})\n$first.on('hover',function(){\n    $first.css('border','1px solid red');\n})\n```\n#### 精简jq代码\n一般来说,最好尽可能合并函数。\n```\n// 糟糕\n$first.click(function(){\n    $first.css('border','1px solid red');\n    $first.css('color','blue');\n});\n\n// 建议\n$first.on('click',function(){\n    $first.css({\n        'border':'1px solid red',\n        'color':'blue'\n    });\n});\n```\n#### 链式操作\njQuery实现方法的链式操作是非常容易的。下面利用这一点。\n```\n// 糟糕\n$second.html(value);\n$second.on('click',function(){\n    alert('hello everybody');\n});\n$second.fadeIn('slow');\n$second.animate({height:'120px'},500);\n\n// 建议\n$second.html(value);\n$second.on('click',function(){\n    alert('hello everybody');\n}).fadeIn('slow').animate({height:'120px'},500);\n```\n#### 维持代码的可读性\n伴随着精简代码和使用链式的同时，可能带来代码的难以阅读。添加缩紧和换行能起到很好的效果。\n```\n// 糟糕\n$second.html(value);\n$second.on('click',function(){\n    alert('hello everybody');\n}).fadeIn('slow').animate({height:'120px'},500);\n\n// 建议\n$second.html(value);\n$second\n    .on('click',function(){ alert('hello everybody');})\n    .fadeIn('slow')\n    .animate({height:'120px'},500);\n```\n#### 选择短路求值\n短路求值是一个从左到右求值的表达式，用 &&（逻辑与）或 ||（逻辑或）操作符。\n```\n// 糟糕\nfunction initVar($myVar) {\n    if(!$myVar) {\n        $myVar = $('#selector');\n    }\n}\n\n// 建议\nfunction initVar($myVar) {\n    $myVar = $myVar || $('#selector');\n}\n```\n#### 选择捷径\n精简代码的其中一种方式是利用编码捷径。\n```\n// 糟糕\nif(collection.length > 0){..}\n\n// 建议\nif(collection.length){..}\n```\n#### 繁重的操作中分离元素\n如果你打算对DOM元素做大量操作（连续设置多个属性或css样式），建议首先分离元素然后在添加。\n```\n// 糟糕\nvar\n    $container = $(\"#container\"),\n    $containerLi = $(\"#container li\"),\n    $element = null;\n\n$element = $containerLi.first();\n//... 许多复杂的操作\n\n// 建议\nvar\n    $container = $(\"#container\"),\n    $containerLi = $container.find(\"li\"),\n    $element = null;\n\n$element = $containerLi.first().detach();\n//... 许多复杂的操作\n$container.append($element);\n```\n#### 熟记技巧\n你可能对使用jQuery中的方法缺少经验,一定要查看的文档，可能会有一个更好或更快的方法来使用它。\n```\n// 糟糕\n$('#id').data(key,value);\n\n// 建议 (高效)\n$.data('#id',key,value);\n```\n#### 使用子查询缓存的父元素\n正如前面所提到的，DOM遍历是一项昂贵的操作。典型做法是缓存父元素并在选择子元素时重用这些缓存元素。\n```\n// 糟糕\nvar\n    $container = $('#container'),\n    $containerLi = $('#container li'),\n    $containerLiSpan = $('#container li span');\n\n// 建议 (高效)\nvar\n    $container = $('#container '),\n    $containerLi = $container.find('li'),\n    $containerLiSpan= $containerLi.find('span');\n```\n#### 避免通用选择符\n将通用选择符放到后代选择符中，性能非常糟糕。\n```\n// 糟糕\n$('.container > *');\n\n// 建议\n$('.container').children();\n```\n#### 避免隐式通用选择符\n通用选择符有时是隐式的，不容易发现。\n```\n// 糟糕\n$('.someclass :radio');\n\n// 建议\n$('.someclass input:radio');\n```\n#### 优化选择符\n例如，Id选择符应该是唯一的，所以没有必要添加额外的选择符。\n```\n// 糟糕\n$('div#myid');\n$('div#footer a.myLink');\n\n// 建议\n$('#myid');\n$('#footer .myLink');\n```\n#### 避免多个ID选择符\n在此强调，ID 选择符应该是唯一的，不需要添加额外的选择符，更不需要多个后代ID选择符。\n```\n// 糟糕\n$('#outer #inner');\n\n// 建议\n$('#inner');\n```\n#### 坚持最新版本\n新版本通常更好：更轻量级，更高效。显然，你需要考虑你要支持的代码的兼容性。例如，2.0版本不支持ie 6/7/8。\n\n#### 摒弃弃用方法\n关注每个新版本的废弃方法是非常重要的并尽量避免使用这些方法。\n```\n// 糟糕 - live 已经废弃\n\n$('#stuff').live('click', function() {\n  console.log('hooray');\n});\n\n// 建议\n$('#stuff').on('click', function() {\n  console.log('hooray');\n});\n// 注：此处可能不当，应为live能实现实时绑定，delegate或许更合适\n```\n#### 利用CDN\n谷歌的CND能保证选择离用户最近的缓存并迅速响应。（使用谷歌CND请自行搜索地址，推荐jquery官网提供的CDN）。\n#### 必要时组合jQuery和javascript原生代码\n如上所述，可以把jQuery看作是javascript的一个语法糖，这意味着用jQuery能做的事情，同样可以用原生代码来做。原生代码的可读性和可维护性可能不如jQuery，而且代码更长。但也意味着更高效（通常更接近底层代码可读性越差，性能越高，例如：汇编，当然需要更强大的人才可以）。牢记没有任何框架能比原生代码更小，更轻，更高效。\n","source":"_posts/jquery-gaoxiao.md","raw":"---\ntitle: 高效的jQuery代码编写技巧总结(收藏转)\ndate: 2014-12-30 14:50:35\ntags: jquery\n---\n**当你准备使用jQuery,强烈建议你遵循下面这些指南:**\n\n#### 缓存变量\nDOM遍历是昂贵的，所以尽量将会重用的元素缓存。\n```\n// 糟糕\nh = $('#element').height();\n$('#element').css('height',h-20);\n\n// 建议\n$element = $('#element');\nh = $element.height();\n$element.css('height',h-20);\n```\n#### 避免全局变量\njQuery与javascript一样，一般来说,最好确保你的变量在函数作用域内。\n```\n// 糟糕\n$element = $('#element');\nh = $element.height();\n$element.css('height',h-20);\n\n// 建议\nvar $element = $('#element');\nvar h = $element.height();\n$element.css('height',h-20);\n```\n#### 使用匈牙利命名法\n在变量前加$前缀，便于识别出jQuery对象。\n```\n// 糟糕\nvar first = $('#first');\nvar second = $('#second');\nvar value = $first.val();\n\n// 建议 - 在jQuery对象前加$前缀\nvar $first = $('#first');\nvar $second = $('#second'),\nvar value = $first.val();\n```\n#### 使用var链（单 Var 模式）\n将多条var语句合并为一条语句，建议将未赋值的变量放到后面。\n```\nvar\n  $first = $('#first'),\n  $second = $('#second'),\n  value = $first.val(),\n  k = 3,\n  cookiestring = 'SOMECOOKIESPLEASE',\n  i,\n  j,\n  myArray = {};\n```\n#### 请使用’On’\n在新版jQuery中，更短的 on(“click”) 用来取代类似 click() 这样的函数。在之前的版本中 on() 就是 bind()。自从jQuery 1.7版本后，on() 附加事件处理程序的首选方法。然而，出于一致性考虑，你可以简单的全部使用 on()方法。\n```\n// 糟糕\n$first.click(function(){\n    $first.css('border','1px solid red');\n    $first.css('color','blue');\n});\n\n$first.hover(function(){\n    $first.css('border','1px solid red');\n})\n\n// 建议\n$first.on('click',function(){\n    $first.css('border','1px solid red');\n    $first.css('color','blue');\n})\n$first.on('hover',function(){\n    $first.css('border','1px solid red');\n})\n```\n#### 精简jq代码\n一般来说,最好尽可能合并函数。\n```\n// 糟糕\n$first.click(function(){\n    $first.css('border','1px solid red');\n    $first.css('color','blue');\n});\n\n// 建议\n$first.on('click',function(){\n    $first.css({\n        'border':'1px solid red',\n        'color':'blue'\n    });\n});\n```\n#### 链式操作\njQuery实现方法的链式操作是非常容易的。下面利用这一点。\n```\n// 糟糕\n$second.html(value);\n$second.on('click',function(){\n    alert('hello everybody');\n});\n$second.fadeIn('slow');\n$second.animate({height:'120px'},500);\n\n// 建议\n$second.html(value);\n$second.on('click',function(){\n    alert('hello everybody');\n}).fadeIn('slow').animate({height:'120px'},500);\n```\n#### 维持代码的可读性\n伴随着精简代码和使用链式的同时，可能带来代码的难以阅读。添加缩紧和换行能起到很好的效果。\n```\n// 糟糕\n$second.html(value);\n$second.on('click',function(){\n    alert('hello everybody');\n}).fadeIn('slow').animate({height:'120px'},500);\n\n// 建议\n$second.html(value);\n$second\n    .on('click',function(){ alert('hello everybody');})\n    .fadeIn('slow')\n    .animate({height:'120px'},500);\n```\n#### 选择短路求值\n短路求值是一个从左到右求值的表达式，用 &&（逻辑与）或 ||（逻辑或）操作符。\n```\n// 糟糕\nfunction initVar($myVar) {\n    if(!$myVar) {\n        $myVar = $('#selector');\n    }\n}\n\n// 建议\nfunction initVar($myVar) {\n    $myVar = $myVar || $('#selector');\n}\n```\n#### 选择捷径\n精简代码的其中一种方式是利用编码捷径。\n```\n// 糟糕\nif(collection.length > 0){..}\n\n// 建议\nif(collection.length){..}\n```\n#### 繁重的操作中分离元素\n如果你打算对DOM元素做大量操作（连续设置多个属性或css样式），建议首先分离元素然后在添加。\n```\n// 糟糕\nvar\n    $container = $(\"#container\"),\n    $containerLi = $(\"#container li\"),\n    $element = null;\n\n$element = $containerLi.first();\n//... 许多复杂的操作\n\n// 建议\nvar\n    $container = $(\"#container\"),\n    $containerLi = $container.find(\"li\"),\n    $element = null;\n\n$element = $containerLi.first().detach();\n//... 许多复杂的操作\n$container.append($element);\n```\n#### 熟记技巧\n你可能对使用jQuery中的方法缺少经验,一定要查看的文档，可能会有一个更好或更快的方法来使用它。\n```\n// 糟糕\n$('#id').data(key,value);\n\n// 建议 (高效)\n$.data('#id',key,value);\n```\n#### 使用子查询缓存的父元素\n正如前面所提到的，DOM遍历是一项昂贵的操作。典型做法是缓存父元素并在选择子元素时重用这些缓存元素。\n```\n// 糟糕\nvar\n    $container = $('#container'),\n    $containerLi = $('#container li'),\n    $containerLiSpan = $('#container li span');\n\n// 建议 (高效)\nvar\n    $container = $('#container '),\n    $containerLi = $container.find('li'),\n    $containerLiSpan= $containerLi.find('span');\n```\n#### 避免通用选择符\n将通用选择符放到后代选择符中，性能非常糟糕。\n```\n// 糟糕\n$('.container > *');\n\n// 建议\n$('.container').children();\n```\n#### 避免隐式通用选择符\n通用选择符有时是隐式的，不容易发现。\n```\n// 糟糕\n$('.someclass :radio');\n\n// 建议\n$('.someclass input:radio');\n```\n#### 优化选择符\n例如，Id选择符应该是唯一的，所以没有必要添加额外的选择符。\n```\n// 糟糕\n$('div#myid');\n$('div#footer a.myLink');\n\n// 建议\n$('#myid');\n$('#footer .myLink');\n```\n#### 避免多个ID选择符\n在此强调，ID 选择符应该是唯一的，不需要添加额外的选择符，更不需要多个后代ID选择符。\n```\n// 糟糕\n$('#outer #inner');\n\n// 建议\n$('#inner');\n```\n#### 坚持最新版本\n新版本通常更好：更轻量级，更高效。显然，你需要考虑你要支持的代码的兼容性。例如，2.0版本不支持ie 6/7/8。\n\n#### 摒弃弃用方法\n关注每个新版本的废弃方法是非常重要的并尽量避免使用这些方法。\n```\n// 糟糕 - live 已经废弃\n\n$('#stuff').live('click', function() {\n  console.log('hooray');\n});\n\n// 建议\n$('#stuff').on('click', function() {\n  console.log('hooray');\n});\n// 注：此处可能不当，应为live能实现实时绑定，delegate或许更合适\n```\n#### 利用CDN\n谷歌的CND能保证选择离用户最近的缓存并迅速响应。（使用谷歌CND请自行搜索地址，推荐jquery官网提供的CDN）。\n#### 必要时组合jQuery和javascript原生代码\n如上所述，可以把jQuery看作是javascript的一个语法糖，这意味着用jQuery能做的事情，同样可以用原生代码来做。原生代码的可读性和可维护性可能不如jQuery，而且代码更长。但也意味着更高效（通常更接近底层代码可读性越差，性能越高，例如：汇编，当然需要更强大的人才可以）。牢记没有任何框架能比原生代码更小，更轻，更高效。\n","slug":"jquery-gaoxiao","published":1,"updated":"2016-12-30T07:15:34.269Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv8a0027jgtuvbt7n0of","content":"<p><strong>当你准备使用jQuery,强烈建议你遵循下面这些指南:</strong></p>\n<h4 id=\"缓存变量\"><a href=\"#缓存变量\" class=\"headerlink\" title=\"缓存变量\"></a>缓存变量</h4><p>DOM遍历是昂贵的，所以尽量将会重用的元素缓存。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">h = $(&apos;#element&apos;).height();</div><div class=\"line\">$(&apos;#element&apos;).css(&apos;height&apos;,h-20);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$element = $(&apos;#element&apos;);</div><div class=\"line\">h = $element.height();</div><div class=\"line\">$element.css(&apos;height&apos;,h-20);</div></pre></td></tr></table></figure></p>\n<h4 id=\"避免全局变量\"><a href=\"#避免全局变量\" class=\"headerlink\" title=\"避免全局变量\"></a>避免全局变量</h4><p>jQuery与javascript一样，一般来说,最好确保你的变量在函数作用域内。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$element = $(&apos;#element&apos;);</div><div class=\"line\">h = $element.height();</div><div class=\"line\">$element.css(&apos;height&apos;,h-20);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">var $element = $(&apos;#element&apos;);</div><div class=\"line\">var h = $element.height();</div><div class=\"line\">$element.css(&apos;height&apos;,h-20);</div></pre></td></tr></table></figure></p>\n<h4 id=\"使用匈牙利命名法\"><a href=\"#使用匈牙利命名法\" class=\"headerlink\" title=\"使用匈牙利命名法\"></a>使用匈牙利命名法</h4><p>在变量前加$前缀，便于识别出jQuery对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">var first = $(&apos;#first&apos;);</div><div class=\"line\">var second = $(&apos;#second&apos;);</div><div class=\"line\">var value = $first.val();</div><div class=\"line\"></div><div class=\"line\">// 建议 - 在jQuery对象前加$前缀</div><div class=\"line\">var $first = $(&apos;#first&apos;);</div><div class=\"line\">var $second = $(&apos;#second&apos;),</div><div class=\"line\">var value = $first.val();</div></pre></td></tr></table></figure></p>\n<h4 id=\"使用var链（单-Var-模式）\"><a href=\"#使用var链（单-Var-模式）\" class=\"headerlink\" title=\"使用var链（单 Var 模式）\"></a>使用var链（单 Var 模式）</h4><p>将多条var语句合并为一条语句，建议将未赋值的变量放到后面。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var</div><div class=\"line\">  $first = $(&apos;#first&apos;),</div><div class=\"line\">  $second = $(&apos;#second&apos;),</div><div class=\"line\">  value = $first.val(),</div><div class=\"line\">  k = 3,</div><div class=\"line\">  cookiestring = &apos;SOMECOOKIESPLEASE&apos;,</div><div class=\"line\">  i,</div><div class=\"line\">  j,</div><div class=\"line\">  myArray = &#123;&#125;;</div></pre></td></tr></table></figure></p>\n<h4 id=\"请使用’On’\"><a href=\"#请使用’On’\" class=\"headerlink\" title=\"请使用’On’\"></a>请使用’On’</h4><p>在新版jQuery中，更短的 on(“click”) 用来取代类似 click() 这样的函数。在之前的版本中 on() 就是 bind()。自从jQuery 1.7版本后，on() 附加事件处理程序的首选方法。然而，出于一致性考虑，你可以简单的全部使用 on()方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$first.click(function()&#123;</div><div class=\"line\">    $first.css(&apos;border&apos;,&apos;1px solid red&apos;);</div><div class=\"line\">    $first.css(&apos;color&apos;,&apos;blue&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">$first.hover(function()&#123;</div><div class=\"line\">    $first.css(&apos;border&apos;,&apos;1px solid red&apos;);</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$first.on(&apos;click&apos;,function()&#123;</div><div class=\"line\">    $first.css(&apos;border&apos;,&apos;1px solid red&apos;);</div><div class=\"line\">    $first.css(&apos;color&apos;,&apos;blue&apos;);</div><div class=\"line\">&#125;)</div><div class=\"line\">$first.on(&apos;hover&apos;,function()&#123;</div><div class=\"line\">    $first.css(&apos;border&apos;,&apos;1px solid red&apos;);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h4 id=\"精简jq代码\"><a href=\"#精简jq代码\" class=\"headerlink\" title=\"精简jq代码\"></a>精简jq代码</h4><p>一般来说,最好尽可能合并函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$first.click(function()&#123;</div><div class=\"line\">    $first.css(&apos;border&apos;,&apos;1px solid red&apos;);</div><div class=\"line\">    $first.css(&apos;color&apos;,&apos;blue&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$first.on(&apos;click&apos;,function()&#123;</div><div class=\"line\">    $first.css(&#123;</div><div class=\"line\">        &apos;border&apos;:&apos;1px solid red&apos;,</div><div class=\"line\">        &apos;color&apos;:&apos;blue&apos;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"链式操作\"><a href=\"#链式操作\" class=\"headerlink\" title=\"链式操作\"></a>链式操作</h4><p>jQuery实现方法的链式操作是非常容易的。下面利用这一点。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$second.html(value);</div><div class=\"line\">$second.on(&apos;click&apos;,function()&#123;</div><div class=\"line\">    alert(&apos;hello everybody&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\">$second.fadeIn(&apos;slow&apos;);</div><div class=\"line\">$second.animate(&#123;height:&apos;120px&apos;&#125;,500);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$second.html(value);</div><div class=\"line\">$second.on(&apos;click&apos;,function()&#123;</div><div class=\"line\">    alert(&apos;hello everybody&apos;);</div><div class=\"line\">&#125;).fadeIn(&apos;slow&apos;).animate(&#123;height:&apos;120px&apos;&#125;,500);</div></pre></td></tr></table></figure></p>\n<h4 id=\"维持代码的可读性\"><a href=\"#维持代码的可读性\" class=\"headerlink\" title=\"维持代码的可读性\"></a>维持代码的可读性</h4><p>伴随着精简代码和使用链式的同时，可能带来代码的难以阅读。添加缩紧和换行能起到很好的效果。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$second.html(value);</div><div class=\"line\">$second.on(&apos;click&apos;,function()&#123;</div><div class=\"line\">    alert(&apos;hello everybody&apos;);</div><div class=\"line\">&#125;).fadeIn(&apos;slow&apos;).animate(&#123;height:&apos;120px&apos;&#125;,500);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$second.html(value);</div><div class=\"line\">$second</div><div class=\"line\">    .on(&apos;click&apos;,function()&#123; alert(&apos;hello everybody&apos;);&#125;)</div><div class=\"line\">    .fadeIn(&apos;slow&apos;)</div><div class=\"line\">    .animate(&#123;height:&apos;120px&apos;&#125;,500);</div></pre></td></tr></table></figure></p>\n<h4 id=\"选择短路求值\"><a href=\"#选择短路求值\" class=\"headerlink\" title=\"选择短路求值\"></a>选择短路求值</h4><p>短路求值是一个从左到右求值的表达式，用 &amp;&amp;（逻辑与）或 ||（逻辑或）操作符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">function initVar($myVar) &#123;</div><div class=\"line\">    if(!$myVar) &#123;</div><div class=\"line\">        $myVar = $(&apos;#selector&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">function initVar($myVar) &#123;</div><div class=\"line\">    $myVar = $myVar || $(&apos;#selector&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"选择捷径\"><a href=\"#选择捷径\" class=\"headerlink\" title=\"选择捷径\"></a>选择捷径</h4><p>精简代码的其中一种方式是利用编码捷径。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">if(collection.length &gt; 0)&#123;..&#125;</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">if(collection.length)&#123;..&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"繁重的操作中分离元素\"><a href=\"#繁重的操作中分离元素\" class=\"headerlink\" title=\"繁重的操作中分离元素\"></a>繁重的操作中分离元素</h4><p>如果你打算对DOM元素做大量操作（连续设置多个属性或css样式），建议首先分离元素然后在添加。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">var</div><div class=\"line\">    $container = $(&quot;#container&quot;),</div><div class=\"line\">    $containerLi = $(&quot;#container li&quot;),</div><div class=\"line\">    $element = null;</div><div class=\"line\"></div><div class=\"line\">$element = $containerLi.first();</div><div class=\"line\">//... 许多复杂的操作</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">var</div><div class=\"line\">    $container = $(&quot;#container&quot;),</div><div class=\"line\">    $containerLi = $container.find(&quot;li&quot;),</div><div class=\"line\">    $element = null;</div><div class=\"line\"></div><div class=\"line\">$element = $containerLi.first().detach();</div><div class=\"line\">//... 许多复杂的操作</div><div class=\"line\">$container.append($element);</div></pre></td></tr></table></figure></p>\n<h4 id=\"熟记技巧\"><a href=\"#熟记技巧\" class=\"headerlink\" title=\"熟记技巧\"></a>熟记技巧</h4><p>你可能对使用jQuery中的方法缺少经验,一定要查看的文档，可能会有一个更好或更快的方法来使用它。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$(&apos;#id&apos;).data(key,value);</div><div class=\"line\"></div><div class=\"line\">// 建议 (高效)</div><div class=\"line\">$.data(&apos;#id&apos;,key,value);</div></pre></td></tr></table></figure></p>\n<h4 id=\"使用子查询缓存的父元素\"><a href=\"#使用子查询缓存的父元素\" class=\"headerlink\" title=\"使用子查询缓存的父元素\"></a>使用子查询缓存的父元素</h4><p>正如前面所提到的，DOM遍历是一项昂贵的操作。典型做法是缓存父元素并在选择子元素时重用这些缓存元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">var</div><div class=\"line\">    $container = $(&apos;#container&apos;),</div><div class=\"line\">    $containerLi = $(&apos;#container li&apos;),</div><div class=\"line\">    $containerLiSpan = $(&apos;#container li span&apos;);</div><div class=\"line\"></div><div class=\"line\">// 建议 (高效)</div><div class=\"line\">var</div><div class=\"line\">    $container = $(&apos;#container &apos;),</div><div class=\"line\">    $containerLi = $container.find(&apos;li&apos;),</div><div class=\"line\">    $containerLiSpan= $containerLi.find(&apos;span&apos;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"避免通用选择符\"><a href=\"#避免通用选择符\" class=\"headerlink\" title=\"避免通用选择符\"></a>避免通用选择符</h4><p>将通用选择符放到后代选择符中，性能非常糟糕。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$(&apos;.container &gt; *&apos;);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$(&apos;.container&apos;).children();</div></pre></td></tr></table></figure></p>\n<h4 id=\"避免隐式通用选择符\"><a href=\"#避免隐式通用选择符\" class=\"headerlink\" title=\"避免隐式通用选择符\"></a>避免隐式通用选择符</h4><p>通用选择符有时是隐式的，不容易发现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$(&apos;.someclass :radio&apos;);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$(&apos;.someclass input:radio&apos;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"优化选择符\"><a href=\"#优化选择符\" class=\"headerlink\" title=\"优化选择符\"></a>优化选择符</h4><p>例如，Id选择符应该是唯一的，所以没有必要添加额外的选择符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$(&apos;div#myid&apos;);</div><div class=\"line\">$(&apos;div#footer a.myLink&apos;);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$(&apos;#myid&apos;);</div><div class=\"line\">$(&apos;#footer .myLink&apos;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"避免多个ID选择符\"><a href=\"#避免多个ID选择符\" class=\"headerlink\" title=\"避免多个ID选择符\"></a>避免多个ID选择符</h4><p>在此强调，ID 选择符应该是唯一的，不需要添加额外的选择符，更不需要多个后代ID选择符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$(&apos;#outer #inner&apos;);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$(&apos;#inner&apos;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"坚持最新版本\"><a href=\"#坚持最新版本\" class=\"headerlink\" title=\"坚持最新版本\"></a>坚持最新版本</h4><p>新版本通常更好：更轻量级，更高效。显然，你需要考虑你要支持的代码的兼容性。例如，2.0版本不支持ie 6/7/8。</p>\n<h4 id=\"摒弃弃用方法\"><a href=\"#摒弃弃用方法\" class=\"headerlink\" title=\"摒弃弃用方法\"></a>摒弃弃用方法</h4><p>关注每个新版本的废弃方法是非常重要的并尽量避免使用这些方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕 - live 已经废弃</div><div class=\"line\"></div><div class=\"line\">$(&apos;#stuff&apos;).live(&apos;click&apos;, function() &#123;</div><div class=\"line\">  console.log(&apos;hooray&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$(&apos;#stuff&apos;).on(&apos;click&apos;, function() &#123;</div><div class=\"line\">  console.log(&apos;hooray&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\">// 注：此处可能不当，应为live能实现实时绑定，delegate或许更合适</div></pre></td></tr></table></figure></p>\n<h4 id=\"利用CDN\"><a href=\"#利用CDN\" class=\"headerlink\" title=\"利用CDN\"></a>利用CDN</h4><p>谷歌的CND能保证选择离用户最近的缓存并迅速响应。（使用谷歌CND请自行搜索地址，推荐jquery官网提供的CDN）。</p>\n<h4 id=\"必要时组合jQuery和javascript原生代码\"><a href=\"#必要时组合jQuery和javascript原生代码\" class=\"headerlink\" title=\"必要时组合jQuery和javascript原生代码\"></a>必要时组合jQuery和javascript原生代码</h4><p>如上所述，可以把jQuery看作是javascript的一个语法糖，这意味着用jQuery能做的事情，同样可以用原生代码来做。原生代码的可读性和可维护性可能不如jQuery，而且代码更长。但也意味着更高效（通常更接近底层代码可读性越差，性能越高，例如：汇编，当然需要更强大的人才可以）。牢记没有任何框架能比原生代码更小，更轻，更高效。</p>\n","excerpt":"","more":"<p><strong>当你准备使用jQuery,强烈建议你遵循下面这些指南:</strong></p>\n<h4 id=\"缓存变量\"><a href=\"#缓存变量\" class=\"headerlink\" title=\"缓存变量\"></a>缓存变量</h4><p>DOM遍历是昂贵的，所以尽量将会重用的元素缓存。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">h = $(&apos;#element&apos;).height();</div><div class=\"line\">$(&apos;#element&apos;).css(&apos;height&apos;,h-20);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$element = $(&apos;#element&apos;);</div><div class=\"line\">h = $element.height();</div><div class=\"line\">$element.css(&apos;height&apos;,h-20);</div></pre></td></tr></table></figure></p>\n<h4 id=\"避免全局变量\"><a href=\"#避免全局变量\" class=\"headerlink\" title=\"避免全局变量\"></a>避免全局变量</h4><p>jQuery与javascript一样，一般来说,最好确保你的变量在函数作用域内。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$element = $(&apos;#element&apos;);</div><div class=\"line\">h = $element.height();</div><div class=\"line\">$element.css(&apos;height&apos;,h-20);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">var $element = $(&apos;#element&apos;);</div><div class=\"line\">var h = $element.height();</div><div class=\"line\">$element.css(&apos;height&apos;,h-20);</div></pre></td></tr></table></figure></p>\n<h4 id=\"使用匈牙利命名法\"><a href=\"#使用匈牙利命名法\" class=\"headerlink\" title=\"使用匈牙利命名法\"></a>使用匈牙利命名法</h4><p>在变量前加$前缀，便于识别出jQuery对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">var first = $(&apos;#first&apos;);</div><div class=\"line\">var second = $(&apos;#second&apos;);</div><div class=\"line\">var value = $first.val();</div><div class=\"line\"></div><div class=\"line\">// 建议 - 在jQuery对象前加$前缀</div><div class=\"line\">var $first = $(&apos;#first&apos;);</div><div class=\"line\">var $second = $(&apos;#second&apos;),</div><div class=\"line\">var value = $first.val();</div></pre></td></tr></table></figure></p>\n<h4 id=\"使用var链（单-Var-模式）\"><a href=\"#使用var链（单-Var-模式）\" class=\"headerlink\" title=\"使用var链（单 Var 模式）\"></a>使用var链（单 Var 模式）</h4><p>将多条var语句合并为一条语句，建议将未赋值的变量放到后面。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var</div><div class=\"line\">  $first = $(&apos;#first&apos;),</div><div class=\"line\">  $second = $(&apos;#second&apos;),</div><div class=\"line\">  value = $first.val(),</div><div class=\"line\">  k = 3,</div><div class=\"line\">  cookiestring = &apos;SOMECOOKIESPLEASE&apos;,</div><div class=\"line\">  i,</div><div class=\"line\">  j,</div><div class=\"line\">  myArray = &#123;&#125;;</div></pre></td></tr></table></figure></p>\n<h4 id=\"请使用’On’\"><a href=\"#请使用’On’\" class=\"headerlink\" title=\"请使用’On’\"></a>请使用’On’</h4><p>在新版jQuery中，更短的 on(“click”) 用来取代类似 click() 这样的函数。在之前的版本中 on() 就是 bind()。自从jQuery 1.7版本后，on() 附加事件处理程序的首选方法。然而，出于一致性考虑，你可以简单的全部使用 on()方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$first.click(function()&#123;</div><div class=\"line\">    $first.css(&apos;border&apos;,&apos;1px solid red&apos;);</div><div class=\"line\">    $first.css(&apos;color&apos;,&apos;blue&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">$first.hover(function()&#123;</div><div class=\"line\">    $first.css(&apos;border&apos;,&apos;1px solid red&apos;);</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$first.on(&apos;click&apos;,function()&#123;</div><div class=\"line\">    $first.css(&apos;border&apos;,&apos;1px solid red&apos;);</div><div class=\"line\">    $first.css(&apos;color&apos;,&apos;blue&apos;);</div><div class=\"line\">&#125;)</div><div class=\"line\">$first.on(&apos;hover&apos;,function()&#123;</div><div class=\"line\">    $first.css(&apos;border&apos;,&apos;1px solid red&apos;);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h4 id=\"精简jq代码\"><a href=\"#精简jq代码\" class=\"headerlink\" title=\"精简jq代码\"></a>精简jq代码</h4><p>一般来说,最好尽可能合并函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$first.click(function()&#123;</div><div class=\"line\">    $first.css(&apos;border&apos;,&apos;1px solid red&apos;);</div><div class=\"line\">    $first.css(&apos;color&apos;,&apos;blue&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$first.on(&apos;click&apos;,function()&#123;</div><div class=\"line\">    $first.css(&#123;</div><div class=\"line\">        &apos;border&apos;:&apos;1px solid red&apos;,</div><div class=\"line\">        &apos;color&apos;:&apos;blue&apos;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"链式操作\"><a href=\"#链式操作\" class=\"headerlink\" title=\"链式操作\"></a>链式操作</h4><p>jQuery实现方法的链式操作是非常容易的。下面利用这一点。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$second.html(value);</div><div class=\"line\">$second.on(&apos;click&apos;,function()&#123;</div><div class=\"line\">    alert(&apos;hello everybody&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\">$second.fadeIn(&apos;slow&apos;);</div><div class=\"line\">$second.animate(&#123;height:&apos;120px&apos;&#125;,500);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$second.html(value);</div><div class=\"line\">$second.on(&apos;click&apos;,function()&#123;</div><div class=\"line\">    alert(&apos;hello everybody&apos;);</div><div class=\"line\">&#125;).fadeIn(&apos;slow&apos;).animate(&#123;height:&apos;120px&apos;&#125;,500);</div></pre></td></tr></table></figure></p>\n<h4 id=\"维持代码的可读性\"><a href=\"#维持代码的可读性\" class=\"headerlink\" title=\"维持代码的可读性\"></a>维持代码的可读性</h4><p>伴随着精简代码和使用链式的同时，可能带来代码的难以阅读。添加缩紧和换行能起到很好的效果。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$second.html(value);</div><div class=\"line\">$second.on(&apos;click&apos;,function()&#123;</div><div class=\"line\">    alert(&apos;hello everybody&apos;);</div><div class=\"line\">&#125;).fadeIn(&apos;slow&apos;).animate(&#123;height:&apos;120px&apos;&#125;,500);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$second.html(value);</div><div class=\"line\">$second</div><div class=\"line\">    .on(&apos;click&apos;,function()&#123; alert(&apos;hello everybody&apos;);&#125;)</div><div class=\"line\">    .fadeIn(&apos;slow&apos;)</div><div class=\"line\">    .animate(&#123;height:&apos;120px&apos;&#125;,500);</div></pre></td></tr></table></figure></p>\n<h4 id=\"选择短路求值\"><a href=\"#选择短路求值\" class=\"headerlink\" title=\"选择短路求值\"></a>选择短路求值</h4><p>短路求值是一个从左到右求值的表达式，用 &amp;&amp;（逻辑与）或 ||（逻辑或）操作符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">function initVar($myVar) &#123;</div><div class=\"line\">    if(!$myVar) &#123;</div><div class=\"line\">        $myVar = $(&apos;#selector&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">function initVar($myVar) &#123;</div><div class=\"line\">    $myVar = $myVar || $(&apos;#selector&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"选择捷径\"><a href=\"#选择捷径\" class=\"headerlink\" title=\"选择捷径\"></a>选择捷径</h4><p>精简代码的其中一种方式是利用编码捷径。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">if(collection.length &gt; 0)&#123;..&#125;</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">if(collection.length)&#123;..&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"繁重的操作中分离元素\"><a href=\"#繁重的操作中分离元素\" class=\"headerlink\" title=\"繁重的操作中分离元素\"></a>繁重的操作中分离元素</h4><p>如果你打算对DOM元素做大量操作（连续设置多个属性或css样式），建议首先分离元素然后在添加。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">var</div><div class=\"line\">    $container = $(&quot;#container&quot;),</div><div class=\"line\">    $containerLi = $(&quot;#container li&quot;),</div><div class=\"line\">    $element = null;</div><div class=\"line\"></div><div class=\"line\">$element = $containerLi.first();</div><div class=\"line\">//... 许多复杂的操作</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">var</div><div class=\"line\">    $container = $(&quot;#container&quot;),</div><div class=\"line\">    $containerLi = $container.find(&quot;li&quot;),</div><div class=\"line\">    $element = null;</div><div class=\"line\"></div><div class=\"line\">$element = $containerLi.first().detach();</div><div class=\"line\">//... 许多复杂的操作</div><div class=\"line\">$container.append($element);</div></pre></td></tr></table></figure></p>\n<h4 id=\"熟记技巧\"><a href=\"#熟记技巧\" class=\"headerlink\" title=\"熟记技巧\"></a>熟记技巧</h4><p>你可能对使用jQuery中的方法缺少经验,一定要查看的文档，可能会有一个更好或更快的方法来使用它。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$(&apos;#id&apos;).data(key,value);</div><div class=\"line\"></div><div class=\"line\">// 建议 (高效)</div><div class=\"line\">$.data(&apos;#id&apos;,key,value);</div></pre></td></tr></table></figure></p>\n<h4 id=\"使用子查询缓存的父元素\"><a href=\"#使用子查询缓存的父元素\" class=\"headerlink\" title=\"使用子查询缓存的父元素\"></a>使用子查询缓存的父元素</h4><p>正如前面所提到的，DOM遍历是一项昂贵的操作。典型做法是缓存父元素并在选择子元素时重用这些缓存元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">var</div><div class=\"line\">    $container = $(&apos;#container&apos;),</div><div class=\"line\">    $containerLi = $(&apos;#container li&apos;),</div><div class=\"line\">    $containerLiSpan = $(&apos;#container li span&apos;);</div><div class=\"line\"></div><div class=\"line\">// 建议 (高效)</div><div class=\"line\">var</div><div class=\"line\">    $container = $(&apos;#container &apos;),</div><div class=\"line\">    $containerLi = $container.find(&apos;li&apos;),</div><div class=\"line\">    $containerLiSpan= $containerLi.find(&apos;span&apos;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"避免通用选择符\"><a href=\"#避免通用选择符\" class=\"headerlink\" title=\"避免通用选择符\"></a>避免通用选择符</h4><p>将通用选择符放到后代选择符中，性能非常糟糕。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$(&apos;.container &gt; *&apos;);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$(&apos;.container&apos;).children();</div></pre></td></tr></table></figure></p>\n<h4 id=\"避免隐式通用选择符\"><a href=\"#避免隐式通用选择符\" class=\"headerlink\" title=\"避免隐式通用选择符\"></a>避免隐式通用选择符</h4><p>通用选择符有时是隐式的，不容易发现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$(&apos;.someclass :radio&apos;);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$(&apos;.someclass input:radio&apos;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"优化选择符\"><a href=\"#优化选择符\" class=\"headerlink\" title=\"优化选择符\"></a>优化选择符</h4><p>例如，Id选择符应该是唯一的，所以没有必要添加额外的选择符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$(&apos;div#myid&apos;);</div><div class=\"line\">$(&apos;div#footer a.myLink&apos;);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$(&apos;#myid&apos;);</div><div class=\"line\">$(&apos;#footer .myLink&apos;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"避免多个ID选择符\"><a href=\"#避免多个ID选择符\" class=\"headerlink\" title=\"避免多个ID选择符\"></a>避免多个ID选择符</h4><p>在此强调，ID 选择符应该是唯一的，不需要添加额外的选择符，更不需要多个后代ID选择符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕</div><div class=\"line\">$(&apos;#outer #inner&apos;);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$(&apos;#inner&apos;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"坚持最新版本\"><a href=\"#坚持最新版本\" class=\"headerlink\" title=\"坚持最新版本\"></a>坚持最新版本</h4><p>新版本通常更好：更轻量级，更高效。显然，你需要考虑你要支持的代码的兼容性。例如，2.0版本不支持ie 6/7/8。</p>\n<h4 id=\"摒弃弃用方法\"><a href=\"#摒弃弃用方法\" class=\"headerlink\" title=\"摒弃弃用方法\"></a>摒弃弃用方法</h4><p>关注每个新版本的废弃方法是非常重要的并尽量避免使用这些方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 糟糕 - live 已经废弃</div><div class=\"line\"></div><div class=\"line\">$(&apos;#stuff&apos;).live(&apos;click&apos;, function() &#123;</div><div class=\"line\">  console.log(&apos;hooray&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// 建议</div><div class=\"line\">$(&apos;#stuff&apos;).on(&apos;click&apos;, function() &#123;</div><div class=\"line\">  console.log(&apos;hooray&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\">// 注：此处可能不当，应为live能实现实时绑定，delegate或许更合适</div></pre></td></tr></table></figure></p>\n<h4 id=\"利用CDN\"><a href=\"#利用CDN\" class=\"headerlink\" title=\"利用CDN\"></a>利用CDN</h4><p>谷歌的CND能保证选择离用户最近的缓存并迅速响应。（使用谷歌CND请自行搜索地址，推荐jquery官网提供的CDN）。</p>\n<h4 id=\"必要时组合jQuery和javascript原生代码\"><a href=\"#必要时组合jQuery和javascript原生代码\" class=\"headerlink\" title=\"必要时组合jQuery和javascript原生代码\"></a>必要时组合jQuery和javascript原生代码</h4><p>如上所述，可以把jQuery看作是javascript的一个语法糖，这意味着用jQuery能做的事情，同样可以用原生代码来做。原生代码的可读性和可维护性可能不如jQuery，而且代码更长。但也意味着更高效（通常更接近底层代码可读性越差，性能越高，例如：汇编，当然需要更强大的人才可以）。牢记没有任何框架能比原生代码更小，更轻，更高效。</p>\n"},{"title":"JS模块规范对比：AMD，CMD，CommonJS","date":"2016-12-13T08:46:32.000Z","_content":"AMD,CMD,CommonJS是目前最常用的三种模块化书写规范。\n### CommonJS （CommonJs Modules规范的简写）\n*NodeJS就采用了CommonJS*\n```\nvar clock = require('clock');\nclock.start();\n```\n　　第二行clock.start()，在第一行require('clock')之后运行，因此必须等clock.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。\n\n　　这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于\"假死\"状态。\n\n　　因此，浏览器端的模块，不能采用\"同步加载\"（synchronou），只能采用\"异步加载\"（asynchronous）。这就是AMD规范CMD规范诞生的背景。\n\n　　CommonJs是同步加载模块，这种同步机制应用到浏览器中就会出现问题了，例如加载速度啥的（浏览器同步加载模块会导致性能、可用性、调试和跨域访问等问题），Commonjs是一个更偏向于服务器端的规范。当然你也可以把它用在浏览器里边。Node.js采用了这个规范。 根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。\n### AMD\n　　AMD，即 (Asynchronous Module Definition)，这种规范是异步的加载模块，requireJs应用了这一规范。先定义所有依赖，然后在加载完成后的回调函数中执行：\n```\nrequire([module], callback);\n```\n用AMD写上一个模块：\n```\nrequire(['clock'],function(clock){\n  clock.start();\n});\n```\n　　AMD虽然实现了异步加载，但是开始就把所有依赖写出来是不符合书写的逻辑顺序的，能不能像commonJS那样用的时候再require，而且还支持异步加载后再执行呢？\n### CMD\n　　CMD (Common Module Definition), 是seajs推崇的规范，CMD则是依赖就近，用的时候再require。它写起来是这样的：\n```\ndefine(function(require, exports, module) {\n   var clock = require('clock');\n   clock.start();\n});\n```\n　　AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。\n　　AMD依赖前置，js可以方便知道依赖模块是谁，立即加载；而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。\n　　对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。CMD 推崇依赖就近，AMD 推崇依赖前置。CMD 推崇 as lazy as possible.\n\n","source":"_posts/js-modules-compare.md","raw":"---\ntitle: JS模块规范对比：AMD，CMD，CommonJS\ndate: 2016-12-13 16:46:32\ntags: js模块化、AMD、CMD、CommonJs\n---\nAMD,CMD,CommonJS是目前最常用的三种模块化书写规范。\n### CommonJS （CommonJs Modules规范的简写）\n*NodeJS就采用了CommonJS*\n```\nvar clock = require('clock');\nclock.start();\n```\n　　第二行clock.start()，在第一行require('clock')之后运行，因此必须等clock.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。\n\n　　这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于\"假死\"状态。\n\n　　因此，浏览器端的模块，不能采用\"同步加载\"（synchronou），只能采用\"异步加载\"（asynchronous）。这就是AMD规范CMD规范诞生的背景。\n\n　　CommonJs是同步加载模块，这种同步机制应用到浏览器中就会出现问题了，例如加载速度啥的（浏览器同步加载模块会导致性能、可用性、调试和跨域访问等问题），Commonjs是一个更偏向于服务器端的规范。当然你也可以把它用在浏览器里边。Node.js采用了这个规范。 根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。\n### AMD\n　　AMD，即 (Asynchronous Module Definition)，这种规范是异步的加载模块，requireJs应用了这一规范。先定义所有依赖，然后在加载完成后的回调函数中执行：\n```\nrequire([module], callback);\n```\n用AMD写上一个模块：\n```\nrequire(['clock'],function(clock){\n  clock.start();\n});\n```\n　　AMD虽然实现了异步加载，但是开始就把所有依赖写出来是不符合书写的逻辑顺序的，能不能像commonJS那样用的时候再require，而且还支持异步加载后再执行呢？\n### CMD\n　　CMD (Common Module Definition), 是seajs推崇的规范，CMD则是依赖就近，用的时候再require。它写起来是这样的：\n```\ndefine(function(require, exports, module) {\n   var clock = require('clock');\n   clock.start();\n});\n```\n　　AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。\n　　AMD依赖前置，js可以方便知道依赖模块是谁，立即加载；而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。\n　　对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。CMD 推崇依赖就近，AMD 推崇依赖前置。CMD 推崇 as lazy as possible.\n\n","slug":"js-modules-compare","published":1,"updated":"2016-12-13T08:56:53.838Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv8c0028jgtu4ju1rj0d","content":"<p>AMD,CMD,CommonJS是目前最常用的三种模块化书写规范。</p>\n<h3 id=\"CommonJS-（CommonJs-Modules规范的简写）\"><a href=\"#CommonJS-（CommonJs-Modules规范的简写）\" class=\"headerlink\" title=\"CommonJS （CommonJs Modules规范的简写）\"></a>CommonJS （CommonJs Modules规范的简写）</h3><p><em>NodeJS就采用了CommonJS</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var clock = require(&apos;clock&apos;);</div><div class=\"line\">clock.start();</div></pre></td></tr></table></figure></p>\n<p>　　第二行clock.start()，在第一行require(‘clock’)之后运行，因此必须等clock.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。</p>\n<p>　　这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。</p>\n<p>　　因此，浏览器端的模块，不能采用”同步加载”（synchronou），只能采用”异步加载”（asynchronous）。这就是AMD规范CMD规范诞生的背景。</p>\n<p>　　CommonJs是同步加载模块，这种同步机制应用到浏览器中就会出现问题了，例如加载速度啥的（浏览器同步加载模块会导致性能、可用性、调试和跨域访问等问题），Commonjs是一个更偏向于服务器端的规范。当然你也可以把它用在浏览器里边。Node.js采用了这个规范。 根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。</p>\n<h3 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h3><p>　　AMD，即 (Asynchronous Module Definition)，这种规范是异步的加载模块，requireJs应用了这一规范。先定义所有依赖，然后在加载完成后的回调函数中执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">require([module], callback);</div></pre></td></tr></table></figure></p>\n<p>用AMD写上一个模块：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">require([&apos;clock&apos;],function(clock)&#123;</div><div class=\"line\">  clock.start();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>　　AMD虽然实现了异步加载，但是开始就把所有依赖写出来是不符合书写的逻辑顺序的，能不能像commonJS那样用的时候再require，而且还支持异步加载后再执行呢？</p>\n<h3 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h3><p>　　CMD (Common Module Definition), 是seajs推崇的规范，CMD则是依赖就近，用的时候再require。它写起来是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(function(require, exports, module) &#123;</div><div class=\"line\">   var clock = require(&apos;clock&apos;);</div><div class=\"line\">   clock.start();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>　　AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。<br>　　AMD依赖前置，js可以方便知道依赖模块是谁，立即加载；而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。<br>　　对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。CMD 推崇依赖就近，AMD 推崇依赖前置。CMD 推崇 as lazy as possible.</p>\n","excerpt":"","more":"<p>AMD,CMD,CommonJS是目前最常用的三种模块化书写规范。</p>\n<h3 id=\"CommonJS-（CommonJs-Modules规范的简写）\"><a href=\"#CommonJS-（CommonJs-Modules规范的简写）\" class=\"headerlink\" title=\"CommonJS （CommonJs Modules规范的简写）\"></a>CommonJS （CommonJs Modules规范的简写）</h3><p><em>NodeJS就采用了CommonJS</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var clock = require(&apos;clock&apos;);</div><div class=\"line\">clock.start();</div></pre></td></tr></table></figure></p>\n<p>　　第二行clock.start()，在第一行require(‘clock’)之后运行，因此必须等clock.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。</p>\n<p>　　这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。</p>\n<p>　　因此，浏览器端的模块，不能采用”同步加载”（synchronou），只能采用”异步加载”（asynchronous）。这就是AMD规范CMD规范诞生的背景。</p>\n<p>　　CommonJs是同步加载模块，这种同步机制应用到浏览器中就会出现问题了，例如加载速度啥的（浏览器同步加载模块会导致性能、可用性、调试和跨域访问等问题），Commonjs是一个更偏向于服务器端的规范。当然你也可以把它用在浏览器里边。Node.js采用了这个规范。 根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。</p>\n<h3 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h3><p>　　AMD，即 (Asynchronous Module Definition)，这种规范是异步的加载模块，requireJs应用了这一规范。先定义所有依赖，然后在加载完成后的回调函数中执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">require([module], callback);</div></pre></td></tr></table></figure></p>\n<p>用AMD写上一个模块：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">require([&apos;clock&apos;],function(clock)&#123;</div><div class=\"line\">  clock.start();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>　　AMD虽然实现了异步加载，但是开始就把所有依赖写出来是不符合书写的逻辑顺序的，能不能像commonJS那样用的时候再require，而且还支持异步加载后再执行呢？</p>\n<h3 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h3><p>　　CMD (Common Module Definition), 是seajs推崇的规范，CMD则是依赖就近，用的时候再require。它写起来是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(function(require, exports, module) &#123;</div><div class=\"line\">   var clock = require(&apos;clock&apos;);</div><div class=\"line\">   clock.start();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>　　AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。<br>　　AMD依赖前置，js可以方便知道依赖模块是谁，立即加载；而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。<br>　　对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。CMD 推崇依赖就近，AMD 推崇依赖前置。CMD 推崇 as lazy as possible.</p>\n"},{"title":"js模块化开发-sea.js(基础)","date":"2015-12-12T02:28:12.000Z","_content":"js模块化开发能解决的问题：1.冲突2.性能 3.依赖\n使用sea.js解决的步骤：\n- 1.引入sea.js的库\n- 2.如何变成模块-define\n- 3.如何调用模块-exports  -seajs.use\n- 4.如何依赖模块？-require\n一、如何变成模块-define 例：test.js\n```\ndefine(function (require, exports, module) {\n    //參數固定，写法不变\n    //exports:对外的接口\n    function abc() {\n        alert(123);\n    }\n    exports.abc=abc;\n});\n```\n二、如何调用模块-exports  -seajs.use\n    seajs.use:例index页面去调用模块，第一个参数：模块的地址，第二个参数：模块加载成功后的回调函数。\n 注：seajs模块的默认根目录是sea.js的目录。也就是说sea.js库在哪个文件夹下，seajs.use找模块的时候就在那个文件下开始找。\n ```\nseajs.use('sea/test.js',function (ex) {\n    //回调的参数，就是模块中的exports.\n    ex.abc();//当加载成功后，会弹出123\n    abc();  //这样做就很好的避免了命名冲突。\n    function abc() {\n        alert(456);\n    }\n});\n```\n三.如何依赖模块？-require\n例：test1.js  var a=10; test2.js依賴于test1.js,在此即说明test2.js要用到test1.js里定义的变量。test2.js如下：\n```\ndefine(function (require,exports,module) {\n    require('./test1.js');//根据当前文件相对的路径来写，这句相当于 let a=10;\n    function abcd() {\n        alert(a);\n    }\n});\n```\n如果test1.js是一个模块的化：\n```\ndefine(function (require,exports,module) {\n    var a=10;\n    exports.a=a;\n});\n//test2.js依賴于test1.js\ndefine(function (require,exports,module) {\n    //require('./test1.js');//如果地址是一个模块的话，那么返回值就是模块中的exports.\n    function abcd() {\n        alert(require('./test1.js').a);\n    }\n});\n```\n","source":"_posts/js-seajs.md","raw":"---\ntitle: js模块化开发-sea.js(基础)\ndate: 2015-12-12 10:28:12\ntags: js sea.js 模块化\n---\njs模块化开发能解决的问题：1.冲突2.性能 3.依赖\n使用sea.js解决的步骤：\n- 1.引入sea.js的库\n- 2.如何变成模块-define\n- 3.如何调用模块-exports  -seajs.use\n- 4.如何依赖模块？-require\n一、如何变成模块-define 例：test.js\n```\ndefine(function (require, exports, module) {\n    //參數固定，写法不变\n    //exports:对外的接口\n    function abc() {\n        alert(123);\n    }\n    exports.abc=abc;\n});\n```\n二、如何调用模块-exports  -seajs.use\n    seajs.use:例index页面去调用模块，第一个参数：模块的地址，第二个参数：模块加载成功后的回调函数。\n 注：seajs模块的默认根目录是sea.js的目录。也就是说sea.js库在哪个文件夹下，seajs.use找模块的时候就在那个文件下开始找。\n ```\nseajs.use('sea/test.js',function (ex) {\n    //回调的参数，就是模块中的exports.\n    ex.abc();//当加载成功后，会弹出123\n    abc();  //这样做就很好的避免了命名冲突。\n    function abc() {\n        alert(456);\n    }\n});\n```\n三.如何依赖模块？-require\n例：test1.js  var a=10; test2.js依賴于test1.js,在此即说明test2.js要用到test1.js里定义的变量。test2.js如下：\n```\ndefine(function (require,exports,module) {\n    require('./test1.js');//根据当前文件相对的路径来写，这句相当于 let a=10;\n    function abcd() {\n        alert(a);\n    }\n});\n```\n如果test1.js是一个模块的化：\n```\ndefine(function (require,exports,module) {\n    var a=10;\n    exports.a=a;\n});\n//test2.js依賴于test1.js\ndefine(function (require,exports,module) {\n    //require('./test1.js');//如果地址是一个模块的话，那么返回值就是模块中的exports.\n    function abcd() {\n        alert(require('./test1.js').a);\n    }\n});\n```\n","slug":"js-seajs","published":1,"updated":"2016-12-12T07:38:32.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv8e002ajgtu0hvtafho","content":"<p>js模块化开发能解决的问题：1.冲突2.性能 3.依赖<br>使用sea.js解决的步骤：</p>\n<ul>\n<li>1.引入sea.js的库</li>\n<li>2.如何变成模块-define</li>\n<li>3.如何调用模块-exports  -seajs.use</li>\n<li>4.如何依赖模块？-require<br>一、如何变成模块-define 例：test.js<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(function (require, exports, module) &#123;</div><div class=\"line\">    //參數固定，写法不变</div><div class=\"line\">    //exports:对外的接口</div><div class=\"line\">    function abc() &#123;</div><div class=\"line\">        alert(123);</div><div class=\"line\">    &#125;</div><div class=\"line\">    exports.abc=abc;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>二、如何调用模块-exports  -seajs.use<br>    seajs.use:例index页面去调用模块，第一个参数：模块的地址，第二个参数：模块加载成功后的回调函数。<br> 注：seajs模块的默认根目录是sea.js的目录。也就是说sea.js库在哪个文件夹下，seajs.use找模块的时候就在那个文件下开始找。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">seajs.use(&apos;sea/test.js&apos;,function (ex) &#123;</div><div class=\"line\">    //回调的参数，就是模块中的exports.</div><div class=\"line\">    ex.abc();//当加载成功后，会弹出123</div><div class=\"line\">    abc();  //这样做就很好的避免了命名冲突。</div><div class=\"line\">    function abc() &#123;</div><div class=\"line\">        alert(456);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>三.如何依赖模块？-require<br>例：test1.js  var a=10; test2.js依賴于test1.js,在此即说明test2.js要用到test1.js里定义的变量。test2.js如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(function (require,exports,module) &#123;</div><div class=\"line\">    require(&apos;./test1.js&apos;);//根据当前文件相对的路径来写，这句相当于 let a=10;</div><div class=\"line\">    function abcd() &#123;</div><div class=\"line\">        alert(a);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>如果test1.js是一个模块的化：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(function (require,exports,module) &#123;</div><div class=\"line\">    var a=10;</div><div class=\"line\">    exports.a=a;</div><div class=\"line\">&#125;);</div><div class=\"line\">//test2.js依賴于test1.js</div><div class=\"line\">define(function (require,exports,module) &#123;</div><div class=\"line\">    //require(&apos;./test1.js&apos;);//如果地址是一个模块的话，那么返回值就是模块中的exports.</div><div class=\"line\">    function abcd() &#123;</div><div class=\"line\">        alert(require(&apos;./test1.js&apos;).a);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>js模块化开发能解决的问题：1.冲突2.性能 3.依赖<br>使用sea.js解决的步骤：</p>\n<ul>\n<li>1.引入sea.js的库</li>\n<li>2.如何变成模块-define</li>\n<li>3.如何调用模块-exports  -seajs.use</li>\n<li>4.如何依赖模块？-require<br>一、如何变成模块-define 例：test.js<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(function (require, exports, module) &#123;</div><div class=\"line\">    //參數固定，写法不变</div><div class=\"line\">    //exports:对外的接口</div><div class=\"line\">    function abc() &#123;</div><div class=\"line\">        alert(123);</div><div class=\"line\">    &#125;</div><div class=\"line\">    exports.abc=abc;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>二、如何调用模块-exports  -seajs.use<br>    seajs.use:例index页面去调用模块，第一个参数：模块的地址，第二个参数：模块加载成功后的回调函数。<br> 注：seajs模块的默认根目录是sea.js的目录。也就是说sea.js库在哪个文件夹下，seajs.use找模块的时候就在那个文件下开始找。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">seajs.use(&apos;sea/test.js&apos;,function (ex) &#123;</div><div class=\"line\">    //回调的参数，就是模块中的exports.</div><div class=\"line\">    ex.abc();//当加载成功后，会弹出123</div><div class=\"line\">    abc();  //这样做就很好的避免了命名冲突。</div><div class=\"line\">    function abc() &#123;</div><div class=\"line\">        alert(456);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>三.如何依赖模块？-require<br>例：test1.js  var a=10; test2.js依賴于test1.js,在此即说明test2.js要用到test1.js里定义的变量。test2.js如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(function (require,exports,module) &#123;</div><div class=\"line\">    require(&apos;./test1.js&apos;);//根据当前文件相对的路径来写，这句相当于 let a=10;</div><div class=\"line\">    function abcd() &#123;</div><div class=\"line\">        alert(a);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>如果test1.js是一个模块的化：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(function (require,exports,module) &#123;</div><div class=\"line\">    var a=10;</div><div class=\"line\">    exports.a=a;</div><div class=\"line\">&#125;);</div><div class=\"line\">//test2.js依賴于test1.js</div><div class=\"line\">define(function (require,exports,module) &#123;</div><div class=\"line\">    //require(&apos;./test1.js&apos;);//如果地址是一个模块的话，那么返回值就是模块中的exports.</div><div class=\"line\">    function abcd() &#123;</div><div class=\"line\">        alert(require(&apos;./test1.js&apos;).a);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n"},{"title":"意念如何影响我们的身体，不可思议！","date":"2016-10-14T14:42:19.000Z","_content":"　　美国的戴维·霍金斯博士是一位医生，在美国很有名，他医治了很多来自世界各地的病人。他研究发现：“人的意念振动频率如果在200以上就不生病。”\n\n　　戴维·霍金斯发现，凡是生病的人一般都用负面的意念，他们喜欢抱怨、指责、仇恨别人，不断指责别人过程当中就消减自己很大的能量。这些意念的振动频率低于200。这些人容易得很多不同的疾病。\n　　![意念](http://oi28tswuq.bkt.clouddn.com/images/life-3.png)\n\n#### 没有爱会生病\n\n　　振动频率也就是人们常说的磁场。“很多人生病是因为没有慈悲心、爱心、宽容、柔和等，只有痛苦和沮丧，通常这些病人的振动频率低于200，容易得很多不同的疾病。”\n    ![意念](http://oi28tswuq.bkt.clouddn.com/images/life-2.png)\n\n　　霍金斯博士说：只要看到病人就知道这个人为什么生病，因为从病人身上找不到任何一个和爱相关字，只有痛苦、怨恨、沮丧，包附着他全身。\n\n#### 振动频率高者能带来美好的磁场\n  ![意念](http://oi28tswuq.bkt.clouddn.com/images/life-1.png)\n\n　　研究发现：最高的振动指数是1000，最低的指数是1。目前，在这个世界上，他看到振动频率最高的是700，他的能量特别足，这些人出现的时候，能够影响一个地方的磁场。\n\n　　当一位诺贝尔和平奖得主特瑞萨女士出现在颁奖台上的时候，全场气氛相当好，振动频率很高，她的磁场让全场的人都感受到她的能量，美好和感动充满其中。\n     ![意念](http://oi28tswuq.bkt.clouddn.com/images/life-4.png)\n\n　　当能量很高的人出现时，他的磁场会带动整个万事万物变得美好祥和，而当一个人有很多负面意念的时候，伤害的不仅是他自己，也让周围环境磁场变得不好。\n\n#### 振动频率不同的人有哪些表现\n  ![意念](http://oi28tswuq.bkt.clouddn.com/images/life-5.png)\n\n　　霍金斯博士说他做过百万次案例，在全球调查过不同的人种，答案都是一致的。只要振动频率低于200，这个人就会生病。200以上的就没有病。\n\n　　200以上的意念通常表现是：喜欢关怀别人，慈悲心、爱心、行善、宽容柔和等等，这些都是高的振动频率，达到400到500。\n\n　　相反,喜欢嗔恨、发怒，动不动就指责、怨恨、嫉妒、苛求他人，凡事自私自利，只考虑自己，很少考虑他人感受，这些人的振动频率很低，这些低的振动频率也是导致癌症、心脏病等种种疾病的原因。\n\n　　他从医学的角度告诉人们，意念真的是不可思议，意念对人的健康有很大影响。 \n\n　　可见，积极乐观的心态，多些正面的念头，以及一颗慈爱的心，是健康不可缺少的因素。\n","source":"_posts/life-yinian.md","raw":"---\ntitle: 意念如何影响我们的身体，不可思议！\ndate: 2016-10-14 22:42:19\ntags: life、意念\n---\n　　美国的戴维·霍金斯博士是一位医生，在美国很有名，他医治了很多来自世界各地的病人。他研究发现：“人的意念振动频率如果在200以上就不生病。”\n\n　　戴维·霍金斯发现，凡是生病的人一般都用负面的意念，他们喜欢抱怨、指责、仇恨别人，不断指责别人过程当中就消减自己很大的能量。这些意念的振动频率低于200。这些人容易得很多不同的疾病。\n　　![意念](http://oi28tswuq.bkt.clouddn.com/images/life-3.png)\n\n#### 没有爱会生病\n\n　　振动频率也就是人们常说的磁场。“很多人生病是因为没有慈悲心、爱心、宽容、柔和等，只有痛苦和沮丧，通常这些病人的振动频率低于200，容易得很多不同的疾病。”\n    ![意念](http://oi28tswuq.bkt.clouddn.com/images/life-2.png)\n\n　　霍金斯博士说：只要看到病人就知道这个人为什么生病，因为从病人身上找不到任何一个和爱相关字，只有痛苦、怨恨、沮丧，包附着他全身。\n\n#### 振动频率高者能带来美好的磁场\n  ![意念](http://oi28tswuq.bkt.clouddn.com/images/life-1.png)\n\n　　研究发现：最高的振动指数是1000，最低的指数是1。目前，在这个世界上，他看到振动频率最高的是700，他的能量特别足，这些人出现的时候，能够影响一个地方的磁场。\n\n　　当一位诺贝尔和平奖得主特瑞萨女士出现在颁奖台上的时候，全场气氛相当好，振动频率很高，她的磁场让全场的人都感受到她的能量，美好和感动充满其中。\n     ![意念](http://oi28tswuq.bkt.clouddn.com/images/life-4.png)\n\n　　当能量很高的人出现时，他的磁场会带动整个万事万物变得美好祥和，而当一个人有很多负面意念的时候，伤害的不仅是他自己，也让周围环境磁场变得不好。\n\n#### 振动频率不同的人有哪些表现\n  ![意念](http://oi28tswuq.bkt.clouddn.com/images/life-5.png)\n\n　　霍金斯博士说他做过百万次案例，在全球调查过不同的人种，答案都是一致的。只要振动频率低于200，这个人就会生病。200以上的就没有病。\n\n　　200以上的意念通常表现是：喜欢关怀别人，慈悲心、爱心、行善、宽容柔和等等，这些都是高的振动频率，达到400到500。\n\n　　相反,喜欢嗔恨、发怒，动不动就指责、怨恨、嫉妒、苛求他人，凡事自私自利，只考虑自己，很少考虑他人感受，这些人的振动频率很低，这些低的振动频率也是导致癌症、心脏病等种种疾病的原因。\n\n　　他从医学的角度告诉人们，意念真的是不可思议，意念对人的健康有很大影响。 \n\n　　可见，积极乐观的心态，多些正面的念头，以及一颗慈爱的心，是健康不可缺少的因素。\n","slug":"life-yinian","published":1,"updated":"2016-12-14T15:03:06.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv8g002cjgtu9cpp3soj","content":"<p>　　美国的戴维·霍金斯博士是一位医生，在美国很有名，他医治了很多来自世界各地的病人。他研究发现：“人的意念振动频率如果在200以上就不生病。”</p>\n<p>　　戴维·霍金斯发现，凡是生病的人一般都用负面的意念，他们喜欢抱怨、指责、仇恨别人，不断指责别人过程当中就消减自己很大的能量。这些意念的振动频率低于200。这些人容易得很多不同的疾病。<br>　　<img src=\"http://oi28tswuq.bkt.clouddn.com/images/life-3.png\" alt=\"意念\"></p>\n<h4 id=\"没有爱会生病\"><a href=\"#没有爱会生病\" class=\"headerlink\" title=\"没有爱会生病\"></a>没有爱会生病</h4><p>　　振动频率也就是人们常说的磁场。“很多人生病是因为没有慈悲心、爱心、宽容、柔和等，只有痛苦和沮丧，通常这些病人的振动频率低于200，容易得很多不同的疾病。”<br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/life-2.png\" alt=\"意念\"></p>\n<p>　　霍金斯博士说：只要看到病人就知道这个人为什么生病，因为从病人身上找不到任何一个和爱相关字，只有痛苦、怨恨、沮丧，包附着他全身。</p>\n<h4 id=\"振动频率高者能带来美好的磁场\"><a href=\"#振动频率高者能带来美好的磁场\" class=\"headerlink\" title=\"振动频率高者能带来美好的磁场\"></a>振动频率高者能带来美好的磁场</h4><p>  <img src=\"http://oi28tswuq.bkt.clouddn.com/images/life-1.png\" alt=\"意念\"></p>\n<p>　　研究发现：最高的振动指数是1000，最低的指数是1。目前，在这个世界上，他看到振动频率最高的是700，他的能量特别足，这些人出现的时候，能够影响一个地方的磁场。</p>\n<p>　　当一位诺贝尔和平奖得主特瑞萨女士出现在颁奖台上的时候，全场气氛相当好，振动频率很高，她的磁场让全场的人都感受到她的能量，美好和感动充满其中。<br>     <img src=\"http://oi28tswuq.bkt.clouddn.com/images/life-4.png\" alt=\"意念\"></p>\n<p>　　当能量很高的人出现时，他的磁场会带动整个万事万物变得美好祥和，而当一个人有很多负面意念的时候，伤害的不仅是他自己，也让周围环境磁场变得不好。</p>\n<h4 id=\"振动频率不同的人有哪些表现\"><a href=\"#振动频率不同的人有哪些表现\" class=\"headerlink\" title=\"振动频率不同的人有哪些表现\"></a>振动频率不同的人有哪些表现</h4><p>  <img src=\"http://oi28tswuq.bkt.clouddn.com/images/life-5.png\" alt=\"意念\"></p>\n<p>　　霍金斯博士说他做过百万次案例，在全球调查过不同的人种，答案都是一致的。只要振动频率低于200，这个人就会生病。200以上的就没有病。</p>\n<p>　　200以上的意念通常表现是：喜欢关怀别人，慈悲心、爱心、行善、宽容柔和等等，这些都是高的振动频率，达到400到500。</p>\n<p>　　相反,喜欢嗔恨、发怒，动不动就指责、怨恨、嫉妒、苛求他人，凡事自私自利，只考虑自己，很少考虑他人感受，这些人的振动频率很低，这些低的振动频率也是导致癌症、心脏病等种种疾病的原因。</p>\n<p>　　他从医学的角度告诉人们，意念真的是不可思议，意念对人的健康有很大影响。 </p>\n<p>　　可见，积极乐观的心态，多些正面的念头，以及一颗慈爱的心，是健康不可缺少的因素。</p>\n","excerpt":"","more":"<p>　　美国的戴维·霍金斯博士是一位医生，在美国很有名，他医治了很多来自世界各地的病人。他研究发现：“人的意念振动频率如果在200以上就不生病。”</p>\n<p>　　戴维·霍金斯发现，凡是生病的人一般都用负面的意念，他们喜欢抱怨、指责、仇恨别人，不断指责别人过程当中就消减自己很大的能量。这些意念的振动频率低于200。这些人容易得很多不同的疾病。<br>　　<img src=\"http://oi28tswuq.bkt.clouddn.com/images/life-3.png\" alt=\"意念\"></p>\n<h4 id=\"没有爱会生病\"><a href=\"#没有爱会生病\" class=\"headerlink\" title=\"没有爱会生病\"></a>没有爱会生病</h4><p>　　振动频率也就是人们常说的磁场。“很多人生病是因为没有慈悲心、爱心、宽容、柔和等，只有痛苦和沮丧，通常这些病人的振动频率低于200，容易得很多不同的疾病。”<br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/life-2.png\" alt=\"意念\"></p>\n<p>　　霍金斯博士说：只要看到病人就知道这个人为什么生病，因为从病人身上找不到任何一个和爱相关字，只有痛苦、怨恨、沮丧，包附着他全身。</p>\n<h4 id=\"振动频率高者能带来美好的磁场\"><a href=\"#振动频率高者能带来美好的磁场\" class=\"headerlink\" title=\"振动频率高者能带来美好的磁场\"></a>振动频率高者能带来美好的磁场</h4><p>  <img src=\"http://oi28tswuq.bkt.clouddn.com/images/life-1.png\" alt=\"意念\"></p>\n<p>　　研究发现：最高的振动指数是1000，最低的指数是1。目前，在这个世界上，他看到振动频率最高的是700，他的能量特别足，这些人出现的时候，能够影响一个地方的磁场。</p>\n<p>　　当一位诺贝尔和平奖得主特瑞萨女士出现在颁奖台上的时候，全场气氛相当好，振动频率很高，她的磁场让全场的人都感受到她的能量，美好和感动充满其中。<br>     <img src=\"http://oi28tswuq.bkt.clouddn.com/images/life-4.png\" alt=\"意念\"></p>\n<p>　　当能量很高的人出现时，他的磁场会带动整个万事万物变得美好祥和，而当一个人有很多负面意念的时候，伤害的不仅是他自己，也让周围环境磁场变得不好。</p>\n<h4 id=\"振动频率不同的人有哪些表现\"><a href=\"#振动频率不同的人有哪些表现\" class=\"headerlink\" title=\"振动频率不同的人有哪些表现\"></a>振动频率不同的人有哪些表现</h4><p>  <img src=\"http://oi28tswuq.bkt.clouddn.com/images/life-5.png\" alt=\"意念\"></p>\n<p>　　霍金斯博士说他做过百万次案例，在全球调查过不同的人种，答案都是一致的。只要振动频率低于200，这个人就会生病。200以上的就没有病。</p>\n<p>　　200以上的意念通常表现是：喜欢关怀别人，慈悲心、爱心、行善、宽容柔和等等，这些都是高的振动频率，达到400到500。</p>\n<p>　　相反,喜欢嗔恨、发怒，动不动就指责、怨恨、嫉妒、苛求他人，凡事自私自利，只考虑自己，很少考虑他人感受，这些人的振动频率很低，这些低的振动频率也是导致癌症、心脏病等种种疾病的原因。</p>\n<p>　　他从医学的角度告诉人们，意念真的是不可思议，意念对人的健康有很大影响。 </p>\n<p>　　可见，积极乐观的心态，多些正面的念头，以及一颗慈爱的心，是健康不可缺少的因素。</p>\n"},{"title":"了解下框架模式 -MVP","date":"2016-12-16T01:43:15.000Z","_content":"#### M-V-P:(模型，视图，派发器)\n　　mvc的弊端：View 和 Model 并不是完全脱离的，还是有一些逻辑耦合，因为需要根据修改后的model从新刷新view。 难免view里面沾染一点model的结构。不方便进行更精细的颗粒化控制。(因为view只知道 model被改了，但不知道谁改的!)，model在对应多个view的时候，很难都伺候到位。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/mvp.png-public)\n</div>\n\n　　针对mvc的一些问题，在mvp模式下， 斩断了 view 与 model的关系， 当m 改变时，m 通知 p 去改变v， 所以v变得更纯洁(刷新逻辑被移动到了p层)， 为了保证m可以最大程度的复用 一部分业务逻辑也从 m 转移到了p所以 mvp下 p 非常厚实。\n  \n  　mvp中最后改变v的是p那么在 v与p 之间会有一个接口，解决怎么转换以及传值的问题。","source":"_posts/mvp.md","raw":"---\ntitle: 了解下框架模式 -MVP\ndate: 2016-12-16 09:43:15\ntags: mvp\n---\n#### M-V-P:(模型，视图，派发器)\n　　mvc的弊端：View 和 Model 并不是完全脱离的，还是有一些逻辑耦合，因为需要根据修改后的model从新刷新view。 难免view里面沾染一点model的结构。不方便进行更精细的颗粒化控制。(因为view只知道 model被改了，但不知道谁改的!)，model在对应多个view的时候，很难都伺候到位。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/mvp.png-public)\n</div>\n\n　　针对mvc的一些问题，在mvp模式下， 斩断了 view 与 model的关系， 当m 改变时，m 通知 p 去改变v， 所以v变得更纯洁(刷新逻辑被移动到了p层)， 为了保证m可以最大程度的复用 一部分业务逻辑也从 m 转移到了p所以 mvp下 p 非常厚实。\n  \n  　mvp中最后改变v的是p那么在 v与p 之间会有一个接口，解决怎么转换以及传值的问题。","slug":"mvp","published":1,"updated":"2017-01-10T08:20:58.824Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv8j002ejgtuer7h8clz","content":"<h4 id=\"M-V-P-模型，视图，派发器\"><a href=\"#M-V-P-模型，视图，派发器\" class=\"headerlink\" title=\"M-V-P:(模型，视图，派发器)\"></a>M-V-P:(模型，视图，派发器)</h4><p>　　mvc的弊端：View 和 Model 并不是完全脱离的，还是有一些逻辑耦合，因为需要根据修改后的model从新刷新view。 难免view里面沾染一点model的结构。不方便进行更精细的颗粒化控制。(因为view只知道 model被改了，但不知道谁改的!)，model在对应多个view的时候，很难都伺候到位。</p>\n<div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/mvp.png-public\" alt=\"\"><br></div>\n\n<p>　　针对mvc的一些问题，在mvp模式下， 斩断了 view 与 model的关系， 当m 改变时，m 通知 p 去改变v， 所以v变得更纯洁(刷新逻辑被移动到了p层)， 为了保证m可以最大程度的复用 一部分业务逻辑也从 m 转移到了p所以 mvp下 p 非常厚实。</p>\n<p>  　mvp中最后改变v的是p那么在 v与p 之间会有一个接口，解决怎么转换以及传值的问题。</p>\n","excerpt":"","more":"<h4 id=\"M-V-P-模型，视图，派发器\"><a href=\"#M-V-P-模型，视图，派发器\" class=\"headerlink\" title=\"M-V-P:(模型，视图，派发器)\"></a>M-V-P:(模型，视图，派发器)</h4><p>　　mvc的弊端：View 和 Model 并不是完全脱离的，还是有一些逻辑耦合，因为需要根据修改后的model从新刷新view。 难免view里面沾染一点model的结构。不方便进行更精细的颗粒化控制。(因为view只知道 model被改了，但不知道谁改的!)，model在对应多个view的时候，很难都伺候到位。</p>\n<div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/mvp.png-public\" alt=\"\"><br></div>\n\n<p>　　针对mvc的一些问题，在mvp模式下， 斩断了 view 与 model的关系， 当m 改变时，m 通知 p 去改变v， 所以v变得更纯洁(刷新逻辑被移动到了p层)， 为了保证m可以最大程度的复用 一部分业务逻辑也从 m 转移到了p所以 mvp下 p 非常厚实。</p>\n<p>  　mvp中最后改变v的是p那么在 v与p 之间会有一个接口，解决怎么转换以及传值的问题。</p>\n"},{"title":"debug模块介绍","date":"2017-01-05T02:44:37.000Z","_content":"一般在nodejs需要进行调试的时候，可以使用console.log()方法来将调试信息输出到控制台，当发布到生产环境的时候，需要将这些调试信息都注释掉，为了方便切换而不需要改动程序代码，可以使用nodejs的debug模块;\ngsb常用调试语句如下：\n```\nset DEBUG=gsb:* && set CMS_HOST=w2&& node app.js --harmony\n```\ndebug调试打印的是开发者自己在 控制台 打印的信息，它的目的是要代替 console.log()。\n特点：1.可以设置打印的信息来自哪个哪个模块：控制台输出的蓝色字体就是表示来自app模块（自己写的模块名）。 2.在发布到外网的情况下，可以用发布模式，这时 debug里打印信息将不会在显示。\n\n```\nvar debug = require('debug')('myapp:main');\ndebug('现在的时间是 %s' , new Date());\n```\n如果是开发环境，只需要设置环境变量\n```\nD:\\nodej\\workspace\\spider\\set debug=myapp:*\n```\n此后再控制台执行node app.js即可输出调试信息了\n如果需要关闭调试信息\n```\nD:\\nodej\\workspace\\spider\\set debug=null\n```\n具体的使用方法可以参考[debug模块](http://npmjs.org/package/debug)的主页 http://npmjs.org/package/debug\n\n","source":"_posts/node-debug.md","raw":"---\ntitle: debug模块介绍\ndate: 2017-01-05 10:44:37\ntags: node debug\n---\n一般在nodejs需要进行调试的时候，可以使用console.log()方法来将调试信息输出到控制台，当发布到生产环境的时候，需要将这些调试信息都注释掉，为了方便切换而不需要改动程序代码，可以使用nodejs的debug模块;\ngsb常用调试语句如下：\n```\nset DEBUG=gsb:* && set CMS_HOST=w2&& node app.js --harmony\n```\ndebug调试打印的是开发者自己在 控制台 打印的信息，它的目的是要代替 console.log()。\n特点：1.可以设置打印的信息来自哪个哪个模块：控制台输出的蓝色字体就是表示来自app模块（自己写的模块名）。 2.在发布到外网的情况下，可以用发布模式，这时 debug里打印信息将不会在显示。\n\n```\nvar debug = require('debug')('myapp:main');\ndebug('现在的时间是 %s' , new Date());\n```\n如果是开发环境，只需要设置环境变量\n```\nD:\\nodej\\workspace\\spider\\set debug=myapp:*\n```\n此后再控制台执行node app.js即可输出调试信息了\n如果需要关闭调试信息\n```\nD:\\nodej\\workspace\\spider\\set debug=null\n```\n具体的使用方法可以参考[debug模块](http://npmjs.org/package/debug)的主页 http://npmjs.org/package/debug\n\n","slug":"node-debug","published":1,"updated":"2017-01-05T03:04:05.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv8l002gjgtu8i1xkvqh","content":"<p>一般在nodejs需要进行调试的时候，可以使用console.log()方法来将调试信息输出到控制台，当发布到生产环境的时候，需要将这些调试信息都注释掉，为了方便切换而不需要改动程序代码，可以使用nodejs的debug模块;<br>gsb常用调试语句如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">set DEBUG=gsb:* &amp;&amp; set CMS_HOST=w2&amp;&amp; node app.js --harmony</div></pre></td></tr></table></figure></p>\n<p>debug调试打印的是开发者自己在 控制台 打印的信息，它的目的是要代替 console.log()。<br>特点：1.可以设置打印的信息来自哪个哪个模块：控制台输出的蓝色字体就是表示来自app模块（自己写的模块名）。 2.在发布到外网的情况下，可以用发布模式，这时 debug里打印信息将不会在显示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var debug = require(&apos;debug&apos;)(&apos;myapp:main&apos;);</div><div class=\"line\">debug(&apos;现在的时间是 %s&apos; , new Date());</div></pre></td></tr></table></figure>\n<p>如果是开发环境，只需要设置环境变量<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">D:\\nodej\\workspace\\spider\\set debug=myapp:*</div></pre></td></tr></table></figure></p>\n<p>此后再控制台执行node app.js即可输出调试信息了<br>如果需要关闭调试信息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">D:\\nodej\\workspace\\spider\\set debug=null</div></pre></td></tr></table></figure></p>\n<p>具体的使用方法可以参考<a href=\"http://npmjs.org/package/debug\" target=\"_blank\" rel=\"external\">debug模块</a>的主页 <a href=\"http://npmjs.org/package/debug\" target=\"_blank\" rel=\"external\">http://npmjs.org/package/debug</a></p>\n","excerpt":"","more":"<p>一般在nodejs需要进行调试的时候，可以使用console.log()方法来将调试信息输出到控制台，当发布到生产环境的时候，需要将这些调试信息都注释掉，为了方便切换而不需要改动程序代码，可以使用nodejs的debug模块;<br>gsb常用调试语句如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">set DEBUG=gsb:* &amp;&amp; set CMS_HOST=w2&amp;&amp; node app.js --harmony</div></pre></td></tr></table></figure></p>\n<p>debug调试打印的是开发者自己在 控制台 打印的信息，它的目的是要代替 console.log()。<br>特点：1.可以设置打印的信息来自哪个哪个模块：控制台输出的蓝色字体就是表示来自app模块（自己写的模块名）。 2.在发布到外网的情况下，可以用发布模式，这时 debug里打印信息将不会在显示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var debug = require(&apos;debug&apos;)(&apos;myapp:main&apos;);</div><div class=\"line\">debug(&apos;现在的时间是 %s&apos; , new Date());</div></pre></td></tr></table></figure>\n<p>如果是开发环境，只需要设置环境变量<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">D:\\nodej\\workspace\\spider\\set debug=myapp:*</div></pre></td></tr></table></figure></p>\n<p>此后再控制台执行node app.js即可输出调试信息了<br>如果需要关闭调试信息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">D:\\nodej\\workspace\\spider\\set debug=null</div></pre></td></tr></table></figure></p>\n<p>具体的使用方法可以参考<a href=\"http://npmjs.org/package/debug\">debug模块</a>的主页 <a href=\"http://npmjs.org/package/debug\">http://npmjs.org/package/debug</a></p>\n"},{"title":"node一些小知识点积累","date":"2016-08-15T14:10:58.000Z","_content":"#### nodemon\n每次我们对app.js文件作修改，都需要停止服务器并且重启。在开发过程中，这个过程太麻烦了，所以我们建议不使用node.js，而是使用nodemon服务器。要安装nodemon，需再次使用npm：\n$ npm install --save-dev nodemon\n$ nodemon app.js\n每次对app.js文件作修改并且保存时， nodemon会自动重启Node应用。\n#### npm install –d\n-d标志告诉npm把依赖项安装在本地。这个语法十分明确：可以丢开这个-d，因为它被设置为默认将依赖项安装到本地。\n","source":"_posts/node-tips.md","raw":"---\ntitle: node一些小知识点积累\ndate: 2016-8-15 22:10:58\ntags: node\n---\n#### nodemon\n每次我们对app.js文件作修改，都需要停止服务器并且重启。在开发过程中，这个过程太麻烦了，所以我们建议不使用node.js，而是使用nodemon服务器。要安装nodemon，需再次使用npm：\n$ npm install --save-dev nodemon\n$ nodemon app.js\n每次对app.js文件作修改并且保存时， nodemon会自动重启Node应用。\n#### npm install –d\n-d标志告诉npm把依赖项安装在本地。这个语法十分明确：可以丢开这个-d，因为它被设置为默认将依赖项安装到本地。\n","slug":"node-tips","published":1,"updated":"2016-12-22T01:47:35.953Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv8n002ijgtujwugqkx2","content":"<h4 id=\"nodemon\"><a href=\"#nodemon\" class=\"headerlink\" title=\"nodemon\"></a>nodemon</h4><p>每次我们对app.js文件作修改，都需要停止服务器并且重启。在开发过程中，这个过程太麻烦了，所以我们建议不使用node.js，而是使用nodemon服务器。要安装nodemon，需再次使用npm：<br>$ npm install –save-dev nodemon<br>$ nodemon app.js<br>每次对app.js文件作修改并且保存时， nodemon会自动重启Node应用。</p>\n<h4 id=\"npm-install-–d\"><a href=\"#npm-install-–d\" class=\"headerlink\" title=\"npm install –d\"></a>npm install –d</h4><p>-d标志告诉npm把依赖项安装在本地。这个语法十分明确：可以丢开这个-d，因为它被设置为默认将依赖项安装到本地。</p>\n","excerpt":"","more":"<h4 id=\"nodemon\"><a href=\"#nodemon\" class=\"headerlink\" title=\"nodemon\"></a>nodemon</h4><p>每次我们对app.js文件作修改，都需要停止服务器并且重启。在开发过程中，这个过程太麻烦了，所以我们建议不使用node.js，而是使用nodemon服务器。要安装nodemon，需再次使用npm：<br>$ npm install –save-dev nodemon<br>$ nodemon app.js<br>每次对app.js文件作修改并且保存时， nodemon会自动重启Node应用。</p>\n<h4 id=\"npm-install-–d\"><a href=\"#npm-install-–d\" class=\"headerlink\" title=\"npm install –d\"></a>npm install –d</h4><p>-d标志告诉npm把依赖项安装在本地。这个语法十分明确：可以丢开这个-d，因为它被设置为默认将依赖项安装到本地。</p>\n"},{"title":"node 中的一些坑","date":"2016-10-23T15:06:26.000Z","_content":"### 核心模块\n\nrequire\n\nnode中通过require引入模块的机制为将需要的模块对应的js文件引入后执行一遍，因此在自己写的依赖模块中尽量不要无故输出信息，否则会使控制台十分混乱。\n\n### fs\n\nfs模块中的所有方法在指定路径时都必须为绝对路径或是完整的相对路径（即包含../、./、/的相对路径）。\n\nfs.mkdir/mkdirSync\n\nAPI\n```\nfs.mkdir(path, callback)\n```\n创建文件夹操作，支持文件夹嵌套，例如fs.mkdir('./a/b/c'),回调函数中的参数为Error信息，只有发生错误的时候才会存在，创建成功则为null。\n\nmkdir操作的路径如果有文件夹嵌套，则当上级路径不存在时，不能直接创建。例如当前文件夹下没有a文件夹，则fs.mkdir('./a/b')不能直接创建a和a/b文件夹。\n为了减少代码的重复量，可使用下面的函数来对mkdir操作进行封装。\n```\nlet path = require('path'),\n    fs = require('fs');\nfunction mkdir(p,fn){\n    fs.exists(p, function (flag) { // 判断当前路径下的文件夹是否已经存在\n        if(flag){ // 如果当前文件夹已经存在则执行回调函数\n            return fn();\n        }\n        // 如果当前文件夹不存在，则将当前文件夹的上级目录作为新的参数p，创建当前文件夹的操作放入回调函数，递归调用mkdir函数\n        mkdir(path.dirname(p), function () {\n            fs.mkdir(p,fn);\n        });\n    });\n}\n```\n这里用到了path模块的dirname方法，这个方法的作用是获取一个路径的上级路径。\n\nfs.readFile/readFileSync\n\n读取文件操作，在使用同步方法readFileSync时函数直接返回读到的数据，如果发生错误则返回错误的信息。\n\n但是异步方法readFile在callback中的参数却是error和data，即不管是否成功第一个参数都是error，第二个参数才是读到的数据。\n\n在node中应尽量用stream来代替文件的直接读写操作。\n\n### 请求与响应\n\n#### 跨域请求\n\n- cors\n\n如果需要采用cors来支持跨域请求，则需要对响应头进行如下设置（完整版）\n```\nres.writeHead(200, {\n    \"Access-Control-Allow-Origin\": \"*\",\n    \"Access-Control-Allow-Methods\": \"GET, POST, PUT, DELETE, OPTIONS\",\n    \"Access-Control-Allow-Headers\": \"Content-Type, accept\"\n});\n```\n另外，跨域时尽量对请求方法和请求路径都进行验证（RESTful），因为某些客户端框架（ionic）在发送跨域请求时，会先发送一个option方法的请求来尝试跨域请求是否成功，在成功之后才会发送原本的请求。\n\n- cookie\n\n一般在node中设置cookies都会使用基于express的第三方包cookie-parser。不使用第三方包的原生写法为\n```\nres.setHeader(\"Set-Cookie\", [...cookies])\n```\n其中cookies的格式为key=value; option，注意;后的空格。\n\noption的参数中max-age=time表示cookie的过期时间，其中time的为number，单位是秒。\n\n获取客户端传递的cookies的方法为\n```\nreq.headers.cookie\n```\n如果使用express和cookie-parser，则关于cookie的方法都会被集成在request和response上，设置cookie的方法为\n```\nres.cookie(key, value, option)\n```\n注意这里的option中的max-age单位变为了毫秒，其他则没有变化。\n\n获取客户端传递的cookies的方法为\n```\nreq.cookies\n```\n获取的cookies为对象形式。\n\nIDE没有提示功能或者提示功能不全的朋友请注意上文中的cookie和cookies并熟练记住。\n","source":"_posts/nodekeng.md","raw":"---\ntitle: node 中的一些坑\ndate: 2016-10-23 23:06:26\ntags: node\n---\n### 核心模块\n\nrequire\n\nnode中通过require引入模块的机制为将需要的模块对应的js文件引入后执行一遍，因此在自己写的依赖模块中尽量不要无故输出信息，否则会使控制台十分混乱。\n\n### fs\n\nfs模块中的所有方法在指定路径时都必须为绝对路径或是完整的相对路径（即包含../、./、/的相对路径）。\n\nfs.mkdir/mkdirSync\n\nAPI\n```\nfs.mkdir(path, callback)\n```\n创建文件夹操作，支持文件夹嵌套，例如fs.mkdir('./a/b/c'),回调函数中的参数为Error信息，只有发生错误的时候才会存在，创建成功则为null。\n\nmkdir操作的路径如果有文件夹嵌套，则当上级路径不存在时，不能直接创建。例如当前文件夹下没有a文件夹，则fs.mkdir('./a/b')不能直接创建a和a/b文件夹。\n为了减少代码的重复量，可使用下面的函数来对mkdir操作进行封装。\n```\nlet path = require('path'),\n    fs = require('fs');\nfunction mkdir(p,fn){\n    fs.exists(p, function (flag) { // 判断当前路径下的文件夹是否已经存在\n        if(flag){ // 如果当前文件夹已经存在则执行回调函数\n            return fn();\n        }\n        // 如果当前文件夹不存在，则将当前文件夹的上级目录作为新的参数p，创建当前文件夹的操作放入回调函数，递归调用mkdir函数\n        mkdir(path.dirname(p), function () {\n            fs.mkdir(p,fn);\n        });\n    });\n}\n```\n这里用到了path模块的dirname方法，这个方法的作用是获取一个路径的上级路径。\n\nfs.readFile/readFileSync\n\n读取文件操作，在使用同步方法readFileSync时函数直接返回读到的数据，如果发生错误则返回错误的信息。\n\n但是异步方法readFile在callback中的参数却是error和data，即不管是否成功第一个参数都是error，第二个参数才是读到的数据。\n\n在node中应尽量用stream来代替文件的直接读写操作。\n\n### 请求与响应\n\n#### 跨域请求\n\n- cors\n\n如果需要采用cors来支持跨域请求，则需要对响应头进行如下设置（完整版）\n```\nres.writeHead(200, {\n    \"Access-Control-Allow-Origin\": \"*\",\n    \"Access-Control-Allow-Methods\": \"GET, POST, PUT, DELETE, OPTIONS\",\n    \"Access-Control-Allow-Headers\": \"Content-Type, accept\"\n});\n```\n另外，跨域时尽量对请求方法和请求路径都进行验证（RESTful），因为某些客户端框架（ionic）在发送跨域请求时，会先发送一个option方法的请求来尝试跨域请求是否成功，在成功之后才会发送原本的请求。\n\n- cookie\n\n一般在node中设置cookies都会使用基于express的第三方包cookie-parser。不使用第三方包的原生写法为\n```\nres.setHeader(\"Set-Cookie\", [...cookies])\n```\n其中cookies的格式为key=value; option，注意;后的空格。\n\noption的参数中max-age=time表示cookie的过期时间，其中time的为number，单位是秒。\n\n获取客户端传递的cookies的方法为\n```\nreq.headers.cookie\n```\n如果使用express和cookie-parser，则关于cookie的方法都会被集成在request和response上，设置cookie的方法为\n```\nres.cookie(key, value, option)\n```\n注意这里的option中的max-age单位变为了毫秒，其他则没有变化。\n\n获取客户端传递的cookies的方法为\n```\nreq.cookies\n```\n获取的cookies为对象形式。\n\nIDE没有提示功能或者提示功能不全的朋友请注意上文中的cookie和cookies并熟练记住。\n","slug":"nodekeng","published":1,"updated":"2016-12-12T08:44:45.640Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv8p002kjgtubwv8ft7n","content":"<h3 id=\"核心模块\"><a href=\"#核心模块\" class=\"headerlink\" title=\"核心模块\"></a>核心模块</h3><p>require</p>\n<p>node中通过require引入模块的机制为将需要的模块对应的js文件引入后执行一遍，因此在自己写的依赖模块中尽量不要无故输出信息，否则会使控制台十分混乱。</p>\n<h3 id=\"fs\"><a href=\"#fs\" class=\"headerlink\" title=\"fs\"></a>fs</h3><p>fs模块中的所有方法在指定路径时都必须为绝对路径或是完整的相对路径（即包含../、./、/的相对路径）。</p>\n<p>fs.mkdir/mkdirSync</p>\n<p>API<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">fs.mkdir(path, callback)</div></pre></td></tr></table></figure></p>\n<p>创建文件夹操作，支持文件夹嵌套，例如fs.mkdir(‘./a/b/c’),回调函数中的参数为Error信息，只有发生错误的时候才会存在，创建成功则为null。</p>\n<p>mkdir操作的路径如果有文件夹嵌套，则当上级路径不存在时，不能直接创建。例如当前文件夹下没有a文件夹，则fs.mkdir(‘./a/b’)不能直接创建a和a/b文件夹。<br>为了减少代码的重复量，可使用下面的函数来对mkdir操作进行封装。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">let path = require(&apos;path&apos;),</div><div class=\"line\">    fs = require(&apos;fs&apos;);</div><div class=\"line\">function mkdir(p,fn)&#123;</div><div class=\"line\">    fs.exists(p, function (flag) &#123; // 判断当前路径下的文件夹是否已经存在</div><div class=\"line\">        if(flag)&#123; // 如果当前文件夹已经存在则执行回调函数</div><div class=\"line\">            return fn();</div><div class=\"line\">        &#125;</div><div class=\"line\">        // 如果当前文件夹不存在，则将当前文件夹的上级目录作为新的参数p，创建当前文件夹的操作放入回调函数，递归调用mkdir函数</div><div class=\"line\">        mkdir(path.dirname(p), function () &#123;</div><div class=\"line\">            fs.mkdir(p,fn);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里用到了path模块的dirname方法，这个方法的作用是获取一个路径的上级路径。</p>\n<p>fs.readFile/readFileSync</p>\n<p>读取文件操作，在使用同步方法readFileSync时函数直接返回读到的数据，如果发生错误则返回错误的信息。</p>\n<p>但是异步方法readFile在callback中的参数却是error和data，即不管是否成功第一个参数都是error，第二个参数才是读到的数据。</p>\n<p>在node中应尽量用stream来代替文件的直接读写操作。</p>\n<h3 id=\"请求与响应\"><a href=\"#请求与响应\" class=\"headerlink\" title=\"请求与响应\"></a>请求与响应</h3><h4 id=\"跨域请求\"><a href=\"#跨域请求\" class=\"headerlink\" title=\"跨域请求\"></a>跨域请求</h4><ul>\n<li>cors</li>\n</ul>\n<p>如果需要采用cors来支持跨域请求，则需要对响应头进行如下设置（完整版）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">res.writeHead(200, &#123;</div><div class=\"line\">    &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;,</div><div class=\"line\">    &quot;Access-Control-Allow-Methods&quot;: &quot;GET, POST, PUT, DELETE, OPTIONS&quot;,</div><div class=\"line\">    &quot;Access-Control-Allow-Headers&quot;: &quot;Content-Type, accept&quot;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>另外，跨域时尽量对请求方法和请求路径都进行验证（RESTful），因为某些客户端框架（ionic）在发送跨域请求时，会先发送一个option方法的请求来尝试跨域请求是否成功，在成功之后才会发送原本的请求。</p>\n<ul>\n<li>cookie</li>\n</ul>\n<p>一般在node中设置cookies都会使用基于express的第三方包cookie-parser。不使用第三方包的原生写法为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">res.setHeader(&quot;Set-Cookie&quot;, [...cookies])</div></pre></td></tr></table></figure></p>\n<p>其中cookies的格式为key=value; option，注意;后的空格。</p>\n<p>option的参数中max-age=time表示cookie的过期时间，其中time的为number，单位是秒。</p>\n<p>获取客户端传递的cookies的方法为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">req.headers.cookie</div></pre></td></tr></table></figure></p>\n<p>如果使用express和cookie-parser，则关于cookie的方法都会被集成在request和response上，设置cookie的方法为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">res.cookie(key, value, option)</div></pre></td></tr></table></figure></p>\n<p>注意这里的option中的max-age单位变为了毫秒，其他则没有变化。</p>\n<p>获取客户端传递的cookies的方法为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">req.cookies</div></pre></td></tr></table></figure></p>\n<p>获取的cookies为对象形式。</p>\n<p>IDE没有提示功能或者提示功能不全的朋友请注意上文中的cookie和cookies并熟练记住。</p>\n","excerpt":"","more":"<h3 id=\"核心模块\"><a href=\"#核心模块\" class=\"headerlink\" title=\"核心模块\"></a>核心模块</h3><p>require</p>\n<p>node中通过require引入模块的机制为将需要的模块对应的js文件引入后执行一遍，因此在自己写的依赖模块中尽量不要无故输出信息，否则会使控制台十分混乱。</p>\n<h3 id=\"fs\"><a href=\"#fs\" class=\"headerlink\" title=\"fs\"></a>fs</h3><p>fs模块中的所有方法在指定路径时都必须为绝对路径或是完整的相对路径（即包含../、./、/的相对路径）。</p>\n<p>fs.mkdir/mkdirSync</p>\n<p>API<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">fs.mkdir(path, callback)</div></pre></td></tr></table></figure></p>\n<p>创建文件夹操作，支持文件夹嵌套，例如fs.mkdir(‘./a/b/c’),回调函数中的参数为Error信息，只有发生错误的时候才会存在，创建成功则为null。</p>\n<p>mkdir操作的路径如果有文件夹嵌套，则当上级路径不存在时，不能直接创建。例如当前文件夹下没有a文件夹，则fs.mkdir(‘./a/b’)不能直接创建a和a/b文件夹。<br>为了减少代码的重复量，可使用下面的函数来对mkdir操作进行封装。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">let path = require(&apos;path&apos;),</div><div class=\"line\">    fs = require(&apos;fs&apos;);</div><div class=\"line\">function mkdir(p,fn)&#123;</div><div class=\"line\">    fs.exists(p, function (flag) &#123; // 判断当前路径下的文件夹是否已经存在</div><div class=\"line\">        if(flag)&#123; // 如果当前文件夹已经存在则执行回调函数</div><div class=\"line\">            return fn();</div><div class=\"line\">        &#125;</div><div class=\"line\">        // 如果当前文件夹不存在，则将当前文件夹的上级目录作为新的参数p，创建当前文件夹的操作放入回调函数，递归调用mkdir函数</div><div class=\"line\">        mkdir(path.dirname(p), function () &#123;</div><div class=\"line\">            fs.mkdir(p,fn);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里用到了path模块的dirname方法，这个方法的作用是获取一个路径的上级路径。</p>\n<p>fs.readFile/readFileSync</p>\n<p>读取文件操作，在使用同步方法readFileSync时函数直接返回读到的数据，如果发生错误则返回错误的信息。</p>\n<p>但是异步方法readFile在callback中的参数却是error和data，即不管是否成功第一个参数都是error，第二个参数才是读到的数据。</p>\n<p>在node中应尽量用stream来代替文件的直接读写操作。</p>\n<h3 id=\"请求与响应\"><a href=\"#请求与响应\" class=\"headerlink\" title=\"请求与响应\"></a>请求与响应</h3><h4 id=\"跨域请求\"><a href=\"#跨域请求\" class=\"headerlink\" title=\"跨域请求\"></a>跨域请求</h4><ul>\n<li>cors</li>\n</ul>\n<p>如果需要采用cors来支持跨域请求，则需要对响应头进行如下设置（完整版）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">res.writeHead(200, &#123;</div><div class=\"line\">    &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;,</div><div class=\"line\">    &quot;Access-Control-Allow-Methods&quot;: &quot;GET, POST, PUT, DELETE, OPTIONS&quot;,</div><div class=\"line\">    &quot;Access-Control-Allow-Headers&quot;: &quot;Content-Type, accept&quot;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>另外，跨域时尽量对请求方法和请求路径都进行验证（RESTful），因为某些客户端框架（ionic）在发送跨域请求时，会先发送一个option方法的请求来尝试跨域请求是否成功，在成功之后才会发送原本的请求。</p>\n<ul>\n<li>cookie</li>\n</ul>\n<p>一般在node中设置cookies都会使用基于express的第三方包cookie-parser。不使用第三方包的原生写法为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">res.setHeader(&quot;Set-Cookie&quot;, [...cookies])</div></pre></td></tr></table></figure></p>\n<p>其中cookies的格式为key=value; option，注意;后的空格。</p>\n<p>option的参数中max-age=time表示cookie的过期时间，其中time的为number，单位是秒。</p>\n<p>获取客户端传递的cookies的方法为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">req.headers.cookie</div></pre></td></tr></table></figure></p>\n<p>如果使用express和cookie-parser，则关于cookie的方法都会被集成在request和response上，设置cookie的方法为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">res.cookie(key, value, option)</div></pre></td></tr></table></figure></p>\n<p>注意这里的option中的max-age单位变为了毫秒，其他则没有变化。</p>\n<p>获取客户端传递的cookies的方法为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">req.cookies</div></pre></td></tr></table></figure></p>\n<p>获取的cookies为对象形式。</p>\n<p>IDE没有提示功能或者提示功能不全的朋友请注意上文中的cookie和cookies并熟练记住。</p>\n"},{"title":"跨域之HTML5 postMessage","date":"2016-12-13T02:23:36.000Z","_content":"　　先了解下什么是同源策略，简单来说，协议+域名+端口三者必须相同，若有一个不同，即为跨域！\n　　相关图解如下：\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/corssDomain.png-public)\n</div>\n    \n　　HTML5中最酷的新功能之一就是 *跨文档消息传输Cross Document Messaging*。下一代浏览器都将支持这个功能：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 。 Facebook已经使用了这个功能，用postMessage支持基于web的实时消息传递。\n```\notherWindow.postMessage(message, targetOrigin);\n```\notherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。\nmessage: 所要发送的数据，string类型。\ntargetOrigin: 用于限制otherWindow，“*”表示不作限制\n\na.com/index.html中的代码：\n```\n<iframe id=\"ifr\" src=\"b.com/index.html\"></iframe>\n<script type=\"text/javascript\">\nwindow.onload = function() {\n    var ifr = document.getElementById('ifr');\n    var targetOrigin = 'http://b.com';  // 若写成'http://b.com/c/proxy.html'效果一样\n                                        // 若写成'http://c.com'就不会执行postMessage了\n    ifr.contentWindow.postMessage('I was there!', targetOrigin);\n};\n</script>\n```\n\nb.com/index.html中的代码：\n```\n<script type=\"text/javascript\">\n    window.addEventListener('message', function(event){\n        // 通过origin属性判断消息来源地址\n        if (event.origin == 'http://a.com') {\n            alert(event.data);    // 弹出\"I was there!\"\n            alert(event.source);  // 对a.com、index.html中window对象的引用\n                                  // 但由于同源策略，这里event.source不可以访问window对象\n        }\n    }, false);\n</script>\n```\n","source":"_posts/postMessage.md","raw":"---\ntitle: 跨域之HTML5 postMessage\ndate: 2016-12-13 10:23:36\ntags: 跨域、postMessage、html5\n---\n　　先了解下什么是同源策略，简单来说，协议+域名+端口三者必须相同，若有一个不同，即为跨域！\n　　相关图解如下：\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/corssDomain.png-public)\n</div>\n    \n　　HTML5中最酷的新功能之一就是 *跨文档消息传输Cross Document Messaging*。下一代浏览器都将支持这个功能：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 。 Facebook已经使用了这个功能，用postMessage支持基于web的实时消息传递。\n```\notherWindow.postMessage(message, targetOrigin);\n```\notherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。\nmessage: 所要发送的数据，string类型。\ntargetOrigin: 用于限制otherWindow，“*”表示不作限制\n\na.com/index.html中的代码：\n```\n<iframe id=\"ifr\" src=\"b.com/index.html\"></iframe>\n<script type=\"text/javascript\">\nwindow.onload = function() {\n    var ifr = document.getElementById('ifr');\n    var targetOrigin = 'http://b.com';  // 若写成'http://b.com/c/proxy.html'效果一样\n                                        // 若写成'http://c.com'就不会执行postMessage了\n    ifr.contentWindow.postMessage('I was there!', targetOrigin);\n};\n</script>\n```\n\nb.com/index.html中的代码：\n```\n<script type=\"text/javascript\">\n    window.addEventListener('message', function(event){\n        // 通过origin属性判断消息来源地址\n        if (event.origin == 'http://a.com') {\n            alert(event.data);    // 弹出\"I was there!\"\n            alert(event.source);  // 对a.com、index.html中window对象的引用\n                                  // 但由于同源策略，这里event.source不可以访问window对象\n        }\n    }, false);\n</script>\n```\n","slug":"postMessage","published":1,"updated":"2017-01-10T08:27:26.592Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv8q002ljgtuun3h8c92","content":"<p>　　先了解下什么是同源策略，简单来说，协议+域名+端口三者必须相同，若有一个不同，即为跨域！<br>　　相关图解如下：</p>\n<div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/corssDomain.png-public\" alt=\"\"><br></div>\n\n<p>　　HTML5中最酷的新功能之一就是 <em>跨文档消息传输Cross Document Messaging</em>。下一代浏览器都将支持这个功能：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 。 Facebook已经使用了这个功能，用postMessage支持基于web的实时消息传递。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">otherWindow.postMessage(message, targetOrigin);</div></pre></td></tr></table></figure></p>\n<p>otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。<br>message: 所要发送的数据，string类型。<br>targetOrigin: 用于限制otherWindow，“*”表示不作限制</p>\n<p>a.com/index.html中的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;iframe id=&quot;ifr&quot; src=&quot;b.com/index.html&quot;&gt;&lt;/iframe&gt;</div><div class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class=\"line\">window.onload = function() &#123;</div><div class=\"line\">    var ifr = document.getElementById(&apos;ifr&apos;);</div><div class=\"line\">    var targetOrigin = &apos;http://b.com&apos;;  // 若写成&apos;http://b.com/c/proxy.html&apos;效果一样</div><div class=\"line\">                                        // 若写成&apos;http://c.com&apos;就不会执行postMessage了</div><div class=\"line\">    ifr.contentWindow.postMessage(&apos;I was there!&apos;, targetOrigin);</div><div class=\"line\">&#125;;</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<p>b.com/index.html中的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class=\"line\">    window.addEventListener(&apos;message&apos;, function(event)&#123;</div><div class=\"line\">        // 通过origin属性判断消息来源地址</div><div class=\"line\">        if (event.origin == &apos;http://a.com&apos;) &#123;</div><div class=\"line\">            alert(event.data);    // 弹出&quot;I was there!&quot;</div><div class=\"line\">            alert(event.source);  // 对a.com、index.html中window对象的引用</div><div class=\"line\">                                  // 但由于同源策略，这里event.source不可以访问window对象</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;, false);</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>　　先了解下什么是同源策略，简单来说，协议+域名+端口三者必须相同，若有一个不同，即为跨域！<br>　　相关图解如下：</p>\n<div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/corssDomain.png-public\" alt=\"\"><br></div>\n\n<p>　　HTML5中最酷的新功能之一就是 <em>跨文档消息传输Cross Document Messaging</em>。下一代浏览器都将支持这个功能：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 。 Facebook已经使用了这个功能，用postMessage支持基于web的实时消息传递。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">otherWindow.postMessage(message, targetOrigin);</div></pre></td></tr></table></figure></p>\n<p>otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。<br>message: 所要发送的数据，string类型。<br>targetOrigin: 用于限制otherWindow，“*”表示不作限制</p>\n<p>a.com/index.html中的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;iframe id=&quot;ifr&quot; src=&quot;b.com/index.html&quot;&gt;&lt;/iframe&gt;</div><div class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class=\"line\">window.onload = function() &#123;</div><div class=\"line\">    var ifr = document.getElementById(&apos;ifr&apos;);</div><div class=\"line\">    var targetOrigin = &apos;http://b.com&apos;;  // 若写成&apos;http://b.com/c/proxy.html&apos;效果一样</div><div class=\"line\">                                        // 若写成&apos;http://c.com&apos;就不会执行postMessage了</div><div class=\"line\">    ifr.contentWindow.postMessage(&apos;I was there!&apos;, targetOrigin);</div><div class=\"line\">&#125;;</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<p>b.com/index.html中的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class=\"line\">    window.addEventListener(&apos;message&apos;, function(event)&#123;</div><div class=\"line\">        // 通过origin属性判断消息来源地址</div><div class=\"line\">        if (event.origin == &apos;http://a.com&apos;) &#123;</div><div class=\"line\">            alert(event.data);    // 弹出&quot;I was there!&quot;</div><div class=\"line\">            alert(event.source);  // 对a.com、index.html中window对象的引用</div><div class=\"line\">                                  // 但由于同源策略，这里event.source不可以访问window对象</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;, false);</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n"},{"title":"面向对象的javascript及js中6种继承方式","date":"2015-06-23T05:06:26.000Z","_content":"#### 面向对象的javascript及js中6种继承方式\n   javascript 没有提供传统的面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。\n   编程语言按照数据类型大致可以为两类：一类是静态类型语言，另一类是动态类型语言。\n   静态类型语言在编译时便已经确定变量的类型，而**动态类型**语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。\n   静态类型语言有java，.net，c等等。动态语言类型有javascript。js是一门典型的动态类型语言。\n   ##### 静态语言类型的优缺点：\n   优点：一是在编译时就能发现类型不匹配的错误。二是程序中规定了数据类型，编译器可以针对这些信息对程序进行一些优化工作，提高程序的执行速度。\n   缺点：一是迫使程序员依照强契约来编写程序，为每个变量规定数据类型。二是类型的声明也会增加更多的代码。\n   ##### 动态语言类型的优缺点：\n   优点：一是编写的代码数量会减少，使代码看起来更加简洁。\n   缺点：无法保证变量的类型，从而在程序的运行期可能发生跟类型相关的错误。\n#### 鸭子类型（duck typing）\n   在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。鸭子类型的通俗说法是：如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。利用鸭子类型的思想，不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程”。面向接口编程是设计模式中最重要的思想。\n   ```\n   //模拟鸭子类型小故事\n   var duck={\n       duckSinging:function () {\n           console.log(\"嘎嘎嘎\");\n       }\n   };\n   var chicken={\n       duckSinging:function () {\n           console.log(\"嘎嘎嘎\");\n       }\n   };\n   var choir=[];\n   var joinChoir=function (animal) {\n       if(animal && typeof animal.duckSinging===\"function\"){\n           choir.push(animal);\n           console.log('恭喜加入合唱团');\n           console.log('合唱团已有成员数量：'+choir.length);\n       }\n   };\n   joinChoir(duck);\n   joinChoir(chicken);\n   ```\n#### 多态\n多态的含义：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。\n```\n//一段多\"多态\"的javascript代码\nvar makeSound=function (animal) {\n    if(animal instanceof Duck){\n        console.log('嘎嘎嘎');\n    }else if(animal instanceof Chicken){\n        console.log('咯咯咯');\n    }\n};\nvar Duck=function () {};\nvar Chicken=function () {};\nmakeSound(new Duck());//嘎嘎嘎\nmakeSound(new Chicken());//咯咯咯\n```\n多态背后的思想是将做什么和谁去做以及怎样去做分离开来，也就是将不变的事物和可以改变的事物分离开来。在这个小故事\n中，动物都会叫，这是不变的，但是不同类的动物具体怎么叫是可变的。\n```\n//把不变的抽离出来\nvar makeSound=function (animal) {\n    animal.sound();\n};\nvar Duck=function () {};\nDuck.prototype.sound=function () {\n    console.log('gagaga');\n};\nvar Chicken=function () {};\nChicken.prototype.sound=function () {\n    console.log('gegege');\n};\nmakeSound(new Duck());//嘎嘎嘎\nmakeSound(new Chicken());//咯咯咯\n```\n```\n//好处就是以后可以任意追加其他小动物，而不用修改公共代码\nvar Dog=function(){};\nDog.prototype.sound=function () {\n    console.log('wangwangwang');\n};\nmakeSound(new Dog());//wangwangwang\n```\n#### 封装\n封装的目的是将信息隐藏。在JS中，只能依赖变量的作用域来实现封装特性，除了es6提供的let、Symbol外，一般通过自执行函数（IIFE）来创建作用域。这种方式封装的是数据。\n封装不仅仅是隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等。\n#### 原型模式和基于原型继承的JS对象系统\njs中常用的6种继承方式，即子类继承父类的方法：\n   1. 原型继承 \n   子类的原型指向父类的一个实例  父类的私有和公有方法都是子类的公有方法\n   ```\n   //原型继承\n   function A(){\n       this.x = 100;\n       this.y = 100;\n   }\n   A.prototype.getX = function (){}\n   \n   function B(){\n       this.x = 100;\n   }\n   B.prototype = new A(); //B的原型重新赋值A的实例==>每个b实例都能通过自己的__proto__找到a上的所有的私有方法，并且还可以通过a.__proto__继续找到A.prototype上的所有属性 ==> A这个类上的方法相对于B都是公有方法\n   B.prototype.constructor = B; //由于重新修改了B的原型导致默认原型上的constructor丢失，我们需要自己添加上\n   ```\n   2. call继承  \n   在子类构造函数中, 父类.call(this)  父类的私有变成子类的私有\n    ```\n    // call继承\n    function C(){\n        this.x = 100; //d.x = 100\n    }\n    C.prototype.getX = function (){};\n    function D(){\n        C.call(this); //构造函数中的this就是当前实例  this ==> d     C.call(d);  ==> 把C中的this修改成d\n    }\n    ```\n   3. 冒充对象继承 \n   循环遍历父类实例，然后父类实例的私有方法全部拿过来添加给子类实例，如果不做hasOwnProperty判断那么就是把父类的公有的和私有的都拿过来当私有的\n   ```\n   //冒充对象继承\n   function E(){\n       this.x = 100;\n       this.y = 200;\n   }\n   E.prototype.getX = function (){}\n   function F(){\n       var e = new E(); //e.x = 100;\n       for(var attr in e){ //for in可以遍历到原型上的公有自定义属性\n           //attr = x\n           if(e.hasOwnProperty(attr)){ //如果这个判断不加，那么无论是公有的还是私有的都拿过来当私有的\n               this[attr] = e[attr];//???  f['x'] = e['x'] ==> f.x = 100;\n           }\n           // e.propertyIsEnumerable() //可枚举属性  ==> 可以拿出来一一列举的属性\n       }\n   }\n   ```\n   4. 混合继承  \n   原型+call  ==> 无论是私有的还是公有的都拿过来了 ==> 子类的原型上的多了一套父类私有属但是不会产生问题。因为子类的私有属性也有一套相同的通过call继承拿过来的\n   ```\n   //混合继承\n   function G(){\n       this.x = 100;\n   }\n   G.prototype.getX = function(){};\n   function H(){\n       G.call(this);\n   }\n   H.prototype = new G();\n   H.prototype.constructor = H;\n   ```\n   5. 中间件继承  \n   M.prototype.__proto__ = K.prototype;  把父类的公有的当作子类的公有的\n   ```\n   // 中间件继承\n   function K(){\n       this.x = 100;\n   }\n   k.prototype.getX = function (){};\n   function M(){\n   \n   }\n   M.prototype.__proto__ = K.prototype; //本来应该是直接指向Object.prototype。从K的原型上的__proto__也可以到Object.prototype==> 在K.prototype上停留了下，K.prototype就是一个中间件  父类的公有当作子类的公有\n   ```\n   6. 寄生组合式继承  \n   Object.create(xx.prototype)方法  ==> 是把xx.prototype当作别人家的原型  不兼容，只能找到父类原型的方法。父类的私有属性访问不到。\n   ```\n   function Parent() {\n       this.name = \"ywx\";\n   }\n   Parent.prototype.eat = function () {\n       console.log(123);\n   };\n   function Child() {}\n   //寄生组合式继承实现方式如下：\n   Child.prototype = Object.create(Parent.prototype);\n   var child=new Child();\n   console.log(child.eat());//只有找到父类原型上的方法 \n   ```\n   注：prototype是函数（一般指构造函数）的一个内置属性;__proto__是一个对象（即实例）拥有的内置属性,是JS内部使用寻找原型链的属性。 实例.__proto__=构造函数.prototype;\n   \n   \n","source":"_posts/object-oriented-js.md","raw":"---\ntitle: 面向对象的javascript及js中6种继承方式\ndate: 2015-06-23 13:06:26\ntags: javascript、object-oriented、继承\n---\n#### 面向对象的javascript及js中6种继承方式\n   javascript 没有提供传统的面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。\n   编程语言按照数据类型大致可以为两类：一类是静态类型语言，另一类是动态类型语言。\n   静态类型语言在编译时便已经确定变量的类型，而**动态类型**语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。\n   静态类型语言有java，.net，c等等。动态语言类型有javascript。js是一门典型的动态类型语言。\n   ##### 静态语言类型的优缺点：\n   优点：一是在编译时就能发现类型不匹配的错误。二是程序中规定了数据类型，编译器可以针对这些信息对程序进行一些优化工作，提高程序的执行速度。\n   缺点：一是迫使程序员依照强契约来编写程序，为每个变量规定数据类型。二是类型的声明也会增加更多的代码。\n   ##### 动态语言类型的优缺点：\n   优点：一是编写的代码数量会减少，使代码看起来更加简洁。\n   缺点：无法保证变量的类型，从而在程序的运行期可能发生跟类型相关的错误。\n#### 鸭子类型（duck typing）\n   在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。鸭子类型的通俗说法是：如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。利用鸭子类型的思想，不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程”。面向接口编程是设计模式中最重要的思想。\n   ```\n   //模拟鸭子类型小故事\n   var duck={\n       duckSinging:function () {\n           console.log(\"嘎嘎嘎\");\n       }\n   };\n   var chicken={\n       duckSinging:function () {\n           console.log(\"嘎嘎嘎\");\n       }\n   };\n   var choir=[];\n   var joinChoir=function (animal) {\n       if(animal && typeof animal.duckSinging===\"function\"){\n           choir.push(animal);\n           console.log('恭喜加入合唱团');\n           console.log('合唱团已有成员数量：'+choir.length);\n       }\n   };\n   joinChoir(duck);\n   joinChoir(chicken);\n   ```\n#### 多态\n多态的含义：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。\n```\n//一段多\"多态\"的javascript代码\nvar makeSound=function (animal) {\n    if(animal instanceof Duck){\n        console.log('嘎嘎嘎');\n    }else if(animal instanceof Chicken){\n        console.log('咯咯咯');\n    }\n};\nvar Duck=function () {};\nvar Chicken=function () {};\nmakeSound(new Duck());//嘎嘎嘎\nmakeSound(new Chicken());//咯咯咯\n```\n多态背后的思想是将做什么和谁去做以及怎样去做分离开来，也就是将不变的事物和可以改变的事物分离开来。在这个小故事\n中，动物都会叫，这是不变的，但是不同类的动物具体怎么叫是可变的。\n```\n//把不变的抽离出来\nvar makeSound=function (animal) {\n    animal.sound();\n};\nvar Duck=function () {};\nDuck.prototype.sound=function () {\n    console.log('gagaga');\n};\nvar Chicken=function () {};\nChicken.prototype.sound=function () {\n    console.log('gegege');\n};\nmakeSound(new Duck());//嘎嘎嘎\nmakeSound(new Chicken());//咯咯咯\n```\n```\n//好处就是以后可以任意追加其他小动物，而不用修改公共代码\nvar Dog=function(){};\nDog.prototype.sound=function () {\n    console.log('wangwangwang');\n};\nmakeSound(new Dog());//wangwangwang\n```\n#### 封装\n封装的目的是将信息隐藏。在JS中，只能依赖变量的作用域来实现封装特性，除了es6提供的let、Symbol外，一般通过自执行函数（IIFE）来创建作用域。这种方式封装的是数据。\n封装不仅仅是隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等。\n#### 原型模式和基于原型继承的JS对象系统\njs中常用的6种继承方式，即子类继承父类的方法：\n   1. 原型继承 \n   子类的原型指向父类的一个实例  父类的私有和公有方法都是子类的公有方法\n   ```\n   //原型继承\n   function A(){\n       this.x = 100;\n       this.y = 100;\n   }\n   A.prototype.getX = function (){}\n   \n   function B(){\n       this.x = 100;\n   }\n   B.prototype = new A(); //B的原型重新赋值A的实例==>每个b实例都能通过自己的__proto__找到a上的所有的私有方法，并且还可以通过a.__proto__继续找到A.prototype上的所有属性 ==> A这个类上的方法相对于B都是公有方法\n   B.prototype.constructor = B; //由于重新修改了B的原型导致默认原型上的constructor丢失，我们需要自己添加上\n   ```\n   2. call继承  \n   在子类构造函数中, 父类.call(this)  父类的私有变成子类的私有\n    ```\n    // call继承\n    function C(){\n        this.x = 100; //d.x = 100\n    }\n    C.prototype.getX = function (){};\n    function D(){\n        C.call(this); //构造函数中的this就是当前实例  this ==> d     C.call(d);  ==> 把C中的this修改成d\n    }\n    ```\n   3. 冒充对象继承 \n   循环遍历父类实例，然后父类实例的私有方法全部拿过来添加给子类实例，如果不做hasOwnProperty判断那么就是把父类的公有的和私有的都拿过来当私有的\n   ```\n   //冒充对象继承\n   function E(){\n       this.x = 100;\n       this.y = 200;\n   }\n   E.prototype.getX = function (){}\n   function F(){\n       var e = new E(); //e.x = 100;\n       for(var attr in e){ //for in可以遍历到原型上的公有自定义属性\n           //attr = x\n           if(e.hasOwnProperty(attr)){ //如果这个判断不加，那么无论是公有的还是私有的都拿过来当私有的\n               this[attr] = e[attr];//???  f['x'] = e['x'] ==> f.x = 100;\n           }\n           // e.propertyIsEnumerable() //可枚举属性  ==> 可以拿出来一一列举的属性\n       }\n   }\n   ```\n   4. 混合继承  \n   原型+call  ==> 无论是私有的还是公有的都拿过来了 ==> 子类的原型上的多了一套父类私有属但是不会产生问题。因为子类的私有属性也有一套相同的通过call继承拿过来的\n   ```\n   //混合继承\n   function G(){\n       this.x = 100;\n   }\n   G.prototype.getX = function(){};\n   function H(){\n       G.call(this);\n   }\n   H.prototype = new G();\n   H.prototype.constructor = H;\n   ```\n   5. 中间件继承  \n   M.prototype.__proto__ = K.prototype;  把父类的公有的当作子类的公有的\n   ```\n   // 中间件继承\n   function K(){\n       this.x = 100;\n   }\n   k.prototype.getX = function (){};\n   function M(){\n   \n   }\n   M.prototype.__proto__ = K.prototype; //本来应该是直接指向Object.prototype。从K的原型上的__proto__也可以到Object.prototype==> 在K.prototype上停留了下，K.prototype就是一个中间件  父类的公有当作子类的公有\n   ```\n   6. 寄生组合式继承  \n   Object.create(xx.prototype)方法  ==> 是把xx.prototype当作别人家的原型  不兼容，只能找到父类原型的方法。父类的私有属性访问不到。\n   ```\n   function Parent() {\n       this.name = \"ywx\";\n   }\n   Parent.prototype.eat = function () {\n       console.log(123);\n   };\n   function Child() {}\n   //寄生组合式继承实现方式如下：\n   Child.prototype = Object.create(Parent.prototype);\n   var child=new Child();\n   console.log(child.eat());//只有找到父类原型上的方法 \n   ```\n   注：prototype是函数（一般指构造函数）的一个内置属性;__proto__是一个对象（即实例）拥有的内置属性,是JS内部使用寻找原型链的属性。 实例.__proto__=构造函数.prototype;\n   \n   \n","slug":"object-oriented-js","published":1,"updated":"2016-12-22T01:36:20.496Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv8s002ojgtuw4dltqgl","content":"<h4 id=\"面向对象的javascript及js中6种继承方式\"><a href=\"#面向对象的javascript及js中6种继承方式\" class=\"headerlink\" title=\"面向对象的javascript及js中6种继承方式\"></a>面向对象的javascript及js中6种继承方式</h4><p>   javascript 没有提供传统的面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。<br>   编程语言按照数据类型大致可以为两类：一类是静态类型语言，另一类是动态类型语言。<br>   静态类型语言在编译时便已经确定变量的类型，而<strong>动态类型</strong>语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。<br>   静态类型语言有java，.net，c等等。动态语言类型有javascript。js是一门典型的动态类型语言。</p>\n<h5 id=\"静态语言类型的优缺点：\"><a href=\"#静态语言类型的优缺点：\" class=\"headerlink\" title=\"静态语言类型的优缺点：\"></a>静态语言类型的优缺点：</h5><p>   优点：一是在编译时就能发现类型不匹配的错误。二是程序中规定了数据类型，编译器可以针对这些信息对程序进行一些优化工作，提高程序的执行速度。<br>   缺点：一是迫使程序员依照强契约来编写程序，为每个变量规定数据类型。二是类型的声明也会增加更多的代码。</p>\n<h5 id=\"动态语言类型的优缺点：\"><a href=\"#动态语言类型的优缺点：\" class=\"headerlink\" title=\"动态语言类型的优缺点：\"></a>动态语言类型的优缺点：</h5><p>   优点：一是编写的代码数量会减少，使代码看起来更加简洁。<br>   缺点：无法保证变量的类型，从而在程序的运行期可能发生跟类型相关的错误。</p>\n<h4 id=\"鸭子类型（duck-typing）\"><a href=\"#鸭子类型（duck-typing）\" class=\"headerlink\" title=\"鸭子类型（duck typing）\"></a>鸭子类型（duck typing）</h4><p>   在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。鸭子类型的通俗说法是：如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。利用鸭子类型的思想，不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程”。面向接口编程是设计模式中最重要的思想。<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">//模拟鸭子类型小故事</div><div class=\"line\">var duck=&#123;</div><div class=\"line\">    duckSinging:function () &#123;</div><div class=\"line\">        console.log(&quot;嘎嘎嘎&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">var chicken=&#123;</div><div class=\"line\">    duckSinging:function () &#123;</div><div class=\"line\">        console.log(&quot;嘎嘎嘎&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">var choir=[];</div><div class=\"line\">var joinChoir=function (animal) &#123;</div><div class=\"line\">    if(animal &amp;&amp; typeof animal.duckSinging===&quot;function&quot;)&#123;</div><div class=\"line\">        choir.push(animal);</div><div class=\"line\">        console.log(&apos;恭喜加入合唱团&apos;);</div><div class=\"line\">        console.log(&apos;合唱团已有成员数量：&apos;+choir.length);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">joinChoir(duck);</div><div class=\"line\">joinChoir(chicken);</div></pre></td></tr></table></figure></p>\n<h4 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h4><p>多态的含义：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">//一段多&quot;多态&quot;的javascript代码</div><div class=\"line\">var makeSound=function (animal) &#123;</div><div class=\"line\">    if(animal instanceof Duck)&#123;</div><div class=\"line\">        console.log(&apos;嘎嘎嘎&apos;);</div><div class=\"line\">    &#125;else if(animal instanceof Chicken)&#123;</div><div class=\"line\">        console.log(&apos;咯咯咯&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">var Duck=function () &#123;&#125;;</div><div class=\"line\">var Chicken=function () &#123;&#125;;</div><div class=\"line\">makeSound(new Duck());//嘎嘎嘎</div><div class=\"line\">makeSound(new Chicken());//咯咯咯</div></pre></td></tr></table></figure></p>\n<p>多态背后的思想是将做什么和谁去做以及怎样去做分离开来，也就是将不变的事物和可以改变的事物分离开来。在这个小故事<br>中，动物都会叫，这是不变的，但是不同类的动物具体怎么叫是可变的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">//把不变的抽离出来</div><div class=\"line\">var makeSound=function (animal) &#123;</div><div class=\"line\">    animal.sound();</div><div class=\"line\">&#125;;</div><div class=\"line\">var Duck=function () &#123;&#125;;</div><div class=\"line\">Duck.prototype.sound=function () &#123;</div><div class=\"line\">    console.log(&apos;gagaga&apos;);</div><div class=\"line\">&#125;;</div><div class=\"line\">var Chicken=function () &#123;&#125;;</div><div class=\"line\">Chicken.prototype.sound=function () &#123;</div><div class=\"line\">    console.log(&apos;gegege&apos;);</div><div class=\"line\">&#125;;</div><div class=\"line\">makeSound(new Duck());//嘎嘎嘎</div><div class=\"line\">makeSound(new Chicken());//咯咯咯</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//好处就是以后可以任意追加其他小动物，而不用修改公共代码</div><div class=\"line\">var Dog=function()&#123;&#125;;</div><div class=\"line\">Dog.prototype.sound=function () &#123;</div><div class=\"line\">    console.log(&apos;wangwangwang&apos;);</div><div class=\"line\">&#125;;</div><div class=\"line\">makeSound(new Dog());//wangwangwang</div></pre></td></tr></table></figure>\n<h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><p>封装的目的是将信息隐藏。在JS中，只能依赖变量的作用域来实现封装特性，除了es6提供的let、Symbol外，一般通过自执行函数（IIFE）来创建作用域。这种方式封装的是数据。<br>封装不仅仅是隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等。</p>\n<h4 id=\"原型模式和基于原型继承的JS对象系统\"><a href=\"#原型模式和基于原型继承的JS对象系统\" class=\"headerlink\" title=\"原型模式和基于原型继承的JS对象系统\"></a>原型模式和基于原型继承的JS对象系统</h4><p>js中常用的6种继承方式，即子类继承父类的方法：</p>\n<ol>\n<li><p>原型继承<br>子类的原型指向父类的一个实例  父类的私有和公有方法都是子类的公有方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">//原型继承</div><div class=\"line\">function A()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">    this.y = 100;</div><div class=\"line\">&#125;</div><div class=\"line\">A.prototype.getX = function ()&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">function B()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">&#125;</div><div class=\"line\">B.prototype = new A(); //B的原型重新赋值A的实例==&gt;每个b实例都能通过自己的__proto__找到a上的所有的私有方法，并且还可以通过a.__proto__继续找到A.prototype上的所有属性 ==&gt; A这个类上的方法相对于B都是公有方法</div><div class=\"line\">B.prototype.constructor = B; //由于重新修改了B的原型导致默认原型上的constructor丢失，我们需要自己添加上</div></pre></td></tr></table></figure>\n</li>\n<li><p>call继承<br>在子类构造函数中, 父类.call(this)  父类的私有变成子类的私有</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// call继承</div><div class=\"line\">function C()&#123;</div><div class=\"line\">    this.x = 100; //d.x = 100</div><div class=\"line\">&#125;</div><div class=\"line\">C.prototype.getX = function ()&#123;&#125;;</div><div class=\"line\">function D()&#123;</div><div class=\"line\">    C.call(this); //构造函数中的this就是当前实例  this ==&gt; d     C.call(d);  ==&gt; 把C中的this修改成d</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>冒充对象继承<br>循环遍历父类实例，然后父类实例的私有方法全部拿过来添加给子类实例，如果不做hasOwnProperty判断那么就是把父类的公有的和私有的都拿过来当私有的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//冒充对象继承</div><div class=\"line\">function E()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">    this.y = 200;</div><div class=\"line\">&#125;</div><div class=\"line\">E.prototype.getX = function ()&#123;&#125;</div><div class=\"line\">function F()&#123;</div><div class=\"line\">    var e = new E(); //e.x = 100;</div><div class=\"line\">    for(var attr in e)&#123; //for in可以遍历到原型上的公有自定义属性</div><div class=\"line\">        //attr = x</div><div class=\"line\">        if(e.hasOwnProperty(attr))&#123; //如果这个判断不加，那么无论是公有的还是私有的都拿过来当私有的</div><div class=\"line\">            this[attr] = e[attr];//???  f[&apos;x&apos;] = e[&apos;x&apos;] ==&gt; f.x = 100;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // e.propertyIsEnumerable() //可枚举属性  ==&gt; 可以拿出来一一列举的属性</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>混合继承<br>原型+call  ==&gt; 无论是私有的还是公有的都拿过来了 ==&gt; 子类的原型上的多了一套父类私有属但是不会产生问题。因为子类的私有属性也有一套相同的通过call继承拿过来的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//混合继承</div><div class=\"line\">function G()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">&#125;</div><div class=\"line\">G.prototype.getX = function()&#123;&#125;;</div><div class=\"line\">function H()&#123;</div><div class=\"line\">    G.call(this);</div><div class=\"line\">&#125;</div><div class=\"line\">H.prototype = new G();</div><div class=\"line\">H.prototype.constructor = H;</div></pre></td></tr></table></figure>\n</li>\n<li><p>中间件继承<br>M.prototype.<strong>proto</strong> = K.prototype;  把父类的公有的当作子类的公有的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 中间件继承</div><div class=\"line\">function K()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">&#125;</div><div class=\"line\">k.prototype.getX = function ()&#123;&#125;;</div><div class=\"line\">function M()&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">M.prototype.__proto__ = K.prototype; //本来应该是直接指向Object.prototype。从K的原型上的__proto__也可以到Object.prototype==&gt; 在K.prototype上停留了下，K.prototype就是一个中间件  父类的公有当作子类的公有</div></pre></td></tr></table></figure>\n</li>\n<li><p>寄生组合式继承<br>Object.create(xx.prototype)方法  ==&gt; 是把xx.prototype当作别人家的原型  不兼容，只能找到父类原型的方法。父类的私有属性访问不到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Parent() &#123;</div><div class=\"line\">    this.name = &quot;ywx&quot;;</div><div class=\"line\">&#125;</div><div class=\"line\">Parent.prototype.eat = function () &#123;</div><div class=\"line\">    console.log(123);</div><div class=\"line\">&#125;;</div><div class=\"line\">function Child() &#123;&#125;</div><div class=\"line\">//寄生组合式继承实现方式如下：</div><div class=\"line\">Child.prototype = Object.create(Parent.prototype);</div><div class=\"line\">var child=new Child();</div><div class=\"line\">console.log(child.eat());//只有找到父类原型上的方法</div></pre></td></tr></table></figure>\n<p>注：prototype是函数（一般指构造函数）的一个内置属性;<strong>proto</strong>是一个对象（即实例）拥有的内置属性,是JS内部使用寻找原型链的属性。 实例.<strong>proto</strong>=构造函数.prototype;</p>\n</li>\n</ol>\n","excerpt":"","more":"<h4 id=\"面向对象的javascript及js中6种继承方式\"><a href=\"#面向对象的javascript及js中6种继承方式\" class=\"headerlink\" title=\"面向对象的javascript及js中6种继承方式\"></a>面向对象的javascript及js中6种继承方式</h4><p>   javascript 没有提供传统的面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。<br>   编程语言按照数据类型大致可以为两类：一类是静态类型语言，另一类是动态类型语言。<br>   静态类型语言在编译时便已经确定变量的类型，而<strong>动态类型</strong>语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。<br>   静态类型语言有java，.net，c等等。动态语言类型有javascript。js是一门典型的动态类型语言。</p>\n<h5 id=\"静态语言类型的优缺点：\"><a href=\"#静态语言类型的优缺点：\" class=\"headerlink\" title=\"静态语言类型的优缺点：\"></a>静态语言类型的优缺点：</h5><p>   优点：一是在编译时就能发现类型不匹配的错误。二是程序中规定了数据类型，编译器可以针对这些信息对程序进行一些优化工作，提高程序的执行速度。<br>   缺点：一是迫使程序员依照强契约来编写程序，为每个变量规定数据类型。二是类型的声明也会增加更多的代码。</p>\n<h5 id=\"动态语言类型的优缺点：\"><a href=\"#动态语言类型的优缺点：\" class=\"headerlink\" title=\"动态语言类型的优缺点：\"></a>动态语言类型的优缺点：</h5><p>   优点：一是编写的代码数量会减少，使代码看起来更加简洁。<br>   缺点：无法保证变量的类型，从而在程序的运行期可能发生跟类型相关的错误。</p>\n<h4 id=\"鸭子类型（duck-typing）\"><a href=\"#鸭子类型（duck-typing）\" class=\"headerlink\" title=\"鸭子类型（duck typing）\"></a>鸭子类型（duck typing）</h4><p>   在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。鸭子类型的通俗说法是：如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。利用鸭子类型的思想，不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程”。面向接口编程是设计模式中最重要的思想。<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">//模拟鸭子类型小故事</div><div class=\"line\">var duck=&#123;</div><div class=\"line\">    duckSinging:function () &#123;</div><div class=\"line\">        console.log(&quot;嘎嘎嘎&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">var chicken=&#123;</div><div class=\"line\">    duckSinging:function () &#123;</div><div class=\"line\">        console.log(&quot;嘎嘎嘎&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">var choir=[];</div><div class=\"line\">var joinChoir=function (animal) &#123;</div><div class=\"line\">    if(animal &amp;&amp; typeof animal.duckSinging===&quot;function&quot;)&#123;</div><div class=\"line\">        choir.push(animal);</div><div class=\"line\">        console.log(&apos;恭喜加入合唱团&apos;);</div><div class=\"line\">        console.log(&apos;合唱团已有成员数量：&apos;+choir.length);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">joinChoir(duck);</div><div class=\"line\">joinChoir(chicken);</div></pre></td></tr></table></figure></p>\n<h4 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h4><p>多态的含义：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">//一段多&quot;多态&quot;的javascript代码</div><div class=\"line\">var makeSound=function (animal) &#123;</div><div class=\"line\">    if(animal instanceof Duck)&#123;</div><div class=\"line\">        console.log(&apos;嘎嘎嘎&apos;);</div><div class=\"line\">    &#125;else if(animal instanceof Chicken)&#123;</div><div class=\"line\">        console.log(&apos;咯咯咯&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">var Duck=function () &#123;&#125;;</div><div class=\"line\">var Chicken=function () &#123;&#125;;</div><div class=\"line\">makeSound(new Duck());//嘎嘎嘎</div><div class=\"line\">makeSound(new Chicken());//咯咯咯</div></pre></td></tr></table></figure></p>\n<p>多态背后的思想是将做什么和谁去做以及怎样去做分离开来，也就是将不变的事物和可以改变的事物分离开来。在这个小故事<br>中，动物都会叫，这是不变的，但是不同类的动物具体怎么叫是可变的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">//把不变的抽离出来</div><div class=\"line\">var makeSound=function (animal) &#123;</div><div class=\"line\">    animal.sound();</div><div class=\"line\">&#125;;</div><div class=\"line\">var Duck=function () &#123;&#125;;</div><div class=\"line\">Duck.prototype.sound=function () &#123;</div><div class=\"line\">    console.log(&apos;gagaga&apos;);</div><div class=\"line\">&#125;;</div><div class=\"line\">var Chicken=function () &#123;&#125;;</div><div class=\"line\">Chicken.prototype.sound=function () &#123;</div><div class=\"line\">    console.log(&apos;gegege&apos;);</div><div class=\"line\">&#125;;</div><div class=\"line\">makeSound(new Duck());//嘎嘎嘎</div><div class=\"line\">makeSound(new Chicken());//咯咯咯</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//好处就是以后可以任意追加其他小动物，而不用修改公共代码</div><div class=\"line\">var Dog=function()&#123;&#125;;</div><div class=\"line\">Dog.prototype.sound=function () &#123;</div><div class=\"line\">    console.log(&apos;wangwangwang&apos;);</div><div class=\"line\">&#125;;</div><div class=\"line\">makeSound(new Dog());//wangwangwang</div></pre></td></tr></table></figure>\n<h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><p>封装的目的是将信息隐藏。在JS中，只能依赖变量的作用域来实现封装特性，除了es6提供的let、Symbol外，一般通过自执行函数（IIFE）来创建作用域。这种方式封装的是数据。<br>封装不仅仅是隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等。</p>\n<h4 id=\"原型模式和基于原型继承的JS对象系统\"><a href=\"#原型模式和基于原型继承的JS对象系统\" class=\"headerlink\" title=\"原型模式和基于原型继承的JS对象系统\"></a>原型模式和基于原型继承的JS对象系统</h4><p>js中常用的6种继承方式，即子类继承父类的方法：</p>\n<ol>\n<li><p>原型继承<br>子类的原型指向父类的一个实例  父类的私有和公有方法都是子类的公有方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">//原型继承</div><div class=\"line\">function A()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">    this.y = 100;</div><div class=\"line\">&#125;</div><div class=\"line\">A.prototype.getX = function ()&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">function B()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">&#125;</div><div class=\"line\">B.prototype = new A(); //B的原型重新赋值A的实例==&gt;每个b实例都能通过自己的__proto__找到a上的所有的私有方法，并且还可以通过a.__proto__继续找到A.prototype上的所有属性 ==&gt; A这个类上的方法相对于B都是公有方法</div><div class=\"line\">B.prototype.constructor = B; //由于重新修改了B的原型导致默认原型上的constructor丢失，我们需要自己添加上</div></pre></td></tr></table></figure>\n</li>\n<li><p>call继承<br>在子类构造函数中, 父类.call(this)  父类的私有变成子类的私有</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// call继承</div><div class=\"line\">function C()&#123;</div><div class=\"line\">    this.x = 100; //d.x = 100</div><div class=\"line\">&#125;</div><div class=\"line\">C.prototype.getX = function ()&#123;&#125;;</div><div class=\"line\">function D()&#123;</div><div class=\"line\">    C.call(this); //构造函数中的this就是当前实例  this ==&gt; d     C.call(d);  ==&gt; 把C中的this修改成d</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>冒充对象继承<br>循环遍历父类实例，然后父类实例的私有方法全部拿过来添加给子类实例，如果不做hasOwnProperty判断那么就是把父类的公有的和私有的都拿过来当私有的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//冒充对象继承</div><div class=\"line\">function E()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">    this.y = 200;</div><div class=\"line\">&#125;</div><div class=\"line\">E.prototype.getX = function ()&#123;&#125;</div><div class=\"line\">function F()&#123;</div><div class=\"line\">    var e = new E(); //e.x = 100;</div><div class=\"line\">    for(var attr in e)&#123; //for in可以遍历到原型上的公有自定义属性</div><div class=\"line\">        //attr = x</div><div class=\"line\">        if(e.hasOwnProperty(attr))&#123; //如果这个判断不加，那么无论是公有的还是私有的都拿过来当私有的</div><div class=\"line\">            this[attr] = e[attr];//???  f[&apos;x&apos;] = e[&apos;x&apos;] ==&gt; f.x = 100;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // e.propertyIsEnumerable() //可枚举属性  ==&gt; 可以拿出来一一列举的属性</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>混合继承<br>原型+call  ==&gt; 无论是私有的还是公有的都拿过来了 ==&gt; 子类的原型上的多了一套父类私有属但是不会产生问题。因为子类的私有属性也有一套相同的通过call继承拿过来的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//混合继承</div><div class=\"line\">function G()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">&#125;</div><div class=\"line\">G.prototype.getX = function()&#123;&#125;;</div><div class=\"line\">function H()&#123;</div><div class=\"line\">    G.call(this);</div><div class=\"line\">&#125;</div><div class=\"line\">H.prototype = new G();</div><div class=\"line\">H.prototype.constructor = H;</div></pre></td></tr></table></figure>\n</li>\n<li><p>中间件继承<br>M.prototype.<strong>proto</strong> = K.prototype;  把父类的公有的当作子类的公有的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 中间件继承</div><div class=\"line\">function K()&#123;</div><div class=\"line\">    this.x = 100;</div><div class=\"line\">&#125;</div><div class=\"line\">k.prototype.getX = function ()&#123;&#125;;</div><div class=\"line\">function M()&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">M.prototype.__proto__ = K.prototype; //本来应该是直接指向Object.prototype。从K的原型上的__proto__也可以到Object.prototype==&gt; 在K.prototype上停留了下，K.prototype就是一个中间件  父类的公有当作子类的公有</div></pre></td></tr></table></figure>\n</li>\n<li><p>寄生组合式继承<br>Object.create(xx.prototype)方法  ==&gt; 是把xx.prototype当作别人家的原型  不兼容，只能找到父类原型的方法。父类的私有属性访问不到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Parent() &#123;</div><div class=\"line\">    this.name = &quot;ywx&quot;;</div><div class=\"line\">&#125;</div><div class=\"line\">Parent.prototype.eat = function () &#123;</div><div class=\"line\">    console.log(123);</div><div class=\"line\">&#125;;</div><div class=\"line\">function Child() &#123;&#125;</div><div class=\"line\">//寄生组合式继承实现方式如下：</div><div class=\"line\">Child.prototype = Object.create(Parent.prototype);</div><div class=\"line\">var child=new Child();</div><div class=\"line\">console.log(child.eat());//只有找到父类原型上的方法</div></pre></td></tr></table></figure>\n<p>注：prototype是函数（一般指构造函数）的一个内置属性;<strong>proto</strong>是一个对象（即实例）拥有的内置属性,是JS内部使用寻找原型链的属性。 实例.<strong>proto</strong>=构造函数.prototype;</p>\n</li>\n</ol>\n"},{"title":"JavaScript 中的“纯函数”","date":"2017-01-03T03:19:27.000Z","_content":"#### 什么是纯函数（pure function）\n纯函数是指 不依赖于且不改变它作用域之外的变量状态 的函数。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/pure%20function.png-public)\n</div>\n也就是说， 纯函数的返回值只由它调用时的参数决定 ，它的执行不依赖于系统的状态（比如：何时、何处调用它）。\n纯函数是 函数式编程 的一个基础。\n#### 下面的例子让其理解更深刻\n```\nvar values = { a: 1 };\nfunction impureFunction ( items ) {\n  var b = 1;\n  items.a = items.a * b + 2;\n  return items.a;\n}\nvar c = impureFunction( values );\n// 现在 `values.a` 变成 3,  impureFunction 改变了它。\n```\n在上面的代码中，我们改变了参数对象中的一个属性。由于我们定义的函数改变的对象在我们的函数作用域之外，导致这个函数成为“不纯”的函数。\n```\nvar values = { a: 1 };\nfunction pureFunction ( a ) {\n  var b = 1;\n  a = a * b + 2;\n  return a;\n}\nvar c = pureFunction( values.a );\n// `values.a` 没有被改变, 它的值仍然是 1\n```\n上面的代码，我们只计算了作用域内的局部变量，没有任何作用域外部的变量被改变，因此这个函数是“纯函数”。\n```\nvar values = { a: 1 };\nvar b = 1;\nfunction impureFunction ( a ) {\n  a = a * b + 2;\n  return a;\n}\nvar c = impureFunction( values.a );\n// 实际上,  `c` 的值依赖于外部变量 `b`.\n// 你可能容易忽略这种情况，外部变量的变化也可能会导致函数出现不确定结果。\n```\n上面的代码里， b 不在作用域中，函数执行结果依赖于上下文环境，因此函数也是“不纯”的。\n```\nvar values = { a: 1 };\nvar b = 1;\nfunction pureFunction ( a, d ) {\n  a = a * d + 2;\n  return a;\n}\nvar c = pureFunction( values.a, b );\n// 这样从定义上明确 `c` 依赖于参数 `b`，避免函数不确定结果。\n```\n上面这样改就成了“纯函数”。\n#### 使用纯函数的好处\n最主要的好处是没有副作用。纯函数不会修改作用域之外的状态，做到这一点，代码就变得足够简单和清晰：当你调用一个纯函数，你只要关注它的返回值，而不用担心因为别处的问题导致错误。\n\n纯函数是健壮的，改变执行次序不会对系统造成影响，因此纯函数的操作可以并行执行。\n\n纯函数非常容易进行单元测试，因为不需要考虑上下文环境，只需要考虑输入和输出。\n\n最后，尽可能使用纯函数 让你的代码保持简单和灵活 。\n","source":"_posts/pure-function.md","raw":"---\ntitle: JavaScript 中的“纯函数”\ndate: 2017-01-03 11:19:27\ntags: js 纯函数\n---\n#### 什么是纯函数（pure function）\n纯函数是指 不依赖于且不改变它作用域之外的变量状态 的函数。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/pure%20function.png-public)\n</div>\n也就是说， 纯函数的返回值只由它调用时的参数决定 ，它的执行不依赖于系统的状态（比如：何时、何处调用它）。\n纯函数是 函数式编程 的一个基础。\n#### 下面的例子让其理解更深刻\n```\nvar values = { a: 1 };\nfunction impureFunction ( items ) {\n  var b = 1;\n  items.a = items.a * b + 2;\n  return items.a;\n}\nvar c = impureFunction( values );\n// 现在 `values.a` 变成 3,  impureFunction 改变了它。\n```\n在上面的代码中，我们改变了参数对象中的一个属性。由于我们定义的函数改变的对象在我们的函数作用域之外，导致这个函数成为“不纯”的函数。\n```\nvar values = { a: 1 };\nfunction pureFunction ( a ) {\n  var b = 1;\n  a = a * b + 2;\n  return a;\n}\nvar c = pureFunction( values.a );\n// `values.a` 没有被改变, 它的值仍然是 1\n```\n上面的代码，我们只计算了作用域内的局部变量，没有任何作用域外部的变量被改变，因此这个函数是“纯函数”。\n```\nvar values = { a: 1 };\nvar b = 1;\nfunction impureFunction ( a ) {\n  a = a * b + 2;\n  return a;\n}\nvar c = impureFunction( values.a );\n// 实际上,  `c` 的值依赖于外部变量 `b`.\n// 你可能容易忽略这种情况，外部变量的变化也可能会导致函数出现不确定结果。\n```\n上面的代码里， b 不在作用域中，函数执行结果依赖于上下文环境，因此函数也是“不纯”的。\n```\nvar values = { a: 1 };\nvar b = 1;\nfunction pureFunction ( a, d ) {\n  a = a * d + 2;\n  return a;\n}\nvar c = pureFunction( values.a, b );\n// 这样从定义上明确 `c` 依赖于参数 `b`，避免函数不确定结果。\n```\n上面这样改就成了“纯函数”。\n#### 使用纯函数的好处\n最主要的好处是没有副作用。纯函数不会修改作用域之外的状态，做到这一点，代码就变得足够简单和清晰：当你调用一个纯函数，你只要关注它的返回值，而不用担心因为别处的问题导致错误。\n\n纯函数是健壮的，改变执行次序不会对系统造成影响，因此纯函数的操作可以并行执行。\n\n纯函数非常容易进行单元测试，因为不需要考虑上下文环境，只需要考虑输入和输出。\n\n最后，尽可能使用纯函数 让你的代码保持简单和灵活 。\n","slug":"pure-function","published":1,"updated":"2017-01-10T08:17:35.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv8v002pjgtuaba6l8hp","content":"<h4 id=\"什么是纯函数（pure-function）\"><a href=\"#什么是纯函数（pure-function）\" class=\"headerlink\" title=\"什么是纯函数（pure function）\"></a>什么是纯函数（pure function）</h4><p>纯函数是指 不依赖于且不改变它作用域之外的变量状态 的函数。</p>\n<p><div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/pure%20function.png-public\" alt=\"\"><br></div><br>也就是说， 纯函数的返回值只由它调用时的参数决定 ，它的执行不依赖于系统的状态（比如：何时、何处调用它）。<br>纯函数是 函数式编程 的一个基础。</p>\n<h4 id=\"下面的例子让其理解更深刻\"><a href=\"#下面的例子让其理解更深刻\" class=\"headerlink\" title=\"下面的例子让其理解更深刻\"></a>下面的例子让其理解更深刻</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var values = &#123; a: 1 &#125;;</div><div class=\"line\">function impureFunction ( items ) &#123;</div><div class=\"line\">  var b = 1;</div><div class=\"line\">  items.a = items.a * b + 2;</div><div class=\"line\">  return items.a;</div><div class=\"line\">&#125;</div><div class=\"line\">var c = impureFunction( values );</div><div class=\"line\">// 现在 `values.a` 变成 3,  impureFunction 改变了它。</div></pre></td></tr></table></figure>\n<p>在上面的代码中，我们改变了参数对象中的一个属性。由于我们定义的函数改变的对象在我们的函数作用域之外，导致这个函数成为“不纯”的函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var values = &#123; a: 1 &#125;;</div><div class=\"line\">function pureFunction ( a ) &#123;</div><div class=\"line\">  var b = 1;</div><div class=\"line\">  a = a * b + 2;</div><div class=\"line\">  return a;</div><div class=\"line\">&#125;</div><div class=\"line\">var c = pureFunction( values.a );</div><div class=\"line\">// `values.a` 没有被改变, 它的值仍然是 1</div></pre></td></tr></table></figure></p>\n<p>上面的代码，我们只计算了作用域内的局部变量，没有任何作用域外部的变量被改变，因此这个函数是“纯函数”。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var values = &#123; a: 1 &#125;;</div><div class=\"line\">var b = 1;</div><div class=\"line\">function impureFunction ( a ) &#123;</div><div class=\"line\">  a = a * b + 2;</div><div class=\"line\">  return a;</div><div class=\"line\">&#125;</div><div class=\"line\">var c = impureFunction( values.a );</div><div class=\"line\">// 实际上,  `c` 的值依赖于外部变量 `b`.</div><div class=\"line\">// 你可能容易忽略这种情况，外部变量的变化也可能会导致函数出现不确定结果。</div></pre></td></tr></table></figure></p>\n<p>上面的代码里， b 不在作用域中，函数执行结果依赖于上下文环境，因此函数也是“不纯”的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var values = &#123; a: 1 &#125;;</div><div class=\"line\">var b = 1;</div><div class=\"line\">function pureFunction ( a, d ) &#123;</div><div class=\"line\">  a = a * d + 2;</div><div class=\"line\">  return a;</div><div class=\"line\">&#125;</div><div class=\"line\">var c = pureFunction( values.a, b );</div><div class=\"line\">// 这样从定义上明确 `c` 依赖于参数 `b`，避免函数不确定结果。</div></pre></td></tr></table></figure></p>\n<p>上面这样改就成了“纯函数”。</p>\n<h4 id=\"使用纯函数的好处\"><a href=\"#使用纯函数的好处\" class=\"headerlink\" title=\"使用纯函数的好处\"></a>使用纯函数的好处</h4><p>最主要的好处是没有副作用。纯函数不会修改作用域之外的状态，做到这一点，代码就变得足够简单和清晰：当你调用一个纯函数，你只要关注它的返回值，而不用担心因为别处的问题导致错误。</p>\n<p>纯函数是健壮的，改变执行次序不会对系统造成影响，因此纯函数的操作可以并行执行。</p>\n<p>纯函数非常容易进行单元测试，因为不需要考虑上下文环境，只需要考虑输入和输出。</p>\n<p>最后，尽可能使用纯函数 让你的代码保持简单和灵活 。</p>\n","excerpt":"","more":"<h4 id=\"什么是纯函数（pure-function）\"><a href=\"#什么是纯函数（pure-function）\" class=\"headerlink\" title=\"什么是纯函数（pure function）\"></a>什么是纯函数（pure function）</h4><p>纯函数是指 不依赖于且不改变它作用域之外的变量状态 的函数。</p>\n<p><div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/pure%20function.png-public\" alt=\"\"><br></div><br>也就是说， 纯函数的返回值只由它调用时的参数决定 ，它的执行不依赖于系统的状态（比如：何时、何处调用它）。<br>纯函数是 函数式编程 的一个基础。</p>\n<h4 id=\"下面的例子让其理解更深刻\"><a href=\"#下面的例子让其理解更深刻\" class=\"headerlink\" title=\"下面的例子让其理解更深刻\"></a>下面的例子让其理解更深刻</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var values = &#123; a: 1 &#125;;</div><div class=\"line\">function impureFunction ( items ) &#123;</div><div class=\"line\">  var b = 1;</div><div class=\"line\">  items.a = items.a * b + 2;</div><div class=\"line\">  return items.a;</div><div class=\"line\">&#125;</div><div class=\"line\">var c = impureFunction( values );</div><div class=\"line\">// 现在 `values.a` 变成 3,  impureFunction 改变了它。</div></pre></td></tr></table></figure>\n<p>在上面的代码中，我们改变了参数对象中的一个属性。由于我们定义的函数改变的对象在我们的函数作用域之外，导致这个函数成为“不纯”的函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var values = &#123; a: 1 &#125;;</div><div class=\"line\">function pureFunction ( a ) &#123;</div><div class=\"line\">  var b = 1;</div><div class=\"line\">  a = a * b + 2;</div><div class=\"line\">  return a;</div><div class=\"line\">&#125;</div><div class=\"line\">var c = pureFunction( values.a );</div><div class=\"line\">// `values.a` 没有被改变, 它的值仍然是 1</div></pre></td></tr></table></figure></p>\n<p>上面的代码，我们只计算了作用域内的局部变量，没有任何作用域外部的变量被改变，因此这个函数是“纯函数”。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var values = &#123; a: 1 &#125;;</div><div class=\"line\">var b = 1;</div><div class=\"line\">function impureFunction ( a ) &#123;</div><div class=\"line\">  a = a * b + 2;</div><div class=\"line\">  return a;</div><div class=\"line\">&#125;</div><div class=\"line\">var c = impureFunction( values.a );</div><div class=\"line\">// 实际上,  `c` 的值依赖于外部变量 `b`.</div><div class=\"line\">// 你可能容易忽略这种情况，外部变量的变化也可能会导致函数出现不确定结果。</div></pre></td></tr></table></figure></p>\n<p>上面的代码里， b 不在作用域中，函数执行结果依赖于上下文环境，因此函数也是“不纯”的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var values = &#123; a: 1 &#125;;</div><div class=\"line\">var b = 1;</div><div class=\"line\">function pureFunction ( a, d ) &#123;</div><div class=\"line\">  a = a * d + 2;</div><div class=\"line\">  return a;</div><div class=\"line\">&#125;</div><div class=\"line\">var c = pureFunction( values.a, b );</div><div class=\"line\">// 这样从定义上明确 `c` 依赖于参数 `b`，避免函数不确定结果。</div></pre></td></tr></table></figure></p>\n<p>上面这样改就成了“纯函数”。</p>\n<h4 id=\"使用纯函数的好处\"><a href=\"#使用纯函数的好处\" class=\"headerlink\" title=\"使用纯函数的好处\"></a>使用纯函数的好处</h4><p>最主要的好处是没有副作用。纯函数不会修改作用域之外的状态，做到这一点，代码就变得足够简单和清晰：当你调用一个纯函数，你只要关注它的返回值，而不用担心因为别处的问题导致错误。</p>\n<p>纯函数是健壮的，改变执行次序不会对系统造成影响，因此纯函数的操作可以并行执行。</p>\n<p>纯函数非常容易进行单元测试，因为不需要考虑上下文环境，只需要考虑输入和输出。</p>\n<p>最后，尽可能使用纯函数 让你的代码保持简单和灵活 。</p>\n"},{"title":"前后端分离，是为了彼此更好","date":"2016-07-16T04:41:23.000Z","_content":"### 一、被误解的前后端分离\n\n在Web应用开发过程中，业界对前后端的分界线似乎一直都没有确定的概念，不过大多数人以浏览器作为前后端的分界线。将浏览器中为用户进行页面展示的部分称为前端，而将运行于服务器，为前端提供业务逻辑和数据准备的所有代码统称为后端。\n\n虽然前后端分离在数年前就已经开始受到关注，但很多人对它却是只闻其声，未见其形，所以对它产生了一些误解，误以为前后段分离只是一种Web应用的开发模式，只要在Web应用的开发期进行了前后端开发工作的分工就是前后端分离。\n\n其实并非如此，准确的说，前后端分离并不只是开发模式，而是Web应用的一种架构模式。在开发期，前后端工程师可以通过约定好交互接口，实现并行开发；在运行期，前后端分离模式需要对Web应用进行分离部署，前后端之间使用HTTP请求进行交互。然而作为应用的架构模式，前后端分离并不是通过这样一句话就能一概而谈的，我们可以从交互形式、代码组织方式、开发模式三个方面对前后端分离进行认识。\n![](http://oi28tswuq.bkt.clouddn.com/images/2.png)\n在前后端分离架构中，后端只需要负责按照约定的数据格式向前端提供可调用的API服务即可。前后端之间通过HTTP请求进行交互，前端获取到数据后，进行页面的装配和渲染。\n![](http://oi28tswuq.bkt.clouddn.com/images/5.png)\n在传统架构模式中，前后端代码存放于同一个代码库中，甚至是同一工程目录下。页面中还夹杂着后端代码。前后端工程师进行开发时，都必须把整个项目导入到开发工具中。\n\n而前后端分离模式在代码组织形式上有以下两种：\n\n#### 半分离\n前后端共用一个代码库，但是代码分别存放在两个工程中。后端不关心或很少关心前端元素的输出情况，前端不能独立进行开发和测试，项目中缺乏前后端交互的测试用例。\n\n#### 分离\n前后端代码库分离，前端代码中有可以进行Mock测试（通过构造虚拟测试对象以简化测试环境的方法）的伪后端，能支持前端的独立开发和测试。而后端代码中除了功能实现外，还有着详细的测试用例，以保证API的可用性，降低集成风险。\n\n#### 3、开发模式\n\n传统的MVC架构开发，没有进行前后端分离，前端工程师负责编写HTML，完成前端页面设计，然后给后端工程师员套界面，使用模板技术将前端代码转换成JSP页面，同时内嵌java代码。应用运行期，将全部代码进行打包，部署到同一服务器上，或者进行简单的动静态分离部署。\n\n此时，应用的开发流程如下图所示。\n![](http://oi28tswuq.bkt.clouddn.com/images/11.png)\n在前后端分离架构中，前端工程师只需要编写HTML、js、CSS等前端资源，然后通过HTTP请求调用后端提供的服务即可。除了开发期的分离，在运行期前后端资源也会进行分离部署。\n\n前后端分离之后，开发流程将如下图所示。\n![](http://oi28tswuq.bkt.clouddn.com/images/3.png)\n通过上面的两幅流程图，不难发现，在开发模式上，前后端分离不仅仅只是工程师的分工开发，更重要的意义在于实现了前后端的并行开发，和简化了开发流程。\n### 二、为什么要“离”：4个好处\n\n重新认识前后端分离之后，想必大家心里都会有疑问，前后端分离模式与之前的Web应用架构相比可谓是大相径庭，我们为什么要进行前后端分离呢？正如莎士比亚在《哈姆雷特》中的经典名句一样，分还是不分，这是个问题。\n\n从目前应用软件的发展趋势来看，一方面，用户越来越注重软件的体验感，随着互联网的蓬勃发展，应用开始走向多终端化；另一方面，大型应用的架构模式正纷纷向着云化、微服务化发展。\n\n虽然过去的应用架构暂时还能支撑起当下应用的开发，但是各种弊端已经开始浮出水面，几年前能带来开发便捷优势的前后端代码混合模式，在当下已经成为了拖慢我们前进步伐的泥沼，让我们屡屡吃痛。我们之所以开始尝试前后端分离，是为了能在未来获得更好的发展，期望通过前后端分离架构，来为我们带来以下4个方面的提升。\n\n为孵化优质产品打造精益团队\n\n正如康威定律所述，产品是组织沟通结构的缩影，软件开发团队想要孵化出优质的产品，必须先打造一个精益的开发团队。开发团队的组织划分是如何影响产品的孵化呢，我们通过下面的示例来进行说明。\n\n如果开发团队是按照业务边界进行划分的，开发出来的产品将可能会是微服务的架构。\n![](http://oi28tswuq.bkt.clouddn.com/images/6.png)\n如果开发团队分为前端团队、后台服务团队和DBA团队，产品将会成长为下面的架构。\n![](http://oi28tswuq.bkt.clouddn.com/images/4.png)\n应用不断迭代，功能日趋完善，开发团队也随之壮大。虽然现在有些人比较推崇全栈工程师，一位全栈工程师就能支持前后端的所有开发。但是试想一下，如果在开发团队中前后端开发分隔不清，职责边界模糊不明，代码均由相同的工程师完成，长此以往前后端代码的耦合程度可想而知。\n\n通过将开发团队前后端分离化，让前后端工程师只需要专注于前端或后端的开发工作，使得前后端工程师分别自治，培养其独特的技术特性，然后构建出一个全栈式的精益开发团队。这样的开发团队能够快速应对需求的变更以及市场的复杂多变，打造出架构清晰、前后端并重的优质产品。\n\n#### 提升开发效率\n\n传统开发模式中，前后端开发强依赖。需要前端工程师先完成静态页面的Demo，后端工程师才能将页面Demo翻译成VM模板，如果前端页面出现变动，又会需要前后端工程师再走一次开发流程，如此一来开发效率将会变得很低。\n\n前后端分离以后，可以实现前后端代码的解耦，只要前后端沟通约定好应用所需接口以及接口参数，便可以开始并行开发，无需等待对方的开发工作结束。与此同时，即使需求发生变更，只要接口与数据格式不变，后端开发人员就不需要修改代码，只要前端进行变动即可。如此一来整个应用的开发效率必然会有质的提升。\n\n#### 完美应对复杂多变的前端需求\n\nWeb应用的用户体验关注度与日俱增，使得应用的前端界面需要有华丽酷炫的外观，简单易用的操作，变化多样的界面设计和个性化的自定义展示。这使得前端开始变重，逻辑复杂程度加大，渲染效果多样化加剧。\n\n移动终端的大范围普及，让应用向着多终端化发展，这就要求前端页面需要对不同终端的显示都能进行配适。\n\n传统开发模式中，前后端工程师开发职责不明确，面对复杂多变的前端需求，开发团队势必会变得捉襟见肘、不堪重负。\n\n如果开发团队能完成前后端分离的转型，打造优秀的前后端团队，开发独立化，让开发人员做到专注专精，开发能力必然会有所提升，能够完美应对各种复杂多变的前端需求。\n\n#### 增强代码可维护性\n\n前后端分离后，应用的代码不再是前后端混合，只有在运行期才会有调用依赖关系。应用代码将会变得整洁清晰，不论是代码阅读还是代码维护都会比以前轻松。\n![](http://oi28tswuq.bkt.clouddn.com/images/7.png)\n### 三、我要不要“离”：4种场景\n\n然而任何一项技术都不是银弹，前后端分离也是如此。虽然前后端分离架构能带来众多优势，但终究得建立在开发团队适合的基础之上。我们暂且以前端页面的渲染效果与逻辑复杂程度把Web应用大致分为轻前端、重前端、前后均衡三种类型，然后加上现在热门的微服务架构应用，一起探讨一下什么样的Web应用适合进行前后端分离。\n\n#### 轻前端\n页面布局简单，颜色、字体类型较少\n对前端界面的渲染效果没有高要求，无动画效果\n只有少量、简单的业务逻辑\n只需要在不同终端上布局能适应\n\n对于这样对前端渲染要求不高，业务逻辑简单的轻前端应用来说，因为涉及到的前端技术并不复杂，所以没必要追求前后端分离。将前后端代码放到一起，反而更方便进行开发，但是在开发过程中需要做到关注点分离（Separate Concern）。\n\n#### 重前端\n页面布局复杂，使用了多种颜色和字体\n需要有较高的页面渲染效果，有大量动画\n前端页面中包含有复杂业务逻辑\n需要在不同终端和浏览器上保证布局适应和渲染效果\n\n对于重前端应用，建议采用前后端分离架构，如果开发团队中前端工程师不足，需要尽早完善前端团队的建设，确保前后端并重。\n\n#### 前后均衡\n页面布局适中，使用的颜色和字体种类不多\n页面中使用了少许动画效果\n业务逻辑较为简单，可下沉到后端实现\n只需要在不同终端上布局能适应\n\n对于前后端均衡应用，建议综合团队的人员结构和未来发展方向进行考虑。如果在团队中前端工程师的占比不高，后续也没有继续发展前端的计划，那么就不建议过于追求前后端分离。如果对未来有更高期望，即使在前端工程师占比不高的情况下，依然建议团队尝试前后端分离转型，开始着手培养合适的前端工程师。如果团队中已经有了相当规模的前端工程师，建议立即转向前后端分离，并且尽早做到前后端代码分离，为前端提供一个可以进行开发调试的伪后端。\n\n#### 微服务架构应用\n微服务架构应用由大量微服务提供者构成，共同为用户提供服务。在微服务架构中，很多微服务提供者都是基于SpringBoot实现的，通过API Getway（API网关）进行微服务的整合，然后在一个统一的前端门户上为用户提供所需服务。\n\n微服务基于SpringBoot开发，要达到快速交付的目的，并且每个微服务的粒度都比较小，这必然需要微服务的前后端由不同的工程师分别实现，然后相互之间使用Restful进行通讯。如果还是沿用之前的开发模式，将会增大微服务架构应用的构建难度。而前后段分离模式正是解决这一难题的良药。\n\n### 四、分离部署方案浅析\n\n前后端开发分离之后，应用在部署时也需要进行前后端分离。在进行前后端分离方案选择的时候，需要结合项目的需求情况和用户群体来考虑。目前业内较为常用的前后端分离部署方案有如下几种。\n\n#### 1、Nginx+Server\n\n将前端资源部署在Nginx上，后端服务部署在常规的服务器。当浏览器发起访问请求的时候，如果请求的是页面资源，Nginx直接把资源返回到前端；如果请求是调用后端服务，则经过Nginx转发到后端服务器，完成响应后经Nginx返回到浏览器。\n![](http://oi28tswuq.bkt.clouddn.com/images/8.png)\n这个方案比较简单，易于实现，而且能达到前后端解耦的目的。\n\n但是对于页面量比较大，需要有良好SEO的应用来说，此方案缺点也较为明显。因为Nginx只是向浏览器返回页面静态资源，而国内的搜索引擎爬虫只会抓取静态数据，不会解析页面中的js，这使得应用得不到良好的搜索引擎支持。同时因为Nginx不会进行页面的组装渲染，需要把静态页面返回到浏览器，然后完成渲染工作，这加重了浏览器的渲染负担。\n\n#### 2、Node+Server\n\n这是淘宝所使用的前后端分离模式，在浏览器与后端服务器之间增加一个了Node Server作为中间层，将前端资源部署到Node Server中。Node Server中还包含了一层Model Proxy，负责与服务端进行通信。\n![](http://oi28tswuq.bkt.clouddn.com/images/10.png)\n浏览器发出的请求都被Node Server接收，然后通过Model Proxy调用后端服务器提供的服务。Node Server得到后端服务器反馈，接着在Node Server中完成页面的组装渲染，把最终页面返回给浏览器。\n\n如此一来不仅达到了前后端解耦的目的，还解决了浏览器渲染负担过重的问题，为SEO提供了比较好的支持。\n\n但在这样的模式中，浏览器所有发出的请求都需要经过Node Server进行中转，然后才能到达后端服务器。在实际的应用中，并不是所有的请求都需要页面渲染，只要在页面上直接调用后端服务器提供的服务即可。所以这个模式必然会对请求性能有所消耗\n\n#### 3、Nginx+Node+Server\n\n为了能解决方案2中请求性能损失的问题，我们可以考虑在其基础之上增加Nginx。浏览器发起的请求经过Nginx进行分发，URL请求统一分发到Node Server，在Node Server中进行页面组装渲染；API请求则直接发送到后端服务器，完成响应。\n\n目前在已经有一个名为Goku的Go语言框架提供了这样的前后端分离解决方案。\n![](http://oi28tswuq.bkt.clouddn.com/images/1.png)\n通过对三种前后端分离方案的对比可以看出：\n\n如果是企业级应用，不需要考虑对SEO的支持，浏览器渲染也可以忽略不计，Nginx+Server的模式无疑是最好的选择，实施成本相对来说比较低；\n\n如果是互联网应用，需要有良好的SEO支持，页面渲染工作量大，那应该选择Nginx+Node+Server的方案，各个方面都能得到比较好的兼顾。\n![](http://oi28tswuq.bkt.clouddn.com/images/9.png)\n### 五、总结\n\n前后端分离并非仅仅只是前后端开发的分工，而是在开发期进行代码存放分离、前后端开发职责分离，前后端能够独立进行开发测试；在运行期进行应用部署分离，前后端之间通过HTTP请求进行通讯。前后端分离的开发模式与传统模式相比，能为我们提升开发效率、增强代码可维护性，让我们有规划地打造一个前后端并重的精益开发团队，更好地应对越来越复杂多变的Web应用开发需求。\n\n传统的前后端混合开发模式，虽然久经考验，到现在依然还是能支撑起应用的开发。但是放眼未来，应用的云化、微服务化势不可挡。同社会分工精细化一样，前后端开发的精细化也是必然趋势。技术在持续进步，架构在不断演进，只有紧跟发展的脚步，不断调整项目管理方式，软件开发模式，才能在互联网浪潮中把握机会，乘风破浪。\n\n前后端分离，是为了让彼此更好。\n\n文章来源网络，版权归作者所有，作者：敖显奇@EAII企业架构创新研究院(eaworld)","source":"_posts/qianhouduanfenli.md","raw":"---\ntitle: 前后端分离，是为了彼此更好\ndate: 2016-7-16 12:41:23\ntags: 前后端分享\n---\n### 一、被误解的前后端分离\n\n在Web应用开发过程中，业界对前后端的分界线似乎一直都没有确定的概念，不过大多数人以浏览器作为前后端的分界线。将浏览器中为用户进行页面展示的部分称为前端，而将运行于服务器，为前端提供业务逻辑和数据准备的所有代码统称为后端。\n\n虽然前后端分离在数年前就已经开始受到关注，但很多人对它却是只闻其声，未见其形，所以对它产生了一些误解，误以为前后段分离只是一种Web应用的开发模式，只要在Web应用的开发期进行了前后端开发工作的分工就是前后端分离。\n\n其实并非如此，准确的说，前后端分离并不只是开发模式，而是Web应用的一种架构模式。在开发期，前后端工程师可以通过约定好交互接口，实现并行开发；在运行期，前后端分离模式需要对Web应用进行分离部署，前后端之间使用HTTP请求进行交互。然而作为应用的架构模式，前后端分离并不是通过这样一句话就能一概而谈的，我们可以从交互形式、代码组织方式、开发模式三个方面对前后端分离进行认识。\n![](http://oi28tswuq.bkt.clouddn.com/images/2.png)\n在前后端分离架构中，后端只需要负责按照约定的数据格式向前端提供可调用的API服务即可。前后端之间通过HTTP请求进行交互，前端获取到数据后，进行页面的装配和渲染。\n![](http://oi28tswuq.bkt.clouddn.com/images/5.png)\n在传统架构模式中，前后端代码存放于同一个代码库中，甚至是同一工程目录下。页面中还夹杂着后端代码。前后端工程师进行开发时，都必须把整个项目导入到开发工具中。\n\n而前后端分离模式在代码组织形式上有以下两种：\n\n#### 半分离\n前后端共用一个代码库，但是代码分别存放在两个工程中。后端不关心或很少关心前端元素的输出情况，前端不能独立进行开发和测试，项目中缺乏前后端交互的测试用例。\n\n#### 分离\n前后端代码库分离，前端代码中有可以进行Mock测试（通过构造虚拟测试对象以简化测试环境的方法）的伪后端，能支持前端的独立开发和测试。而后端代码中除了功能实现外，还有着详细的测试用例，以保证API的可用性，降低集成风险。\n\n#### 3、开发模式\n\n传统的MVC架构开发，没有进行前后端分离，前端工程师负责编写HTML，完成前端页面设计，然后给后端工程师员套界面，使用模板技术将前端代码转换成JSP页面，同时内嵌java代码。应用运行期，将全部代码进行打包，部署到同一服务器上，或者进行简单的动静态分离部署。\n\n此时，应用的开发流程如下图所示。\n![](http://oi28tswuq.bkt.clouddn.com/images/11.png)\n在前后端分离架构中，前端工程师只需要编写HTML、js、CSS等前端资源，然后通过HTTP请求调用后端提供的服务即可。除了开发期的分离，在运行期前后端资源也会进行分离部署。\n\n前后端分离之后，开发流程将如下图所示。\n![](http://oi28tswuq.bkt.clouddn.com/images/3.png)\n通过上面的两幅流程图，不难发现，在开发模式上，前后端分离不仅仅只是工程师的分工开发，更重要的意义在于实现了前后端的并行开发，和简化了开发流程。\n### 二、为什么要“离”：4个好处\n\n重新认识前后端分离之后，想必大家心里都会有疑问，前后端分离模式与之前的Web应用架构相比可谓是大相径庭，我们为什么要进行前后端分离呢？正如莎士比亚在《哈姆雷特》中的经典名句一样，分还是不分，这是个问题。\n\n从目前应用软件的发展趋势来看，一方面，用户越来越注重软件的体验感，随着互联网的蓬勃发展，应用开始走向多终端化；另一方面，大型应用的架构模式正纷纷向着云化、微服务化发展。\n\n虽然过去的应用架构暂时还能支撑起当下应用的开发，但是各种弊端已经开始浮出水面，几年前能带来开发便捷优势的前后端代码混合模式，在当下已经成为了拖慢我们前进步伐的泥沼，让我们屡屡吃痛。我们之所以开始尝试前后端分离，是为了能在未来获得更好的发展，期望通过前后端分离架构，来为我们带来以下4个方面的提升。\n\n为孵化优质产品打造精益团队\n\n正如康威定律所述，产品是组织沟通结构的缩影，软件开发团队想要孵化出优质的产品，必须先打造一个精益的开发团队。开发团队的组织划分是如何影响产品的孵化呢，我们通过下面的示例来进行说明。\n\n如果开发团队是按照业务边界进行划分的，开发出来的产品将可能会是微服务的架构。\n![](http://oi28tswuq.bkt.clouddn.com/images/6.png)\n如果开发团队分为前端团队、后台服务团队和DBA团队，产品将会成长为下面的架构。\n![](http://oi28tswuq.bkt.clouddn.com/images/4.png)\n应用不断迭代，功能日趋完善，开发团队也随之壮大。虽然现在有些人比较推崇全栈工程师，一位全栈工程师就能支持前后端的所有开发。但是试想一下，如果在开发团队中前后端开发分隔不清，职责边界模糊不明，代码均由相同的工程师完成，长此以往前后端代码的耦合程度可想而知。\n\n通过将开发团队前后端分离化，让前后端工程师只需要专注于前端或后端的开发工作，使得前后端工程师分别自治，培养其独特的技术特性，然后构建出一个全栈式的精益开发团队。这样的开发团队能够快速应对需求的变更以及市场的复杂多变，打造出架构清晰、前后端并重的优质产品。\n\n#### 提升开发效率\n\n传统开发模式中，前后端开发强依赖。需要前端工程师先完成静态页面的Demo，后端工程师才能将页面Demo翻译成VM模板，如果前端页面出现变动，又会需要前后端工程师再走一次开发流程，如此一来开发效率将会变得很低。\n\n前后端分离以后，可以实现前后端代码的解耦，只要前后端沟通约定好应用所需接口以及接口参数，便可以开始并行开发，无需等待对方的开发工作结束。与此同时，即使需求发生变更，只要接口与数据格式不变，后端开发人员就不需要修改代码，只要前端进行变动即可。如此一来整个应用的开发效率必然会有质的提升。\n\n#### 完美应对复杂多变的前端需求\n\nWeb应用的用户体验关注度与日俱增，使得应用的前端界面需要有华丽酷炫的外观，简单易用的操作，变化多样的界面设计和个性化的自定义展示。这使得前端开始变重，逻辑复杂程度加大，渲染效果多样化加剧。\n\n移动终端的大范围普及，让应用向着多终端化发展，这就要求前端页面需要对不同终端的显示都能进行配适。\n\n传统开发模式中，前后端工程师开发职责不明确，面对复杂多变的前端需求，开发团队势必会变得捉襟见肘、不堪重负。\n\n如果开发团队能完成前后端分离的转型，打造优秀的前后端团队，开发独立化，让开发人员做到专注专精，开发能力必然会有所提升，能够完美应对各种复杂多变的前端需求。\n\n#### 增强代码可维护性\n\n前后端分离后，应用的代码不再是前后端混合，只有在运行期才会有调用依赖关系。应用代码将会变得整洁清晰，不论是代码阅读还是代码维护都会比以前轻松。\n![](http://oi28tswuq.bkt.clouddn.com/images/7.png)\n### 三、我要不要“离”：4种场景\n\n然而任何一项技术都不是银弹，前后端分离也是如此。虽然前后端分离架构能带来众多优势，但终究得建立在开发团队适合的基础之上。我们暂且以前端页面的渲染效果与逻辑复杂程度把Web应用大致分为轻前端、重前端、前后均衡三种类型，然后加上现在热门的微服务架构应用，一起探讨一下什么样的Web应用适合进行前后端分离。\n\n#### 轻前端\n页面布局简单，颜色、字体类型较少\n对前端界面的渲染效果没有高要求，无动画效果\n只有少量、简单的业务逻辑\n只需要在不同终端上布局能适应\n\n对于这样对前端渲染要求不高，业务逻辑简单的轻前端应用来说，因为涉及到的前端技术并不复杂，所以没必要追求前后端分离。将前后端代码放到一起，反而更方便进行开发，但是在开发过程中需要做到关注点分离（Separate Concern）。\n\n#### 重前端\n页面布局复杂，使用了多种颜色和字体\n需要有较高的页面渲染效果，有大量动画\n前端页面中包含有复杂业务逻辑\n需要在不同终端和浏览器上保证布局适应和渲染效果\n\n对于重前端应用，建议采用前后端分离架构，如果开发团队中前端工程师不足，需要尽早完善前端团队的建设，确保前后端并重。\n\n#### 前后均衡\n页面布局适中，使用的颜色和字体种类不多\n页面中使用了少许动画效果\n业务逻辑较为简单，可下沉到后端实现\n只需要在不同终端上布局能适应\n\n对于前后端均衡应用，建议综合团队的人员结构和未来发展方向进行考虑。如果在团队中前端工程师的占比不高，后续也没有继续发展前端的计划，那么就不建议过于追求前后端分离。如果对未来有更高期望，即使在前端工程师占比不高的情况下，依然建议团队尝试前后端分离转型，开始着手培养合适的前端工程师。如果团队中已经有了相当规模的前端工程师，建议立即转向前后端分离，并且尽早做到前后端代码分离，为前端提供一个可以进行开发调试的伪后端。\n\n#### 微服务架构应用\n微服务架构应用由大量微服务提供者构成，共同为用户提供服务。在微服务架构中，很多微服务提供者都是基于SpringBoot实现的，通过API Getway（API网关）进行微服务的整合，然后在一个统一的前端门户上为用户提供所需服务。\n\n微服务基于SpringBoot开发，要达到快速交付的目的，并且每个微服务的粒度都比较小，这必然需要微服务的前后端由不同的工程师分别实现，然后相互之间使用Restful进行通讯。如果还是沿用之前的开发模式，将会增大微服务架构应用的构建难度。而前后段分离模式正是解决这一难题的良药。\n\n### 四、分离部署方案浅析\n\n前后端开发分离之后，应用在部署时也需要进行前后端分离。在进行前后端分离方案选择的时候，需要结合项目的需求情况和用户群体来考虑。目前业内较为常用的前后端分离部署方案有如下几种。\n\n#### 1、Nginx+Server\n\n将前端资源部署在Nginx上，后端服务部署在常规的服务器。当浏览器发起访问请求的时候，如果请求的是页面资源，Nginx直接把资源返回到前端；如果请求是调用后端服务，则经过Nginx转发到后端服务器，完成响应后经Nginx返回到浏览器。\n![](http://oi28tswuq.bkt.clouddn.com/images/8.png)\n这个方案比较简单，易于实现，而且能达到前后端解耦的目的。\n\n但是对于页面量比较大，需要有良好SEO的应用来说，此方案缺点也较为明显。因为Nginx只是向浏览器返回页面静态资源，而国内的搜索引擎爬虫只会抓取静态数据，不会解析页面中的js，这使得应用得不到良好的搜索引擎支持。同时因为Nginx不会进行页面的组装渲染，需要把静态页面返回到浏览器，然后完成渲染工作，这加重了浏览器的渲染负担。\n\n#### 2、Node+Server\n\n这是淘宝所使用的前后端分离模式，在浏览器与后端服务器之间增加一个了Node Server作为中间层，将前端资源部署到Node Server中。Node Server中还包含了一层Model Proxy，负责与服务端进行通信。\n![](http://oi28tswuq.bkt.clouddn.com/images/10.png)\n浏览器发出的请求都被Node Server接收，然后通过Model Proxy调用后端服务器提供的服务。Node Server得到后端服务器反馈，接着在Node Server中完成页面的组装渲染，把最终页面返回给浏览器。\n\n如此一来不仅达到了前后端解耦的目的，还解决了浏览器渲染负担过重的问题，为SEO提供了比较好的支持。\n\n但在这样的模式中，浏览器所有发出的请求都需要经过Node Server进行中转，然后才能到达后端服务器。在实际的应用中，并不是所有的请求都需要页面渲染，只要在页面上直接调用后端服务器提供的服务即可。所以这个模式必然会对请求性能有所消耗\n\n#### 3、Nginx+Node+Server\n\n为了能解决方案2中请求性能损失的问题，我们可以考虑在其基础之上增加Nginx。浏览器发起的请求经过Nginx进行分发，URL请求统一分发到Node Server，在Node Server中进行页面组装渲染；API请求则直接发送到后端服务器，完成响应。\n\n目前在已经有一个名为Goku的Go语言框架提供了这样的前后端分离解决方案。\n![](http://oi28tswuq.bkt.clouddn.com/images/1.png)\n通过对三种前后端分离方案的对比可以看出：\n\n如果是企业级应用，不需要考虑对SEO的支持，浏览器渲染也可以忽略不计，Nginx+Server的模式无疑是最好的选择，实施成本相对来说比较低；\n\n如果是互联网应用，需要有良好的SEO支持，页面渲染工作量大，那应该选择Nginx+Node+Server的方案，各个方面都能得到比较好的兼顾。\n![](http://oi28tswuq.bkt.clouddn.com/images/9.png)\n### 五、总结\n\n前后端分离并非仅仅只是前后端开发的分工，而是在开发期进行代码存放分离、前后端开发职责分离，前后端能够独立进行开发测试；在运行期进行应用部署分离，前后端之间通过HTTP请求进行通讯。前后端分离的开发模式与传统模式相比，能为我们提升开发效率、增强代码可维护性，让我们有规划地打造一个前后端并重的精益开发团队，更好地应对越来越复杂多变的Web应用开发需求。\n\n传统的前后端混合开发模式，虽然久经考验，到现在依然还是能支撑起应用的开发。但是放眼未来，应用的云化、微服务化势不可挡。同社会分工精细化一样，前后端开发的精细化也是必然趋势。技术在持续进步，架构在不断演进，只有紧跟发展的脚步，不断调整项目管理方式，软件开发模式，才能在互联网浪潮中把握机会，乘风破浪。\n\n前后端分离，是为了让彼此更好。\n\n文章来源网络，版权归作者所有，作者：敖显奇@EAII企业架构创新研究院(eaworld)","slug":"qianhouduanfenli","published":1,"updated":"2016-12-12T14:21:26.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv8x002rjgtuwld6lc1f","content":"<h3 id=\"一、被误解的前后端分离\"><a href=\"#一、被误解的前后端分离\" class=\"headerlink\" title=\"一、被误解的前后端分离\"></a>一、被误解的前后端分离</h3><p>在Web应用开发过程中，业界对前后端的分界线似乎一直都没有确定的概念，不过大多数人以浏览器作为前后端的分界线。将浏览器中为用户进行页面展示的部分称为前端，而将运行于服务器，为前端提供业务逻辑和数据准备的所有代码统称为后端。</p>\n<p>虽然前后端分离在数年前就已经开始受到关注，但很多人对它却是只闻其声，未见其形，所以对它产生了一些误解，误以为前后段分离只是一种Web应用的开发模式，只要在Web应用的开发期进行了前后端开发工作的分工就是前后端分离。</p>\n<p>其实并非如此，准确的说，前后端分离并不只是开发模式，而是Web应用的一种架构模式。在开发期，前后端工程师可以通过约定好交互接口，实现并行开发；在运行期，前后端分离模式需要对Web应用进行分离部署，前后端之间使用HTTP请求进行交互。然而作为应用的架构模式，前后端分离并不是通过这样一句话就能一概而谈的，我们可以从交互形式、代码组织方式、开发模式三个方面对前后端分离进行认识。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/2.png\" alt=\"\"><br>在前后端分离架构中，后端只需要负责按照约定的数据格式向前端提供可调用的API服务即可。前后端之间通过HTTP请求进行交互，前端获取到数据后，进行页面的装配和渲染。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/5.png\" alt=\"\"><br>在传统架构模式中，前后端代码存放于同一个代码库中，甚至是同一工程目录下。页面中还夹杂着后端代码。前后端工程师进行开发时，都必须把整个项目导入到开发工具中。</p>\n<p>而前后端分离模式在代码组织形式上有以下两种：</p>\n<h4 id=\"半分离\"><a href=\"#半分离\" class=\"headerlink\" title=\"半分离\"></a>半分离</h4><p>前后端共用一个代码库，但是代码分别存放在两个工程中。后端不关心或很少关心前端元素的输出情况，前端不能独立进行开发和测试，项目中缺乏前后端交互的测试用例。</p>\n<h4 id=\"分离\"><a href=\"#分离\" class=\"headerlink\" title=\"分离\"></a>分离</h4><p>前后端代码库分离，前端代码中有可以进行Mock测试（通过构造虚拟测试对象以简化测试环境的方法）的伪后端，能支持前端的独立开发和测试。而后端代码中除了功能实现外，还有着详细的测试用例，以保证API的可用性，降低集成风险。</p>\n<h4 id=\"3、开发模式\"><a href=\"#3、开发模式\" class=\"headerlink\" title=\"3、开发模式\"></a>3、开发模式</h4><p>传统的MVC架构开发，没有进行前后端分离，前端工程师负责编写HTML，完成前端页面设计，然后给后端工程师员套界面，使用模板技术将前端代码转换成JSP页面，同时内嵌java代码。应用运行期，将全部代码进行打包，部署到同一服务器上，或者进行简单的动静态分离部署。</p>\n<p>此时，应用的开发流程如下图所示。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/11.png\" alt=\"\"><br>在前后端分离架构中，前端工程师只需要编写HTML、js、CSS等前端资源，然后通过HTTP请求调用后端提供的服务即可。除了开发期的分离，在运行期前后端资源也会进行分离部署。</p>\n<p>前后端分离之后，开发流程将如下图所示。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/3.png\" alt=\"\"><br>通过上面的两幅流程图，不难发现，在开发模式上，前后端分离不仅仅只是工程师的分工开发，更重要的意义在于实现了前后端的并行开发，和简化了开发流程。</p>\n<h3 id=\"二、为什么要“离”：4个好处\"><a href=\"#二、为什么要“离”：4个好处\" class=\"headerlink\" title=\"二、为什么要“离”：4个好处\"></a>二、为什么要“离”：4个好处</h3><p>重新认识前后端分离之后，想必大家心里都会有疑问，前后端分离模式与之前的Web应用架构相比可谓是大相径庭，我们为什么要进行前后端分离呢？正如莎士比亚在《哈姆雷特》中的经典名句一样，分还是不分，这是个问题。</p>\n<p>从目前应用软件的发展趋势来看，一方面，用户越来越注重软件的体验感，随着互联网的蓬勃发展，应用开始走向多终端化；另一方面，大型应用的架构模式正纷纷向着云化、微服务化发展。</p>\n<p>虽然过去的应用架构暂时还能支撑起当下应用的开发，但是各种弊端已经开始浮出水面，几年前能带来开发便捷优势的前后端代码混合模式，在当下已经成为了拖慢我们前进步伐的泥沼，让我们屡屡吃痛。我们之所以开始尝试前后端分离，是为了能在未来获得更好的发展，期望通过前后端分离架构，来为我们带来以下4个方面的提升。</p>\n<p>为孵化优质产品打造精益团队</p>\n<p>正如康威定律所述，产品是组织沟通结构的缩影，软件开发团队想要孵化出优质的产品，必须先打造一个精益的开发团队。开发团队的组织划分是如何影响产品的孵化呢，我们通过下面的示例来进行说明。</p>\n<p>如果开发团队是按照业务边界进行划分的，开发出来的产品将可能会是微服务的架构。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/6.png\" alt=\"\"><br>如果开发团队分为前端团队、后台服务团队和DBA团队，产品将会成长为下面的架构。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/4.png\" alt=\"\"><br>应用不断迭代，功能日趋完善，开发团队也随之壮大。虽然现在有些人比较推崇全栈工程师，一位全栈工程师就能支持前后端的所有开发。但是试想一下，如果在开发团队中前后端开发分隔不清，职责边界模糊不明，代码均由相同的工程师完成，长此以往前后端代码的耦合程度可想而知。</p>\n<p>通过将开发团队前后端分离化，让前后端工程师只需要专注于前端或后端的开发工作，使得前后端工程师分别自治，培养其独特的技术特性，然后构建出一个全栈式的精益开发团队。这样的开发团队能够快速应对需求的变更以及市场的复杂多变，打造出架构清晰、前后端并重的优质产品。</p>\n<h4 id=\"提升开发效率\"><a href=\"#提升开发效率\" class=\"headerlink\" title=\"提升开发效率\"></a>提升开发效率</h4><p>传统开发模式中，前后端开发强依赖。需要前端工程师先完成静态页面的Demo，后端工程师才能将页面Demo翻译成VM模板，如果前端页面出现变动，又会需要前后端工程师再走一次开发流程，如此一来开发效率将会变得很低。</p>\n<p>前后端分离以后，可以实现前后端代码的解耦，只要前后端沟通约定好应用所需接口以及接口参数，便可以开始并行开发，无需等待对方的开发工作结束。与此同时，即使需求发生变更，只要接口与数据格式不变，后端开发人员就不需要修改代码，只要前端进行变动即可。如此一来整个应用的开发效率必然会有质的提升。</p>\n<h4 id=\"完美应对复杂多变的前端需求\"><a href=\"#完美应对复杂多变的前端需求\" class=\"headerlink\" title=\"完美应对复杂多变的前端需求\"></a>完美应对复杂多变的前端需求</h4><p>Web应用的用户体验关注度与日俱增，使得应用的前端界面需要有华丽酷炫的外观，简单易用的操作，变化多样的界面设计和个性化的自定义展示。这使得前端开始变重，逻辑复杂程度加大，渲染效果多样化加剧。</p>\n<p>移动终端的大范围普及，让应用向着多终端化发展，这就要求前端页面需要对不同终端的显示都能进行配适。</p>\n<p>传统开发模式中，前后端工程师开发职责不明确，面对复杂多变的前端需求，开发团队势必会变得捉襟见肘、不堪重负。</p>\n<p>如果开发团队能完成前后端分离的转型，打造优秀的前后端团队，开发独立化，让开发人员做到专注专精，开发能力必然会有所提升，能够完美应对各种复杂多变的前端需求。</p>\n<h4 id=\"增强代码可维护性\"><a href=\"#增强代码可维护性\" class=\"headerlink\" title=\"增强代码可维护性\"></a>增强代码可维护性</h4><p>前后端分离后，应用的代码不再是前后端混合，只有在运行期才会有调用依赖关系。应用代码将会变得整洁清晰，不论是代码阅读还是代码维护都会比以前轻松。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/7.png\" alt=\"\"></p>\n<h3 id=\"三、我要不要“离”：4种场景\"><a href=\"#三、我要不要“离”：4种场景\" class=\"headerlink\" title=\"三、我要不要“离”：4种场景\"></a>三、我要不要“离”：4种场景</h3><p>然而任何一项技术都不是银弹，前后端分离也是如此。虽然前后端分离架构能带来众多优势，但终究得建立在开发团队适合的基础之上。我们暂且以前端页面的渲染效果与逻辑复杂程度把Web应用大致分为轻前端、重前端、前后均衡三种类型，然后加上现在热门的微服务架构应用，一起探讨一下什么样的Web应用适合进行前后端分离。</p>\n<h4 id=\"轻前端\"><a href=\"#轻前端\" class=\"headerlink\" title=\"轻前端\"></a>轻前端</h4><p>页面布局简单，颜色、字体类型较少<br>对前端界面的渲染效果没有高要求，无动画效果<br>只有少量、简单的业务逻辑<br>只需要在不同终端上布局能适应</p>\n<p>对于这样对前端渲染要求不高，业务逻辑简单的轻前端应用来说，因为涉及到的前端技术并不复杂，所以没必要追求前后端分离。将前后端代码放到一起，反而更方便进行开发，但是在开发过程中需要做到关注点分离（Separate Concern）。</p>\n<h4 id=\"重前端\"><a href=\"#重前端\" class=\"headerlink\" title=\"重前端\"></a>重前端</h4><p>页面布局复杂，使用了多种颜色和字体<br>需要有较高的页面渲染效果，有大量动画<br>前端页面中包含有复杂业务逻辑<br>需要在不同终端和浏览器上保证布局适应和渲染效果</p>\n<p>对于重前端应用，建议采用前后端分离架构，如果开发团队中前端工程师不足，需要尽早完善前端团队的建设，确保前后端并重。</p>\n<h4 id=\"前后均衡\"><a href=\"#前后均衡\" class=\"headerlink\" title=\"前后均衡\"></a>前后均衡</h4><p>页面布局适中，使用的颜色和字体种类不多<br>页面中使用了少许动画效果<br>业务逻辑较为简单，可下沉到后端实现<br>只需要在不同终端上布局能适应</p>\n<p>对于前后端均衡应用，建议综合团队的人员结构和未来发展方向进行考虑。如果在团队中前端工程师的占比不高，后续也没有继续发展前端的计划，那么就不建议过于追求前后端分离。如果对未来有更高期望，即使在前端工程师占比不高的情况下，依然建议团队尝试前后端分离转型，开始着手培养合适的前端工程师。如果团队中已经有了相当规模的前端工程师，建议立即转向前后端分离，并且尽早做到前后端代码分离，为前端提供一个可以进行开发调试的伪后端。</p>\n<h4 id=\"微服务架构应用\"><a href=\"#微服务架构应用\" class=\"headerlink\" title=\"微服务架构应用\"></a>微服务架构应用</h4><p>微服务架构应用由大量微服务提供者构成，共同为用户提供服务。在微服务架构中，很多微服务提供者都是基于SpringBoot实现的，通过API Getway（API网关）进行微服务的整合，然后在一个统一的前端门户上为用户提供所需服务。</p>\n<p>微服务基于SpringBoot开发，要达到快速交付的目的，并且每个微服务的粒度都比较小，这必然需要微服务的前后端由不同的工程师分别实现，然后相互之间使用Restful进行通讯。如果还是沿用之前的开发模式，将会增大微服务架构应用的构建难度。而前后段分离模式正是解决这一难题的良药。</p>\n<h3 id=\"四、分离部署方案浅析\"><a href=\"#四、分离部署方案浅析\" class=\"headerlink\" title=\"四、分离部署方案浅析\"></a>四、分离部署方案浅析</h3><p>前后端开发分离之后，应用在部署时也需要进行前后端分离。在进行前后端分离方案选择的时候，需要结合项目的需求情况和用户群体来考虑。目前业内较为常用的前后端分离部署方案有如下几种。</p>\n<h4 id=\"1、Nginx-Server\"><a href=\"#1、Nginx-Server\" class=\"headerlink\" title=\"1、Nginx+Server\"></a>1、Nginx+Server</h4><p>将前端资源部署在Nginx上，后端服务部署在常规的服务器。当浏览器发起访问请求的时候，如果请求的是页面资源，Nginx直接把资源返回到前端；如果请求是调用后端服务，则经过Nginx转发到后端服务器，完成响应后经Nginx返回到浏览器。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/8.png\" alt=\"\"><br>这个方案比较简单，易于实现，而且能达到前后端解耦的目的。</p>\n<p>但是对于页面量比较大，需要有良好SEO的应用来说，此方案缺点也较为明显。因为Nginx只是向浏览器返回页面静态资源，而国内的搜索引擎爬虫只会抓取静态数据，不会解析页面中的js，这使得应用得不到良好的搜索引擎支持。同时因为Nginx不会进行页面的组装渲染，需要把静态页面返回到浏览器，然后完成渲染工作，这加重了浏览器的渲染负担。</p>\n<h4 id=\"2、Node-Server\"><a href=\"#2、Node-Server\" class=\"headerlink\" title=\"2、Node+Server\"></a>2、Node+Server</h4><p>这是淘宝所使用的前后端分离模式，在浏览器与后端服务器之间增加一个了Node Server作为中间层，将前端资源部署到Node Server中。Node Server中还包含了一层Model Proxy，负责与服务端进行通信。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/10.png\" alt=\"\"><br>浏览器发出的请求都被Node Server接收，然后通过Model Proxy调用后端服务器提供的服务。Node Server得到后端服务器反馈，接着在Node Server中完成页面的组装渲染，把最终页面返回给浏览器。</p>\n<p>如此一来不仅达到了前后端解耦的目的，还解决了浏览器渲染负担过重的问题，为SEO提供了比较好的支持。</p>\n<p>但在这样的模式中，浏览器所有发出的请求都需要经过Node Server进行中转，然后才能到达后端服务器。在实际的应用中，并不是所有的请求都需要页面渲染，只要在页面上直接调用后端服务器提供的服务即可。所以这个模式必然会对请求性能有所消耗</p>\n<h4 id=\"3、Nginx-Node-Server\"><a href=\"#3、Nginx-Node-Server\" class=\"headerlink\" title=\"3、Nginx+Node+Server\"></a>3、Nginx+Node+Server</h4><p>为了能解决方案2中请求性能损失的问题，我们可以考虑在其基础之上增加Nginx。浏览器发起的请求经过Nginx进行分发，URL请求统一分发到Node Server，在Node Server中进行页面组装渲染；API请求则直接发送到后端服务器，完成响应。</p>\n<p>目前在已经有一个名为Goku的Go语言框架提供了这样的前后端分离解决方案。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/1.png\" alt=\"\"><br>通过对三种前后端分离方案的对比可以看出：</p>\n<p>如果是企业级应用，不需要考虑对SEO的支持，浏览器渲染也可以忽略不计，Nginx+Server的模式无疑是最好的选择，实施成本相对来说比较低；</p>\n<p>如果是互联网应用，需要有良好的SEO支持，页面渲染工作量大，那应该选择Nginx+Node+Server的方案，各个方面都能得到比较好的兼顾。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/9.png\" alt=\"\"></p>\n<h3 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h3><p>前后端分离并非仅仅只是前后端开发的分工，而是在开发期进行代码存放分离、前后端开发职责分离，前后端能够独立进行开发测试；在运行期进行应用部署分离，前后端之间通过HTTP请求进行通讯。前后端分离的开发模式与传统模式相比，能为我们提升开发效率、增强代码可维护性，让我们有规划地打造一个前后端并重的精益开发团队，更好地应对越来越复杂多变的Web应用开发需求。</p>\n<p>传统的前后端混合开发模式，虽然久经考验，到现在依然还是能支撑起应用的开发。但是放眼未来，应用的云化、微服务化势不可挡。同社会分工精细化一样，前后端开发的精细化也是必然趋势。技术在持续进步，架构在不断演进，只有紧跟发展的脚步，不断调整项目管理方式，软件开发模式，才能在互联网浪潮中把握机会，乘风破浪。</p>\n<p>前后端分离，是为了让彼此更好。</p>\n<p>文章来源网络，版权归作者所有，作者：敖显奇@EAII企业架构创新研究院(eaworld)</p>\n","excerpt":"","more":"<h3 id=\"一、被误解的前后端分离\"><a href=\"#一、被误解的前后端分离\" class=\"headerlink\" title=\"一、被误解的前后端分离\"></a>一、被误解的前后端分离</h3><p>在Web应用开发过程中，业界对前后端的分界线似乎一直都没有确定的概念，不过大多数人以浏览器作为前后端的分界线。将浏览器中为用户进行页面展示的部分称为前端，而将运行于服务器，为前端提供业务逻辑和数据准备的所有代码统称为后端。</p>\n<p>虽然前后端分离在数年前就已经开始受到关注，但很多人对它却是只闻其声，未见其形，所以对它产生了一些误解，误以为前后段分离只是一种Web应用的开发模式，只要在Web应用的开发期进行了前后端开发工作的分工就是前后端分离。</p>\n<p>其实并非如此，准确的说，前后端分离并不只是开发模式，而是Web应用的一种架构模式。在开发期，前后端工程师可以通过约定好交互接口，实现并行开发；在运行期，前后端分离模式需要对Web应用进行分离部署，前后端之间使用HTTP请求进行交互。然而作为应用的架构模式，前后端分离并不是通过这样一句话就能一概而谈的，我们可以从交互形式、代码组织方式、开发模式三个方面对前后端分离进行认识。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/2.png\" alt=\"\"><br>在前后端分离架构中，后端只需要负责按照约定的数据格式向前端提供可调用的API服务即可。前后端之间通过HTTP请求进行交互，前端获取到数据后，进行页面的装配和渲染。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/5.png\" alt=\"\"><br>在传统架构模式中，前后端代码存放于同一个代码库中，甚至是同一工程目录下。页面中还夹杂着后端代码。前后端工程师进行开发时，都必须把整个项目导入到开发工具中。</p>\n<p>而前后端分离模式在代码组织形式上有以下两种：</p>\n<h4 id=\"半分离\"><a href=\"#半分离\" class=\"headerlink\" title=\"半分离\"></a>半分离</h4><p>前后端共用一个代码库，但是代码分别存放在两个工程中。后端不关心或很少关心前端元素的输出情况，前端不能独立进行开发和测试，项目中缺乏前后端交互的测试用例。</p>\n<h4 id=\"分离\"><a href=\"#分离\" class=\"headerlink\" title=\"分离\"></a>分离</h4><p>前后端代码库分离，前端代码中有可以进行Mock测试（通过构造虚拟测试对象以简化测试环境的方法）的伪后端，能支持前端的独立开发和测试。而后端代码中除了功能实现外，还有着详细的测试用例，以保证API的可用性，降低集成风险。</p>\n<h4 id=\"3、开发模式\"><a href=\"#3、开发模式\" class=\"headerlink\" title=\"3、开发模式\"></a>3、开发模式</h4><p>传统的MVC架构开发，没有进行前后端分离，前端工程师负责编写HTML，完成前端页面设计，然后给后端工程师员套界面，使用模板技术将前端代码转换成JSP页面，同时内嵌java代码。应用运行期，将全部代码进行打包，部署到同一服务器上，或者进行简单的动静态分离部署。</p>\n<p>此时，应用的开发流程如下图所示。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/11.png\" alt=\"\"><br>在前后端分离架构中，前端工程师只需要编写HTML、js、CSS等前端资源，然后通过HTTP请求调用后端提供的服务即可。除了开发期的分离，在运行期前后端资源也会进行分离部署。</p>\n<p>前后端分离之后，开发流程将如下图所示。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/3.png\" alt=\"\"><br>通过上面的两幅流程图，不难发现，在开发模式上，前后端分离不仅仅只是工程师的分工开发，更重要的意义在于实现了前后端的并行开发，和简化了开发流程。</p>\n<h3 id=\"二、为什么要“离”：4个好处\"><a href=\"#二、为什么要“离”：4个好处\" class=\"headerlink\" title=\"二、为什么要“离”：4个好处\"></a>二、为什么要“离”：4个好处</h3><p>重新认识前后端分离之后，想必大家心里都会有疑问，前后端分离模式与之前的Web应用架构相比可谓是大相径庭，我们为什么要进行前后端分离呢？正如莎士比亚在《哈姆雷特》中的经典名句一样，分还是不分，这是个问题。</p>\n<p>从目前应用软件的发展趋势来看，一方面，用户越来越注重软件的体验感，随着互联网的蓬勃发展，应用开始走向多终端化；另一方面，大型应用的架构模式正纷纷向着云化、微服务化发展。</p>\n<p>虽然过去的应用架构暂时还能支撑起当下应用的开发，但是各种弊端已经开始浮出水面，几年前能带来开发便捷优势的前后端代码混合模式，在当下已经成为了拖慢我们前进步伐的泥沼，让我们屡屡吃痛。我们之所以开始尝试前后端分离，是为了能在未来获得更好的发展，期望通过前后端分离架构，来为我们带来以下4个方面的提升。</p>\n<p>为孵化优质产品打造精益团队</p>\n<p>正如康威定律所述，产品是组织沟通结构的缩影，软件开发团队想要孵化出优质的产品，必须先打造一个精益的开发团队。开发团队的组织划分是如何影响产品的孵化呢，我们通过下面的示例来进行说明。</p>\n<p>如果开发团队是按照业务边界进行划分的，开发出来的产品将可能会是微服务的架构。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/6.png\" alt=\"\"><br>如果开发团队分为前端团队、后台服务团队和DBA团队，产品将会成长为下面的架构。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/4.png\" alt=\"\"><br>应用不断迭代，功能日趋完善，开发团队也随之壮大。虽然现在有些人比较推崇全栈工程师，一位全栈工程师就能支持前后端的所有开发。但是试想一下，如果在开发团队中前后端开发分隔不清，职责边界模糊不明，代码均由相同的工程师完成，长此以往前后端代码的耦合程度可想而知。</p>\n<p>通过将开发团队前后端分离化，让前后端工程师只需要专注于前端或后端的开发工作，使得前后端工程师分别自治，培养其独特的技术特性，然后构建出一个全栈式的精益开发团队。这样的开发团队能够快速应对需求的变更以及市场的复杂多变，打造出架构清晰、前后端并重的优质产品。</p>\n<h4 id=\"提升开发效率\"><a href=\"#提升开发效率\" class=\"headerlink\" title=\"提升开发效率\"></a>提升开发效率</h4><p>传统开发模式中，前后端开发强依赖。需要前端工程师先完成静态页面的Demo，后端工程师才能将页面Demo翻译成VM模板，如果前端页面出现变动，又会需要前后端工程师再走一次开发流程，如此一来开发效率将会变得很低。</p>\n<p>前后端分离以后，可以实现前后端代码的解耦，只要前后端沟通约定好应用所需接口以及接口参数，便可以开始并行开发，无需等待对方的开发工作结束。与此同时，即使需求发生变更，只要接口与数据格式不变，后端开发人员就不需要修改代码，只要前端进行变动即可。如此一来整个应用的开发效率必然会有质的提升。</p>\n<h4 id=\"完美应对复杂多变的前端需求\"><a href=\"#完美应对复杂多变的前端需求\" class=\"headerlink\" title=\"完美应对复杂多变的前端需求\"></a>完美应对复杂多变的前端需求</h4><p>Web应用的用户体验关注度与日俱增，使得应用的前端界面需要有华丽酷炫的外观，简单易用的操作，变化多样的界面设计和个性化的自定义展示。这使得前端开始变重，逻辑复杂程度加大，渲染效果多样化加剧。</p>\n<p>移动终端的大范围普及，让应用向着多终端化发展，这就要求前端页面需要对不同终端的显示都能进行配适。</p>\n<p>传统开发模式中，前后端工程师开发职责不明确，面对复杂多变的前端需求，开发团队势必会变得捉襟见肘、不堪重负。</p>\n<p>如果开发团队能完成前后端分离的转型，打造优秀的前后端团队，开发独立化，让开发人员做到专注专精，开发能力必然会有所提升，能够完美应对各种复杂多变的前端需求。</p>\n<h4 id=\"增强代码可维护性\"><a href=\"#增强代码可维护性\" class=\"headerlink\" title=\"增强代码可维护性\"></a>增强代码可维护性</h4><p>前后端分离后，应用的代码不再是前后端混合，只有在运行期才会有调用依赖关系。应用代码将会变得整洁清晰，不论是代码阅读还是代码维护都会比以前轻松。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/7.png\" alt=\"\"></p>\n<h3 id=\"三、我要不要“离”：4种场景\"><a href=\"#三、我要不要“离”：4种场景\" class=\"headerlink\" title=\"三、我要不要“离”：4种场景\"></a>三、我要不要“离”：4种场景</h3><p>然而任何一项技术都不是银弹，前后端分离也是如此。虽然前后端分离架构能带来众多优势，但终究得建立在开发团队适合的基础之上。我们暂且以前端页面的渲染效果与逻辑复杂程度把Web应用大致分为轻前端、重前端、前后均衡三种类型，然后加上现在热门的微服务架构应用，一起探讨一下什么样的Web应用适合进行前后端分离。</p>\n<h4 id=\"轻前端\"><a href=\"#轻前端\" class=\"headerlink\" title=\"轻前端\"></a>轻前端</h4><p>页面布局简单，颜色、字体类型较少<br>对前端界面的渲染效果没有高要求，无动画效果<br>只有少量、简单的业务逻辑<br>只需要在不同终端上布局能适应</p>\n<p>对于这样对前端渲染要求不高，业务逻辑简单的轻前端应用来说，因为涉及到的前端技术并不复杂，所以没必要追求前后端分离。将前后端代码放到一起，反而更方便进行开发，但是在开发过程中需要做到关注点分离（Separate Concern）。</p>\n<h4 id=\"重前端\"><a href=\"#重前端\" class=\"headerlink\" title=\"重前端\"></a>重前端</h4><p>页面布局复杂，使用了多种颜色和字体<br>需要有较高的页面渲染效果，有大量动画<br>前端页面中包含有复杂业务逻辑<br>需要在不同终端和浏览器上保证布局适应和渲染效果</p>\n<p>对于重前端应用，建议采用前后端分离架构，如果开发团队中前端工程师不足，需要尽早完善前端团队的建设，确保前后端并重。</p>\n<h4 id=\"前后均衡\"><a href=\"#前后均衡\" class=\"headerlink\" title=\"前后均衡\"></a>前后均衡</h4><p>页面布局适中，使用的颜色和字体种类不多<br>页面中使用了少许动画效果<br>业务逻辑较为简单，可下沉到后端实现<br>只需要在不同终端上布局能适应</p>\n<p>对于前后端均衡应用，建议综合团队的人员结构和未来发展方向进行考虑。如果在团队中前端工程师的占比不高，后续也没有继续发展前端的计划，那么就不建议过于追求前后端分离。如果对未来有更高期望，即使在前端工程师占比不高的情况下，依然建议团队尝试前后端分离转型，开始着手培养合适的前端工程师。如果团队中已经有了相当规模的前端工程师，建议立即转向前后端分离，并且尽早做到前后端代码分离，为前端提供一个可以进行开发调试的伪后端。</p>\n<h4 id=\"微服务架构应用\"><a href=\"#微服务架构应用\" class=\"headerlink\" title=\"微服务架构应用\"></a>微服务架构应用</h4><p>微服务架构应用由大量微服务提供者构成，共同为用户提供服务。在微服务架构中，很多微服务提供者都是基于SpringBoot实现的，通过API Getway（API网关）进行微服务的整合，然后在一个统一的前端门户上为用户提供所需服务。</p>\n<p>微服务基于SpringBoot开发，要达到快速交付的目的，并且每个微服务的粒度都比较小，这必然需要微服务的前后端由不同的工程师分别实现，然后相互之间使用Restful进行通讯。如果还是沿用之前的开发模式，将会增大微服务架构应用的构建难度。而前后段分离模式正是解决这一难题的良药。</p>\n<h3 id=\"四、分离部署方案浅析\"><a href=\"#四、分离部署方案浅析\" class=\"headerlink\" title=\"四、分离部署方案浅析\"></a>四、分离部署方案浅析</h3><p>前后端开发分离之后，应用在部署时也需要进行前后端分离。在进行前后端分离方案选择的时候，需要结合项目的需求情况和用户群体来考虑。目前业内较为常用的前后端分离部署方案有如下几种。</p>\n<h4 id=\"1、Nginx-Server\"><a href=\"#1、Nginx-Server\" class=\"headerlink\" title=\"1、Nginx+Server\"></a>1、Nginx+Server</h4><p>将前端资源部署在Nginx上，后端服务部署在常规的服务器。当浏览器发起访问请求的时候，如果请求的是页面资源，Nginx直接把资源返回到前端；如果请求是调用后端服务，则经过Nginx转发到后端服务器，完成响应后经Nginx返回到浏览器。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/8.png\" alt=\"\"><br>这个方案比较简单，易于实现，而且能达到前后端解耦的目的。</p>\n<p>但是对于页面量比较大，需要有良好SEO的应用来说，此方案缺点也较为明显。因为Nginx只是向浏览器返回页面静态资源，而国内的搜索引擎爬虫只会抓取静态数据，不会解析页面中的js，这使得应用得不到良好的搜索引擎支持。同时因为Nginx不会进行页面的组装渲染，需要把静态页面返回到浏览器，然后完成渲染工作，这加重了浏览器的渲染负担。</p>\n<h4 id=\"2、Node-Server\"><a href=\"#2、Node-Server\" class=\"headerlink\" title=\"2、Node+Server\"></a>2、Node+Server</h4><p>这是淘宝所使用的前后端分离模式，在浏览器与后端服务器之间增加一个了Node Server作为中间层，将前端资源部署到Node Server中。Node Server中还包含了一层Model Proxy，负责与服务端进行通信。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/10.png\" alt=\"\"><br>浏览器发出的请求都被Node Server接收，然后通过Model Proxy调用后端服务器提供的服务。Node Server得到后端服务器反馈，接着在Node Server中完成页面的组装渲染，把最终页面返回给浏览器。</p>\n<p>如此一来不仅达到了前后端解耦的目的，还解决了浏览器渲染负担过重的问题，为SEO提供了比较好的支持。</p>\n<p>但在这样的模式中，浏览器所有发出的请求都需要经过Node Server进行中转，然后才能到达后端服务器。在实际的应用中，并不是所有的请求都需要页面渲染，只要在页面上直接调用后端服务器提供的服务即可。所以这个模式必然会对请求性能有所消耗</p>\n<h4 id=\"3、Nginx-Node-Server\"><a href=\"#3、Nginx-Node-Server\" class=\"headerlink\" title=\"3、Nginx+Node+Server\"></a>3、Nginx+Node+Server</h4><p>为了能解决方案2中请求性能损失的问题，我们可以考虑在其基础之上增加Nginx。浏览器发起的请求经过Nginx进行分发，URL请求统一分发到Node Server，在Node Server中进行页面组装渲染；API请求则直接发送到后端服务器，完成响应。</p>\n<p>目前在已经有一个名为Goku的Go语言框架提供了这样的前后端分离解决方案。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/1.png\" alt=\"\"><br>通过对三种前后端分离方案的对比可以看出：</p>\n<p>如果是企业级应用，不需要考虑对SEO的支持，浏览器渲染也可以忽略不计，Nginx+Server的模式无疑是最好的选择，实施成本相对来说比较低；</p>\n<p>如果是互联网应用，需要有良好的SEO支持，页面渲染工作量大，那应该选择Nginx+Node+Server的方案，各个方面都能得到比较好的兼顾。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/9.png\" alt=\"\"></p>\n<h3 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h3><p>前后端分离并非仅仅只是前后端开发的分工，而是在开发期进行代码存放分离、前后端开发职责分离，前后端能够独立进行开发测试；在运行期进行应用部署分离，前后端之间通过HTTP请求进行通讯。前后端分离的开发模式与传统模式相比，能为我们提升开发效率、增强代码可维护性，让我们有规划地打造一个前后端并重的精益开发团队，更好地应对越来越复杂多变的Web应用开发需求。</p>\n<p>传统的前后端混合开发模式，虽然久经考验，到现在依然还是能支撑起应用的开发。但是放眼未来，应用的云化、微服务化势不可挡。同社会分工精细化一样，前后端开发的精细化也是必然趋势。技术在持续进步，架构在不断演进，只有紧跟发展的脚步，不断调整项目管理方式，软件开发模式，才能在互联网浪潮中把握机会，乘风破浪。</p>\n<p>前后端分离，是为了让彼此更好。</p>\n<p>文章来源网络，版权归作者所有，作者：敖显奇@EAII企业架构创新研究院(eaworld)</p>\n"},{"title":"爱你不是为了和你去如家-MV版","date":"2015-12-26T09:10:37.000Z","_content":"**分享一首很久之前听过的说唱，希望大家能喜欢，希望大家有所感悟！**\n\n<iframe width=80% height=498  src='http://player.youku.com/embed/XMzYxMzUzMzYw' frameborder=0 'allowfullscreen'></iframe>\n","source":"_posts/rap-loverujia.md","raw":"---\ntitle: 爱你不是为了和你去如家-MV版\ndate: 2015-12-26 17:10:37\ntags: rap\n---\n**分享一首很久之前听过的说唱，希望大家能喜欢，希望大家有所感悟！**\n\n<iframe width=80% height=498  src='http://player.youku.com/embed/XMzYxMzUzMzYw' frameborder=0 'allowfullscreen'></iframe>\n","slug":"rap-loverujia","published":1,"updated":"2016-12-30T09:17:31.356Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv8z002tjgtunlf124xn","content":"<p><strong>分享一首很久之前听过的说唱，希望大家能喜欢，希望大家有所感悟！</strong></p>\n<iframe width=\"80%\" height=\"498\" src=\"http://player.youku.com/embed/XMzYxMzUzMzYw\" frameborder=\"0\" 'allowfullscreen'=\"\"></iframe>\n","excerpt":"","more":"<p><strong>分享一首很久之前听过的说唱，希望大家能喜欢，希望大家有所感悟！</strong></p>\n<iframe width=80% height=498  src='http://player.youku.com/embed/XMzYxMzUzMzYw' frameborder=0 'allowfullscreen'></iframe>\n"},{"title":"坚强-一首即将消失在网络上的rap","date":"2015-12-30T14:03:25.000Z","_content":"#### 《坚强》Feat.ST&苍狼&韩歙敏(爆爆)\n很早之前就很喜欢听，后来一段时间发现此歌要消声匿迹了，通过三个多小时的努力，我终于找到它了，所以保存下来以作记念。\n<iframe style=\"display:block; margin:0 auto;\" height=200 width=610 src='http://player.youku.com/embed/XMTg5MTYwMDEyMA==' frameborder=0 'allowfullscreen'></iframe>\n## 歌词如下：\n\n**ST**\n我开始忘了是否你又开始想了\n曾经咱们一起追逐的那些梦想\n记不清流了多少眼泪与汗水\n不能忘记的是咱们艰辛与疲惫\n\n回忆中的痛苦 决定你的胜负\n眼神中的无助 决定了你的旅途\n生活就是一遍一遍遍的重复\n或许只是为了寻找一条新的出路\n\n寂寞的时候找了一个人安慰\n却没有想到会是一个红颜祸水\n你害我伤痕累累神情疲惫\n但是感谢你给我承受伤害的机会\n\n我各种坚强任你随便的伤\n生活的艰难阻挡不了我的狂妄\n伤害的话说多了我也不想再说了\n狂风暴雨扛起 这是我的肩膀\n\n**韩歙敏(爆爆)**\n浓重的迷雾堵住梦的路口\n声丝力竭的声音喊不出口\n握着安慰自己虚假的借口\n默默接受这冰冷的渡口\n\n**苍 狼**\n有多少人为了梦想去奋斗\n但面对残酷的现实却又不得不低头\n又有多少人为了生活拼劲所有\n但拼搏到最后却不知这一生何求\n\n错过的感情已经无法再重来\n就算再多的挽留都已经显得苍白\n不在回忆过去只要把握住现在\n努力去创造属于我自己的未来\n\n我不是一个神我只是一个人\n满身伤痕却无法看破滚滚红尘\n只是渴望能够开启理想那道门\n如今我却住进了现实这座坟\n\n困难的生活我也不在感到迷茫\n再多的创伤也无法将我去阻挡\n只要心中充满希望跟信仰\n风雨过后我们定能看见朝阳\n\n**韩歙敏(爆爆)**\n浓重的迷雾堵住梦的路口\n声丝力竭的声音喊不出口\n握着安慰自己虚假的借口\n默默接受这冰冷的渡口\n\n**A.J:**\n我们说好的像飞蛾扑火一样不回头\n我们曾失败过那时不堪回首\n我们曾经失去的一切\n我们曾经失去的感觉\n\n我们渐渐的改变\n慢慢的习惯 面对了太多的不愿\n某天 当我再想起某一年\n的那个誓言的那种感觉\n就像是无数次的在我伤口上撒盐\n忍着疼痛我还要继续向前\n\n我在一点一点一步步的往前走\n只有一个信念我不怕生命会有终点\n这一切 要感谢那些陪伴我的人\n让我的梦想直到今天都没有被磨灭\n\n感谢 上天赋予我的生命\n感谢 那些折磨让我的意志更加坚定\n感谢 我自己 没有选择放弃\n感谢 我们自己 直到今天还在努力\n\n**韩歙敏(爆爆)**\n浓重的迷雾堵住梦的路口\n声丝力竭的声音喊不出口\n握着安慰自己虚假的借口\n默默接受这冰冷的渡口","source":"_posts/rap-strong.md","raw":"---\ntitle: 坚强-一首即将消失在网络上的rap\ndate: 2015-12-30 22:03:25\ntags: rap\n---\n#### 《坚强》Feat.ST&苍狼&韩歙敏(爆爆)\n很早之前就很喜欢听，后来一段时间发现此歌要消声匿迹了，通过三个多小时的努力，我终于找到它了，所以保存下来以作记念。\n<iframe style=\"display:block; margin:0 auto;\" height=200 width=610 src='http://player.youku.com/embed/XMTg5MTYwMDEyMA==' frameborder=0 'allowfullscreen'></iframe>\n## 歌词如下：\n\n**ST**\n我开始忘了是否你又开始想了\n曾经咱们一起追逐的那些梦想\n记不清流了多少眼泪与汗水\n不能忘记的是咱们艰辛与疲惫\n\n回忆中的痛苦 决定你的胜负\n眼神中的无助 决定了你的旅途\n生活就是一遍一遍遍的重复\n或许只是为了寻找一条新的出路\n\n寂寞的时候找了一个人安慰\n却没有想到会是一个红颜祸水\n你害我伤痕累累神情疲惫\n但是感谢你给我承受伤害的机会\n\n我各种坚强任你随便的伤\n生活的艰难阻挡不了我的狂妄\n伤害的话说多了我也不想再说了\n狂风暴雨扛起 这是我的肩膀\n\n**韩歙敏(爆爆)**\n浓重的迷雾堵住梦的路口\n声丝力竭的声音喊不出口\n握着安慰自己虚假的借口\n默默接受这冰冷的渡口\n\n**苍 狼**\n有多少人为了梦想去奋斗\n但面对残酷的现实却又不得不低头\n又有多少人为了生活拼劲所有\n但拼搏到最后却不知这一生何求\n\n错过的感情已经无法再重来\n就算再多的挽留都已经显得苍白\n不在回忆过去只要把握住现在\n努力去创造属于我自己的未来\n\n我不是一个神我只是一个人\n满身伤痕却无法看破滚滚红尘\n只是渴望能够开启理想那道门\n如今我却住进了现实这座坟\n\n困难的生活我也不在感到迷茫\n再多的创伤也无法将我去阻挡\n只要心中充满希望跟信仰\n风雨过后我们定能看见朝阳\n\n**韩歙敏(爆爆)**\n浓重的迷雾堵住梦的路口\n声丝力竭的声音喊不出口\n握着安慰自己虚假的借口\n默默接受这冰冷的渡口\n\n**A.J:**\n我们说好的像飞蛾扑火一样不回头\n我们曾失败过那时不堪回首\n我们曾经失去的一切\n我们曾经失去的感觉\n\n我们渐渐的改变\n慢慢的习惯 面对了太多的不愿\n某天 当我再想起某一年\n的那个誓言的那种感觉\n就像是无数次的在我伤口上撒盐\n忍着疼痛我还要继续向前\n\n我在一点一点一步步的往前走\n只有一个信念我不怕生命会有终点\n这一切 要感谢那些陪伴我的人\n让我的梦想直到今天都没有被磨灭\n\n感谢 上天赋予我的生命\n感谢 那些折磨让我的意志更加坚定\n感谢 我自己 没有选择放弃\n感谢 我们自己 直到今天还在努力\n\n**韩歙敏(爆爆)**\n浓重的迷雾堵住梦的路口\n声丝力竭的声音喊不出口\n握着安慰自己虚假的借口\n默默接受这冰冷的渡口","slug":"rap-strong","published":1,"updated":"2016-12-31T04:06:04.811Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv91002vjgtutf1uu194","content":"<h4 id=\"《坚强》Feat-ST-amp-苍狼-amp-韩歙敏-爆爆\"><a href=\"#《坚强》Feat-ST-amp-苍狼-amp-韩歙敏-爆爆\" class=\"headerlink\" title=\"《坚强》Feat.ST&amp;苍狼&amp;韩歙敏(爆爆)\"></a>《坚强》Feat.ST&amp;苍狼&amp;韩歙敏(爆爆)</h4><p>很早之前就很喜欢听，后来一段时间发现此歌要消声匿迹了，通过三个多小时的努力，我终于找到它了，所以保存下来以作记念。</p>\n<p><iframe style=\"display:block; margin:0 auto;\" height=\"200\" width=\"610\" src=\"http://player.youku.com/embed/XMTg5MTYwMDEyMA==\" frameborder=\"0\" 'allowfullscreen'=\"\"></iframe></p>\n<h2 id=\"歌词如下：\"><a href=\"#歌词如下：\" class=\"headerlink\" title=\"歌词如下：\"></a>歌词如下：</h2><p><strong>ST</strong><br>我开始忘了是否你又开始想了<br>曾经咱们一起追逐的那些梦想<br>记不清流了多少眼泪与汗水<br>不能忘记的是咱们艰辛与疲惫</p>\n<p>回忆中的痛苦 决定你的胜负<br>眼神中的无助 决定了你的旅途<br>生活就是一遍一遍遍的重复<br>或许只是为了寻找一条新的出路</p>\n<p>寂寞的时候找了一个人安慰<br>却没有想到会是一个红颜祸水<br>你害我伤痕累累神情疲惫<br>但是感谢你给我承受伤害的机会</p>\n<p>我各种坚强任你随便的伤<br>生活的艰难阻挡不了我的狂妄<br>伤害的话说多了我也不想再说了<br>狂风暴雨扛起 这是我的肩膀</p>\n<p><strong>韩歙敏(爆爆)</strong><br>浓重的迷雾堵住梦的路口<br>声丝力竭的声音喊不出口<br>握着安慰自己虚假的借口<br>默默接受这冰冷的渡口</p>\n<p><strong>苍 狼</strong><br>有多少人为了梦想去奋斗<br>但面对残酷的现实却又不得不低头<br>又有多少人为了生活拼劲所有<br>但拼搏到最后却不知这一生何求</p>\n<p>错过的感情已经无法再重来<br>就算再多的挽留都已经显得苍白<br>不在回忆过去只要把握住现在<br>努力去创造属于我自己的未来</p>\n<p>我不是一个神我只是一个人<br>满身伤痕却无法看破滚滚红尘<br>只是渴望能够开启理想那道门<br>如今我却住进了现实这座坟</p>\n<p>困难的生活我也不在感到迷茫<br>再多的创伤也无法将我去阻挡<br>只要心中充满希望跟信仰<br>风雨过后我们定能看见朝阳</p>\n<p><strong>韩歙敏(爆爆)</strong><br>浓重的迷雾堵住梦的路口<br>声丝力竭的声音喊不出口<br>握着安慰自己虚假的借口<br>默默接受这冰冷的渡口</p>\n<p><strong>A.J:</strong><br>我们说好的像飞蛾扑火一样不回头<br>我们曾失败过那时不堪回首<br>我们曾经失去的一切<br>我们曾经失去的感觉</p>\n<p>我们渐渐的改变<br>慢慢的习惯 面对了太多的不愿<br>某天 当我再想起某一年<br>的那个誓言的那种感觉<br>就像是无数次的在我伤口上撒盐<br>忍着疼痛我还要继续向前</p>\n<p>我在一点一点一步步的往前走<br>只有一个信念我不怕生命会有终点<br>这一切 要感谢那些陪伴我的人<br>让我的梦想直到今天都没有被磨灭</p>\n<p>感谢 上天赋予我的生命<br>感谢 那些折磨让我的意志更加坚定<br>感谢 我自己 没有选择放弃<br>感谢 我们自己 直到今天还在努力</p>\n<p><strong>韩歙敏(爆爆)</strong><br>浓重的迷雾堵住梦的路口<br>声丝力竭的声音喊不出口<br>握着安慰自己虚假的借口<br>默默接受这冰冷的渡口</p>\n","excerpt":"","more":"<h4 id=\"《坚强》Feat-ST-amp-苍狼-amp-韩歙敏-爆爆\"><a href=\"#《坚强》Feat-ST-amp-苍狼-amp-韩歙敏-爆爆\" class=\"headerlink\" title=\"《坚强》Feat.ST&amp;苍狼&amp;韩歙敏(爆爆)\"></a>《坚强》Feat.ST&amp;苍狼&amp;韩歙敏(爆爆)</h4><p>很早之前就很喜欢听，后来一段时间发现此歌要消声匿迹了，通过三个多小时的努力，我终于找到它了，所以保存下来以作记念。</p>\n<p><iframe style=\"display:block; margin:0 auto;\" height=200 width=610 src='http://player.youku.com/embed/XMTg5MTYwMDEyMA==' frameborder=0 'allowfullscreen'></iframe></p>\n<h2 id=\"歌词如下：\"><a href=\"#歌词如下：\" class=\"headerlink\" title=\"歌词如下：\"></a>歌词如下：</h2><p><strong>ST</strong><br>我开始忘了是否你又开始想了<br>曾经咱们一起追逐的那些梦想<br>记不清流了多少眼泪与汗水<br>不能忘记的是咱们艰辛与疲惫</p>\n<p>回忆中的痛苦 决定你的胜负<br>眼神中的无助 决定了你的旅途<br>生活就是一遍一遍遍的重复<br>或许只是为了寻找一条新的出路</p>\n<p>寂寞的时候找了一个人安慰<br>却没有想到会是一个红颜祸水<br>你害我伤痕累累神情疲惫<br>但是感谢你给我承受伤害的机会</p>\n<p>我各种坚强任你随便的伤<br>生活的艰难阻挡不了我的狂妄<br>伤害的话说多了我也不想再说了<br>狂风暴雨扛起 这是我的肩膀</p>\n<p><strong>韩歙敏(爆爆)</strong><br>浓重的迷雾堵住梦的路口<br>声丝力竭的声音喊不出口<br>握着安慰自己虚假的借口<br>默默接受这冰冷的渡口</p>\n<p><strong>苍 狼</strong><br>有多少人为了梦想去奋斗<br>但面对残酷的现实却又不得不低头<br>又有多少人为了生活拼劲所有<br>但拼搏到最后却不知这一生何求</p>\n<p>错过的感情已经无法再重来<br>就算再多的挽留都已经显得苍白<br>不在回忆过去只要把握住现在<br>努力去创造属于我自己的未来</p>\n<p>我不是一个神我只是一个人<br>满身伤痕却无法看破滚滚红尘<br>只是渴望能够开启理想那道门<br>如今我却住进了现实这座坟</p>\n<p>困难的生活我也不在感到迷茫<br>再多的创伤也无法将我去阻挡<br>只要心中充满希望跟信仰<br>风雨过后我们定能看见朝阳</p>\n<p><strong>韩歙敏(爆爆)</strong><br>浓重的迷雾堵住梦的路口<br>声丝力竭的声音喊不出口<br>握着安慰自己虚假的借口<br>默默接受这冰冷的渡口</p>\n<p><strong>A.J:</strong><br>我们说好的像飞蛾扑火一样不回头<br>我们曾失败过那时不堪回首<br>我们曾经失去的一切<br>我们曾经失去的感觉</p>\n<p>我们渐渐的改变<br>慢慢的习惯 面对了太多的不愿<br>某天 当我再想起某一年<br>的那个誓言的那种感觉<br>就像是无数次的在我伤口上撒盐<br>忍着疼痛我还要继续向前</p>\n<p>我在一点一点一步步的往前走<br>只有一个信念我不怕生命会有终点<br>这一切 要感谢那些陪伴我的人<br>让我的梦想直到今天都没有被磨灭</p>\n<p>感谢 上天赋予我的生命<br>感谢 那些折磨让我的意志更加坚定<br>感谢 我自己 没有选择放弃<br>感谢 我们自己 直到今天还在努力</p>\n<p><strong>韩歙敏(爆爆)</strong><br>浓重的迷雾堵住梦的路口<br>声丝力竭的声音喊不出口<br>握着安慰自己虚假的借口<br>默默接受这冰冷的渡口</p>\n"},{"title":"rap集合","date":"2016-05-30T12:50:07.000Z","_content":"## 我是自动播放的，不想听点我，别找不着我\n<iframe style=\"margin:0 auto; display:block;\" frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=25713016&auto=1&height=66\"></iframe>\n**1.电台情歌-fatkan**\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=34078039&auto=0&height=66\"></iframe>\n**2.正皇旗-兄弟情义**\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=29816209&auto=0&height=66\"></iframe>\n**3.正皇旗-泛黄的日记**\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=29816206&auto=0&height=66\"></iframe>\n**黑暗中的莲花-爽子**\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=419077145&auto=0&height=66\"></iframe>\n**别趴下 - 爽子**\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=442518697&auto=0&height=66\"></iframe>\n**自由的飞 - 爽子与瓷乐队**\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=381200&auto=0&height=66\"></iframe>\n**我知道 - 苏德牧仁**\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=27908045&auto=0&height=66\"></iframe>\n**爱你不是为了和你去如家 - 新街口**\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=27533115&auto=0&height=66\"></iframe>\n**谁没年轻过 - 新街口**\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=31140262&auto=0&height=66\"></iframe>","source":"_posts/raps.md","raw":"---\ntitle: rap集合\ndate: 2016-05-30 20:50:07\ntags: rap\n---\n## 我是自动播放的，不想听点我，别找不着我\n<iframe style=\"margin:0 auto; display:block;\" frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=25713016&auto=1&height=66\"></iframe>\n**1.电台情歌-fatkan**\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=34078039&auto=0&height=66\"></iframe>\n**2.正皇旗-兄弟情义**\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=29816209&auto=0&height=66\"></iframe>\n**3.正皇旗-泛黄的日记**\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=29816206&auto=0&height=66\"></iframe>\n**黑暗中的莲花-爽子**\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=419077145&auto=0&height=66\"></iframe>\n**别趴下 - 爽子**\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=442518697&auto=0&height=66\"></iframe>\n**自由的飞 - 爽子与瓷乐队**\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=381200&auto=0&height=66\"></iframe>\n**我知道 - 苏德牧仁**\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=27908045&auto=0&height=66\"></iframe>\n**爱你不是为了和你去如家 - 新街口**\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=27533115&auto=0&height=66\"></iframe>\n**谁没年轻过 - 新街口**\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=31140262&auto=0&height=66\"></iframe>","slug":"raps","published":1,"updated":"2016-12-31T02:50:56.835Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv93002xjgtuc5pl2eh8","content":"<h2 id=\"我是自动播放的，不想听点我，别找不着我\"><a href=\"#我是自动播放的，不想听点我，别找不着我\" class=\"headerlink\" title=\"我是自动播放的，不想听点我，别找不着我\"></a>我是自动播放的，不想听点我，别找不着我</h2><iframe style=\"margin:0 auto; display:block;\" frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"530\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=25713016&auto=1&height=66\"></iframe><br><strong>1.电台情歌-fatkan</strong><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"530\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=34078039&auto=0&height=66\"></iframe><br><strong>2.正皇旗-兄弟情义</strong><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"530\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=29816209&auto=0&height=66\"></iframe><br><strong>3.正皇旗-泛黄的日记</strong><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"530\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=29816206&auto=0&height=66\"></iframe><br><strong>黑暗中的莲花-爽子</strong><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"530\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=419077145&auto=0&height=66\"></iframe><br><strong>别趴下 - 爽子</strong><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"530\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=442518697&auto=0&height=66\"></iframe><br><strong>自由的飞 - 爽子与瓷乐队</strong><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"530\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=381200&auto=0&height=66\"></iframe><br><strong>我知道 - 苏德牧仁</strong><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"530\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=27908045&auto=0&height=66\"></iframe><br><strong>爱你不是为了和你去如家 - 新街口</strong><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"530\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=27533115&auto=0&height=66\"></iframe><br><strong>谁没年轻过 - 新街口</strong><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"530\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=31140262&auto=0&height=66\"></iframe>","excerpt":"","more":"<h2 id=\"我是自动播放的，不想听点我，别找不着我\"><a href=\"#我是自动播放的，不想听点我，别找不着我\" class=\"headerlink\" title=\"我是自动播放的，不想听点我，别找不着我\"></a>我是自动播放的，不想听点我，别找不着我</h2><iframe style=\"margin:0 auto; display:block;\" frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=25713016&auto=1&height=66\"></iframe><br><strong>1.电台情歌-fatkan</strong><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=34078039&auto=0&height=66\"></iframe><br><strong>2.正皇旗-兄弟情义</strong><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=29816209&auto=0&height=66\"></iframe><br><strong>3.正皇旗-泛黄的日记</strong><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=29816206&auto=0&height=66\"></iframe><br><strong>黑暗中的莲花-爽子</strong><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=419077145&auto=0&height=66\"></iframe><br><strong>别趴下 - 爽子</strong><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=442518697&auto=0&height=66\"></iframe><br><strong>自由的飞 - 爽子与瓷乐队</strong><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=381200&auto=0&height=66\"></iframe><br><strong>我知道 - 苏德牧仁</strong><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=27908045&auto=0&height=66\"></iframe><br><strong>爱你不是为了和你去如家 - 新街口</strong><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=27533115&auto=0&height=66\"></iframe><br><strong>谁没年轻过 - 新街口</strong><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=31140262&auto=0&height=66\"></iframe>"},{"title":"react入门篇 ant-design","date":"2016-11-10T09:09:32.000Z","_content":"   2016年9月到11月在一家公司上了三月的班，做的是sass系统，学习了react,redux，改写了一部分组件。真是日了狗了，由于上班地点原因就辞职了，不过工作对于有准备的人也不是那么难找，面了三家我就又上班了。写篇文章记录下react的学习，以便之后有时间再深入接触。\n   之前那家公司都是用react自己写组件，自己用，当时我还想react有没有ui组件库呢，毕竟自己开发成本有点高，结果我在面试过程中了解到了阿里的开源组件库：ant-design;面试回来做了下简单了解。\n\n   对于初学者来说，一个现成的框架能使学习的效率快很多，因为框架会告诉你如何构建整个应用。可以点击直接进官方文档学习，[Ant Design of React](https://ant.design/docs/react/introduce-cn)\n   大致过了下文档，有时间或者以后工作中用到再细看，毕竟前端技术更新那么快，了解了思想即可，细节用到再说，现在没有经历去细研究。不过再开发定义的组件的时候，**自定义组件的首字母必须大写**，否则组件不能正常显示，在此记录一下，应该有好多人在此遇到过坑。","source":"_posts/react-ant-design.md","raw":"---\ntitle: react入门篇 ant-design\ndate: 2016-11-10 17:09:32\ntags: react ant-design\n---\n   2016年9月到11月在一家公司上了三月的班，做的是sass系统，学习了react,redux，改写了一部分组件。真是日了狗了，由于上班地点原因就辞职了，不过工作对于有准备的人也不是那么难找，面了三家我就又上班了。写篇文章记录下react的学习，以便之后有时间再深入接触。\n   之前那家公司都是用react自己写组件，自己用，当时我还想react有没有ui组件库呢，毕竟自己开发成本有点高，结果我在面试过程中了解到了阿里的开源组件库：ant-design;面试回来做了下简单了解。\n\n   对于初学者来说，一个现成的框架能使学习的效率快很多，因为框架会告诉你如何构建整个应用。可以点击直接进官方文档学习，[Ant Design of React](https://ant.design/docs/react/introduce-cn)\n   大致过了下文档，有时间或者以后工作中用到再细看，毕竟前端技术更新那么快，了解了思想即可，细节用到再说，现在没有经历去细研究。不过再开发定义的组件的时候，**自定义组件的首字母必须大写**，否则组件不能正常显示，在此记录一下，应该有好多人在此遇到过坑。","slug":"react-ant-design","published":1,"updated":"2016-12-22T06:25:59.501Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv95002zjgtuoqjq0d1y","content":"<p>   2016年9月到11月在一家公司上了三月的班，做的是sass系统，学习了react,redux，改写了一部分组件。真是日了狗了，由于上班地点原因就辞职了，不过工作对于有准备的人也不是那么难找，面了三家我就又上班了。写篇文章记录下react的学习，以便之后有时间再深入接触。<br>   之前那家公司都是用react自己写组件，自己用，当时我还想react有没有ui组件库呢，毕竟自己开发成本有点高，结果我在面试过程中了解到了阿里的开源组件库：ant-design;面试回来做了下简单了解。</p>\n<p>   对于初学者来说，一个现成的框架能使学习的效率快很多，因为框架会告诉你如何构建整个应用。可以点击直接进官方文档学习，<a href=\"https://ant.design/docs/react/introduce-cn\" target=\"_blank\" rel=\"external\">Ant Design of React</a><br>   大致过了下文档，有时间或者以后工作中用到再细看，毕竟前端技术更新那么快，了解了思想即可，细节用到再说，现在没有经历去细研究。不过再开发定义的组件的时候，<strong>自定义组件的首字母必须大写</strong>，否则组件不能正常显示，在此记录一下，应该有好多人在此遇到过坑。</p>\n","excerpt":"","more":"<p>   2016年9月到11月在一家公司上了三月的班，做的是sass系统，学习了react,redux，改写了一部分组件。真是日了狗了，由于上班地点原因就辞职了，不过工作对于有准备的人也不是那么难找，面了三家我就又上班了。写篇文章记录下react的学习，以便之后有时间再深入接触。<br>   之前那家公司都是用react自己写组件，自己用，当时我还想react有没有ui组件库呢，毕竟自己开发成本有点高，结果我在面试过程中了解到了阿里的开源组件库：ant-design;面试回来做了下简单了解。</p>\n<p>   对于初学者来说，一个现成的框架能使学习的效率快很多，因为框架会告诉你如何构建整个应用。可以点击直接进官方文档学习，<a href=\"https://ant.design/docs/react/introduce-cn\">Ant Design of React</a><br>   大致过了下文档，有时间或者以后工作中用到再细看，毕竟前端技术更新那么快，了解了思想即可，细节用到再说，现在没有经历去细研究。不过再开发定义的组件的时候，<strong>自定义组件的首字母必须大写</strong>，否则组件不能正常显示，在此记录一下，应该有好多人在此遇到过坑。</p>\n"},{"title":"react入门学习","date":"2016-08-12T14:10:58.000Z","_content":"## 1.什么是react\nReact 是一个用于构建用户界面的JavaScript库\n### 2.安装react\n`$ bower install react babel --save`\n## 3.直接在浏览器中使用React\n```\n  <script src=\"../bower_components/react/react.js\"></script>\n  <script src=\"../bower_components/react/react-dom.js\"></script>\n  <script src=\"../bower_components/babel/browser.js\"></script>\n  <script type=\"text/babel\" src=\"index.js\"></script>\n```\n* react.js 是 React 的核心库\n* react-dom.js 是提供与DOM相关的功能,会在window下增加ReactDOM属性\n* browser.js 的作用是将JSX语法转为JavaScript语法\nscript中的type属性为text/babel,因为React独有的JSX语法,跟JavaScript不兼容\n### 4.ReactDOM.render\nReactDOM.render 是 React 的最基本方法,用于将标签模板转为HTML语言，并插入指定的DOM节点\n* 4.1.index.html\n  ```\n   <div id=\"app\"></div>\n   <script type=\"text/babel\" src=\"js/1.react.js\"/>\n  ```\n- 4.2. js/1.react.js\n```\n    ReactDOM.render(\n    <h1>ywx</h1>,\n        document.getElementById('app')\n    );\n```\n上面代码将一个h1标题，插入app元素内部\n## 5.JSX 语法\n 它是一种JS和HTML混合的语法,将组件的结构、数据甚至样式都聚合在一起定义组件,会编译成普通的Javascript。\n* 遇到HTML标签(以 < 开头)，就用HTML规则解析\n* 遇到代码块(以 { 开头)，就用JavaScript规则解析\n* 使用样式时可以让style等于一个样式对象\n* 使用样式类时只能使用className=类名,因为class是Javascript关键字\n```\nvar persons = ['刘德华', '范冰冰', '郭跃'];\nvar style = {color:'red'};\nReactDOM.render(\n  <div>\n  {\n    persons.map(function (person) {\n      return <div style={style}>Hello, {person}!</div>\n    })\n  }\n  </div>,\n  document.getElementById('app')\n);\n```\n### 6.定义组件\n我们可以很直观的将一个复杂的页面分割成若干个独立组件,每个组件包含自己的逻辑和样式 再将这些独立组件组合完成一个复杂的页面。 这样既减少了逻辑复杂度，又实现了代码的重用\n•\t可组合：一个组件可以和其他的组件一起使用或者可以直接嵌套在另一个组件内部\n•\t可重用：每个组件都是具有独立功能的，它可以被使用在多个场景中\n•\t可维护：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护\n - 6.1 定义组件\nReact允许将代码封装成组件，然后像插入普通HTML标签一样，在网页中插入这个组件\n* 组件类的第一个字母必须大写\n* 组件类能且只能包含一个顶层标签\n```\nvar Message = React.createClass({\n    render: function() {\n        return <h1>Hello</h1>;\n    }\n});\nReactDOM.render(\n    <Message/>,\n    document.getElementById('app')\n);\n```\n - 6.2 组件的属性\n* 每个组件可以有自己的属性,一般用来存放组件初始后不变的数据,比如人的性别，姓名等\n* 属性一般用作组件的数据源，一般由父组件传入,比如你的名字一般是由你父母取的\n* 属性可以通过this.props中取出\n* propTypes可以用来定义传入组件属性的名称和类型\n* getDefaultProps函数可以用来定会引起组件的默认属性\n```\nvar Person = React.createClass({\n    //类似于约定了一个接口文档,用于这是验证传递给组件的属性，\n    propTypes: {\n        //定义msg的属性类型为字符串，必须传入\n        name: React.PropTypes.string.isRequired,\n        gender: React.PropTypes.string.isRequired,\n        age:React.PropTypes.number.isRequired\n    },\n    getDefaultProps:function(){\n        return {name:'无名氏'}\n    },\n    render: function() {\n        //属性可以通过属性对象this.props中取出\n        return (<h1> {this.props.name}\n                     {this.props.gender}\n                     {this.props.age}\n                </h1>);\n    }\n});\n\nvar props = {\n    gender:'男',\n    age:18\n}\n\nReactDOM.render(\n    <Person {...props} />,//属性可以在使用组件时传入\n    document.getElementById('app')\n);\n```\n","source":"_posts/react1.md","raw":"---\ntitle: react入门学习\ndate: 2016-8-12 22:10:58\ntags: react\n---\n## 1.什么是react\nReact 是一个用于构建用户界面的JavaScript库\n### 2.安装react\n`$ bower install react babel --save`\n## 3.直接在浏览器中使用React\n```\n  <script src=\"../bower_components/react/react.js\"></script>\n  <script src=\"../bower_components/react/react-dom.js\"></script>\n  <script src=\"../bower_components/babel/browser.js\"></script>\n  <script type=\"text/babel\" src=\"index.js\"></script>\n```\n* react.js 是 React 的核心库\n* react-dom.js 是提供与DOM相关的功能,会在window下增加ReactDOM属性\n* browser.js 的作用是将JSX语法转为JavaScript语法\nscript中的type属性为text/babel,因为React独有的JSX语法,跟JavaScript不兼容\n### 4.ReactDOM.render\nReactDOM.render 是 React 的最基本方法,用于将标签模板转为HTML语言，并插入指定的DOM节点\n* 4.1.index.html\n  ```\n   <div id=\"app\"></div>\n   <script type=\"text/babel\" src=\"js/1.react.js\"/>\n  ```\n- 4.2. js/1.react.js\n```\n    ReactDOM.render(\n    <h1>ywx</h1>,\n        document.getElementById('app')\n    );\n```\n上面代码将一个h1标题，插入app元素内部\n## 5.JSX 语法\n 它是一种JS和HTML混合的语法,将组件的结构、数据甚至样式都聚合在一起定义组件,会编译成普通的Javascript。\n* 遇到HTML标签(以 < 开头)，就用HTML规则解析\n* 遇到代码块(以 { 开头)，就用JavaScript规则解析\n* 使用样式时可以让style等于一个样式对象\n* 使用样式类时只能使用className=类名,因为class是Javascript关键字\n```\nvar persons = ['刘德华', '范冰冰', '郭跃'];\nvar style = {color:'red'};\nReactDOM.render(\n  <div>\n  {\n    persons.map(function (person) {\n      return <div style={style}>Hello, {person}!</div>\n    })\n  }\n  </div>,\n  document.getElementById('app')\n);\n```\n### 6.定义组件\n我们可以很直观的将一个复杂的页面分割成若干个独立组件,每个组件包含自己的逻辑和样式 再将这些独立组件组合完成一个复杂的页面。 这样既减少了逻辑复杂度，又实现了代码的重用\n•\t可组合：一个组件可以和其他的组件一起使用或者可以直接嵌套在另一个组件内部\n•\t可重用：每个组件都是具有独立功能的，它可以被使用在多个场景中\n•\t可维护：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护\n - 6.1 定义组件\nReact允许将代码封装成组件，然后像插入普通HTML标签一样，在网页中插入这个组件\n* 组件类的第一个字母必须大写\n* 组件类能且只能包含一个顶层标签\n```\nvar Message = React.createClass({\n    render: function() {\n        return <h1>Hello</h1>;\n    }\n});\nReactDOM.render(\n    <Message/>,\n    document.getElementById('app')\n);\n```\n - 6.2 组件的属性\n* 每个组件可以有自己的属性,一般用来存放组件初始后不变的数据,比如人的性别，姓名等\n* 属性一般用作组件的数据源，一般由父组件传入,比如你的名字一般是由你父母取的\n* 属性可以通过this.props中取出\n* propTypes可以用来定义传入组件属性的名称和类型\n* getDefaultProps函数可以用来定会引起组件的默认属性\n```\nvar Person = React.createClass({\n    //类似于约定了一个接口文档,用于这是验证传递给组件的属性，\n    propTypes: {\n        //定义msg的属性类型为字符串，必须传入\n        name: React.PropTypes.string.isRequired,\n        gender: React.PropTypes.string.isRequired,\n        age:React.PropTypes.number.isRequired\n    },\n    getDefaultProps:function(){\n        return {name:'无名氏'}\n    },\n    render: function() {\n        //属性可以通过属性对象this.props中取出\n        return (<h1> {this.props.name}\n                     {this.props.gender}\n                     {this.props.age}\n                </h1>);\n    }\n});\n\nvar props = {\n    gender:'男',\n    age:18\n}\n\nReactDOM.render(\n    <Person {...props} />,//属性可以在使用组件时传入\n    document.getElementById('app')\n);\n```\n","slug":"react1","published":1,"updated":"2017-01-01T10:00:13.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv960031jgtucwua3ksq","content":"<h2 id=\"1-什么是react\"><a href=\"#1-什么是react\" class=\"headerlink\" title=\"1.什么是react\"></a>1.什么是react</h2><p>React 是一个用于构建用户界面的JavaScript库</p>\n<h3 id=\"2-安装react\"><a href=\"#2-安装react\" class=\"headerlink\" title=\"2.安装react\"></a>2.安装react</h3><p><code>$ bower install react babel --save</code></p>\n<h2 id=\"3-直接在浏览器中使用React\"><a href=\"#3-直接在浏览器中使用React\" class=\"headerlink\" title=\"3.直接在浏览器中使用React\"></a>3.直接在浏览器中使用React</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;../bower_components/react/react.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;../bower_components/react/react-dom.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;../bower_components/babel/browser.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script type=&quot;text/babel&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>react.js 是 React 的核心库</li>\n<li>react-dom.js 是提供与DOM相关的功能,会在window下增加ReactDOM属性</li>\n<li>browser.js 的作用是将JSX语法转为JavaScript语法<br>script中的type属性为text/babel,因为React独有的JSX语法,跟JavaScript不兼容<h3 id=\"4-ReactDOM-render\"><a href=\"#4-ReactDOM-render\" class=\"headerlink\" title=\"4.ReactDOM.render\"></a>4.ReactDOM.render</h3>ReactDOM.render 是 React 的最基本方法,用于将标签模板转为HTML语言，并插入指定的DOM节点</li>\n<li>4.1.index.html<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;script type=&quot;text/babel&quot; src=&quot;js/1.react.js&quot;/&gt;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>4.2. js/1.react.js<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReactDOM.render(</div><div class=\"line\">&lt;h1&gt;ywx&lt;/h1&gt;,</div><div class=\"line\">    document.getElementById(&apos;app&apos;)</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面代码将一个h1标题，插入app元素内部</p>\n<h2 id=\"5-JSX-语法\"><a href=\"#5-JSX-语法\" class=\"headerlink\" title=\"5.JSX 语法\"></a>5.JSX 语法</h2><p> 它是一种JS和HTML混合的语法,将组件的结构、数据甚至样式都聚合在一起定义组件,会编译成普通的Javascript。</p>\n<ul>\n<li>遇到HTML标签(以 &lt; 开头)，就用HTML规则解析</li>\n<li>遇到代码块(以 { 开头)，就用JavaScript规则解析</li>\n<li>使用样式时可以让style等于一个样式对象</li>\n<li>使用样式类时只能使用className=类名,因为class是Javascript关键字<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">var persons = [&apos;刘德华&apos;, &apos;范冰冰&apos;, &apos;郭跃&apos;];</div><div class=\"line\">var style = &#123;color:&apos;red&apos;&#125;;</div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;div&gt;</div><div class=\"line\">  &#123;</div><div class=\"line\">    persons.map(function (person) &#123;</div><div class=\"line\">      return &lt;div style=&#123;style&#125;&gt;Hello, &#123;person&#125;!&lt;/div&gt;</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">  &lt;/div&gt;,</div><div class=\"line\">  document.getElementById(&apos;app&apos;)</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"6-定义组件\"><a href=\"#6-定义组件\" class=\"headerlink\" title=\"6.定义组件\"></a>6.定义组件</h3><p>我们可以很直观的将一个复杂的页面分割成若干个独立组件,每个组件包含自己的逻辑和样式 再将这些独立组件组合完成一个复杂的页面。 这样既减少了逻辑复杂度，又实现了代码的重用<br>•    可组合：一个组件可以和其他的组件一起使用或者可以直接嵌套在另一个组件内部<br>•    可重用：每个组件都是具有独立功能的，它可以被使用在多个场景中<br>•    可维护：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护</p>\n<ul>\n<li><p>6.1 定义组件<br>React允许将代码封装成组件，然后像插入普通HTML标签一样，在网页中插入这个组件</p>\n<ul>\n<li>组件类的第一个字母必须大写</li>\n<li>组件类能且只能包含一个顶层标签<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Message = React.createClass(&#123;</div><div class=\"line\">    render: function() &#123;</div><div class=\"line\">        return &lt;h1&gt;Hello&lt;/h1&gt;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">    &lt;Message/&gt;,</div><div class=\"line\">    document.getElementById(&apos;app&apos;)</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>6.2 组件的属性</p>\n<ul>\n<li>每个组件可以有自己的属性,一般用来存放组件初始后不变的数据,比如人的性别，姓名等</li>\n<li>属性一般用作组件的数据源，一般由父组件传入,比如你的名字一般是由你父母取的</li>\n<li>属性可以通过this.props中取出</li>\n<li>propTypes可以用来定义传入组件属性的名称和类型</li>\n<li>getDefaultProps函数可以用来定会引起组件的默认属性<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Person = React.createClass(&#123;</div><div class=\"line\">    //类似于约定了一个接口文档,用于这是验证传递给组件的属性，</div><div class=\"line\">    propTypes: &#123;</div><div class=\"line\">        //定义msg的属性类型为字符串，必须传入</div><div class=\"line\">        name: React.PropTypes.string.isRequired,</div><div class=\"line\">        gender: React.PropTypes.string.isRequired,</div><div class=\"line\">        age:React.PropTypes.number.isRequired</div><div class=\"line\">    &#125;,</div><div class=\"line\">    getDefaultProps:function()&#123;</div><div class=\"line\">        return &#123;name:&apos;无名氏&apos;&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: function() &#123;</div><div class=\"line\">        //属性可以通过属性对象this.props中取出</div><div class=\"line\">        return (&lt;h1&gt; &#123;this.props.name&#125;</div><div class=\"line\">                     &#123;this.props.gender&#125;</div><div class=\"line\">                     &#123;this.props.age&#125;</div><div class=\"line\">                &lt;/h1&gt;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var props = &#123;</div><div class=\"line\">    gender:&apos;男&apos;,</div><div class=\"line\">    age:18</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">    &lt;Person &#123;...props&#125; /&gt;,//属性可以在使用组件时传入</div><div class=\"line\">    document.getElementById(&apos;app&apos;)</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"1-什么是react\"><a href=\"#1-什么是react\" class=\"headerlink\" title=\"1.什么是react\"></a>1.什么是react</h2><p>React 是一个用于构建用户界面的JavaScript库</p>\n<h3 id=\"2-安装react\"><a href=\"#2-安装react\" class=\"headerlink\" title=\"2.安装react\"></a>2.安装react</h3><p><code>$ bower install react babel --save</code></p>\n<h2 id=\"3-直接在浏览器中使用React\"><a href=\"#3-直接在浏览器中使用React\" class=\"headerlink\" title=\"3.直接在浏览器中使用React\"></a>3.直接在浏览器中使用React</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;../bower_components/react/react.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;../bower_components/react/react-dom.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;../bower_components/babel/browser.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script type=&quot;text/babel&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>react.js 是 React 的核心库</li>\n<li>react-dom.js 是提供与DOM相关的功能,会在window下增加ReactDOM属性</li>\n<li>browser.js 的作用是将JSX语法转为JavaScript语法<br>script中的type属性为text/babel,因为React独有的JSX语法,跟JavaScript不兼容<h3 id=\"4-ReactDOM-render\"><a href=\"#4-ReactDOM-render\" class=\"headerlink\" title=\"4.ReactDOM.render\"></a>4.ReactDOM.render</h3>ReactDOM.render 是 React 的最基本方法,用于将标签模板转为HTML语言，并插入指定的DOM节点</li>\n<li>4.1.index.html<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;script type=&quot;text/babel&quot; src=&quot;js/1.react.js&quot;/&gt;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>4.2. js/1.react.js<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReactDOM.render(</div><div class=\"line\">&lt;h1&gt;ywx&lt;/h1&gt;,</div><div class=\"line\">    document.getElementById(&apos;app&apos;)</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面代码将一个h1标题，插入app元素内部</p>\n<h2 id=\"5-JSX-语法\"><a href=\"#5-JSX-语法\" class=\"headerlink\" title=\"5.JSX 语法\"></a>5.JSX 语法</h2><p> 它是一种JS和HTML混合的语法,将组件的结构、数据甚至样式都聚合在一起定义组件,会编译成普通的Javascript。</p>\n<ul>\n<li>遇到HTML标签(以 &lt; 开头)，就用HTML规则解析</li>\n<li>遇到代码块(以 { 开头)，就用JavaScript规则解析</li>\n<li>使用样式时可以让style等于一个样式对象</li>\n<li>使用样式类时只能使用className=类名,因为class是Javascript关键字<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">var persons = [&apos;刘德华&apos;, &apos;范冰冰&apos;, &apos;郭跃&apos;];</div><div class=\"line\">var style = &#123;color:&apos;red&apos;&#125;;</div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;div&gt;</div><div class=\"line\">  &#123;</div><div class=\"line\">    persons.map(function (person) &#123;</div><div class=\"line\">      return &lt;div style=&#123;style&#125;&gt;Hello, &#123;person&#125;!&lt;/div&gt;</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">  &lt;/div&gt;,</div><div class=\"line\">  document.getElementById(&apos;app&apos;)</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"6-定义组件\"><a href=\"#6-定义组件\" class=\"headerlink\" title=\"6.定义组件\"></a>6.定义组件</h3><p>我们可以很直观的将一个复杂的页面分割成若干个独立组件,每个组件包含自己的逻辑和样式 再将这些独立组件组合完成一个复杂的页面。 这样既减少了逻辑复杂度，又实现了代码的重用<br>•    可组合：一个组件可以和其他的组件一起使用或者可以直接嵌套在另一个组件内部<br>•    可重用：每个组件都是具有独立功能的，它可以被使用在多个场景中<br>•    可维护：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护</p>\n<ul>\n<li><p>6.1 定义组件<br>React允许将代码封装成组件，然后像插入普通HTML标签一样，在网页中插入这个组件</p>\n<ul>\n<li>组件类的第一个字母必须大写</li>\n<li>组件类能且只能包含一个顶层标签<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Message = React.createClass(&#123;</div><div class=\"line\">    render: function() &#123;</div><div class=\"line\">        return &lt;h1&gt;Hello&lt;/h1&gt;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">    &lt;Message/&gt;,</div><div class=\"line\">    document.getElementById(&apos;app&apos;)</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>6.2 组件的属性</p>\n<ul>\n<li>每个组件可以有自己的属性,一般用来存放组件初始后不变的数据,比如人的性别，姓名等</li>\n<li>属性一般用作组件的数据源，一般由父组件传入,比如你的名字一般是由你父母取的</li>\n<li>属性可以通过this.props中取出</li>\n<li>propTypes可以用来定义传入组件属性的名称和类型</li>\n<li>getDefaultProps函数可以用来定会引起组件的默认属性<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Person = React.createClass(&#123;</div><div class=\"line\">    //类似于约定了一个接口文档,用于这是验证传递给组件的属性，</div><div class=\"line\">    propTypes: &#123;</div><div class=\"line\">        //定义msg的属性类型为字符串，必须传入</div><div class=\"line\">        name: React.PropTypes.string.isRequired,</div><div class=\"line\">        gender: React.PropTypes.string.isRequired,</div><div class=\"line\">        age:React.PropTypes.number.isRequired</div><div class=\"line\">    &#125;,</div><div class=\"line\">    getDefaultProps:function()&#123;</div><div class=\"line\">        return &#123;name:&apos;无名氏&apos;&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: function() &#123;</div><div class=\"line\">        //属性可以通过属性对象this.props中取出</div><div class=\"line\">        return (&lt;h1&gt; &#123;this.props.name&#125;</div><div class=\"line\">                     &#123;this.props.gender&#125;</div><div class=\"line\">                     &#123;this.props.age&#125;</div><div class=\"line\">                &lt;/h1&gt;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var props = &#123;</div><div class=\"line\">    gender:&apos;男&apos;,</div><div class=\"line\">    age:18</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">    &lt;Person &#123;...props&#125; /&gt;,//属性可以在使用组件时传入</div><div class=\"line\">    document.getElementById(&apos;app&apos;)</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"你应了解的4种JS设计模式","date":"2016-10-23T14:49:07.000Z","_content":"\n每个JS开发者都力求写出可维护、复用性和可读性高的代码。随着应用不断扩大，代码组织的合理性也越来越重要。设计模式为特定环境下的常见问题提供了一个组织结构，对于克服这些挑战起到至关重要的作用。\n\nJavaScript 网页开发者在创建应用时，频繁地跟设计模式打交道（甚至在不知情的情况下）。\n\n尽管特定环境下有各种各样的设计模式，JS 开发者还是倾向于使用一些习惯性的模式。\n\n在这篇文章中，我将讨论这些常见的设计模式，展出优化代码库的方法，并深入解读JavaScript的内部构件。\n\n本文讨论的设计模式包括这几种:\n- 模块设计模式\n- 原型模式\n- 观察者模式\n- 单例模式\n\n尽管每种模式都包含很多属性，这里我强调以下几点：\n*上下文:* 设计模式的使用场景\n*问题:* 我们尝试解决的问题是什么?\n*解决方法:* 使用设计模式如何解决我们提出的问题?\n*实施:* 实施方案看起来怎样?\n\n### 模块设计模式\n\nJS模块化是使用最普遍的设计模式，用于保持特殊的代码块与其它组件之间互相独立。为支持结构良好的代码提供了松耦合。\n\n对于熟悉面向对象的开发者来说，模块就是JS的 “类”。封装是“类”的众多优点之一，可以确保它本身的状态和行为不被其它的类访问到。模块设计模式有公有和私有两种访问级别（除此之外，还有比较少为人知的保护级别、特权级别）。\n\n考虑到私有的作用域，模块应该是一个立即调用函数（IIFE) ，也就是说，它是一个保护其私有变量和方法的闭包。（然而，它返回的却不是一个函数，而是一个对象）。它的写法就是这样的：\n```\n (function() {\n\n    // declare private variables and/or functions\n\n    return {\n      // declare public variables and/or functions\n    }\n\n})();\n```\n\n我们在返回一个对象之前，先初始化一下私有的变量和方法。由于作用域不同，闭包外面的代码是无法访问到闭包内的私有变量的。一起来看下更具体的实现方法：\n```\nvar HTMLChanger = (function() {\n  var contents = 'contents'\n\n  var changeHTML = function() {\n    var element = document.getElementById('attribute-to-change');\n    element.innerHTML = contents;\n  }\n\n  return {\n    callChangeHTML: function() {\n      changeHTML();\n      console.log(contents);\n    }\n  };\n\n})();\n\nHTMLChanger.callChangeHTML();       // Outputs: 'contents'\nconsole.log(HTMLChanger.contents);  // undefined \n```\n\n请注意 callChangeHTML 是在返回的对象中绑定的，因此可以访问到 HTMLChanger 这个命名空间内的变量。然而，在模块外面，是不能访问到闭包里面的 contents 的。\n\n### 揭示性模块模式\n\n模块模式的另一种变体称为 揭示性模块模式，它主要是为了在保持封装性的同时，揭示在对象字面量中返回的特定的变量和方法。直接的实现方式类似这样：\n```\nvar Exposer = (function() {\n  var privateVariable = 10;\n\n  var privateMethod = function() {\n    console.log('Inside a private method!');\n    privateVariable++;\n  }\n\n  var methodToExpose = function() {\n    console.log('This is a method I want to expose!');\n  }\n\n  var otherMethodIWantToExpose = function() {\n    privateMethod();\n  }\n\n  return {\n      first: methodToExpose,\n      second: otherMethodIWantToExpose\n  };\n})();\n\nExposer.first();        // Output: This is a method I want to expose!\nExposer.second();       // Output: Inside a private method!\nExposer.methodToExpose; // undefined \n```\n尽管这样看起来更加简洁，但它是有明显不足的 -- 不能引用私有变量。这会给单元测试带来一定的挑战。类似地，公有行为也是不可重写的。\n\n### 原型设计模式\n\nJS开发者要么把 原型 和 原型继承 相互混淆，要么在他们的代码里面直接使用原型。原型设计模式依赖于JavaScript原型继承. 原型模式主要用于为高性能环境创建对象。\n\n被创建的对象是从传下来的原对象克隆（浅克隆）出来的。原型模式的一种使用场景，是执行一个扩展性的数据库操作来创建一个对象，把该对象用于应用的其他层面。如果其他流程需要用到这个对象，我们不需要大量地操作数据库，只要克隆一下之前创建的对象就可以了。与其实质性地操作数据库，不如从之前创建的对象克隆一个更具优势。\n![](http://oi28tswuq.bkt.clouddn.com/images/shejimoshi.png)\n                            Wikipedia 原型设计模式图解\n\nUML 描述了原型交互是如何被用于克隆具体的代码实施方案的。\n要克隆一个对象，必须存在一个构造器来实例化第一个对象。接下来，通过使用 prototype 的变量和方法来绑定对象的结构。一起来看下基本的示例：\n```\nvar TeslaModelS = function() {\n  this.numWheels    = 4;\n  this.manufacturer = 'Tesla';\n  this.make         = 'Model S';\n}\n\nTeslaModelS.prototype.go = function() {\n  // Rotate wheels\n}\n\nTeslaModelS.prototype.stop = function() {\n  // Apply brake pads\n} \n```\n\n构造器 TeslaModelS 允许创建一个简单的 TeslaModelS 对象。对于一个新创建的 TeslaModelS 对象，它将保持构造器初始化的状态。此外，它也很简单的持有 go 和 stop 这两个方法，因为这两个方法是在 prototype 声明的。在原型上拓展方法，还可以这样写：\n```\n var TeslaModelS = function() {\n  this.numWheels    = 4;\n  this.manufacturer = 'Tesla';\n  this.make         = 'Model S';\n}\n\nTeslaModelS.prototype = {\n  go: function() {\n    // Rotate wheels\n  },\n  stop: function() {\n    // Apply brake pads\n  }\n} \n```\n\n### 揭示性原型模式\n\n类似于模块模式，原型模式也有一个 揭示性模式。揭示性原型模式 通过返回一个对象字面量，对公有和私有的成员进行封装。\n\n由于我们返回的是一个对象，我们将在原型对象上添加 function 的前缀。通过对以上例子进行改写，我们可以选择在当前的 prototype 暴露哪些方法或变量，以此来保护它们的访问层级。\n```\n var TeslaModelS = function() {\n  this.numWheels    = 4;\n  this.manufacturer = 'Tesla';\n  this.make         = 'Model S';\n}\n\nTeslaModelS.prototype = function() {\n\n  var go = function() {\n    // Rotate wheels\n  };\n\n  var stop = function() {\n    // Apply brake pads\n  };\n\n  return {\n    pressBrakePedal: stop,\n    pressGasPedal: go\n  }\n\n}(); \n```\n\n请注意 stop 和 go 两个方法是被隔开的，因为他们在所返回的对象作用域之外。由于 JavaScript 本身支持原型继承，也就没必要重写基本的功能了。\n\n### 观察者设计模式\n\n很多时候，当应用的一部分改变了，另一部分也需要相应更新。在 AngularJs 里面，如果 $scope 被更新，就会触发一个事件去通知其他组件。结合观察这模式就是：如果一个对象改变了，它只要派发 broadcasts 事件通知依赖的对象它已经改变了则可。\n\n又一个典型的例子就是 model-view-controller (MVC) 架构了；当 model 改变时， 更新相应的 view。这样做有一个好处，就是从 model 上解耦出 view 来减少依赖。\n```\n![观察这设计模式](<html>\n<head><title>502 Bad Gateway</title></head>\n<body bgcolor=\"white\">\n<center><h1>502 Bad Gateway</h1></center>\n\n<center>nginx/1.9.15</center>\n</body>\n</html>\n)\n```\n\n### Wikipedia 观察者设计模式\n\n如 UML 图表所示，subject、observer, and concrete objects 是必不可少的。 subject 包含对每个具体观察者的引用，以便传递改动信息。观察者本身是一个抽象的类，使得具体的观察者可以执行通讯方法。\n\n一起来看下 AngularJS 的示例，在事件管理上应用了观察这模式。\n```\n // Controller 1\n$scope.$on('nameChanged', function(event, args) {\n    $scope.name = args.name;\n});\n\n...\n\n// Controller 2\n$scope.userNameChanged = function(name) {\n    $scope.$emit('nameChanged', {name: name});\n}; \n```\n\n使用观察者模式，重要的一点就是要区分独立的对象或者 subject(主体)。\n\n在看到观察者模式众多优点的同时，我们必须注意到它的一个缺点：随着观察者数量的增加，应用的性能会大大降低。大家都比较熟悉的观察者就是 watchers 。 在AngularJS中，我们可以 watch 变量、方法和对象。$digest 循环更新，当一个作用域内对象被修改时，它就把新的值告诉每个监听者。\n\n我们可以在JS中创建自己的主体和观察者。一起来看下下面的代码是如何运行的：\n```\n var Subject = function() {\n  this.observers = [];\n\n  return {\n    subscribeObserver: function(observer) {\n      this.observers.push(observer);\n    },\n    unsubscribeObserver: function(observer) {\n      var index = this.observers.indexOf(observer);\n      if(index > -1) {\n        this.observers.splice(index, 1);\n      }\n    },\n    notifyObserver: function(observer) {\n      var index = this.observers.indexOf(observer);\n      if(index > -1) {\n        this.observers[index].notify(index);\n      }\n    },\n    notifyAllObservers: function() {\n      for(var i = 0; i < this.observers.length; i++){\n        this.observers[i].notify(i);\n      };\n    }\n  };\n};\n\nvar Observer = function() {\n  return {\n    notify: function(index) {\n      console.log(\"Observer \" + index + \" is notified!\");\n    }\n  }\n}\n\nvar subject = new Subject();\n\nvar observer1 = new Observer();\nvar observer2 = new Observer();\nvar observer3 = new Observer();\nvar observer4 = new Observer();\n\nsubject.subscribeObserver(observer1);\nsubject.subscribeObserver(observer2);\nsubject.subscribeObserver(observer3);\nsubject.subscribeObserver(observer4);\n\nsubject.notifyObserver(observer2); // Observer 2 is notified!\n\nsubject.notifyAllObservers();\n// Observer 1 is notified!\n// Observer 2 is notified!\n// Observer 3 is notified!\n// Observer 4 is notified! \n```\n\n### 发布、订阅模式\n\n然而，发布、订阅模式是采用一个话题来绑定发布者和订阅者之间的关系，订阅者接收事件通知，发布者派发事件。该事件系统支持定义特殊应用的事件，可以传递包含订阅者本身需要的自定义参数。这样做主要是为了避免订阅者和发布者之间的依赖。\n\n这里有别于观察者模式的是，任何订阅者都可以通过恰当的事件处理器来注册并接受发布者广播的通知。\n\n很多开发者选择把 发布订阅模式 和 观察者模式 结合起来用，尽管他们最终的目标只有一个。发布订阅模式中的订阅者是通过一些通讯媒介被告知的，而观察者则是通过执行事件处理器来获得消息通知。\n\n在 AngularJs， 订阅者使用 $on(event、cbk) 来订阅一个事件，发布者则使用$emit(‘event’, args) 或者 $broadcast(‘event’, args) 来发布一个事件。\n\n### 单例模式\n\n单例模式只允许实例化一个对象，但是相同的对象，会用很多个实例。单例模式制约着客户端创建多个对象。第一个对象创建后，就返回实例本身。\n\n单例模式比较少用，很难找到实际开发的例子。使用一个办公室打印机的例子吧。假设办公室有10个人，他们都用到打印机，10台电脑共享一部打印机（一个实例）。通过分享一部打印机，他们共享相同的资源。\n```\nvar printer = (function () {\n\n  var printerInstance;\n\n  function create () {\n\n    function print() {\n      // underlying printer mechanics\n    }\n\n    function turnOn() {\n      // warm up\n      // check for paper\n    }\n\n    return {\n      // public + private states and behaviors\n      print: print,\n      turnOn: turnOn\n    };\n  }\n\n  return {\n    getInstance: function() {\n      if(!printerInstance) {\n        printerInstance = create();\n      }\n      return printerInstance;\n    }\n  };\n\n  function Singleton () {\n    if(!printerInstance) {\n      printerInstance = intialize();\n    }\n  };\n\n})(); \n```\n\ncreate 这个方法是私有的，因为我们不希望它被外部人员访问到，然而，getInstance 方法是公有的。每个办公人员都可以实例化一个 printer，只需要这样调用一下：\n```\nvar officePrinter = printer.getInstance();\n```\n单例模式在 AngularJS 相当流行，最常见的是作为 services、factories、和 providers。它们维护状态，提供资源访问，创建两个实例摆脱一个共享的service/factory/provider。\n\n在多线程的应用中，当多个线程尝试去访问同个资源时，就会出现 竞争状态。单例模式会受到竞争状态的干扰，比如在没有初始化实例的情况下，两个线程会创建两个对象，而不是返回一个实例。这与单例模式的目的是相悖的。因此，开发者在多线程应用里面使用单例模式时，必须清楚同步性。\n\n### 总结\n\n设计模式经常用于比较大型的应用，想知道哪种模式更具优势，来实践吧。\n\n在构建任何应用之前，都应该全面地考虑每个角色，以及它们之间存在的关系。在回顾 模块模式、原型模式、观察者模式 和 单例模式 之后，你应该能够区分它们，并且在实际开发中使用它们了。\n\n--文章参考来源网络，版权归作者所有。\n","source":"_posts/shejimoshi.md","raw":"---\ntitle: 你应了解的4种JS设计模式\ndate: 2016-10-23 22:49:07\ntags: JS设计模式 设计模式\n---\n\n每个JS开发者都力求写出可维护、复用性和可读性高的代码。随着应用不断扩大，代码组织的合理性也越来越重要。设计模式为特定环境下的常见问题提供了一个组织结构，对于克服这些挑战起到至关重要的作用。\n\nJavaScript 网页开发者在创建应用时，频繁地跟设计模式打交道（甚至在不知情的情况下）。\n\n尽管特定环境下有各种各样的设计模式，JS 开发者还是倾向于使用一些习惯性的模式。\n\n在这篇文章中，我将讨论这些常见的设计模式，展出优化代码库的方法，并深入解读JavaScript的内部构件。\n\n本文讨论的设计模式包括这几种:\n- 模块设计模式\n- 原型模式\n- 观察者模式\n- 单例模式\n\n尽管每种模式都包含很多属性，这里我强调以下几点：\n*上下文:* 设计模式的使用场景\n*问题:* 我们尝试解决的问题是什么?\n*解决方法:* 使用设计模式如何解决我们提出的问题?\n*实施:* 实施方案看起来怎样?\n\n### 模块设计模式\n\nJS模块化是使用最普遍的设计模式，用于保持特殊的代码块与其它组件之间互相独立。为支持结构良好的代码提供了松耦合。\n\n对于熟悉面向对象的开发者来说，模块就是JS的 “类”。封装是“类”的众多优点之一，可以确保它本身的状态和行为不被其它的类访问到。模块设计模式有公有和私有两种访问级别（除此之外，还有比较少为人知的保护级别、特权级别）。\n\n考虑到私有的作用域，模块应该是一个立即调用函数（IIFE) ，也就是说，它是一个保护其私有变量和方法的闭包。（然而，它返回的却不是一个函数，而是一个对象）。它的写法就是这样的：\n```\n (function() {\n\n    // declare private variables and/or functions\n\n    return {\n      // declare public variables and/or functions\n    }\n\n})();\n```\n\n我们在返回一个对象之前，先初始化一下私有的变量和方法。由于作用域不同，闭包外面的代码是无法访问到闭包内的私有变量的。一起来看下更具体的实现方法：\n```\nvar HTMLChanger = (function() {\n  var contents = 'contents'\n\n  var changeHTML = function() {\n    var element = document.getElementById('attribute-to-change');\n    element.innerHTML = contents;\n  }\n\n  return {\n    callChangeHTML: function() {\n      changeHTML();\n      console.log(contents);\n    }\n  };\n\n})();\n\nHTMLChanger.callChangeHTML();       // Outputs: 'contents'\nconsole.log(HTMLChanger.contents);  // undefined \n```\n\n请注意 callChangeHTML 是在返回的对象中绑定的，因此可以访问到 HTMLChanger 这个命名空间内的变量。然而，在模块外面，是不能访问到闭包里面的 contents 的。\n\n### 揭示性模块模式\n\n模块模式的另一种变体称为 揭示性模块模式，它主要是为了在保持封装性的同时，揭示在对象字面量中返回的特定的变量和方法。直接的实现方式类似这样：\n```\nvar Exposer = (function() {\n  var privateVariable = 10;\n\n  var privateMethod = function() {\n    console.log('Inside a private method!');\n    privateVariable++;\n  }\n\n  var methodToExpose = function() {\n    console.log('This is a method I want to expose!');\n  }\n\n  var otherMethodIWantToExpose = function() {\n    privateMethod();\n  }\n\n  return {\n      first: methodToExpose,\n      second: otherMethodIWantToExpose\n  };\n})();\n\nExposer.first();        // Output: This is a method I want to expose!\nExposer.second();       // Output: Inside a private method!\nExposer.methodToExpose; // undefined \n```\n尽管这样看起来更加简洁，但它是有明显不足的 -- 不能引用私有变量。这会给单元测试带来一定的挑战。类似地，公有行为也是不可重写的。\n\n### 原型设计模式\n\nJS开发者要么把 原型 和 原型继承 相互混淆，要么在他们的代码里面直接使用原型。原型设计模式依赖于JavaScript原型继承. 原型模式主要用于为高性能环境创建对象。\n\n被创建的对象是从传下来的原对象克隆（浅克隆）出来的。原型模式的一种使用场景，是执行一个扩展性的数据库操作来创建一个对象，把该对象用于应用的其他层面。如果其他流程需要用到这个对象，我们不需要大量地操作数据库，只要克隆一下之前创建的对象就可以了。与其实质性地操作数据库，不如从之前创建的对象克隆一个更具优势。\n![](http://oi28tswuq.bkt.clouddn.com/images/shejimoshi.png)\n                            Wikipedia 原型设计模式图解\n\nUML 描述了原型交互是如何被用于克隆具体的代码实施方案的。\n要克隆一个对象，必须存在一个构造器来实例化第一个对象。接下来，通过使用 prototype 的变量和方法来绑定对象的结构。一起来看下基本的示例：\n```\nvar TeslaModelS = function() {\n  this.numWheels    = 4;\n  this.manufacturer = 'Tesla';\n  this.make         = 'Model S';\n}\n\nTeslaModelS.prototype.go = function() {\n  // Rotate wheels\n}\n\nTeslaModelS.prototype.stop = function() {\n  // Apply brake pads\n} \n```\n\n构造器 TeslaModelS 允许创建一个简单的 TeslaModelS 对象。对于一个新创建的 TeslaModelS 对象，它将保持构造器初始化的状态。此外，它也很简单的持有 go 和 stop 这两个方法，因为这两个方法是在 prototype 声明的。在原型上拓展方法，还可以这样写：\n```\n var TeslaModelS = function() {\n  this.numWheels    = 4;\n  this.manufacturer = 'Tesla';\n  this.make         = 'Model S';\n}\n\nTeslaModelS.prototype = {\n  go: function() {\n    // Rotate wheels\n  },\n  stop: function() {\n    // Apply brake pads\n  }\n} \n```\n\n### 揭示性原型模式\n\n类似于模块模式，原型模式也有一个 揭示性模式。揭示性原型模式 通过返回一个对象字面量，对公有和私有的成员进行封装。\n\n由于我们返回的是一个对象，我们将在原型对象上添加 function 的前缀。通过对以上例子进行改写，我们可以选择在当前的 prototype 暴露哪些方法或变量，以此来保护它们的访问层级。\n```\n var TeslaModelS = function() {\n  this.numWheels    = 4;\n  this.manufacturer = 'Tesla';\n  this.make         = 'Model S';\n}\n\nTeslaModelS.prototype = function() {\n\n  var go = function() {\n    // Rotate wheels\n  };\n\n  var stop = function() {\n    // Apply brake pads\n  };\n\n  return {\n    pressBrakePedal: stop,\n    pressGasPedal: go\n  }\n\n}(); \n```\n\n请注意 stop 和 go 两个方法是被隔开的，因为他们在所返回的对象作用域之外。由于 JavaScript 本身支持原型继承，也就没必要重写基本的功能了。\n\n### 观察者设计模式\n\n很多时候，当应用的一部分改变了，另一部分也需要相应更新。在 AngularJs 里面，如果 $scope 被更新，就会触发一个事件去通知其他组件。结合观察这模式就是：如果一个对象改变了，它只要派发 broadcasts 事件通知依赖的对象它已经改变了则可。\n\n又一个典型的例子就是 model-view-controller (MVC) 架构了；当 model 改变时， 更新相应的 view。这样做有一个好处，就是从 model 上解耦出 view 来减少依赖。\n```\n![观察这设计模式](<html>\n<head><title>502 Bad Gateway</title></head>\n<body bgcolor=\"white\">\n<center><h1>502 Bad Gateway</h1></center>\n\n<center>nginx/1.9.15</center>\n</body>\n</html>\n)\n```\n\n### Wikipedia 观察者设计模式\n\n如 UML 图表所示，subject、observer, and concrete objects 是必不可少的。 subject 包含对每个具体观察者的引用，以便传递改动信息。观察者本身是一个抽象的类，使得具体的观察者可以执行通讯方法。\n\n一起来看下 AngularJS 的示例，在事件管理上应用了观察这模式。\n```\n // Controller 1\n$scope.$on('nameChanged', function(event, args) {\n    $scope.name = args.name;\n});\n\n...\n\n// Controller 2\n$scope.userNameChanged = function(name) {\n    $scope.$emit('nameChanged', {name: name});\n}; \n```\n\n使用观察者模式，重要的一点就是要区分独立的对象或者 subject(主体)。\n\n在看到观察者模式众多优点的同时，我们必须注意到它的一个缺点：随着观察者数量的增加，应用的性能会大大降低。大家都比较熟悉的观察者就是 watchers 。 在AngularJS中，我们可以 watch 变量、方法和对象。$digest 循环更新，当一个作用域内对象被修改时，它就把新的值告诉每个监听者。\n\n我们可以在JS中创建自己的主体和观察者。一起来看下下面的代码是如何运行的：\n```\n var Subject = function() {\n  this.observers = [];\n\n  return {\n    subscribeObserver: function(observer) {\n      this.observers.push(observer);\n    },\n    unsubscribeObserver: function(observer) {\n      var index = this.observers.indexOf(observer);\n      if(index > -1) {\n        this.observers.splice(index, 1);\n      }\n    },\n    notifyObserver: function(observer) {\n      var index = this.observers.indexOf(observer);\n      if(index > -1) {\n        this.observers[index].notify(index);\n      }\n    },\n    notifyAllObservers: function() {\n      for(var i = 0; i < this.observers.length; i++){\n        this.observers[i].notify(i);\n      };\n    }\n  };\n};\n\nvar Observer = function() {\n  return {\n    notify: function(index) {\n      console.log(\"Observer \" + index + \" is notified!\");\n    }\n  }\n}\n\nvar subject = new Subject();\n\nvar observer1 = new Observer();\nvar observer2 = new Observer();\nvar observer3 = new Observer();\nvar observer4 = new Observer();\n\nsubject.subscribeObserver(observer1);\nsubject.subscribeObserver(observer2);\nsubject.subscribeObserver(observer3);\nsubject.subscribeObserver(observer4);\n\nsubject.notifyObserver(observer2); // Observer 2 is notified!\n\nsubject.notifyAllObservers();\n// Observer 1 is notified!\n// Observer 2 is notified!\n// Observer 3 is notified!\n// Observer 4 is notified! \n```\n\n### 发布、订阅模式\n\n然而，发布、订阅模式是采用一个话题来绑定发布者和订阅者之间的关系，订阅者接收事件通知，发布者派发事件。该事件系统支持定义特殊应用的事件，可以传递包含订阅者本身需要的自定义参数。这样做主要是为了避免订阅者和发布者之间的依赖。\n\n这里有别于观察者模式的是，任何订阅者都可以通过恰当的事件处理器来注册并接受发布者广播的通知。\n\n很多开发者选择把 发布订阅模式 和 观察者模式 结合起来用，尽管他们最终的目标只有一个。发布订阅模式中的订阅者是通过一些通讯媒介被告知的，而观察者则是通过执行事件处理器来获得消息通知。\n\n在 AngularJs， 订阅者使用 $on(event、cbk) 来订阅一个事件，发布者则使用$emit(‘event’, args) 或者 $broadcast(‘event’, args) 来发布一个事件。\n\n### 单例模式\n\n单例模式只允许实例化一个对象，但是相同的对象，会用很多个实例。单例模式制约着客户端创建多个对象。第一个对象创建后，就返回实例本身。\n\n单例模式比较少用，很难找到实际开发的例子。使用一个办公室打印机的例子吧。假设办公室有10个人，他们都用到打印机，10台电脑共享一部打印机（一个实例）。通过分享一部打印机，他们共享相同的资源。\n```\nvar printer = (function () {\n\n  var printerInstance;\n\n  function create () {\n\n    function print() {\n      // underlying printer mechanics\n    }\n\n    function turnOn() {\n      // warm up\n      // check for paper\n    }\n\n    return {\n      // public + private states and behaviors\n      print: print,\n      turnOn: turnOn\n    };\n  }\n\n  return {\n    getInstance: function() {\n      if(!printerInstance) {\n        printerInstance = create();\n      }\n      return printerInstance;\n    }\n  };\n\n  function Singleton () {\n    if(!printerInstance) {\n      printerInstance = intialize();\n    }\n  };\n\n})(); \n```\n\ncreate 这个方法是私有的，因为我们不希望它被外部人员访问到，然而，getInstance 方法是公有的。每个办公人员都可以实例化一个 printer，只需要这样调用一下：\n```\nvar officePrinter = printer.getInstance();\n```\n单例模式在 AngularJS 相当流行，最常见的是作为 services、factories、和 providers。它们维护状态，提供资源访问，创建两个实例摆脱一个共享的service/factory/provider。\n\n在多线程的应用中，当多个线程尝试去访问同个资源时，就会出现 竞争状态。单例模式会受到竞争状态的干扰，比如在没有初始化实例的情况下，两个线程会创建两个对象，而不是返回一个实例。这与单例模式的目的是相悖的。因此，开发者在多线程应用里面使用单例模式时，必须清楚同步性。\n\n### 总结\n\n设计模式经常用于比较大型的应用，想知道哪种模式更具优势，来实践吧。\n\n在构建任何应用之前，都应该全面地考虑每个角色，以及它们之间存在的关系。在回顾 模块模式、原型模式、观察者模式 和 单例模式 之后，你应该能够区分它们，并且在实际开发中使用它们了。\n\n--文章参考来源网络，版权归作者所有。\n","slug":"shejimoshi","published":1,"updated":"2016-12-12T09:43:36.437Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv980032jgtufjjtqsle","content":"<p>每个JS开发者都力求写出可维护、复用性和可读性高的代码。随着应用不断扩大，代码组织的合理性也越来越重要。设计模式为特定环境下的常见问题提供了一个组织结构，对于克服这些挑战起到至关重要的作用。</p>\n<p>JavaScript 网页开发者在创建应用时，频繁地跟设计模式打交道（甚至在不知情的情况下）。</p>\n<p>尽管特定环境下有各种各样的设计模式，JS 开发者还是倾向于使用一些习惯性的模式。</p>\n<p>在这篇文章中，我将讨论这些常见的设计模式，展出优化代码库的方法，并深入解读JavaScript的内部构件。</p>\n<p>本文讨论的设计模式包括这几种:</p>\n<ul>\n<li>模块设计模式</li>\n<li>原型模式</li>\n<li>观察者模式</li>\n<li>单例模式</li>\n</ul>\n<p>尽管每种模式都包含很多属性，这里我强调以下几点：<br><em>上下文:</em> 设计模式的使用场景<br><em>问题:</em> 我们尝试解决的问题是什么?<br><em>解决方法:</em> 使用设计模式如何解决我们提出的问题?<br><em>实施:</em> 实施方案看起来怎样?</p>\n<h3 id=\"模块设计模式\"><a href=\"#模块设计模式\" class=\"headerlink\" title=\"模块设计模式\"></a>模块设计模式</h3><p>JS模块化是使用最普遍的设计模式，用于保持特殊的代码块与其它组件之间互相独立。为支持结构良好的代码提供了松耦合。</p>\n<p>对于熟悉面向对象的开发者来说，模块就是JS的 “类”。封装是“类”的众多优点之一，可以确保它本身的状态和行为不被其它的类访问到。模块设计模式有公有和私有两种访问级别（除此之外，还有比较少为人知的保护级别、特权级别）。</p>\n<p>考虑到私有的作用域，模块应该是一个立即调用函数（IIFE) ，也就是说，它是一个保护其私有变量和方法的闭包。（然而，它返回的却不是一个函数，而是一个对象）。它的写法就是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"> (function() &#123;</div><div class=\"line\"></div><div class=\"line\">    // declare private variables and/or functions</div><div class=\"line\"></div><div class=\"line\">    return &#123;</div><div class=\"line\">      // declare public variables and/or functions</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure></p>\n<p>我们在返回一个对象之前，先初始化一下私有的变量和方法。由于作用域不同，闭包外面的代码是无法访问到闭包内的私有变量的。一起来看下更具体的实现方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">var HTMLChanger = (function() &#123;</div><div class=\"line\">  var contents = &apos;contents&apos;</div><div class=\"line\"></div><div class=\"line\">  var changeHTML = function() &#123;</div><div class=\"line\">    var element = document.getElementById(&apos;attribute-to-change&apos;);</div><div class=\"line\">    element.innerHTML = contents;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  return &#123;</div><div class=\"line\">    callChangeHTML: function() &#123;</div><div class=\"line\">      changeHTML();</div><div class=\"line\">      console.log(contents);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;)();</div><div class=\"line\"></div><div class=\"line\">HTMLChanger.callChangeHTML();       // Outputs: &apos;contents&apos;</div><div class=\"line\">console.log(HTMLChanger.contents);  // undefined</div></pre></td></tr></table></figure></p>\n<p>请注意 callChangeHTML 是在返回的对象中绑定的，因此可以访问到 HTMLChanger 这个命名空间内的变量。然而，在模块外面，是不能访问到闭包里面的 contents 的。</p>\n<h3 id=\"揭示性模块模式\"><a href=\"#揭示性模块模式\" class=\"headerlink\" title=\"揭示性模块模式\"></a>揭示性模块模式</h3><p>模块模式的另一种变体称为 揭示性模块模式，它主要是为了在保持封装性的同时，揭示在对象字面量中返回的特定的变量和方法。直接的实现方式类似这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Exposer = (function() &#123;</div><div class=\"line\">  var privateVariable = 10;</div><div class=\"line\"></div><div class=\"line\">  var privateMethod = function() &#123;</div><div class=\"line\">    console.log(&apos;Inside a private method!&apos;);</div><div class=\"line\">    privateVariable++;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  var methodToExpose = function() &#123;</div><div class=\"line\">    console.log(&apos;This is a method I want to expose!&apos;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  var otherMethodIWantToExpose = function() &#123;</div><div class=\"line\">    privateMethod();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  return &#123;</div><div class=\"line\">      first: methodToExpose,</div><div class=\"line\">      second: otherMethodIWantToExpose</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;)();</div><div class=\"line\"></div><div class=\"line\">Exposer.first();        // Output: This is a method I want to expose!</div><div class=\"line\">Exposer.second();       // Output: Inside a private method!</div><div class=\"line\">Exposer.methodToExpose; // undefined</div></pre></td></tr></table></figure></p>\n<p>尽管这样看起来更加简洁，但它是有明显不足的 – 不能引用私有变量。这会给单元测试带来一定的挑战。类似地，公有行为也是不可重写的。</p>\n<h3 id=\"原型设计模式\"><a href=\"#原型设计模式\" class=\"headerlink\" title=\"原型设计模式\"></a>原型设计模式</h3><p>JS开发者要么把 原型 和 原型继承 相互混淆，要么在他们的代码里面直接使用原型。原型设计模式依赖于JavaScript原型继承. 原型模式主要用于为高性能环境创建对象。</p>\n<p>被创建的对象是从传下来的原对象克隆（浅克隆）出来的。原型模式的一种使用场景，是执行一个扩展性的数据库操作来创建一个对象，把该对象用于应用的其他层面。如果其他流程需要用到这个对象，我们不需要大量地操作数据库，只要克隆一下之前创建的对象就可以了。与其实质性地操作数据库，不如从之前创建的对象克隆一个更具优势。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/shejimoshi.png\" alt=\"\"><br>                            Wikipedia 原型设计模式图解</p>\n<p>UML 描述了原型交互是如何被用于克隆具体的代码实施方案的。<br>要克隆一个对象，必须存在一个构造器来实例化第一个对象。接下来，通过使用 prototype 的变量和方法来绑定对象的结构。一起来看下基本的示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">var TeslaModelS = function() &#123;</div><div class=\"line\">  this.numWheels    = 4;</div><div class=\"line\">  this.manufacturer = &apos;Tesla&apos;;</div><div class=\"line\">  this.make         = &apos;Model S&apos;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">TeslaModelS.prototype.go = function() &#123;</div><div class=\"line\">  // Rotate wheels</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">TeslaModelS.prototype.stop = function() &#123;</div><div class=\"line\">  // Apply brake pads</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>构造器 TeslaModelS 允许创建一个简单的 TeslaModelS 对象。对于一个新创建的 TeslaModelS 对象，它将保持构造器初始化的状态。此外，它也很简单的持有 go 和 stop 这两个方法，因为这两个方法是在 prototype 声明的。在原型上拓展方法，还可以这样写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"> var TeslaModelS = function() &#123;</div><div class=\"line\">  this.numWheels    = 4;</div><div class=\"line\">  this.manufacturer = &apos;Tesla&apos;;</div><div class=\"line\">  this.make         = &apos;Model S&apos;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">TeslaModelS.prototype = &#123;</div><div class=\"line\">  go: function() &#123;</div><div class=\"line\">    // Rotate wheels</div><div class=\"line\">  &#125;,</div><div class=\"line\">  stop: function() &#123;</div><div class=\"line\">    // Apply brake pads</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"揭示性原型模式\"><a href=\"#揭示性原型模式\" class=\"headerlink\" title=\"揭示性原型模式\"></a>揭示性原型模式</h3><p>类似于模块模式，原型模式也有一个 揭示性模式。揭示性原型模式 通过返回一个对象字面量，对公有和私有的成员进行封装。</p>\n<p>由于我们返回的是一个对象，我们将在原型对象上添加 function 的前缀。通过对以上例子进行改写，我们可以选择在当前的 prototype 暴露哪些方法或变量，以此来保护它们的访问层级。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"> var TeslaModelS = function() &#123;</div><div class=\"line\">  this.numWheels    = 4;</div><div class=\"line\">  this.manufacturer = &apos;Tesla&apos;;</div><div class=\"line\">  this.make         = &apos;Model S&apos;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">TeslaModelS.prototype = function() &#123;</div><div class=\"line\"></div><div class=\"line\">  var go = function() &#123;</div><div class=\"line\">    // Rotate wheels</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">  var stop = function() &#123;</div><div class=\"line\">    // Apply brake pads</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">  return &#123;</div><div class=\"line\">    pressBrakePedal: stop,</div><div class=\"line\">    pressGasPedal: go</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;();</div></pre></td></tr></table></figure></p>\n<p>请注意 stop 和 go 两个方法是被隔开的，因为他们在所返回的对象作用域之外。由于 JavaScript 本身支持原型继承，也就没必要重写基本的功能了。</p>\n<h3 id=\"观察者设计模式\"><a href=\"#观察者设计模式\" class=\"headerlink\" title=\"观察者设计模式\"></a>观察者设计模式</h3><p>很多时候，当应用的一部分改变了，另一部分也需要相应更新。在 AngularJs 里面，如果 $scope 被更新，就会触发一个事件去通知其他组件。结合观察这模式就是：如果一个对象改变了，它只要派发 broadcasts 事件通知依赖的对象它已经改变了则可。</p>\n<p>又一个典型的例子就是 model-view-controller (MVC) 架构了；当 model 改变时， 更新相应的 view。这样做有一个好处，就是从 model 上解耦出 view 来减少依赖。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">![观察这设计模式](&lt;html&gt;</div><div class=\"line\">&lt;head&gt;&lt;title&gt;502 Bad Gateway&lt;/title&gt;&lt;/head&gt;</div><div class=\"line\">&lt;body bgcolor=&quot;white&quot;&gt;</div><div class=\"line\">&lt;center&gt;&lt;h1&gt;502 Bad Gateway&lt;/h1&gt;&lt;/center&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;center&gt;nginx/1.9.15&lt;/center&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<h3 id=\"Wikipedia-观察者设计模式\"><a href=\"#Wikipedia-观察者设计模式\" class=\"headerlink\" title=\"Wikipedia 观察者设计模式\"></a>Wikipedia 观察者设计模式</h3><p>如 UML 图表所示，subject、observer, and concrete objects 是必不可少的。 subject 包含对每个具体观察者的引用，以便传递改动信息。观察者本身是一个抽象的类，使得具体的观察者可以执行通讯方法。</p>\n<p>一起来看下 AngularJS 的示例，在事件管理上应用了观察这模式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> // Controller 1</div><div class=\"line\">$scope.$on(&apos;nameChanged&apos;, function(event, args) &#123;</div><div class=\"line\">    $scope.name = args.name;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\">// Controller 2</div><div class=\"line\">$scope.userNameChanged = function(name) &#123;</div><div class=\"line\">    $scope.$emit(&apos;nameChanged&apos;, &#123;name: name&#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>使用观察者模式，重要的一点就是要区分独立的对象或者 subject(主体)。</p>\n<p>在看到观察者模式众多优点的同时，我们必须注意到它的一个缺点：随着观察者数量的增加，应用的性能会大大降低。大家都比较熟悉的观察者就是 watchers 。 在AngularJS中，我们可以 watch 变量、方法和对象。$digest 循环更新，当一个作用域内对象被修改时，它就把新的值告诉每个监听者。</p>\n<p>我们可以在JS中创建自己的主体和观察者。一起来看下下面的代码是如何运行的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"> var Subject = function() &#123;</div><div class=\"line\">  this.observers = [];</div><div class=\"line\"></div><div class=\"line\">  return &#123;</div><div class=\"line\">    subscribeObserver: function(observer) &#123;</div><div class=\"line\">      this.observers.push(observer);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    unsubscribeObserver: function(observer) &#123;</div><div class=\"line\">      var index = this.observers.indexOf(observer);</div><div class=\"line\">      if(index &gt; -1) &#123;</div><div class=\"line\">        this.observers.splice(index, 1);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    notifyObserver: function(observer) &#123;</div><div class=\"line\">      var index = this.observers.indexOf(observer);</div><div class=\"line\">      if(index &gt; -1) &#123;</div><div class=\"line\">        this.observers[index].notify(index);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    notifyAllObservers: function() &#123;</div><div class=\"line\">      for(var i = 0; i &lt; this.observers.length; i++)&#123;</div><div class=\"line\">        this.observers[i].notify(i);</div><div class=\"line\">      &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var Observer = function() &#123;</div><div class=\"line\">  return &#123;</div><div class=\"line\">    notify: function(index) &#123;</div><div class=\"line\">      console.log(&quot;Observer &quot; + index + &quot; is notified!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var subject = new Subject();</div><div class=\"line\"></div><div class=\"line\">var observer1 = new Observer();</div><div class=\"line\">var observer2 = new Observer();</div><div class=\"line\">var observer3 = new Observer();</div><div class=\"line\">var observer4 = new Observer();</div><div class=\"line\"></div><div class=\"line\">subject.subscribeObserver(observer1);</div><div class=\"line\">subject.subscribeObserver(observer2);</div><div class=\"line\">subject.subscribeObserver(observer3);</div><div class=\"line\">subject.subscribeObserver(observer4);</div><div class=\"line\"></div><div class=\"line\">subject.notifyObserver(observer2); // Observer 2 is notified!</div><div class=\"line\"></div><div class=\"line\">subject.notifyAllObservers();</div><div class=\"line\">// Observer 1 is notified!</div><div class=\"line\">// Observer 2 is notified!</div><div class=\"line\">// Observer 3 is notified!</div><div class=\"line\">// Observer 4 is notified!</div></pre></td></tr></table></figure></p>\n<h3 id=\"发布、订阅模式\"><a href=\"#发布、订阅模式\" class=\"headerlink\" title=\"发布、订阅模式\"></a>发布、订阅模式</h3><p>然而，发布、订阅模式是采用一个话题来绑定发布者和订阅者之间的关系，订阅者接收事件通知，发布者派发事件。该事件系统支持定义特殊应用的事件，可以传递包含订阅者本身需要的自定义参数。这样做主要是为了避免订阅者和发布者之间的依赖。</p>\n<p>这里有别于观察者模式的是，任何订阅者都可以通过恰当的事件处理器来注册并接受发布者广播的通知。</p>\n<p>很多开发者选择把 发布订阅模式 和 观察者模式 结合起来用，尽管他们最终的目标只有一个。发布订阅模式中的订阅者是通过一些通讯媒介被告知的，而观察者则是通过执行事件处理器来获得消息通知。</p>\n<p>在 AngularJs， 订阅者使用 $on(event、cbk) 来订阅一个事件，发布者则使用$emit(‘event’, args) 或者 $broadcast(‘event’, args) 来发布一个事件。</p>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>单例模式只允许实例化一个对象，但是相同的对象，会用很多个实例。单例模式制约着客户端创建多个对象。第一个对象创建后，就返回实例本身。</p>\n<p>单例模式比较少用，很难找到实际开发的例子。使用一个办公室打印机的例子吧。假设办公室有10个人，他们都用到打印机，10台电脑共享一部打印机（一个实例）。通过分享一部打印机，他们共享相同的资源。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">var printer = (function () &#123;</div><div class=\"line\"></div><div class=\"line\">  var printerInstance;</div><div class=\"line\"></div><div class=\"line\">  function create () &#123;</div><div class=\"line\"></div><div class=\"line\">    function print() &#123;</div><div class=\"line\">      // underlying printer mechanics</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    function turnOn() &#123;</div><div class=\"line\">      // warm up</div><div class=\"line\">      // check for paper</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return &#123;</div><div class=\"line\">      // public + private states and behaviors</div><div class=\"line\">      print: print,</div><div class=\"line\">      turnOn: turnOn</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  return &#123;</div><div class=\"line\">    getInstance: function() &#123;</div><div class=\"line\">      if(!printerInstance) &#123;</div><div class=\"line\">        printerInstance = create();</div><div class=\"line\">      &#125;</div><div class=\"line\">      return printerInstance;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">  function Singleton () &#123;</div><div class=\"line\">    if(!printerInstance) &#123;</div><div class=\"line\">      printerInstance = intialize();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure></p>\n<p>create 这个方法是私有的，因为我们不希望它被外部人员访问到，然而，getInstance 方法是公有的。每个办公人员都可以实例化一个 printer，只需要这样调用一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var officePrinter = printer.getInstance();</div></pre></td></tr></table></figure></p>\n<p>单例模式在 AngularJS 相当流行，最常见的是作为 services、factories、和 providers。它们维护状态，提供资源访问，创建两个实例摆脱一个共享的service/factory/provider。</p>\n<p>在多线程的应用中，当多个线程尝试去访问同个资源时，就会出现 竞争状态。单例模式会受到竞争状态的干扰，比如在没有初始化实例的情况下，两个线程会创建两个对象，而不是返回一个实例。这与单例模式的目的是相悖的。因此，开发者在多线程应用里面使用单例模式时，必须清楚同步性。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>设计模式经常用于比较大型的应用，想知道哪种模式更具优势，来实践吧。</p>\n<p>在构建任何应用之前，都应该全面地考虑每个角色，以及它们之间存在的关系。在回顾 模块模式、原型模式、观察者模式 和 单例模式 之后，你应该能够区分它们，并且在实际开发中使用它们了。</p>\n<p>–文章参考来源网络，版权归作者所有。</p>\n","excerpt":"","more":"<p>每个JS开发者都力求写出可维护、复用性和可读性高的代码。随着应用不断扩大，代码组织的合理性也越来越重要。设计模式为特定环境下的常见问题提供了一个组织结构，对于克服这些挑战起到至关重要的作用。</p>\n<p>JavaScript 网页开发者在创建应用时，频繁地跟设计模式打交道（甚至在不知情的情况下）。</p>\n<p>尽管特定环境下有各种各样的设计模式，JS 开发者还是倾向于使用一些习惯性的模式。</p>\n<p>在这篇文章中，我将讨论这些常见的设计模式，展出优化代码库的方法，并深入解读JavaScript的内部构件。</p>\n<p>本文讨论的设计模式包括这几种:</p>\n<ul>\n<li>模块设计模式</li>\n<li>原型模式</li>\n<li>观察者模式</li>\n<li>单例模式</li>\n</ul>\n<p>尽管每种模式都包含很多属性，这里我强调以下几点：<br><em>上下文:</em> 设计模式的使用场景<br><em>问题:</em> 我们尝试解决的问题是什么?<br><em>解决方法:</em> 使用设计模式如何解决我们提出的问题?<br><em>实施:</em> 实施方案看起来怎样?</p>\n<h3 id=\"模块设计模式\"><a href=\"#模块设计模式\" class=\"headerlink\" title=\"模块设计模式\"></a>模块设计模式</h3><p>JS模块化是使用最普遍的设计模式，用于保持特殊的代码块与其它组件之间互相独立。为支持结构良好的代码提供了松耦合。</p>\n<p>对于熟悉面向对象的开发者来说，模块就是JS的 “类”。封装是“类”的众多优点之一，可以确保它本身的状态和行为不被其它的类访问到。模块设计模式有公有和私有两种访问级别（除此之外，还有比较少为人知的保护级别、特权级别）。</p>\n<p>考虑到私有的作用域，模块应该是一个立即调用函数（IIFE) ，也就是说，它是一个保护其私有变量和方法的闭包。（然而，它返回的却不是一个函数，而是一个对象）。它的写法就是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"> (function() &#123;</div><div class=\"line\"></div><div class=\"line\">    // declare private variables and/or functions</div><div class=\"line\"></div><div class=\"line\">    return &#123;</div><div class=\"line\">      // declare public variables and/or functions</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure></p>\n<p>我们在返回一个对象之前，先初始化一下私有的变量和方法。由于作用域不同，闭包外面的代码是无法访问到闭包内的私有变量的。一起来看下更具体的实现方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">var HTMLChanger = (function() &#123;</div><div class=\"line\">  var contents = &apos;contents&apos;</div><div class=\"line\"></div><div class=\"line\">  var changeHTML = function() &#123;</div><div class=\"line\">    var element = document.getElementById(&apos;attribute-to-change&apos;);</div><div class=\"line\">    element.innerHTML = contents;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  return &#123;</div><div class=\"line\">    callChangeHTML: function() &#123;</div><div class=\"line\">      changeHTML();</div><div class=\"line\">      console.log(contents);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;)();</div><div class=\"line\"></div><div class=\"line\">HTMLChanger.callChangeHTML();       // Outputs: &apos;contents&apos;</div><div class=\"line\">console.log(HTMLChanger.contents);  // undefined</div></pre></td></tr></table></figure></p>\n<p>请注意 callChangeHTML 是在返回的对象中绑定的，因此可以访问到 HTMLChanger 这个命名空间内的变量。然而，在模块外面，是不能访问到闭包里面的 contents 的。</p>\n<h3 id=\"揭示性模块模式\"><a href=\"#揭示性模块模式\" class=\"headerlink\" title=\"揭示性模块模式\"></a>揭示性模块模式</h3><p>模块模式的另一种变体称为 揭示性模块模式，它主要是为了在保持封装性的同时，揭示在对象字面量中返回的特定的变量和方法。直接的实现方式类似这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Exposer = (function() &#123;</div><div class=\"line\">  var privateVariable = 10;</div><div class=\"line\"></div><div class=\"line\">  var privateMethod = function() &#123;</div><div class=\"line\">    console.log(&apos;Inside a private method!&apos;);</div><div class=\"line\">    privateVariable++;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  var methodToExpose = function() &#123;</div><div class=\"line\">    console.log(&apos;This is a method I want to expose!&apos;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  var otherMethodIWantToExpose = function() &#123;</div><div class=\"line\">    privateMethod();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  return &#123;</div><div class=\"line\">      first: methodToExpose,</div><div class=\"line\">      second: otherMethodIWantToExpose</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;)();</div><div class=\"line\"></div><div class=\"line\">Exposer.first();        // Output: This is a method I want to expose!</div><div class=\"line\">Exposer.second();       // Output: Inside a private method!</div><div class=\"line\">Exposer.methodToExpose; // undefined</div></pre></td></tr></table></figure></p>\n<p>尽管这样看起来更加简洁，但它是有明显不足的 – 不能引用私有变量。这会给单元测试带来一定的挑战。类似地，公有行为也是不可重写的。</p>\n<h3 id=\"原型设计模式\"><a href=\"#原型设计模式\" class=\"headerlink\" title=\"原型设计模式\"></a>原型设计模式</h3><p>JS开发者要么把 原型 和 原型继承 相互混淆，要么在他们的代码里面直接使用原型。原型设计模式依赖于JavaScript原型继承. 原型模式主要用于为高性能环境创建对象。</p>\n<p>被创建的对象是从传下来的原对象克隆（浅克隆）出来的。原型模式的一种使用场景，是执行一个扩展性的数据库操作来创建一个对象，把该对象用于应用的其他层面。如果其他流程需要用到这个对象，我们不需要大量地操作数据库，只要克隆一下之前创建的对象就可以了。与其实质性地操作数据库，不如从之前创建的对象克隆一个更具优势。<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/shejimoshi.png\" alt=\"\"><br>                            Wikipedia 原型设计模式图解</p>\n<p>UML 描述了原型交互是如何被用于克隆具体的代码实施方案的。<br>要克隆一个对象，必须存在一个构造器来实例化第一个对象。接下来，通过使用 prototype 的变量和方法来绑定对象的结构。一起来看下基本的示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">var TeslaModelS = function() &#123;</div><div class=\"line\">  this.numWheels    = 4;</div><div class=\"line\">  this.manufacturer = &apos;Tesla&apos;;</div><div class=\"line\">  this.make         = &apos;Model S&apos;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">TeslaModelS.prototype.go = function() &#123;</div><div class=\"line\">  // Rotate wheels</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">TeslaModelS.prototype.stop = function() &#123;</div><div class=\"line\">  // Apply brake pads</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>构造器 TeslaModelS 允许创建一个简单的 TeslaModelS 对象。对于一个新创建的 TeslaModelS 对象，它将保持构造器初始化的状态。此外，它也很简单的持有 go 和 stop 这两个方法，因为这两个方法是在 prototype 声明的。在原型上拓展方法，还可以这样写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"> var TeslaModelS = function() &#123;</div><div class=\"line\">  this.numWheels    = 4;</div><div class=\"line\">  this.manufacturer = &apos;Tesla&apos;;</div><div class=\"line\">  this.make         = &apos;Model S&apos;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">TeslaModelS.prototype = &#123;</div><div class=\"line\">  go: function() &#123;</div><div class=\"line\">    // Rotate wheels</div><div class=\"line\">  &#125;,</div><div class=\"line\">  stop: function() &#123;</div><div class=\"line\">    // Apply brake pads</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"揭示性原型模式\"><a href=\"#揭示性原型模式\" class=\"headerlink\" title=\"揭示性原型模式\"></a>揭示性原型模式</h3><p>类似于模块模式，原型模式也有一个 揭示性模式。揭示性原型模式 通过返回一个对象字面量，对公有和私有的成员进行封装。</p>\n<p>由于我们返回的是一个对象，我们将在原型对象上添加 function 的前缀。通过对以上例子进行改写，我们可以选择在当前的 prototype 暴露哪些方法或变量，以此来保护它们的访问层级。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"> var TeslaModelS = function() &#123;</div><div class=\"line\">  this.numWheels    = 4;</div><div class=\"line\">  this.manufacturer = &apos;Tesla&apos;;</div><div class=\"line\">  this.make         = &apos;Model S&apos;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">TeslaModelS.prototype = function() &#123;</div><div class=\"line\"></div><div class=\"line\">  var go = function() &#123;</div><div class=\"line\">    // Rotate wheels</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">  var stop = function() &#123;</div><div class=\"line\">    // Apply brake pads</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">  return &#123;</div><div class=\"line\">    pressBrakePedal: stop,</div><div class=\"line\">    pressGasPedal: go</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;();</div></pre></td></tr></table></figure></p>\n<p>请注意 stop 和 go 两个方法是被隔开的，因为他们在所返回的对象作用域之外。由于 JavaScript 本身支持原型继承，也就没必要重写基本的功能了。</p>\n<h3 id=\"观察者设计模式\"><a href=\"#观察者设计模式\" class=\"headerlink\" title=\"观察者设计模式\"></a>观察者设计模式</h3><p>很多时候，当应用的一部分改变了，另一部分也需要相应更新。在 AngularJs 里面，如果 $scope 被更新，就会触发一个事件去通知其他组件。结合观察这模式就是：如果一个对象改变了，它只要派发 broadcasts 事件通知依赖的对象它已经改变了则可。</p>\n<p>又一个典型的例子就是 model-view-controller (MVC) 架构了；当 model 改变时， 更新相应的 view。这样做有一个好处，就是从 model 上解耦出 view 来减少依赖。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">![观察这设计模式](&lt;html&gt;</div><div class=\"line\">&lt;head&gt;&lt;title&gt;502 Bad Gateway&lt;/title&gt;&lt;/head&gt;</div><div class=\"line\">&lt;body bgcolor=&quot;white&quot;&gt;</div><div class=\"line\">&lt;center&gt;&lt;h1&gt;502 Bad Gateway&lt;/h1&gt;&lt;/center&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;center&gt;nginx/1.9.15&lt;/center&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<h3 id=\"Wikipedia-观察者设计模式\"><a href=\"#Wikipedia-观察者设计模式\" class=\"headerlink\" title=\"Wikipedia 观察者设计模式\"></a>Wikipedia 观察者设计模式</h3><p>如 UML 图表所示，subject、observer, and concrete objects 是必不可少的。 subject 包含对每个具体观察者的引用，以便传递改动信息。观察者本身是一个抽象的类，使得具体的观察者可以执行通讯方法。</p>\n<p>一起来看下 AngularJS 的示例，在事件管理上应用了观察这模式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> // Controller 1</div><div class=\"line\">$scope.$on(&apos;nameChanged&apos;, function(event, args) &#123;</div><div class=\"line\">    $scope.name = args.name;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\">// Controller 2</div><div class=\"line\">$scope.userNameChanged = function(name) &#123;</div><div class=\"line\">    $scope.$emit(&apos;nameChanged&apos;, &#123;name: name&#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>使用观察者模式，重要的一点就是要区分独立的对象或者 subject(主体)。</p>\n<p>在看到观察者模式众多优点的同时，我们必须注意到它的一个缺点：随着观察者数量的增加，应用的性能会大大降低。大家都比较熟悉的观察者就是 watchers 。 在AngularJS中，我们可以 watch 变量、方法和对象。$digest 循环更新，当一个作用域内对象被修改时，它就把新的值告诉每个监听者。</p>\n<p>我们可以在JS中创建自己的主体和观察者。一起来看下下面的代码是如何运行的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"> var Subject = function() &#123;</div><div class=\"line\">  this.observers = [];</div><div class=\"line\"></div><div class=\"line\">  return &#123;</div><div class=\"line\">    subscribeObserver: function(observer) &#123;</div><div class=\"line\">      this.observers.push(observer);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    unsubscribeObserver: function(observer) &#123;</div><div class=\"line\">      var index = this.observers.indexOf(observer);</div><div class=\"line\">      if(index &gt; -1) &#123;</div><div class=\"line\">        this.observers.splice(index, 1);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    notifyObserver: function(observer) &#123;</div><div class=\"line\">      var index = this.observers.indexOf(observer);</div><div class=\"line\">      if(index &gt; -1) &#123;</div><div class=\"line\">        this.observers[index].notify(index);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    notifyAllObservers: function() &#123;</div><div class=\"line\">      for(var i = 0; i &lt; this.observers.length; i++)&#123;</div><div class=\"line\">        this.observers[i].notify(i);</div><div class=\"line\">      &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var Observer = function() &#123;</div><div class=\"line\">  return &#123;</div><div class=\"line\">    notify: function(index) &#123;</div><div class=\"line\">      console.log(&quot;Observer &quot; + index + &quot; is notified!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var subject = new Subject();</div><div class=\"line\"></div><div class=\"line\">var observer1 = new Observer();</div><div class=\"line\">var observer2 = new Observer();</div><div class=\"line\">var observer3 = new Observer();</div><div class=\"line\">var observer4 = new Observer();</div><div class=\"line\"></div><div class=\"line\">subject.subscribeObserver(observer1);</div><div class=\"line\">subject.subscribeObserver(observer2);</div><div class=\"line\">subject.subscribeObserver(observer3);</div><div class=\"line\">subject.subscribeObserver(observer4);</div><div class=\"line\"></div><div class=\"line\">subject.notifyObserver(observer2); // Observer 2 is notified!</div><div class=\"line\"></div><div class=\"line\">subject.notifyAllObservers();</div><div class=\"line\">// Observer 1 is notified!</div><div class=\"line\">// Observer 2 is notified!</div><div class=\"line\">// Observer 3 is notified!</div><div class=\"line\">// Observer 4 is notified!</div></pre></td></tr></table></figure></p>\n<h3 id=\"发布、订阅模式\"><a href=\"#发布、订阅模式\" class=\"headerlink\" title=\"发布、订阅模式\"></a>发布、订阅模式</h3><p>然而，发布、订阅模式是采用一个话题来绑定发布者和订阅者之间的关系，订阅者接收事件通知，发布者派发事件。该事件系统支持定义特殊应用的事件，可以传递包含订阅者本身需要的自定义参数。这样做主要是为了避免订阅者和发布者之间的依赖。</p>\n<p>这里有别于观察者模式的是，任何订阅者都可以通过恰当的事件处理器来注册并接受发布者广播的通知。</p>\n<p>很多开发者选择把 发布订阅模式 和 观察者模式 结合起来用，尽管他们最终的目标只有一个。发布订阅模式中的订阅者是通过一些通讯媒介被告知的，而观察者则是通过执行事件处理器来获得消息通知。</p>\n<p>在 AngularJs， 订阅者使用 $on(event、cbk) 来订阅一个事件，发布者则使用$emit(‘event’, args) 或者 $broadcast(‘event’, args) 来发布一个事件。</p>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>单例模式只允许实例化一个对象，但是相同的对象，会用很多个实例。单例模式制约着客户端创建多个对象。第一个对象创建后，就返回实例本身。</p>\n<p>单例模式比较少用，很难找到实际开发的例子。使用一个办公室打印机的例子吧。假设办公室有10个人，他们都用到打印机，10台电脑共享一部打印机（一个实例）。通过分享一部打印机，他们共享相同的资源。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">var printer = (function () &#123;</div><div class=\"line\"></div><div class=\"line\">  var printerInstance;</div><div class=\"line\"></div><div class=\"line\">  function create () &#123;</div><div class=\"line\"></div><div class=\"line\">    function print() &#123;</div><div class=\"line\">      // underlying printer mechanics</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    function turnOn() &#123;</div><div class=\"line\">      // warm up</div><div class=\"line\">      // check for paper</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return &#123;</div><div class=\"line\">      // public + private states and behaviors</div><div class=\"line\">      print: print,</div><div class=\"line\">      turnOn: turnOn</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  return &#123;</div><div class=\"line\">    getInstance: function() &#123;</div><div class=\"line\">      if(!printerInstance) &#123;</div><div class=\"line\">        printerInstance = create();</div><div class=\"line\">      &#125;</div><div class=\"line\">      return printerInstance;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">  function Singleton () &#123;</div><div class=\"line\">    if(!printerInstance) &#123;</div><div class=\"line\">      printerInstance = intialize();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure></p>\n<p>create 这个方法是私有的，因为我们不希望它被外部人员访问到，然而，getInstance 方法是公有的。每个办公人员都可以实例化一个 printer，只需要这样调用一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var officePrinter = printer.getInstance();</div></pre></td></tr></table></figure></p>\n<p>单例模式在 AngularJS 相当流行，最常见的是作为 services、factories、和 providers。它们维护状态，提供资源访问，创建两个实例摆脱一个共享的service/factory/provider。</p>\n<p>在多线程的应用中，当多个线程尝试去访问同个资源时，就会出现 竞争状态。单例模式会受到竞争状态的干扰，比如在没有初始化实例的情况下，两个线程会创建两个对象，而不是返回一个实例。这与单例模式的目的是相悖的。因此，开发者在多线程应用里面使用单例模式时，必须清楚同步性。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>设计模式经常用于比较大型的应用，想知道哪种模式更具优势，来实践吧。</p>\n<p>在构建任何应用之前，都应该全面地考虑每个角色，以及它们之间存在的关系。在回顾 模块模式、原型模式、观察者模式 和 单例模式 之后，你应该能够区分它们，并且在实际开发中使用它们了。</p>\n<p>–文章参考来源网络，版权归作者所有。</p>\n"},{"title":"markdown 语法入大门","date":"2015-02-02T02:04:31.000Z","_content":"\n## 正文\n\n### 1. Markdown是*什么*？\n**Markdown**是一种轻量级**标记语言**，它以纯文本形式(_易读、易写、易更改_)编写文档，并最终以HTML格式发布。\n**Markdown**也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本_Markdown.pl_。\n\n### 4. *怎么*使用？ ###\n如果不算**扩展**，Markdown的语法绝对**简单**到让你爱不释手。\n\n废话太多，下面正文，Markdown语法主要分为如下几大部分：\n**标题**，**段落**，**区块引用**，**代码区块**，**强调**，**列表**，**分割线**，**链接**，**图片**，**反斜杠 `\\`**，**符号'`'**。\n\n#### 4.1 标题 ####\n两种形式：\n1）使用`=`和`-`标记一级和二级标题。\n> 一级标题\n> `=========`\n> 二级标题\n> `---------`\n\n效果：\n> 一级标题\n> =========\n> 二级标题\n> ---------\n\n2）使用`#`，可表示1-6级标题。\n> \\# 一级标题\n> \\## 二级标题\n> \\### 三级标题\n> \\#### 四级标题\n> \\##### 五级标题\n> \\###### 六级标题\n\n效果：\n> # 一级标题\n> ## 二级标题\n> ### 三级标题\n> #### 四级标题\n> ##### 五级标题\n> ###### 六级标题\n\n#### 4.2 段落 ####\n段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用**两个以上**空格加上回车（引用中换行省略回车）。\n\n#### 4.3 区块引用 ####\n在段落的每行或者只在第一行使用符号`>`,还可使用多个嵌套引用，如：\n> \\> 区块引用\n> \\>> 嵌套引用\n\n效果：\n> 区块引用\n>> 嵌套引用\n\n#### 4.4 代码区块 ####\n代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如\n普通段落：\n\nvoid main()\n{\n    printf(\"Hello, Markdown.\");\n}\n\n代码区块：\n\n    void main()\n    {\n        printf(\"Hello, Markdown.\");\n    }\n\n**注意**:需要和普通段落之间存在空行。\n\n#### 4.5 强调 ####\n在强调内容两侧分别加上`*`或者`_`，如：\n> \\*斜体\\*，\\_斜体\\_\n> \\*\\*粗体\\*\\*，\\_\\_粗体\\_\\_\n\n效果：\n> *斜体*，_斜体_\n> **粗体**，__粗体__\n\n#### 4.6 列表 ####\n使用`·`、`+`、或`-`标记无序列表，如：\n> \\-（+\\*） 第一项\n> \\-（+\\*） 第二项\n> \\- （+\\*）第三项\n\n**注意**：标记后面最少有一个_空格_或_制表符_。若不在引用区块中，必须和前方段落之间存在空行。\n\n效果：\n> + 第一项\n> + 第二项\n> + 第三项\n\n有序列表的标记方式是将上述的符号换成数字,并辅以`.`，如：\n> 1 . 第一项\n> 2 . 第二项\n> 3 . 第三项\n\n效果：\n> 1. 第一项\n> 2. 第二项\n> 3. 第三项\n\n#### 4.7 分割线 ####\n分割线最常使用就是三个或以上`*`，还可以使用`-`和`_`。\n\n#### 4.8 链接 ####\n链接可以由两种形式生成：**行内式**和**参考式**。\n**行内式**：\n> \\[ywx的Markdown\\]\\(https:://github.com/yanwenxi)。\n\n效果：\n> [ywx的Markdown](https:://github.com/yanwenxi)。\n\n**参考式**：\n> \\[ywx的Markdown1\\]\\[1\\]\n> \\[ywx的Markdown2\\]\\[2\\]\n> \\[1\\]:https:://github.com/yanwenxi\"\n> \\[2\\]:https:://github.com/yanwenxi\"\n\n效果：\n> [ywx的Markdown1][1]\n> [ywx的Markdown2][2]\n\n#### 4.9 图片 ####\n添加图片的形式和链接相似，只需在链接的基础上前方加一个`！`。\n#### 4.10 反斜杠`\\` ####\n相当于**反转义**作用。使符号成为普通符号。\n#### 4.11 符号'`' ####\n起到标记作用。如：\n>\\`ctrl+a\\`\n\n效果：\n>`ctrl+a`\n****\n**注意**：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。\n****\n以上基本是所有traditonal markdown的语法。\n\n### 其它： ###\n列表的使用(非traditonal markdown)：\n\n用`|`表示表格纵向边界，表头和表内容用`-`隔开，并可用`:`进行对齐设置，两边都有`:`则表示居中，若不加`:`则默认左对齐。\n\n关于其它扩展语法可参见具体工具的使用说明。\n\n### markdown里写html标签\n若直接在md里直接写<p>,这样不能正确解析出来，需要在英文状态下按esc输出“``”，用此包住标签即可。\n例：`<p>`,`<script>\n#### 粗体和斜体\n使用 ** 或者 __ 表示粗体。使用 * 或者 _ 表示斜体。\n注意:前后的 * 或 _ 与要 加粗或倾斜 的字体之间不能有空格。\n#### markdown里如何加入angular中的\\{ \\{ \\} \\}\n我了个去去去，坑了我一上午的时间，文章一直报错，所以标记下：\\{ \\{ \\} \\}要显示在页面上，必须用转义符，并且第个\\{都需要转义，在代码块中不用转义了，但是在代码高亮显示的时候也必须转义。","source":"_posts/test-makrdown.md","raw":"---\ntitle: \"markdown 语法入大门\"\ndate: 2015-02-02 10:04:31\ntags: markdown\n---\n\n## 正文\n\n### 1. Markdown是*什么*？\n**Markdown**是一种轻量级**标记语言**，它以纯文本形式(_易读、易写、易更改_)编写文档，并最终以HTML格式发布。\n**Markdown**也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本_Markdown.pl_。\n\n### 4. *怎么*使用？ ###\n如果不算**扩展**，Markdown的语法绝对**简单**到让你爱不释手。\n\n废话太多，下面正文，Markdown语法主要分为如下几大部分：\n**标题**，**段落**，**区块引用**，**代码区块**，**强调**，**列表**，**分割线**，**链接**，**图片**，**反斜杠 `\\`**，**符号'`'**。\n\n#### 4.1 标题 ####\n两种形式：\n1）使用`=`和`-`标记一级和二级标题。\n> 一级标题\n> `=========`\n> 二级标题\n> `---------`\n\n效果：\n> 一级标题\n> =========\n> 二级标题\n> ---------\n\n2）使用`#`，可表示1-6级标题。\n> \\# 一级标题\n> \\## 二级标题\n> \\### 三级标题\n> \\#### 四级标题\n> \\##### 五级标题\n> \\###### 六级标题\n\n效果：\n> # 一级标题\n> ## 二级标题\n> ### 三级标题\n> #### 四级标题\n> ##### 五级标题\n> ###### 六级标题\n\n#### 4.2 段落 ####\n段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用**两个以上**空格加上回车（引用中换行省略回车）。\n\n#### 4.3 区块引用 ####\n在段落的每行或者只在第一行使用符号`>`,还可使用多个嵌套引用，如：\n> \\> 区块引用\n> \\>> 嵌套引用\n\n效果：\n> 区块引用\n>> 嵌套引用\n\n#### 4.4 代码区块 ####\n代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如\n普通段落：\n\nvoid main()\n{\n    printf(\"Hello, Markdown.\");\n}\n\n代码区块：\n\n    void main()\n    {\n        printf(\"Hello, Markdown.\");\n    }\n\n**注意**:需要和普通段落之间存在空行。\n\n#### 4.5 强调 ####\n在强调内容两侧分别加上`*`或者`_`，如：\n> \\*斜体\\*，\\_斜体\\_\n> \\*\\*粗体\\*\\*，\\_\\_粗体\\_\\_\n\n效果：\n> *斜体*，_斜体_\n> **粗体**，__粗体__\n\n#### 4.6 列表 ####\n使用`·`、`+`、或`-`标记无序列表，如：\n> \\-（+\\*） 第一项\n> \\-（+\\*） 第二项\n> \\- （+\\*）第三项\n\n**注意**：标记后面最少有一个_空格_或_制表符_。若不在引用区块中，必须和前方段落之间存在空行。\n\n效果：\n> + 第一项\n> + 第二项\n> + 第三项\n\n有序列表的标记方式是将上述的符号换成数字,并辅以`.`，如：\n> 1 . 第一项\n> 2 . 第二项\n> 3 . 第三项\n\n效果：\n> 1. 第一项\n> 2. 第二项\n> 3. 第三项\n\n#### 4.7 分割线 ####\n分割线最常使用就是三个或以上`*`，还可以使用`-`和`_`。\n\n#### 4.8 链接 ####\n链接可以由两种形式生成：**行内式**和**参考式**。\n**行内式**：\n> \\[ywx的Markdown\\]\\(https:://github.com/yanwenxi)。\n\n效果：\n> [ywx的Markdown](https:://github.com/yanwenxi)。\n\n**参考式**：\n> \\[ywx的Markdown1\\]\\[1\\]\n> \\[ywx的Markdown2\\]\\[2\\]\n> \\[1\\]:https:://github.com/yanwenxi\"\n> \\[2\\]:https:://github.com/yanwenxi\"\n\n效果：\n> [ywx的Markdown1][1]\n> [ywx的Markdown2][2]\n\n#### 4.9 图片 ####\n添加图片的形式和链接相似，只需在链接的基础上前方加一个`！`。\n#### 4.10 反斜杠`\\` ####\n相当于**反转义**作用。使符号成为普通符号。\n#### 4.11 符号'`' ####\n起到标记作用。如：\n>\\`ctrl+a\\`\n\n效果：\n>`ctrl+a`\n****\n**注意**：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。\n****\n以上基本是所有traditonal markdown的语法。\n\n### 其它： ###\n列表的使用(非traditonal markdown)：\n\n用`|`表示表格纵向边界，表头和表内容用`-`隔开，并可用`:`进行对齐设置，两边都有`:`则表示居中，若不加`:`则默认左对齐。\n\n关于其它扩展语法可参见具体工具的使用说明。\n\n### markdown里写html标签\n若直接在md里直接写<p>,这样不能正确解析出来，需要在英文状态下按esc输出“``”，用此包住标签即可。\n例：`<p>`,`<script>\n#### 粗体和斜体\n使用 ** 或者 __ 表示粗体。使用 * 或者 _ 表示斜体。\n注意:前后的 * 或 _ 与要 加粗或倾斜 的字体之间不能有空格。\n#### markdown里如何加入angular中的\\{ \\{ \\} \\}\n我了个去去去，坑了我一上午的时间，文章一直报错，所以标记下：\\{ \\{ \\} \\}要显示在页面上，必须用转义符，并且第个\\{都需要转义，在代码块中不用转义了，但是在代码高亮显示的时候也必须转义。","slug":"test-makrdown","published":1,"updated":"2016-12-26T06:24:41.768Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv9b0035jgtu0bp282sl","content":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"1-Markdown是什么？\"><a href=\"#1-Markdown是什么？\" class=\"headerlink\" title=\"1. Markdown是什么？\"></a>1. Markdown是<em>什么</em>？</h3><p><strong>Markdown</strong>是一种轻量级<strong>标记语言</strong>，它以纯文本形式(<em>易读、易写、易更改</em>)编写文档，并最终以HTML格式发布。<br><strong>Markdown</strong>也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本<em>Markdown.pl</em>。</p>\n<h3 id=\"4-怎么使用？\"><a href=\"#4-怎么使用？\" class=\"headerlink\" title=\"4. 怎么使用？\"></a>4. <em>怎么</em>使用？</h3><p>如果不算<strong>扩展</strong>，Markdown的语法绝对<strong>简单</strong>到让你爱不释手。</p>\n<p>废话太多，下面正文，Markdown语法主要分为如下几大部分：<br><strong>标题</strong>，<strong>段落</strong>，<strong>区块引用</strong>，<strong>代码区块</strong>，<strong>强调</strong>，<strong>列表</strong>，<strong>分割线</strong>，<strong>链接</strong>，<strong>图片</strong>，<strong>反斜杠 <code>\\</code></strong>，<strong>符号’`’</strong>。</p>\n<h4 id=\"4-1-标题\"><a href=\"#4-1-标题\" class=\"headerlink\" title=\"4.1 标题\"></a>4.1 标题</h4><p>两种形式：<br>1）使用<code>=</code>和<code>-</code>标记一级和二级标题。</p>\n<blockquote>\n<p>一级标题<br><code>=========</code><br>二级标题<br><code>---------</code></p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2></blockquote>\n<p>2）使用<code>#</code>，可表示1-6级标题。</p>\n<blockquote>\n<p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<h1 id=\"一级标题-1\"><a href=\"#一级标题-1\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题-1\"><a href=\"#二级标题-1\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6></blockquote>\n<h4 id=\"4-2-段落\"><a href=\"#4-2-段落\" class=\"headerlink\" title=\"4.2 段落\"></a>4.2 段落</h4><p>段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用<strong>两个以上</strong>空格加上回车（引用中换行省略回车）。</p>\n<h4 id=\"4-3-区块引用\"><a href=\"#4-3-区块引用\" class=\"headerlink\" title=\"4.3 区块引用\"></a>4.3 区块引用</h4><p>在段落的每行或者只在第一行使用符号<code>&gt;</code>,还可使用多个嵌套引用，如：</p>\n<blockquote>\n<p>> 区块引用<br>>&gt; 嵌套引用</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p>区块引用</p>\n<blockquote>\n<p>嵌套引用</p>\n</blockquote>\n</blockquote>\n<h4 id=\"4-4-代码区块\"><a href=\"#4-4-代码区块\" class=\"headerlink\" title=\"4.4 代码区块\"></a>4.4 代码区块</h4><p>代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如<br>普通段落：</p>\n<p>void main()<br>{<br>    printf(“Hello, Markdown.”);<br>}</p>\n<p>代码区块：</p>\n<pre><code>void main()\n{\n    printf(&quot;Hello, Markdown.&quot;);\n}\n</code></pre><p><strong>注意</strong>:需要和普通段落之间存在空行。</p>\n<h4 id=\"4-5-强调\"><a href=\"#4-5-强调\" class=\"headerlink\" title=\"4.5 强调\"></a>4.5 强调</h4><p>在强调内容两侧分别加上<code>*</code>或者<code>_</code>，如：</p>\n<blockquote>\n<p>*斜体*，_斜体_<br>**粗体**，__粗体__</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong></p>\n</blockquote>\n<h4 id=\"4-6-列表\"><a href=\"#4-6-列表\" class=\"headerlink\" title=\"4.6 列表\"></a>4.6 列表</h4><p>使用<code>·</code>、<code>+</code>、或<code>-</code>标记无序列表，如：</p>\n<blockquote>\n<p>-（+*） 第一项<br>-（+*） 第二项<br>- （+*）第三项</p>\n</blockquote>\n<p><strong>注意</strong>：标记后面最少有一个<em>空格</em>或<em>制表符</em>。若不在引用区块中，必须和前方段落之间存在空行。</p>\n<p>效果：</p>\n<blockquote>\n<ul>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ul>\n</blockquote>\n<p>有序列表的标记方式是将上述的符号换成数字,并辅以<code>.</code>，如：</p>\n<blockquote>\n<p>1 . 第一项<br>2 . 第二项<br>3 . 第三项</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<ol>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ol>\n</blockquote>\n<h4 id=\"4-7-分割线\"><a href=\"#4-7-分割线\" class=\"headerlink\" title=\"4.7 分割线\"></a>4.7 分割线</h4><p>分割线最常使用就是三个或以上<code>*</code>，还可以使用<code>-</code>和<code>_</code>。</p>\n<h4 id=\"4-8-链接\"><a href=\"#4-8-链接\" class=\"headerlink\" title=\"4.8 链接\"></a>4.8 链接</h4><p>链接可以由两种形式生成：<strong>行内式</strong>和<strong>参考式</strong>。<br><strong>行内式</strong>：</p>\n<blockquote>\n<p>[ywx的Markdown](https:://github.com/yanwenxi)。</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p><a href=\"https:://github.com/yanwenxi\" target=\"_blank\" rel=\"external\">ywx的Markdown</a>。</p>\n</blockquote>\n<p><strong>参考式</strong>：</p>\n<blockquote>\n<p>[ywx的Markdown1][1]<br>[ywx的Markdown2][2]<br>[1]:https:://github.com/yanwenxi”<br>[2]:https:://github.com/yanwenxi”</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p>[ywx的Markdown1][1]<br>[ywx的Markdown2][2]</p>\n</blockquote>\n<h4 id=\"4-9-图片\"><a href=\"#4-9-图片\" class=\"headerlink\" title=\"4.9 图片\"></a>4.9 图片</h4><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个<code>！</code>。</p>\n<h4 id=\"4-10-反斜杠\"><a href=\"#4-10-反斜杠\" class=\"headerlink\" title=\"4.10 反斜杠\\\"></a>4.10 反斜杠<code>\\</code></h4><p>相当于<strong>反转义</strong>作用。使符号成为普通符号。</p>\n<h4 id=\"4-11-符号’-’\"><a href=\"#4-11-符号’-’\" class=\"headerlink\" title=\"4.11 符号’`’\"></a>4.11 符号’`’</h4><p>起到标记作用。如：</p>\n<blockquote>\n<p>`ctrl+a`</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p><code>ctrl+a</code></p>\n<hr>\n<p><strong>注意</strong>：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。</p>\n<hr>\n<p>以上基本是所有traditonal markdown的语法。</p>\n</blockquote>\n<h3 id=\"其它：\"><a href=\"#其它：\" class=\"headerlink\" title=\"其它：\"></a>其它：</h3><p>列表的使用(非traditonal markdown)：</p>\n<p>用<code>|</code>表示表格纵向边界，表头和表内容用<code>-</code>隔开，并可用<code>:</code>进行对齐设置，两边都有<code>:</code>则表示居中，若不加<code>:</code>则默认左对齐。</p>\n<p>关于其它扩展语法可参见具体工具的使用说明。</p>\n<h3 id=\"markdown里写html标签\"><a href=\"#markdown里写html标签\" class=\"headerlink\" title=\"markdown里写html标签\"></a>markdown里写html标签</h3><p>若直接在md里直接写</p><p>,这样不能正确解析出来，需要在英文状态下按esc输出“<code>`”，用此包住标签即可。\n例：</code></p><p><code>,</code><script></p>\n<h4 id=\"粗体和斜体\"><a href=\"#粗体和斜体\" class=\"headerlink\" title=\"粗体和斜体\"></a>粗体和斜体</h4><p>使用 <em>* 或者 __ 表示粗体。使用 </em> 或者 <em> 表示斜体。<br>注意:前后的 * 或 </em> 与要 加粗或倾斜 的字体之间不能有空格。</p>\n<h4 id=\"markdown里如何加入angular中的\"><a href=\"#markdown里如何加入angular中的\" class=\"headerlink\" title=\"markdown里如何加入angular中的{ { } }\"></a>markdown里如何加入angular中的{ { } }</h4><p>我了个去去去，坑了我一上午的时间，文章一直报错，所以标记下：{ { } }要显示在页面上，必须用转义符，并且第个{都需要转义，在代码块中不用转义了，但是在代码高亮显示的时候也必须转义。</p>\n</script></p>","excerpt":"","more":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"1-Markdown是什么？\"><a href=\"#1-Markdown是什么？\" class=\"headerlink\" title=\"1. Markdown是什么？\"></a>1. Markdown是<em>什么</em>？</h3><p><strong>Markdown</strong>是一种轻量级<strong>标记语言</strong>，它以纯文本形式(<em>易读、易写、易更改</em>)编写文档，并最终以HTML格式发布。<br><strong>Markdown</strong>也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本<em>Markdown.pl</em>。</p>\n<h3 id=\"4-怎么使用？\"><a href=\"#4-怎么使用？\" class=\"headerlink\" title=\"4. 怎么使用？\"></a>4. <em>怎么</em>使用？</h3><p>如果不算<strong>扩展</strong>，Markdown的语法绝对<strong>简单</strong>到让你爱不释手。</p>\n<p>废话太多，下面正文，Markdown语法主要分为如下几大部分：<br><strong>标题</strong>，<strong>段落</strong>，<strong>区块引用</strong>，<strong>代码区块</strong>，<strong>强调</strong>，<strong>列表</strong>，<strong>分割线</strong>，<strong>链接</strong>，<strong>图片</strong>，<strong>反斜杠 <code>\\</code></strong>，<strong>符号’`’</strong>。</p>\n<h4 id=\"4-1-标题\"><a href=\"#4-1-标题\" class=\"headerlink\" title=\"4.1 标题\"></a>4.1 标题</h4><p>两种形式：<br>1）使用<code>=</code>和<code>-</code>标记一级和二级标题。</p>\n<blockquote>\n<p>一级标题<br><code>=========</code><br>二级标题<br><code>---------</code></p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2></blockquote>\n<p>2）使用<code>#</code>，可表示1-6级标题。</p>\n<blockquote>\n<p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<h1 id=\"一级标题-1\"><a href=\"#一级标题-1\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题-1\"><a href=\"#二级标题-1\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6></blockquote>\n<h4 id=\"4-2-段落\"><a href=\"#4-2-段落\" class=\"headerlink\" title=\"4.2 段落\"></a>4.2 段落</h4><p>段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用<strong>两个以上</strong>空格加上回车（引用中换行省略回车）。</p>\n<h4 id=\"4-3-区块引用\"><a href=\"#4-3-区块引用\" class=\"headerlink\" title=\"4.3 区块引用\"></a>4.3 区块引用</h4><p>在段落的每行或者只在第一行使用符号<code>&gt;</code>,还可使用多个嵌套引用，如：</p>\n<blockquote>\n<p>> 区块引用<br>>&gt; 嵌套引用</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p>区块引用</p>\n<blockquote>\n<p>嵌套引用</p>\n</blockquote>\n</blockquote>\n<h4 id=\"4-4-代码区块\"><a href=\"#4-4-代码区块\" class=\"headerlink\" title=\"4.4 代码区块\"></a>4.4 代码区块</h4><p>代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如<br>普通段落：</p>\n<p>void main()<br>{<br>    printf(“Hello, Markdown.”);<br>}</p>\n<p>代码区块：</p>\n<pre><code>void main()\n{\n    printf(&quot;Hello, Markdown.&quot;);\n}\n</code></pre><p><strong>注意</strong>:需要和普通段落之间存在空行。</p>\n<h4 id=\"4-5-强调\"><a href=\"#4-5-强调\" class=\"headerlink\" title=\"4.5 强调\"></a>4.5 强调</h4><p>在强调内容两侧分别加上<code>*</code>或者<code>_</code>，如：</p>\n<blockquote>\n<p>*斜体*，_斜体_<br>**粗体**，__粗体__</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong></p>\n</blockquote>\n<h4 id=\"4-6-列表\"><a href=\"#4-6-列表\" class=\"headerlink\" title=\"4.6 列表\"></a>4.6 列表</h4><p>使用<code>·</code>、<code>+</code>、或<code>-</code>标记无序列表，如：</p>\n<blockquote>\n<p>-（+*） 第一项<br>-（+*） 第二项<br>- （+*）第三项</p>\n</blockquote>\n<p><strong>注意</strong>：标记后面最少有一个<em>空格</em>或<em>制表符</em>。若不在引用区块中，必须和前方段落之间存在空行。</p>\n<p>效果：</p>\n<blockquote>\n<ul>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ul>\n</blockquote>\n<p>有序列表的标记方式是将上述的符号换成数字,并辅以<code>.</code>，如：</p>\n<blockquote>\n<p>1 . 第一项<br>2 . 第二项<br>3 . 第三项</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<ol>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ol>\n</blockquote>\n<h4 id=\"4-7-分割线\"><a href=\"#4-7-分割线\" class=\"headerlink\" title=\"4.7 分割线\"></a>4.7 分割线</h4><p>分割线最常使用就是三个或以上<code>*</code>，还可以使用<code>-</code>和<code>_</code>。</p>\n<h4 id=\"4-8-链接\"><a href=\"#4-8-链接\" class=\"headerlink\" title=\"4.8 链接\"></a>4.8 链接</h4><p>链接可以由两种形式生成：<strong>行内式</strong>和<strong>参考式</strong>。<br><strong>行内式</strong>：</p>\n<blockquote>\n<p>[ywx的Markdown](https:://github.com/yanwenxi)。</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p><a href=\"https:://github.com/yanwenxi\">ywx的Markdown</a>。</p>\n</blockquote>\n<p><strong>参考式</strong>：</p>\n<blockquote>\n<p>[ywx的Markdown1][1]<br>[ywx的Markdown2][2]<br>[1]:https:://github.com/yanwenxi”<br>[2]:https:://github.com/yanwenxi”</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p>[ywx的Markdown1][1]<br>[ywx的Markdown2][2]</p>\n</blockquote>\n<h4 id=\"4-9-图片\"><a href=\"#4-9-图片\" class=\"headerlink\" title=\"4.9 图片\"></a>4.9 图片</h4><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个<code>！</code>。</p>\n<h4 id=\"4-10-反斜杠\"><a href=\"#4-10-反斜杠\" class=\"headerlink\" title=\"4.10 反斜杠\\\"></a>4.10 反斜杠<code>\\</code></h4><p>相当于<strong>反转义</strong>作用。使符号成为普通符号。</p>\n<h4 id=\"4-11-符号’-’\"><a href=\"#4-11-符号’-’\" class=\"headerlink\" title=\"4.11 符号’`’\"></a>4.11 符号’`’</h4><p>起到标记作用。如：</p>\n<blockquote>\n<p>`ctrl+a`</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p><code>ctrl+a</code></p>\n<hr>\n<p><strong>注意</strong>：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。</p>\n<hr>\n<p>以上基本是所有traditonal markdown的语法。</p>\n</blockquote>\n<h3 id=\"其它：\"><a href=\"#其它：\" class=\"headerlink\" title=\"其它：\"></a>其它：</h3><p>列表的使用(非traditonal markdown)：</p>\n<p>用<code>|</code>表示表格纵向边界，表头和表内容用<code>-</code>隔开，并可用<code>:</code>进行对齐设置，两边都有<code>:</code>则表示居中，若不加<code>:</code>则默认左对齐。</p>\n<p>关于其它扩展语法可参见具体工具的使用说明。</p>\n<h3 id=\"markdown里写html标签\"><a href=\"#markdown里写html标签\" class=\"headerlink\" title=\"markdown里写html标签\"></a>markdown里写html标签</h3><p>若直接在md里直接写<p>,这样不能正确解析出来，需要在英文状态下按esc输出“<code>`”，用此包住标签即可。\n例：</code><p><code>,</code><script></p>\n<h4 id=\"粗体和斜体\"><a href=\"#粗体和斜体\" class=\"headerlink\" title=\"粗体和斜体\"></a>粗体和斜体</h4><p>使用 <em>* 或者 __ 表示粗体。使用 </em> 或者 <em> 表示斜体。<br>注意:前后的 * 或 </em> 与要 加粗或倾斜 的字体之间不能有空格。</p>\n<h4 id=\"markdown里如何加入angular中的\"><a href=\"#markdown里如何加入angular中的\" class=\"headerlink\" title=\"markdown里如何加入angular中的{ { } }\"></a>markdown里如何加入angular中的{ { } }</h4><p>我了个去去去，坑了我一上午的时间，文章一直报错，所以标记下：{ { } }要显示在页面上，必须用转义符，并且第个{都需要转义，在代码块中不用转义了，但是在代码高亮显示的时候也必须转义。</p>\n"},{"title":"谢谢，现实！-fatkan","date":"2016-12-31T09:22:05.000Z","_content":"这是一首非常低调的rapper唱的rap，一直都想看他的MV，可惜没有，他基本不录MV，歌词写的非常好，非常正能量，反正我非常喜欢！！！提前祝元旦快乐，歌曲就当礼物了\n<iframe src=\"http://www.tudou.com/programs/view/html5embed.action?type=0&code=L5uQBBv9aWk&lcode=&resourceId=0_06_05_99\" allowtransparency=\"true\"  scrolling=\"no\" border=\"0\" frameborder=\"0\" style=\"width:80%;height:40%;\"></iframe>","source":"_posts/thanks-real.md","raw":"---\ntitle: 谢谢，现实！-fatkan\ndate: 2016-12-31 17:22:05\ntags: rap\n---\n这是一首非常低调的rapper唱的rap，一直都想看他的MV，可惜没有，他基本不录MV，歌词写的非常好，非常正能量，反正我非常喜欢！！！提前祝元旦快乐，歌曲就当礼物了\n<iframe src=\"http://www.tudou.com/programs/view/html5embed.action?type=0&code=L5uQBBv9aWk&lcode=&resourceId=0_06_05_99\" allowtransparency=\"true\"  scrolling=\"no\" border=\"0\" frameborder=\"0\" style=\"width:80%;height:40%;\"></iframe>","slug":"thanks-real","published":1,"updated":"2017-01-01T10:06:00.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv9d0036jgtujwqao8vj","content":"<p>这是一首非常低调的rapper唱的rap，一直都想看他的MV，可惜没有，他基本不录MV，歌词写的非常好，非常正能量，反正我非常喜欢！！！提前祝元旦快乐，歌曲就当礼物了</p>\n<iframe src=\"http://www.tudou.com/programs/view/html5embed.action?type=0&code=L5uQBBv9aWk&lcode=&resourceId=0_06_05_99\" allowtransparency=\"true\" scrolling=\"no\" border=\"0\" frameborder=\"0\" style=\"width:80%;height:40%;\"></iframe>","excerpt":"","more":"<p>这是一首非常低调的rapper唱的rap，一直都想看他的MV，可惜没有，他基本不录MV，歌词写的非常好，非常正能量，反正我非常喜欢！！！提前祝元旦快乐，歌曲就当礼物了</p>\n<iframe src=\"http://www.tudou.com/programs/view/html5embed.action?type=0&code=L5uQBBv9aWk&lcode=&resourceId=0_06_05_99\" allowtransparency=\"true\"  scrolling=\"no\" border=\"0\" frameborder=\"0\" style=\"width:80%;height:40%;\"></iframe>"},{"title":"前端Web开发资源整理","date":"2015-12-13T07:09:54.000Z","_content":"　　说明：关于前端学习网站，太多了，什么官方文档啦、各种在线学习网站啦，只要你想学前端，那么一搜就全出来了，现在对常用到的主要整理为3个部分：\n\n- 1）想开发项目，哪里找教程？\n- 2）关于前端的有趣网站；\n### 一、前端项目哪里找？\n　　哪里可以找到前端项目，就是有源代码的，可以拿来学习或者拿来用的。没有详细的教程，但可以找到项目并查看源代码和效果图：\n- 1、[CodePen](http://codepen.io/)\n网站里有很多很酷的特效，而且看到它们的源代码，也可以看到效果图。\n其实类似的网站有很多，就不一一介绍了：\n- [RunJS](http://runjs.cn/square)\n- [CSSdeck](http://cssdeck.com/)\n\n-  2、[CodePlayer](http://thecodeplayer.com/)\n　　网站里有各种项目效果，选择自己想学的，同样可以看到源代码和效果图，和codepen不同的是你可以看到作者是怎样把代码打出来的。\n\n- 3、[html5tricks](http://www.html5tricks.com/)\n　　网站里有很多前端实现的功能，可以在线查看效果，也可以下载源码的。里面有详细的教程，而且步骤详细，教你一步步开发出项目。\n\n- 4、[phodal/ideabook](http://ideabook.phodal.com/)\n　　一个练手项目集，有很多实战项目，有步骤、效果图，同样可以看到源代码啊。\n\n- 5、[实验楼-WEB](https://www.shiyanlou.com/courses/?course_type=all&tag=Web)\n　　网站里有很多前端项目教程，可以跟着教程一步步在环境中实现，并查看效果图，同样可以下载源代码，非常适合项目实战学习。\n\n### 二、前端有趣的网站：\n\n- 1、[JS1k](http://js1k.com/)\n\n大名鼎鼎的js1K，1K字节以内的Javascript代码，实现一个酷炫的动画、特效、小游戏之类的。官网从2010年开始征集参赛作品。\n- 2、[Can I use](http://caniuse.com/)\n\nCAN I USE，相信每个前端同学都不陌生，查询浏览器兼容性的利器。\n- 3、[JSHint](http://jshint.com/) \n\n一个在线JS检测工具，可以检测JavaScript代码中的错误和潜在问题。\n- 4、[aaencode](http://utf-8.jp/public/aaencode.html)\n\n将JS代码转换成常用的网络表情，例如“(ﾟΘﾟ)”。转换的代码并不复杂，可以在源代码里看到。\n- 5、[jsobfuscate](http://www.danstools.com/javascript-obfuscate/)\n一个在线混淆工具，通过先进的算法，来混淆你的JavaScript代码，使其不可读。该工具还可以减小文件的大小，以便快速加载。\n- 6、[Best CSS Button Generator](http://www.bestcssbuttongenerator.com/)\n \n 网站主要提供各种按钮的CSS代码，你可以从预设的按钮中选择并使用模板用于自己的设计，还可以查看源代码，非常适合学习。\n- 7、[Enjoy CSS](http://enjoycss.com/)\n 网站是一个完整的代码生成器，可以自定义输入域或CSS3按钮，同样可以查看源代码，适合学习。\n- 6、[CSS属性指引](http://www.blooberry.com/indexdot/css/propindex/all.htm)\n \n 一份清单，按字母表顺序列出了每个CSS属性。","source":"_posts/web-resource.md","raw":"---\ntitle: 前端Web开发资源整理\ndate: 2015-12-13 15:09:54\ntags:  web、前端\n---\n　　说明：关于前端学习网站，太多了，什么官方文档啦、各种在线学习网站啦，只要你想学前端，那么一搜就全出来了，现在对常用到的主要整理为3个部分：\n\n- 1）想开发项目，哪里找教程？\n- 2）关于前端的有趣网站；\n### 一、前端项目哪里找？\n　　哪里可以找到前端项目，就是有源代码的，可以拿来学习或者拿来用的。没有详细的教程，但可以找到项目并查看源代码和效果图：\n- 1、[CodePen](http://codepen.io/)\n网站里有很多很酷的特效，而且看到它们的源代码，也可以看到效果图。\n其实类似的网站有很多，就不一一介绍了：\n- [RunJS](http://runjs.cn/square)\n- [CSSdeck](http://cssdeck.com/)\n\n-  2、[CodePlayer](http://thecodeplayer.com/)\n　　网站里有各种项目效果，选择自己想学的，同样可以看到源代码和效果图，和codepen不同的是你可以看到作者是怎样把代码打出来的。\n\n- 3、[html5tricks](http://www.html5tricks.com/)\n　　网站里有很多前端实现的功能，可以在线查看效果，也可以下载源码的。里面有详细的教程，而且步骤详细，教你一步步开发出项目。\n\n- 4、[phodal/ideabook](http://ideabook.phodal.com/)\n　　一个练手项目集，有很多实战项目，有步骤、效果图，同样可以看到源代码啊。\n\n- 5、[实验楼-WEB](https://www.shiyanlou.com/courses/?course_type=all&tag=Web)\n　　网站里有很多前端项目教程，可以跟着教程一步步在环境中实现，并查看效果图，同样可以下载源代码，非常适合项目实战学习。\n\n### 二、前端有趣的网站：\n\n- 1、[JS1k](http://js1k.com/)\n\n大名鼎鼎的js1K，1K字节以内的Javascript代码，实现一个酷炫的动画、特效、小游戏之类的。官网从2010年开始征集参赛作品。\n- 2、[Can I use](http://caniuse.com/)\n\nCAN I USE，相信每个前端同学都不陌生，查询浏览器兼容性的利器。\n- 3、[JSHint](http://jshint.com/) \n\n一个在线JS检测工具，可以检测JavaScript代码中的错误和潜在问题。\n- 4、[aaencode](http://utf-8.jp/public/aaencode.html)\n\n将JS代码转换成常用的网络表情，例如“(ﾟΘﾟ)”。转换的代码并不复杂，可以在源代码里看到。\n- 5、[jsobfuscate](http://www.danstools.com/javascript-obfuscate/)\n一个在线混淆工具，通过先进的算法，来混淆你的JavaScript代码，使其不可读。该工具还可以减小文件的大小，以便快速加载。\n- 6、[Best CSS Button Generator](http://www.bestcssbuttongenerator.com/)\n \n 网站主要提供各种按钮的CSS代码，你可以从预设的按钮中选择并使用模板用于自己的设计，还可以查看源代码，非常适合学习。\n- 7、[Enjoy CSS](http://enjoycss.com/)\n 网站是一个完整的代码生成器，可以自定义输入域或CSS3按钮，同样可以查看源代码，适合学习。\n- 6、[CSS属性指引](http://www.blooberry.com/indexdot/css/propindex/all.htm)\n \n 一份清单，按字母表顺序列出了每个CSS属性。","slug":"web-resource","published":1,"updated":"2016-12-13T07:38:02.078Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv9f0038jgtuj7sij5t8","content":"<p>　　说明：关于前端学习网站，太多了，什么官方文档啦、各种在线学习网站啦，只要你想学前端，那么一搜就全出来了，现在对常用到的主要整理为3个部分：</p>\n<ul>\n<li>1）想开发项目，哪里找教程？</li>\n<li>2）关于前端的有趣网站；<h3 id=\"一、前端项目哪里找？\"><a href=\"#一、前端项目哪里找？\" class=\"headerlink\" title=\"一、前端项目哪里找？\"></a>一、前端项目哪里找？</h3>　　哪里可以找到前端项目，就是有源代码的，可以拿来学习或者拿来用的。没有详细的教程，但可以找到项目并查看源代码和效果图：</li>\n<li>1、<a href=\"http://codepen.io/\" target=\"_blank\" rel=\"external\">CodePen</a><br>网站里有很多很酷的特效，而且看到它们的源代码，也可以看到效果图。<br>其实类似的网站有很多，就不一一介绍了：</li>\n<li><a href=\"http://runjs.cn/square\" target=\"_blank\" rel=\"external\">RunJS</a></li>\n<li><p><a href=\"http://cssdeck.com/\" target=\"_blank\" rel=\"external\">CSSdeck</a></p>\n</li>\n<li><p>2、<a href=\"http://thecodeplayer.com/\" target=\"_blank\" rel=\"external\">CodePlayer</a><br>　　网站里有各种项目效果，选择自己想学的，同样可以看到源代码和效果图，和codepen不同的是你可以看到作者是怎样把代码打出来的。</p>\n</li>\n<li><p>3、<a href=\"http://www.html5tricks.com/\" target=\"_blank\" rel=\"external\">html5tricks</a><br>　　网站里有很多前端实现的功能，可以在线查看效果，也可以下载源码的。里面有详细的教程，而且步骤详细，教你一步步开发出项目。</p>\n</li>\n<li><p>4、<a href=\"http://ideabook.phodal.com/\" target=\"_blank\" rel=\"external\">phodal/ideabook</a><br>　　一个练手项目集，有很多实战项目，有步骤、效果图，同样可以看到源代码啊。</p>\n</li>\n<li><p>5、<a href=\"https://www.shiyanlou.com/courses/?course_type=all&amp;tag=Web\" target=\"_blank\" rel=\"external\">实验楼-WEB</a><br>　　网站里有很多前端项目教程，可以跟着教程一步步在环境中实现，并查看效果图，同样可以下载源代码，非常适合项目实战学习。</p>\n</li>\n</ul>\n<h3 id=\"二、前端有趣的网站：\"><a href=\"#二、前端有趣的网站：\" class=\"headerlink\" title=\"二、前端有趣的网站：\"></a>二、前端有趣的网站：</h3><ul>\n<li>1、<a href=\"http://js1k.com/\" target=\"_blank\" rel=\"external\">JS1k</a></li>\n</ul>\n<p>大名鼎鼎的js1K，1K字节以内的Javascript代码，实现一个酷炫的动画、特效、小游戏之类的。官网从2010年开始征集参赛作品。</p>\n<ul>\n<li>2、<a href=\"http://caniuse.com/\" target=\"_blank\" rel=\"external\">Can I use</a></li>\n</ul>\n<p>CAN I USE，相信每个前端同学都不陌生，查询浏览器兼容性的利器。</p>\n<ul>\n<li>3、<a href=\"http://jshint.com/\" target=\"_blank\" rel=\"external\">JSHint</a> </li>\n</ul>\n<p>一个在线JS检测工具，可以检测JavaScript代码中的错误和潜在问题。</p>\n<ul>\n<li>4、<a href=\"http://utf-8.jp/public/aaencode.html\" target=\"_blank\" rel=\"external\">aaencode</a></li>\n</ul>\n<p>将JS代码转换成常用的网络表情，例如“(ﾟΘﾟ)”。转换的代码并不复杂，可以在源代码里看到。</p>\n<ul>\n<li>5、<a href=\"http://www.danstools.com/javascript-obfuscate/\" target=\"_blank\" rel=\"external\">jsobfuscate</a><br>一个在线混淆工具，通过先进的算法，来混淆你的JavaScript代码，使其不可读。该工具还可以减小文件的大小，以便快速加载。</li>\n<li><p>6、<a href=\"http://www.bestcssbuttongenerator.com/\" target=\"_blank\" rel=\"external\">Best CSS Button Generator</a></p>\n<p>网站主要提供各种按钮的CSS代码，你可以从预设的按钮中选择并使用模板用于自己的设计，还可以查看源代码，非常适合学习。</p>\n</li>\n<li>7、<a href=\"http://enjoycss.com/\" target=\"_blank\" rel=\"external\">Enjoy CSS</a><br>网站是一个完整的代码生成器，可以自定义输入域或CSS3按钮，同样可以查看源代码，适合学习。</li>\n<li><p>6、<a href=\"http://www.blooberry.com/indexdot/css/propindex/all.htm\" target=\"_blank\" rel=\"external\">CSS属性指引</a></p>\n<p>一份清单，按字母表顺序列出了每个CSS属性。</p>\n</li>\n</ul>\n","excerpt":"","more":"<p>　　说明：关于前端学习网站，太多了，什么官方文档啦、各种在线学习网站啦，只要你想学前端，那么一搜就全出来了，现在对常用到的主要整理为3个部分：</p>\n<ul>\n<li>1）想开发项目，哪里找教程？</li>\n<li>2）关于前端的有趣网站；<h3 id=\"一、前端项目哪里找？\"><a href=\"#一、前端项目哪里找？\" class=\"headerlink\" title=\"一、前端项目哪里找？\"></a>一、前端项目哪里找？</h3>　　哪里可以找到前端项目，就是有源代码的，可以拿来学习或者拿来用的。没有详细的教程，但可以找到项目并查看源代码和效果图：</li>\n<li>1、<a href=\"http://codepen.io/\">CodePen</a><br>网站里有很多很酷的特效，而且看到它们的源代码，也可以看到效果图。<br>其实类似的网站有很多，就不一一介绍了：</li>\n<li><a href=\"http://runjs.cn/square\">RunJS</a></li>\n<li><p><a href=\"http://cssdeck.com/\">CSSdeck</a></p>\n</li>\n<li><p>2、<a href=\"http://thecodeplayer.com/\">CodePlayer</a><br>　　网站里有各种项目效果，选择自己想学的，同样可以看到源代码和效果图，和codepen不同的是你可以看到作者是怎样把代码打出来的。</p>\n</li>\n<li><p>3、<a href=\"http://www.html5tricks.com/\">html5tricks</a><br>　　网站里有很多前端实现的功能，可以在线查看效果，也可以下载源码的。里面有详细的教程，而且步骤详细，教你一步步开发出项目。</p>\n</li>\n<li><p>4、<a href=\"http://ideabook.phodal.com/\">phodal/ideabook</a><br>　　一个练手项目集，有很多实战项目，有步骤、效果图，同样可以看到源代码啊。</p>\n</li>\n<li><p>5、<a href=\"https://www.shiyanlou.com/courses/?course_type=all&amp;tag=Web\">实验楼-WEB</a><br>　　网站里有很多前端项目教程，可以跟着教程一步步在环境中实现，并查看效果图，同样可以下载源代码，非常适合项目实战学习。</p>\n</li>\n</ul>\n<h3 id=\"二、前端有趣的网站：\"><a href=\"#二、前端有趣的网站：\" class=\"headerlink\" title=\"二、前端有趣的网站：\"></a>二、前端有趣的网站：</h3><ul>\n<li>1、<a href=\"http://js1k.com/\">JS1k</a></li>\n</ul>\n<p>大名鼎鼎的js1K，1K字节以内的Javascript代码，实现一个酷炫的动画、特效、小游戏之类的。官网从2010年开始征集参赛作品。</p>\n<ul>\n<li>2、<a href=\"http://caniuse.com/\">Can I use</a></li>\n</ul>\n<p>CAN I USE，相信每个前端同学都不陌生，查询浏览器兼容性的利器。</p>\n<ul>\n<li>3、<a href=\"http://jshint.com/\">JSHint</a> </li>\n</ul>\n<p>一个在线JS检测工具，可以检测JavaScript代码中的错误和潜在问题。</p>\n<ul>\n<li>4、<a href=\"http://utf-8.jp/public/aaencode.html\">aaencode</a></li>\n</ul>\n<p>将JS代码转换成常用的网络表情，例如“(ﾟΘﾟ)”。转换的代码并不复杂，可以在源代码里看到。</p>\n<ul>\n<li>5、<a href=\"http://www.danstools.com/javascript-obfuscate/\">jsobfuscate</a><br>一个在线混淆工具，通过先进的算法，来混淆你的JavaScript代码，使其不可读。该工具还可以减小文件的大小，以便快速加载。</li>\n<li><p>6、<a href=\"http://www.bestcssbuttongenerator.com/\">Best CSS Button Generator</a></p>\n<p>网站主要提供各种按钮的CSS代码，你可以从预设的按钮中选择并使用模板用于自己的设计，还可以查看源代码，非常适合学习。</p>\n</li>\n<li>7、<a href=\"http://enjoycss.com/\">Enjoy CSS</a><br>网站是一个完整的代码生成器，可以自定义输入域或CSS3按钮，同样可以查看源代码，适合学习。</li>\n<li><p>6、<a href=\"http://www.blooberry.com/indexdot/css/propindex/all.htm\">CSS属性指引</a></p>\n<p>一份清单，按字母表顺序列出了每个CSS属性。</p>\n</li>\n</ul>\n"},{"title":"前端性能优化积累","date":"2016-01-22T02:01:06.000Z","_content":"1. 阿里云云存储服务-对象存储OSS\n对象存储（Object Storage Service，简称OSS），是阿里云对外提供的海量、安全和高可靠的云存储服务。按实际容量及流量收费。可以放置项目图片及项目的静态文件，每个文件对应返回一个url可以直接调用,用此方法可以减轻服务器的压力及减少了http请求次数。当然也可以用其他云服务比如七牛云等，个人博客的话建议用七牛云，认证后会有10g的免费空间，足够使用了。\n2. 图片转base64\n可根据项目需要来决定是否使用base64，虽然转了base64可减少http请求数，但是过多使用会造成页面的冗余。其次是无法利用浏览器缓存。\n3. css sprite\n雪碧图又称css精灵，这是一种常用的优化手段，将多个小图片或者小图标合并到一张大图上，根据定位来计算要显示的图标，现在可以用字体图标来代替一些常用的小图标，建议项目中这么干。\n4. css及js文件合并与压缩\n可以使用打包工具对文件进行处理，比如webpack,gulp,建议自己学习。如果你到了一个牛比的大公司就不用细学了，因为有专门的打包工程师来负责，你只管开发代码就可以了。\n5. 从设计实现层面简化页面\n　如果你的页面像百度首页一样简单，那么上面的规则基本上都用不着了。保持页面简洁、减少资源的使用是最直接的。\n6. 合理设置 HTTP缓存\n　    缓存的力量是强大的，恰当的缓存设置可以大大的减少 HTTP请求。（这里需要说明的是，如果直接 F5刷新页面的话效果是不一样的，这种情况下请求数还是一样，不过被缓存资源的请求服务器是 304响应，只有 Header没有Body ，可以节省带宽 )\n     那么怎样才算合理设置 ?原则很简单，能缓存越多越好，能缓存越久越好。例如，很少变化的图片资源可以直接通过 HTTP Header中的Expires设置一个很长的过期头 ;变化不频繁而又可能会变的资源可以使用 Last-Modifed来做请求验证。尽可能的让资源能够在缓存中待得更久。\n7. Lazy Load Images\n延迟加载图片，在移动端常用，因为流量比较贵，要一心想着为用户节省流量及提升用户的体验，这也是前端工程师的职责。这条策略实际上并不一定能减少 HTTP请求数，但是却能在某些条件下或者页面刚加载时减少HTTP请求数。对于图片而言，在页面刚加载的时候可以只加载第一屏，当用户继续往后滚屏的时候才加载后续的图片。这样一来，假如用户只对第一屏的内容感兴趣时，那剩余的图片请求就都节省了。也可理解为按需加载。\n8. 将外部脚本置底（将脚本内容在页面信息内容加载后再加载）\n浏览器是可以并发请求的，这一特点使得其能够更快的加载资源，然而外链脚本在加载时却会阻塞其他资源，例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载。如果将脚本放在比较靠前的位置，则会影响整个页面的加载速度从而影响用户体验。最简单可依赖的方法就是将脚本尽可能的往后挪，减少对并发下载的影响。\n9. 异步执行 inline脚本(其实原理和上面是一样，保证脚本在页面内容后面加载。)\n　　inline脚本对性能的影响与外部脚本相比，是有过之而无不及。首页，与外部脚本一样， inline脚本在执行的时候一样会阻塞并发请求，除此之外，由于浏览器在页面处理方面是单线程的，当 inline脚本在页面渲染之前执行时，页面的渲染工作则会被推迟。简而言之， inline脚本在执行的时候，页面处于空白状态。鉴于以上两点原因，建议将执行时间较长的 inline脚本异步执行，异步的方式有很多种，例如使用 script元素的defer属性(存在兼容性问题和其他一些问题，例如不能使用 document.write)、使用setTimeout ，此外，在HTML5中引入了 Web Workers的机制，恰恰可以解决此类问题。此条没有实践过，因为没写过行内js，当然也不建议写行内js。\n10. Lazy Load Javascript（只有在需要加载的时候加载，在一般情况下并不加载信息内容。）\n    随着 Javascript框架的流行，越来越多的站点也使用起了框架。不过，一个框架往往包括了很多的功能实现，这些功能并不是每一个页面都需要的，如果下载了不需要的脚本则算得上是一种资源浪费 -既浪费了带宽又浪费了执行花费的时间。目前的做法大概有两种，一种是为那些流量特别大的页面专门定制一个专用的 mini版框架，另一种则是 Lazy Load。YUI 则使用了第二种方式，在 YUI的实现中，最初只加载核心模块，其他模块可以等到需要使用的时候才加载。\n    注：YUI 库，全称Yahoo! UI Library。是一组工具和控件，用JavaScript写成, 为的是用DOM 脚本，DHTML和AJAX等技术创建丰富的网页交互式应用程序。\n11. 将 CSS放在 HEAD中\n    　如果将 CSS放在其他地方比如 BODY中，则浏览器有可能还未下载和解析到 CSS就已经开始渲染页面了，这就导致页面由无 CSS状态跳转到 CSS状态，用户体验比较糟糕。除此之外，有些浏览器会在 CSS下载完成后才开始渲染页面，如果 CSS放在靠下的位置则会导致浏览器将渲染时间推迟。\n12. 避免重复的资源请求\n　　这种情况主要是由于疏忽或页面由多个模块拼接而成，然后每个模块中请求了同样的资源时，会导致资源的重复请求 \n13. js代码级优化\n一是尽量减少dom操作。DOM操作应该是脚本中最耗性能的一类操作，例如增加、修改、删除 DOM元素或者对 DOM集合进行操作。二是 慎用with。三是 避免使用 eval和 Function。四是减少作用域链查找。五是字符串拼接：\n 在 Javascript中使用\"+\" 号来拼接字符串效率是比较低的，因为每次运行都会开辟新的内存并生成新的字符串变量，然后将拼接结果赋值给新变量。六是CSS选择符：#top a { color: #444; }。注意：浏览器对选择符的解析是从右往左进行的。如上面的选择符，浏览器必须遍历查找每一个a标签的祖先节点，看看哪个是#top然后再渲染，并不是我们想的那样从左往右进行渲染，当然效率并不像我们想象的那样高。\n14. cdn加速\n如果面试你上面的基本都说出来了，面试官还问你有什么牛比的优化方案没，你就来一句cdn加速啊,说实在的，你就是再怎么费劲吧次地优化，再怎么减少http请求，也不如直接弄个cdn快，cdn就是这么牛比，一线互联网公司都开启了cdn加速，要不打开网页速度嗖嗖的啊。\n\n上面的优化只是项目中比较常用的，当然还有其他一些常用的优化方案，最后啥也不说了，yahoo前端性能团队总结的35条黄金定律如下图：大家可以自行学习下\n![](http://oi28tswuq.bkt.clouddn.com/images/xingnengyouhua.png)\n","source":"_posts/web-xingnengyouhua.md","raw":"---\ntitle: 前端性能优化积累\ndate: 2016-1-22 10:01:06\ntags: web、性能优化\n---\n1. 阿里云云存储服务-对象存储OSS\n对象存储（Object Storage Service，简称OSS），是阿里云对外提供的海量、安全和高可靠的云存储服务。按实际容量及流量收费。可以放置项目图片及项目的静态文件，每个文件对应返回一个url可以直接调用,用此方法可以减轻服务器的压力及减少了http请求次数。当然也可以用其他云服务比如七牛云等，个人博客的话建议用七牛云，认证后会有10g的免费空间，足够使用了。\n2. 图片转base64\n可根据项目需要来决定是否使用base64，虽然转了base64可减少http请求数，但是过多使用会造成页面的冗余。其次是无法利用浏览器缓存。\n3. css sprite\n雪碧图又称css精灵，这是一种常用的优化手段，将多个小图片或者小图标合并到一张大图上，根据定位来计算要显示的图标，现在可以用字体图标来代替一些常用的小图标，建议项目中这么干。\n4. css及js文件合并与压缩\n可以使用打包工具对文件进行处理，比如webpack,gulp,建议自己学习。如果你到了一个牛比的大公司就不用细学了，因为有专门的打包工程师来负责，你只管开发代码就可以了。\n5. 从设计实现层面简化页面\n　如果你的页面像百度首页一样简单，那么上面的规则基本上都用不着了。保持页面简洁、减少资源的使用是最直接的。\n6. 合理设置 HTTP缓存\n　    缓存的力量是强大的，恰当的缓存设置可以大大的减少 HTTP请求。（这里需要说明的是，如果直接 F5刷新页面的话效果是不一样的，这种情况下请求数还是一样，不过被缓存资源的请求服务器是 304响应，只有 Header没有Body ，可以节省带宽 )\n     那么怎样才算合理设置 ?原则很简单，能缓存越多越好，能缓存越久越好。例如，很少变化的图片资源可以直接通过 HTTP Header中的Expires设置一个很长的过期头 ;变化不频繁而又可能会变的资源可以使用 Last-Modifed来做请求验证。尽可能的让资源能够在缓存中待得更久。\n7. Lazy Load Images\n延迟加载图片，在移动端常用，因为流量比较贵，要一心想着为用户节省流量及提升用户的体验，这也是前端工程师的职责。这条策略实际上并不一定能减少 HTTP请求数，但是却能在某些条件下或者页面刚加载时减少HTTP请求数。对于图片而言，在页面刚加载的时候可以只加载第一屏，当用户继续往后滚屏的时候才加载后续的图片。这样一来，假如用户只对第一屏的内容感兴趣时，那剩余的图片请求就都节省了。也可理解为按需加载。\n8. 将外部脚本置底（将脚本内容在页面信息内容加载后再加载）\n浏览器是可以并发请求的，这一特点使得其能够更快的加载资源，然而外链脚本在加载时却会阻塞其他资源，例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载。如果将脚本放在比较靠前的位置，则会影响整个页面的加载速度从而影响用户体验。最简单可依赖的方法就是将脚本尽可能的往后挪，减少对并发下载的影响。\n9. 异步执行 inline脚本(其实原理和上面是一样，保证脚本在页面内容后面加载。)\n　　inline脚本对性能的影响与外部脚本相比，是有过之而无不及。首页，与外部脚本一样， inline脚本在执行的时候一样会阻塞并发请求，除此之外，由于浏览器在页面处理方面是单线程的，当 inline脚本在页面渲染之前执行时，页面的渲染工作则会被推迟。简而言之， inline脚本在执行的时候，页面处于空白状态。鉴于以上两点原因，建议将执行时间较长的 inline脚本异步执行，异步的方式有很多种，例如使用 script元素的defer属性(存在兼容性问题和其他一些问题，例如不能使用 document.write)、使用setTimeout ，此外，在HTML5中引入了 Web Workers的机制，恰恰可以解决此类问题。此条没有实践过，因为没写过行内js，当然也不建议写行内js。\n10. Lazy Load Javascript（只有在需要加载的时候加载，在一般情况下并不加载信息内容。）\n    随着 Javascript框架的流行，越来越多的站点也使用起了框架。不过，一个框架往往包括了很多的功能实现，这些功能并不是每一个页面都需要的，如果下载了不需要的脚本则算得上是一种资源浪费 -既浪费了带宽又浪费了执行花费的时间。目前的做法大概有两种，一种是为那些流量特别大的页面专门定制一个专用的 mini版框架，另一种则是 Lazy Load。YUI 则使用了第二种方式，在 YUI的实现中，最初只加载核心模块，其他模块可以等到需要使用的时候才加载。\n    注：YUI 库，全称Yahoo! UI Library。是一组工具和控件，用JavaScript写成, 为的是用DOM 脚本，DHTML和AJAX等技术创建丰富的网页交互式应用程序。\n11. 将 CSS放在 HEAD中\n    　如果将 CSS放在其他地方比如 BODY中，则浏览器有可能还未下载和解析到 CSS就已经开始渲染页面了，这就导致页面由无 CSS状态跳转到 CSS状态，用户体验比较糟糕。除此之外，有些浏览器会在 CSS下载完成后才开始渲染页面，如果 CSS放在靠下的位置则会导致浏览器将渲染时间推迟。\n12. 避免重复的资源请求\n　　这种情况主要是由于疏忽或页面由多个模块拼接而成，然后每个模块中请求了同样的资源时，会导致资源的重复请求 \n13. js代码级优化\n一是尽量减少dom操作。DOM操作应该是脚本中最耗性能的一类操作，例如增加、修改、删除 DOM元素或者对 DOM集合进行操作。二是 慎用with。三是 避免使用 eval和 Function。四是减少作用域链查找。五是字符串拼接：\n 在 Javascript中使用\"+\" 号来拼接字符串效率是比较低的，因为每次运行都会开辟新的内存并生成新的字符串变量，然后将拼接结果赋值给新变量。六是CSS选择符：#top a { color: #444; }。注意：浏览器对选择符的解析是从右往左进行的。如上面的选择符，浏览器必须遍历查找每一个a标签的祖先节点，看看哪个是#top然后再渲染，并不是我们想的那样从左往右进行渲染，当然效率并不像我们想象的那样高。\n14. cdn加速\n如果面试你上面的基本都说出来了，面试官还问你有什么牛比的优化方案没，你就来一句cdn加速啊,说实在的，你就是再怎么费劲吧次地优化，再怎么减少http请求，也不如直接弄个cdn快，cdn就是这么牛比，一线互联网公司都开启了cdn加速，要不打开网页速度嗖嗖的啊。\n\n上面的优化只是项目中比较常用的，当然还有其他一些常用的优化方案，最后啥也不说了，yahoo前端性能团队总结的35条黄金定律如下图：大家可以自行学习下\n![](http://oi28tswuq.bkt.clouddn.com/images/xingnengyouhua.png)\n","slug":"web-xingnengyouhua","published":1,"updated":"2016-12-22T03:26:41.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv9i003ajgtur3ywgwj4","content":"<ol>\n<li>阿里云云存储服务-对象存储OSS<br>对象存储（Object Storage Service，简称OSS），是阿里云对外提供的海量、安全和高可靠的云存储服务。按实际容量及流量收费。可以放置项目图片及项目的静态文件，每个文件对应返回一个url可以直接调用,用此方法可以减轻服务器的压力及减少了http请求次数。当然也可以用其他云服务比如七牛云等，个人博客的话建议用七牛云，认证后会有10g的免费空间，足够使用了。</li>\n<li>图片转base64<br>可根据项目需要来决定是否使用base64，虽然转了base64可减少http请求数，但是过多使用会造成页面的冗余。其次是无法利用浏览器缓存。</li>\n<li>css sprite<br>雪碧图又称css精灵，这是一种常用的优化手段，将多个小图片或者小图标合并到一张大图上，根据定位来计算要显示的图标，现在可以用字体图标来代替一些常用的小图标，建议项目中这么干。</li>\n<li>css及js文件合并与压缩<br>可以使用打包工具对文件进行处理，比如webpack,gulp,建议自己学习。如果你到了一个牛比的大公司就不用细学了，因为有专门的打包工程师来负责，你只管开发代码就可以了。</li>\n<li>从设计实现层面简化页面<br>　如果你的页面像百度首页一样简单，那么上面的规则基本上都用不着了。保持页面简洁、减少资源的使用是最直接的。</li>\n<li>合理设置 HTTP缓存<br>　    缓存的力量是强大的，恰当的缓存设置可以大大的减少 HTTP请求。（这里需要说明的是，如果直接 F5刷新页面的话效果是不一样的，这种情况下请求数还是一样，不过被缓存资源的请求服务器是 304响应，只有 Header没有Body ，可以节省带宽 )<br>  那么怎样才算合理设置 ?原则很简单，能缓存越多越好，能缓存越久越好。例如，很少变化的图片资源可以直接通过 HTTP Header中的Expires设置一个很长的过期头 ;变化不频繁而又可能会变的资源可以使用 Last-Modifed来做请求验证。尽可能的让资源能够在缓存中待得更久。</li>\n<li>Lazy Load Images<br>延迟加载图片，在移动端常用，因为流量比较贵，要一心想着为用户节省流量及提升用户的体验，这也是前端工程师的职责。这条策略实际上并不一定能减少 HTTP请求数，但是却能在某些条件下或者页面刚加载时减少HTTP请求数。对于图片而言，在页面刚加载的时候可以只加载第一屏，当用户继续往后滚屏的时候才加载后续的图片。这样一来，假如用户只对第一屏的内容感兴趣时，那剩余的图片请求就都节省了。也可理解为按需加载。</li>\n<li>将外部脚本置底（将脚本内容在页面信息内容加载后再加载）<br>浏览器是可以并发请求的，这一特点使得其能够更快的加载资源，然而外链脚本在加载时却会阻塞其他资源，例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载。如果将脚本放在比较靠前的位置，则会影响整个页面的加载速度从而影响用户体验。最简单可依赖的方法就是将脚本尽可能的往后挪，减少对并发下载的影响。</li>\n<li>异步执行 inline脚本(其实原理和上面是一样，保证脚本在页面内容后面加载。)<br>　　inline脚本对性能的影响与外部脚本相比，是有过之而无不及。首页，与外部脚本一样， inline脚本在执行的时候一样会阻塞并发请求，除此之外，由于浏览器在页面处理方面是单线程的，当 inline脚本在页面渲染之前执行时，页面的渲染工作则会被推迟。简而言之， inline脚本在执行的时候，页面处于空白状态。鉴于以上两点原因，建议将执行时间较长的 inline脚本异步执行，异步的方式有很多种，例如使用 script元素的defer属性(存在兼容性问题和其他一些问题，例如不能使用 document.write)、使用setTimeout ，此外，在HTML5中引入了 Web Workers的机制，恰恰可以解决此类问题。此条没有实践过，因为没写过行内js，当然也不建议写行内js。</li>\n<li>Lazy Load Javascript（只有在需要加载的时候加载，在一般情况下并不加载信息内容。）<br>随着 Javascript框架的流行，越来越多的站点也使用起了框架。不过，一个框架往往包括了很多的功能实现，这些功能并不是每一个页面都需要的，如果下载了不需要的脚本则算得上是一种资源浪费 -既浪费了带宽又浪费了执行花费的时间。目前的做法大概有两种，一种是为那些流量特别大的页面专门定制一个专用的 mini版框架，另一种则是 Lazy Load。YUI 则使用了第二种方式，在 YUI的实现中，最初只加载核心模块，其他模块可以等到需要使用的时候才加载。<br>注：YUI 库，全称Yahoo! UI Library。是一组工具和控件，用JavaScript写成, 为的是用DOM 脚本，DHTML和AJAX等技术创建丰富的网页交互式应用程序。</li>\n<li>将 CSS放在 HEAD中<br>　如果将 CSS放在其他地方比如 BODY中，则浏览器有可能还未下载和解析到 CSS就已经开始渲染页面了，这就导致页面由无 CSS状态跳转到 CSS状态，用户体验比较糟糕。除此之外，有些浏览器会在 CSS下载完成后才开始渲染页面，如果 CSS放在靠下的位置则会导致浏览器将渲染时间推迟。</li>\n<li>避免重复的资源请求<br>　　这种情况主要是由于疏忽或页面由多个模块拼接而成，然后每个模块中请求了同样的资源时，会导致资源的重复请求 </li>\n<li>js代码级优化<br>一是尽量减少dom操作。DOM操作应该是脚本中最耗性能的一类操作，例如增加、修改、删除 DOM元素或者对 DOM集合进行操作。二是 慎用with。三是 避免使用 eval和 Function。四是减少作用域链查找。五是字符串拼接：<br>在 Javascript中使用”+” 号来拼接字符串效率是比较低的，因为每次运行都会开辟新的内存并生成新的字符串变量，然后将拼接结果赋值给新变量。六是CSS选择符：#top a { color: #444; }。注意：浏览器对选择符的解析是从右往左进行的。如上面的选择符，浏览器必须遍历查找每一个a标签的祖先节点，看看哪个是#top然后再渲染，并不是我们想的那样从左往右进行渲染，当然效率并不像我们想象的那样高。</li>\n<li>cdn加速<br>如果面试你上面的基本都说出来了，面试官还问你有什么牛比的优化方案没，你就来一句cdn加速啊,说实在的，你就是再怎么费劲吧次地优化，再怎么减少http请求，也不如直接弄个cdn快，cdn就是这么牛比，一线互联网公司都开启了cdn加速，要不打开网页速度嗖嗖的啊。</li>\n</ol>\n<p>上面的优化只是项目中比较常用的，当然还有其他一些常用的优化方案，最后啥也不说了，yahoo前端性能团队总结的35条黄金定律如下图：大家可以自行学习下<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/xingnengyouhua.png\" alt=\"\"></p>\n","excerpt":"","more":"<ol>\n<li>阿里云云存储服务-对象存储OSS<br>对象存储（Object Storage Service，简称OSS），是阿里云对外提供的海量、安全和高可靠的云存储服务。按实际容量及流量收费。可以放置项目图片及项目的静态文件，每个文件对应返回一个url可以直接调用,用此方法可以减轻服务器的压力及减少了http请求次数。当然也可以用其他云服务比如七牛云等，个人博客的话建议用七牛云，认证后会有10g的免费空间，足够使用了。</li>\n<li>图片转base64<br>可根据项目需要来决定是否使用base64，虽然转了base64可减少http请求数，但是过多使用会造成页面的冗余。其次是无法利用浏览器缓存。</li>\n<li>css sprite<br>雪碧图又称css精灵，这是一种常用的优化手段，将多个小图片或者小图标合并到一张大图上，根据定位来计算要显示的图标，现在可以用字体图标来代替一些常用的小图标，建议项目中这么干。</li>\n<li>css及js文件合并与压缩<br>可以使用打包工具对文件进行处理，比如webpack,gulp,建议自己学习。如果你到了一个牛比的大公司就不用细学了，因为有专门的打包工程师来负责，你只管开发代码就可以了。</li>\n<li>从设计实现层面简化页面<br>　如果你的页面像百度首页一样简单，那么上面的规则基本上都用不着了。保持页面简洁、减少资源的使用是最直接的。</li>\n<li>合理设置 HTTP缓存<br>　    缓存的力量是强大的，恰当的缓存设置可以大大的减少 HTTP请求。（这里需要说明的是，如果直接 F5刷新页面的话效果是不一样的，这种情况下请求数还是一样，不过被缓存资源的请求服务器是 304响应，只有 Header没有Body ，可以节省带宽 )<br>  那么怎样才算合理设置 ?原则很简单，能缓存越多越好，能缓存越久越好。例如，很少变化的图片资源可以直接通过 HTTP Header中的Expires设置一个很长的过期头 ;变化不频繁而又可能会变的资源可以使用 Last-Modifed来做请求验证。尽可能的让资源能够在缓存中待得更久。</li>\n<li>Lazy Load Images<br>延迟加载图片，在移动端常用，因为流量比较贵，要一心想着为用户节省流量及提升用户的体验，这也是前端工程师的职责。这条策略实际上并不一定能减少 HTTP请求数，但是却能在某些条件下或者页面刚加载时减少HTTP请求数。对于图片而言，在页面刚加载的时候可以只加载第一屏，当用户继续往后滚屏的时候才加载后续的图片。这样一来，假如用户只对第一屏的内容感兴趣时，那剩余的图片请求就都节省了。也可理解为按需加载。</li>\n<li>将外部脚本置底（将脚本内容在页面信息内容加载后再加载）<br>浏览器是可以并发请求的，这一特点使得其能够更快的加载资源，然而外链脚本在加载时却会阻塞其他资源，例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载。如果将脚本放在比较靠前的位置，则会影响整个页面的加载速度从而影响用户体验。最简单可依赖的方法就是将脚本尽可能的往后挪，减少对并发下载的影响。</li>\n<li>异步执行 inline脚本(其实原理和上面是一样，保证脚本在页面内容后面加载。)<br>　　inline脚本对性能的影响与外部脚本相比，是有过之而无不及。首页，与外部脚本一样， inline脚本在执行的时候一样会阻塞并发请求，除此之外，由于浏览器在页面处理方面是单线程的，当 inline脚本在页面渲染之前执行时，页面的渲染工作则会被推迟。简而言之， inline脚本在执行的时候，页面处于空白状态。鉴于以上两点原因，建议将执行时间较长的 inline脚本异步执行，异步的方式有很多种，例如使用 script元素的defer属性(存在兼容性问题和其他一些问题，例如不能使用 document.write)、使用setTimeout ，此外，在HTML5中引入了 Web Workers的机制，恰恰可以解决此类问题。此条没有实践过，因为没写过行内js，当然也不建议写行内js。</li>\n<li>Lazy Load Javascript（只有在需要加载的时候加载，在一般情况下并不加载信息内容。）<br>随着 Javascript框架的流行，越来越多的站点也使用起了框架。不过，一个框架往往包括了很多的功能实现，这些功能并不是每一个页面都需要的，如果下载了不需要的脚本则算得上是一种资源浪费 -既浪费了带宽又浪费了执行花费的时间。目前的做法大概有两种，一种是为那些流量特别大的页面专门定制一个专用的 mini版框架，另一种则是 Lazy Load。YUI 则使用了第二种方式，在 YUI的实现中，最初只加载核心模块，其他模块可以等到需要使用的时候才加载。<br>注：YUI 库，全称Yahoo! UI Library。是一组工具和控件，用JavaScript写成, 为的是用DOM 脚本，DHTML和AJAX等技术创建丰富的网页交互式应用程序。</li>\n<li>将 CSS放在 HEAD中<br>　如果将 CSS放在其他地方比如 BODY中，则浏览器有可能还未下载和解析到 CSS就已经开始渲染页面了，这就导致页面由无 CSS状态跳转到 CSS状态，用户体验比较糟糕。除此之外，有些浏览器会在 CSS下载完成后才开始渲染页面，如果 CSS放在靠下的位置则会导致浏览器将渲染时间推迟。</li>\n<li>避免重复的资源请求<br>　　这种情况主要是由于疏忽或页面由多个模块拼接而成，然后每个模块中请求了同样的资源时，会导致资源的重复请求 </li>\n<li>js代码级优化<br>一是尽量减少dom操作。DOM操作应该是脚本中最耗性能的一类操作，例如增加、修改、删除 DOM元素或者对 DOM集合进行操作。二是 慎用with。三是 避免使用 eval和 Function。四是减少作用域链查找。五是字符串拼接：<br>在 Javascript中使用”+” 号来拼接字符串效率是比较低的，因为每次运行都会开辟新的内存并生成新的字符串变量，然后将拼接结果赋值给新变量。六是CSS选择符：#top a { color: #444; }。注意：浏览器对选择符的解析是从右往左进行的。如上面的选择符，浏览器必须遍历查找每一个a标签的祖先节点，看看哪个是#top然后再渲染，并不是我们想的那样从左往右进行渲染，当然效率并不像我们想象的那样高。</li>\n<li>cdn加速<br>如果面试你上面的基本都说出来了，面试官还问你有什么牛比的优化方案没，你就来一句cdn加速啊,说实在的，你就是再怎么费劲吧次地优化，再怎么减少http请求，也不如直接弄个cdn快，cdn就是这么牛比，一线互联网公司都开启了cdn加速，要不打开网页速度嗖嗖的啊。</li>\n</ol>\n<p>上面的优化只是项目中比较常用的，当然还有其他一些常用的优化方案，最后啥也不说了，yahoo前端性能团队总结的35条黄金定律如下图：大家可以自行学习下<br><img src=\"http://oi28tswuq.bkt.clouddn.com/images/xingnengyouhua.png\" alt=\"\"></p>\n"},{"title":"nodejs开发微信公众号介绍","date":"2017-01-10T08:32:43.000Z","_content":"\n公众号开发需要与公众号后台有交互，需要在后台网页进行配置，比如通信的域名地址，js sdk的授权地址等等。\nsdk （软件开发工具包）：外语全称：Software Development Kit,通俗一点的理解，是指由第三方服务商提供的实现软件产品某项功能的工具包。一般以集合api和文档、范例、工具的形式出现.\n\n这个Nodejs项目会用到不少框架或者模块，并没有100%用es6的规范来开发，而是混用了一些es6的特性，比如yield\n\n项目的web层使用的框架是KOA，主要用来处理服务器之间的应用初始化、接口调用以及数据的响应。\nPromise尽管在高版本Nodejs里面已经原生提供，我们还是用到了一个Promise库，就是bluebird,用来处理和封装异步请求。\n网络请求我们使用的request，它是对原生的http request的封装\n\n微信的数据包装方式是xml，所以我们借助ejs这个模板库，把数据作为变量替换到xml字符中\n\n还有一些工具模块，比如lodash是一些常用的方法集，做数组拆分，类型判断等等，Heredoc是一个黑科技，把函数体里面的多行的注释作为字符串提取出来，主要用来降低拼接字符串的成本。\n\nraw-body用来获取一个http请求返回的可读流的内容实体。对于加密我们选用sha1这个哈希算法库。\n\n微信服务器返回的数据既然是xml格式的，我们就没法直接在js函数中使用，所以会借助xml2js这个模块把xml数据解析为js对象，方便我们使用。\n\n小难点：1.微信公众号的配置接入流程 2.wechat加密认证环节 3.票据access_token.\n\n需要具备的基础：1、能利用nodejs开发一些常用网页或者爬虫工具，来对nodejs api和它的技术特点有一定的认识。2.有些其他的后端语言经验，比如：java,php等，主要弄明白一个网络http请求从开始到结束中间所经过的这些环节。\n前五天针对微信常用接口进行一个一个的单独讲解和实现，并且有许多的小案例来演示。后两天开发电影公众号的这个网站项目。\n\n为了让本地调试环境与微信远端服务器之间进行通信，我们要用到网络代理工具，我们可以借助QQ浏览器，也可以用ngrok.","source":"_posts/wechat1-1.md","raw":"---\ntitle: nodejs开发微信公众号介绍\ndate: 2017-01-10 16:32:43\ntags: node wechat\n---\n\n公众号开发需要与公众号后台有交互，需要在后台网页进行配置，比如通信的域名地址，js sdk的授权地址等等。\nsdk （软件开发工具包）：外语全称：Software Development Kit,通俗一点的理解，是指由第三方服务商提供的实现软件产品某项功能的工具包。一般以集合api和文档、范例、工具的形式出现.\n\n这个Nodejs项目会用到不少框架或者模块，并没有100%用es6的规范来开发，而是混用了一些es6的特性，比如yield\n\n项目的web层使用的框架是KOA，主要用来处理服务器之间的应用初始化、接口调用以及数据的响应。\nPromise尽管在高版本Nodejs里面已经原生提供，我们还是用到了一个Promise库，就是bluebird,用来处理和封装异步请求。\n网络请求我们使用的request，它是对原生的http request的封装\n\n微信的数据包装方式是xml，所以我们借助ejs这个模板库，把数据作为变量替换到xml字符中\n\n还有一些工具模块，比如lodash是一些常用的方法集，做数组拆分，类型判断等等，Heredoc是一个黑科技，把函数体里面的多行的注释作为字符串提取出来，主要用来降低拼接字符串的成本。\n\nraw-body用来获取一个http请求返回的可读流的内容实体。对于加密我们选用sha1这个哈希算法库。\n\n微信服务器返回的数据既然是xml格式的，我们就没法直接在js函数中使用，所以会借助xml2js这个模块把xml数据解析为js对象，方便我们使用。\n\n小难点：1.微信公众号的配置接入流程 2.wechat加密认证环节 3.票据access_token.\n\n需要具备的基础：1、能利用nodejs开发一些常用网页或者爬虫工具，来对nodejs api和它的技术特点有一定的认识。2.有些其他的后端语言经验，比如：java,php等，主要弄明白一个网络http请求从开始到结束中间所经过的这些环节。\n前五天针对微信常用接口进行一个一个的单独讲解和实现，并且有许多的小案例来演示。后两天开发电影公众号的这个网站项目。\n\n为了让本地调试环境与微信远端服务器之间进行通信，我们要用到网络代理工具，我们可以借助QQ浏览器，也可以用ngrok.","slug":"wechat1-1","published":1,"updated":"2017-01-10T08:37:11.219Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv9l003cjgtu6fvu7dn6","content":"<p>公众号开发需要与公众号后台有交互，需要在后台网页进行配置，比如通信的域名地址，js sdk的授权地址等等。<br>sdk （软件开发工具包）：外语全称：Software Development Kit,通俗一点的理解，是指由第三方服务商提供的实现软件产品某项功能的工具包。一般以集合api和文档、范例、工具的形式出现.</p>\n<p>这个Nodejs项目会用到不少框架或者模块，并没有100%用es6的规范来开发，而是混用了一些es6的特性，比如yield</p>\n<p>项目的web层使用的框架是KOA，主要用来处理服务器之间的应用初始化、接口调用以及数据的响应。<br>Promise尽管在高版本Nodejs里面已经原生提供，我们还是用到了一个Promise库，就是bluebird,用来处理和封装异步请求。<br>网络请求我们使用的request，它是对原生的http request的封装</p>\n<p>微信的数据包装方式是xml，所以我们借助ejs这个模板库，把数据作为变量替换到xml字符中</p>\n<p>还有一些工具模块，比如lodash是一些常用的方法集，做数组拆分，类型判断等等，Heredoc是一个黑科技，把函数体里面的多行的注释作为字符串提取出来，主要用来降低拼接字符串的成本。</p>\n<p>raw-body用来获取一个http请求返回的可读流的内容实体。对于加密我们选用sha1这个哈希算法库。</p>\n<p>微信服务器返回的数据既然是xml格式的，我们就没法直接在js函数中使用，所以会借助xml2js这个模块把xml数据解析为js对象，方便我们使用。</p>\n<p>小难点：1.微信公众号的配置接入流程 2.wechat加密认证环节 3.票据access_token.</p>\n<p>需要具备的基础：1、能利用nodejs开发一些常用网页或者爬虫工具，来对nodejs api和它的技术特点有一定的认识。2.有些其他的后端语言经验，比如：java,php等，主要弄明白一个网络http请求从开始到结束中间所经过的这些环节。<br>前五天针对微信常用接口进行一个一个的单独讲解和实现，并且有许多的小案例来演示。后两天开发电影公众号的这个网站项目。</p>\n<p>为了让本地调试环境与微信远端服务器之间进行通信，我们要用到网络代理工具，我们可以借助QQ浏览器，也可以用ngrok.</p>\n","excerpt":"","more":"<p>公众号开发需要与公众号后台有交互，需要在后台网页进行配置，比如通信的域名地址，js sdk的授权地址等等。<br>sdk （软件开发工具包）：外语全称：Software Development Kit,通俗一点的理解，是指由第三方服务商提供的实现软件产品某项功能的工具包。一般以集合api和文档、范例、工具的形式出现.</p>\n<p>这个Nodejs项目会用到不少框架或者模块，并没有100%用es6的规范来开发，而是混用了一些es6的特性，比如yield</p>\n<p>项目的web层使用的框架是KOA，主要用来处理服务器之间的应用初始化、接口调用以及数据的响应。<br>Promise尽管在高版本Nodejs里面已经原生提供，我们还是用到了一个Promise库，就是bluebird,用来处理和封装异步请求。<br>网络请求我们使用的request，它是对原生的http request的封装</p>\n<p>微信的数据包装方式是xml，所以我们借助ejs这个模板库，把数据作为变量替换到xml字符中</p>\n<p>还有一些工具模块，比如lodash是一些常用的方法集，做数组拆分，类型判断等等，Heredoc是一个黑科技，把函数体里面的多行的注释作为字符串提取出来，主要用来降低拼接字符串的成本。</p>\n<p>raw-body用来获取一个http请求返回的可读流的内容实体。对于加密我们选用sha1这个哈希算法库。</p>\n<p>微信服务器返回的数据既然是xml格式的，我们就没法直接在js函数中使用，所以会借助xml2js这个模块把xml数据解析为js对象，方便我们使用。</p>\n<p>小难点：1.微信公众号的配置接入流程 2.wechat加密认证环节 3.票据access_token.</p>\n<p>需要具备的基础：1、能利用nodejs开发一些常用网页或者爬虫工具，来对nodejs api和它的技术特点有一定的认识。2.有些其他的后端语言经验，比如：java,php等，主要弄明白一个网络http请求从开始到结束中间所经过的这些环节。<br>前五天针对微信常用接口进行一个一个的单独讲解和实现，并且有许多的小案例来演示。后两天开发电影公众号的这个网站项目。</p>\n<p>为了让本地调试环境与微信远端服务器之间进行通信，我们要用到网络代理工具，我们可以借助QQ浏览器，也可以用ngrok.</p>\n"},{"title":"微信号分类与功能","date":"2017-01-10T08:38:13.000Z","_content":"\n#### 微信号分类：\n1.企业号：不太适合个人小型开发，是为企业或者组织提供移动应用入口，帮助企业建立与员工、上下游供应链及企业应用间的连接。\n2.订阅号：比较适合与个人。小团队，小公司，主要用于信息的传播，帮助管理用户以及和用户互动。比如撰写文章 咨询传播，消息定制等等。\n3.服务号：企业和组织，提供更强大的业务服务与用户管理能力，比如支付，智能接口。\n#### 举个例子来理解微信号的区别：\n订阅号：管理一个班级，一个学院的信息订阅，通知和互动。\n服务号：管理全学校的水果商店或者打印店，可以直接支付送货上门，及时推送一些特价水果。\n企业号：管理全学校所有学院，团委，学生处各个部门上班人员的考勤，活动进程等等。\n\n#### 公众号认证方面：\n订阅号：认证和非认证账号的区别就是，认证账号别人可以直接在添加好友里搜索关键词就能找到你。\n订阅号和服务号三点不同：\n1.关注后出现的位置不同\n2.是单月发送消息的消息数量不同，订阅号可以一天一篇，服务号一个月最多4篇。\n3.订阅号没有9大接口和支付功能。\n#### 服务号9大接口有哪些：\n1.语音识别：就是能识别你说的话，并翻译成文本内容。\n2.客服接口：就是公众号可以在你发送过消息的24小时内，向你回复消息\n3.OAuth 2.0网页授权：可以通过这个授权接口，请求用户授权，从而拿到更多用户的信息。\n4.生成带参数的二维码：公众号可以获得一系列携带不同参数的二维码，在用户扫描关注公众号后，公众号可以根据参数分析各二维的效果，这些参数可以自己定制，从而可以实现更多分析结果，比如用户从哪儿来的。\n5.获取用户地理位置：公众号能够获得用户进入公众号会话时的地理位置。可以做微信导航。\n6.获取用户的基本信息：公众号可以根据加密后的用户OpenID,通过一系列的参数交互，最终拿到用户基础信息，包括头像、名称、性别、地区。\n7.获取关注者列表：通过这个接口，可以拿到所有关注者的OpenID,就知道有多少人关注你，是谁在关注你。\n8.用户分组接口：通过分组接口，可以在后台为用户移动，创建、修改分组，比如把你们班级你们团队分成男生一组，女生一组。\n9.上传下载多媒体文件：通过这个接口，公众号可以在需要时在微信服务器上传下载多媒体文件。\n#### 订阅号支持的接口功能 其实也不少，按需要来选择，接口共5个：\n1.会话界面的自定义菜单\n2.多客服接口，提供贴心快捷的客服服务\n3.获取用户的地址位置，精确提供服务\n4.高级群发接口，实现更灵活的群发能力。\n5.用户分组接口，方便管理用户。\n\n#### 新手入门重点：本地代理环境的搭建以及最入门的加密认证\n域名服务器环境配置\n利用QQ浏览器代理调试端口。\n加密认证逻辑这一块很容易出错。要多注意。","source":"_posts/wechat1-2.md","raw":"---\ntitle: 微信号分类与功能\ndate: 2017-01-10 16:38:13\ntags: node wechat\n---\n\n#### 微信号分类：\n1.企业号：不太适合个人小型开发，是为企业或者组织提供移动应用入口，帮助企业建立与员工、上下游供应链及企业应用间的连接。\n2.订阅号：比较适合与个人。小团队，小公司，主要用于信息的传播，帮助管理用户以及和用户互动。比如撰写文章 咨询传播，消息定制等等。\n3.服务号：企业和组织，提供更强大的业务服务与用户管理能力，比如支付，智能接口。\n#### 举个例子来理解微信号的区别：\n订阅号：管理一个班级，一个学院的信息订阅，通知和互动。\n服务号：管理全学校的水果商店或者打印店，可以直接支付送货上门，及时推送一些特价水果。\n企业号：管理全学校所有学院，团委，学生处各个部门上班人员的考勤，活动进程等等。\n\n#### 公众号认证方面：\n订阅号：认证和非认证账号的区别就是，认证账号别人可以直接在添加好友里搜索关键词就能找到你。\n订阅号和服务号三点不同：\n1.关注后出现的位置不同\n2.是单月发送消息的消息数量不同，订阅号可以一天一篇，服务号一个月最多4篇。\n3.订阅号没有9大接口和支付功能。\n#### 服务号9大接口有哪些：\n1.语音识别：就是能识别你说的话，并翻译成文本内容。\n2.客服接口：就是公众号可以在你发送过消息的24小时内，向你回复消息\n3.OAuth 2.0网页授权：可以通过这个授权接口，请求用户授权，从而拿到更多用户的信息。\n4.生成带参数的二维码：公众号可以获得一系列携带不同参数的二维码，在用户扫描关注公众号后，公众号可以根据参数分析各二维的效果，这些参数可以自己定制，从而可以实现更多分析结果，比如用户从哪儿来的。\n5.获取用户地理位置：公众号能够获得用户进入公众号会话时的地理位置。可以做微信导航。\n6.获取用户的基本信息：公众号可以根据加密后的用户OpenID,通过一系列的参数交互，最终拿到用户基础信息，包括头像、名称、性别、地区。\n7.获取关注者列表：通过这个接口，可以拿到所有关注者的OpenID,就知道有多少人关注你，是谁在关注你。\n8.用户分组接口：通过分组接口，可以在后台为用户移动，创建、修改分组，比如把你们班级你们团队分成男生一组，女生一组。\n9.上传下载多媒体文件：通过这个接口，公众号可以在需要时在微信服务器上传下载多媒体文件。\n#### 订阅号支持的接口功能 其实也不少，按需要来选择，接口共5个：\n1.会话界面的自定义菜单\n2.多客服接口，提供贴心快捷的客服服务\n3.获取用户的地址位置，精确提供服务\n4.高级群发接口，实现更灵活的群发能力。\n5.用户分组接口，方便管理用户。\n\n#### 新手入门重点：本地代理环境的搭建以及最入门的加密认证\n域名服务器环境配置\n利用QQ浏览器代理调试端口。\n加密认证逻辑这一块很容易出错。要多注意。","slug":"wechat1-2","published":1,"updated":"2017-01-10T08:42:28.070Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv9m003ejgtus8t6u7l1","content":"<h4 id=\"微信号分类：\"><a href=\"#微信号分类：\" class=\"headerlink\" title=\"微信号分类：\"></a>微信号分类：</h4><p>1.企业号：不太适合个人小型开发，是为企业或者组织提供移动应用入口，帮助企业建立与员工、上下游供应链及企业应用间的连接。<br>2.订阅号：比较适合与个人。小团队，小公司，主要用于信息的传播，帮助管理用户以及和用户互动。比如撰写文章 咨询传播，消息定制等等。<br>3.服务号：企业和组织，提供更强大的业务服务与用户管理能力，比如支付，智能接口。</p>\n<h4 id=\"举个例子来理解微信号的区别：\"><a href=\"#举个例子来理解微信号的区别：\" class=\"headerlink\" title=\"举个例子来理解微信号的区别：\"></a>举个例子来理解微信号的区别：</h4><p>订阅号：管理一个班级，一个学院的信息订阅，通知和互动。<br>服务号：管理全学校的水果商店或者打印店，可以直接支付送货上门，及时推送一些特价水果。<br>企业号：管理全学校所有学院，团委，学生处各个部门上班人员的考勤，活动进程等等。</p>\n<h4 id=\"公众号认证方面：\"><a href=\"#公众号认证方面：\" class=\"headerlink\" title=\"公众号认证方面：\"></a>公众号认证方面：</h4><p>订阅号：认证和非认证账号的区别就是，认证账号别人可以直接在添加好友里搜索关键词就能找到你。<br>订阅号和服务号三点不同：<br>1.关注后出现的位置不同<br>2.是单月发送消息的消息数量不同，订阅号可以一天一篇，服务号一个月最多4篇。<br>3.订阅号没有9大接口和支付功能。</p>\n<h4 id=\"服务号9大接口有哪些：\"><a href=\"#服务号9大接口有哪些：\" class=\"headerlink\" title=\"服务号9大接口有哪些：\"></a>服务号9大接口有哪些：</h4><p>1.语音识别：就是能识别你说的话，并翻译成文本内容。<br>2.客服接口：就是公众号可以在你发送过消息的24小时内，向你回复消息<br>3.OAuth 2.0网页授权：可以通过这个授权接口，请求用户授权，从而拿到更多用户的信息。<br>4.生成带参数的二维码：公众号可以获得一系列携带不同参数的二维码，在用户扫描关注公众号后，公众号可以根据参数分析各二维的效果，这些参数可以自己定制，从而可以实现更多分析结果，比如用户从哪儿来的。<br>5.获取用户地理位置：公众号能够获得用户进入公众号会话时的地理位置。可以做微信导航。<br>6.获取用户的基本信息：公众号可以根据加密后的用户OpenID,通过一系列的参数交互，最终拿到用户基础信息，包括头像、名称、性别、地区。<br>7.获取关注者列表：通过这个接口，可以拿到所有关注者的OpenID,就知道有多少人关注你，是谁在关注你。<br>8.用户分组接口：通过分组接口，可以在后台为用户移动，创建、修改分组，比如把你们班级你们团队分成男生一组，女生一组。<br>9.上传下载多媒体文件：通过这个接口，公众号可以在需要时在微信服务器上传下载多媒体文件。</p>\n<h4 id=\"订阅号支持的接口功能-其实也不少，按需要来选择，接口共5个：\"><a href=\"#订阅号支持的接口功能-其实也不少，按需要来选择，接口共5个：\" class=\"headerlink\" title=\"订阅号支持的接口功能 其实也不少，按需要来选择，接口共5个：\"></a>订阅号支持的接口功能 其实也不少，按需要来选择，接口共5个：</h4><p>1.会话界面的自定义菜单<br>2.多客服接口，提供贴心快捷的客服服务<br>3.获取用户的地址位置，精确提供服务<br>4.高级群发接口，实现更灵活的群发能力。<br>5.用户分组接口，方便管理用户。</p>\n<h4 id=\"新手入门重点：本地代理环境的搭建以及最入门的加密认证\"><a href=\"#新手入门重点：本地代理环境的搭建以及最入门的加密认证\" class=\"headerlink\" title=\"新手入门重点：本地代理环境的搭建以及最入门的加密认证\"></a>新手入门重点：本地代理环境的搭建以及最入门的加密认证</h4><p>域名服务器环境配置<br>利用QQ浏览器代理调试端口。<br>加密认证逻辑这一块很容易出错。要多注意。</p>\n","excerpt":"","more":"<h4 id=\"微信号分类：\"><a href=\"#微信号分类：\" class=\"headerlink\" title=\"微信号分类：\"></a>微信号分类：</h4><p>1.企业号：不太适合个人小型开发，是为企业或者组织提供移动应用入口，帮助企业建立与员工、上下游供应链及企业应用间的连接。<br>2.订阅号：比较适合与个人。小团队，小公司，主要用于信息的传播，帮助管理用户以及和用户互动。比如撰写文章 咨询传播，消息定制等等。<br>3.服务号：企业和组织，提供更强大的业务服务与用户管理能力，比如支付，智能接口。</p>\n<h4 id=\"举个例子来理解微信号的区别：\"><a href=\"#举个例子来理解微信号的区别：\" class=\"headerlink\" title=\"举个例子来理解微信号的区别：\"></a>举个例子来理解微信号的区别：</h4><p>订阅号：管理一个班级，一个学院的信息订阅，通知和互动。<br>服务号：管理全学校的水果商店或者打印店，可以直接支付送货上门，及时推送一些特价水果。<br>企业号：管理全学校所有学院，团委，学生处各个部门上班人员的考勤，活动进程等等。</p>\n<h4 id=\"公众号认证方面：\"><a href=\"#公众号认证方面：\" class=\"headerlink\" title=\"公众号认证方面：\"></a>公众号认证方面：</h4><p>订阅号：认证和非认证账号的区别就是，认证账号别人可以直接在添加好友里搜索关键词就能找到你。<br>订阅号和服务号三点不同：<br>1.关注后出现的位置不同<br>2.是单月发送消息的消息数量不同，订阅号可以一天一篇，服务号一个月最多4篇。<br>3.订阅号没有9大接口和支付功能。</p>\n<h4 id=\"服务号9大接口有哪些：\"><a href=\"#服务号9大接口有哪些：\" class=\"headerlink\" title=\"服务号9大接口有哪些：\"></a>服务号9大接口有哪些：</h4><p>1.语音识别：就是能识别你说的话，并翻译成文本内容。<br>2.客服接口：就是公众号可以在你发送过消息的24小时内，向你回复消息<br>3.OAuth 2.0网页授权：可以通过这个授权接口，请求用户授权，从而拿到更多用户的信息。<br>4.生成带参数的二维码：公众号可以获得一系列携带不同参数的二维码，在用户扫描关注公众号后，公众号可以根据参数分析各二维的效果，这些参数可以自己定制，从而可以实现更多分析结果，比如用户从哪儿来的。<br>5.获取用户地理位置：公众号能够获得用户进入公众号会话时的地理位置。可以做微信导航。<br>6.获取用户的基本信息：公众号可以根据加密后的用户OpenID,通过一系列的参数交互，最终拿到用户基础信息，包括头像、名称、性别、地区。<br>7.获取关注者列表：通过这个接口，可以拿到所有关注者的OpenID,就知道有多少人关注你，是谁在关注你。<br>8.用户分组接口：通过分组接口，可以在后台为用户移动，创建、修改分组，比如把你们班级你们团队分成男生一组，女生一组。<br>9.上传下载多媒体文件：通过这个接口，公众号可以在需要时在微信服务器上传下载多媒体文件。</p>\n<h4 id=\"订阅号支持的接口功能-其实也不少，按需要来选择，接口共5个：\"><a href=\"#订阅号支持的接口功能-其实也不少，按需要来选择，接口共5个：\" class=\"headerlink\" title=\"订阅号支持的接口功能 其实也不少，按需要来选择，接口共5个：\"></a>订阅号支持的接口功能 其实也不少，按需要来选择，接口共5个：</h4><p>1.会话界面的自定义菜单<br>2.多客服接口，提供贴心快捷的客服服务<br>3.获取用户的地址位置，精确提供服务<br>4.高级群发接口，实现更灵活的群发能力。<br>5.用户分组接口，方便管理用户。</p>\n<h4 id=\"新手入门重点：本地代理环境的搭建以及最入门的加密认证\"><a href=\"#新手入门重点：本地代理环境的搭建以及最入门的加密认证\" class=\"headerlink\" title=\"新手入门重点：本地代理环境的搭建以及最入门的加密认证\"></a>新手入门重点：本地代理环境的搭建以及最入门的加密认证</h4><p>域名服务器环境配置<br>利用QQ浏览器代理调试端口。<br>加密认证逻辑这一块很容易出错。要多注意。</p>\n"},{"title":"域名服务器及ngrok环境配置。","date":"2017-01-10T08:43:14.000Z","_content":"域名最好买一个，万一你先买了个牛比的域名，到时候还能卖不少钞票，哈哈，如果你不是专门炒域名的，估计比中彩票机率还小。服务器最好是用vpn搭建一个，对新手来说有一定的难度，所以推荐使用下面的方法。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/wechat1.png-public)\n    ![](http://oi28tswuq.bkt.clouddn.com/images/wechat2.png-public)\n    ![](http://oi28tswuq.bkt.clouddn.com/images/wechat3.png-public)\n</div>\nngrok并不稳定，推荐使用一个网站：www.tunnel.mobi.\n1.mac系统自带python web服务,通过python在控制台开启一个简单的web服务器，命令如下：\n```\npython m SimpleHTTPSwrver 8080,8080为端口号。\n```\n当然也可以使用nginx，apache等等开启一个本地web服务，只要能开启一个特定端口号的服务即可。\n\n2.按照mobi官方文档来，开启ngrok这个工具。\n```\n./ngrok -config ngrok.cfg -subdomain webywx-wechat 8080//ywx-wechat为子域名\n```\n开启成功之后，会得到两个链接，一个http的,一个https的，例：\n```\nhttp://webywx-wechat.tunnel.mobi->127.0.0.1:8080\nhttps://webywx-wechat.tunnel.mobi->127.0.0.1:8080\n```\n注：当然端口号建议使用1234,4321等小数字的，有人碰到过使用大数字而导致代理失效\n\n3.复制链接能成功打开即说明成功了。不过有时候此网站使用的人也会很多，流量太大服务器直接挂了，或者作者把服务器关了，此时建议使用nodejs的第三方模块：localtunnel服务\n\n#### 建议使用localtunnel服务（比较方便）：方法如下：\n安装：npm install -g localtunnel\n安装成之后可以通过localtunnel的缩写lt来开启一个端口：lt --prot 8080\n运行之后它会自动生成一个随机的二级域名。复制到浏览器能打开就成功了。\n缺点就是不能指定特定的域名，它会随机生成。关闭服务重启url会变，所以还需要重新配置公众号后台的url。\n","source":"_posts/wechat1-4.md","raw":"---\ntitle: 域名服务器及ngrok环境配置。\ndate: 2017-01-10 16:43:14\ntags: node wechat\n---\n域名最好买一个，万一你先买了个牛比的域名，到时候还能卖不少钞票，哈哈，如果你不是专门炒域名的，估计比中彩票机率还小。服务器最好是用vpn搭建一个，对新手来说有一定的难度，所以推荐使用下面的方法。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/wechat1.png-public)\n    ![](http://oi28tswuq.bkt.clouddn.com/images/wechat2.png-public)\n    ![](http://oi28tswuq.bkt.clouddn.com/images/wechat3.png-public)\n</div>\nngrok并不稳定，推荐使用一个网站：www.tunnel.mobi.\n1.mac系统自带python web服务,通过python在控制台开启一个简单的web服务器，命令如下：\n```\npython m SimpleHTTPSwrver 8080,8080为端口号。\n```\n当然也可以使用nginx，apache等等开启一个本地web服务，只要能开启一个特定端口号的服务即可。\n\n2.按照mobi官方文档来，开启ngrok这个工具。\n```\n./ngrok -config ngrok.cfg -subdomain webywx-wechat 8080//ywx-wechat为子域名\n```\n开启成功之后，会得到两个链接，一个http的,一个https的，例：\n```\nhttp://webywx-wechat.tunnel.mobi->127.0.0.1:8080\nhttps://webywx-wechat.tunnel.mobi->127.0.0.1:8080\n```\n注：当然端口号建议使用1234,4321等小数字的，有人碰到过使用大数字而导致代理失效\n\n3.复制链接能成功打开即说明成功了。不过有时候此网站使用的人也会很多，流量太大服务器直接挂了，或者作者把服务器关了，此时建议使用nodejs的第三方模块：localtunnel服务\n\n#### 建议使用localtunnel服务（比较方便）：方法如下：\n安装：npm install -g localtunnel\n安装成之后可以通过localtunnel的缩写lt来开启一个端口：lt --prot 8080\n运行之后它会自动生成一个随机的二级域名。复制到浏览器能打开就成功了。\n缺点就是不能指定特定的域名，它会随机生成。关闭服务重启url会变，所以还需要重新配置公众号后台的url。\n","slug":"wechat1-4","published":1,"updated":"2017-01-10T09:00:31.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv9p003gjgtuh35q4nbb","content":"<p>域名最好买一个，万一你先买了个牛比的域名，到时候还能卖不少钞票，哈哈，如果你不是专门炒域名的，估计比中彩票机率还小。服务器最好是用vpn搭建一个，对新手来说有一定的难度，所以推荐使用下面的方法。</p>\n<p><div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/wechat1.png-public\" alt=\"\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/wechat2.png-public\" alt=\"\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/wechat3.png-public\" alt=\"\"><br></div><br>ngrok并不稳定，推荐使用一个网站：www.tunnel.mobi.<br>1.mac系统自带python web服务,通过python在控制台开启一个简单的web服务器，命令如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python m SimpleHTTPSwrver 8080,8080为端口号。</div></pre></td></tr></table></figure></p>\n<p>当然也可以使用nginx，apache等等开启一个本地web服务，只要能开启一个特定端口号的服务即可。</p>\n<p>2.按照mobi官方文档来，开启ngrok这个工具。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./ngrok -config ngrok.cfg -subdomain webywx-wechat 8080//ywx-wechat为子域名</div></pre></td></tr></table></figure></p>\n<p>开启成功之后，会得到两个链接，一个http的,一个https的，例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://webywx-wechat.tunnel.mobi-&gt;127.0.0.1:8080</div><div class=\"line\">https://webywx-wechat.tunnel.mobi-&gt;127.0.0.1:8080</div></pre></td></tr></table></figure></p>\n<p>注：当然端口号建议使用1234,4321等小数字的，有人碰到过使用大数字而导致代理失效</p>\n<p>3.复制链接能成功打开即说明成功了。不过有时候此网站使用的人也会很多，流量太大服务器直接挂了，或者作者把服务器关了，此时建议使用nodejs的第三方模块：localtunnel服务</p>\n<h4 id=\"建议使用localtunnel服务（比较方便）：方法如下：\"><a href=\"#建议使用localtunnel服务（比较方便）：方法如下：\" class=\"headerlink\" title=\"建议使用localtunnel服务（比较方便）：方法如下：\"></a>建议使用localtunnel服务（比较方便）：方法如下：</h4><p>安装：npm install -g localtunnel<br>安装成之后可以通过localtunnel的缩写lt来开启一个端口：lt –prot 8080<br>运行之后它会自动生成一个随机的二级域名。复制到浏览器能打开就成功了。<br>缺点就是不能指定特定的域名，它会随机生成。关闭服务重启url会变，所以还需要重新配置公众号后台的url。</p>\n","excerpt":"","more":"<p>域名最好买一个，万一你先买了个牛比的域名，到时候还能卖不少钞票，哈哈，如果你不是专门炒域名的，估计比中彩票机率还小。服务器最好是用vpn搭建一个，对新手来说有一定的难度，所以推荐使用下面的方法。</p>\n<p><div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/wechat1.png-public\" alt=\"\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/wechat2.png-public\" alt=\"\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/wechat3.png-public\" alt=\"\"><br></div><br>ngrok并不稳定，推荐使用一个网站：www.tunnel.mobi.<br>1.mac系统自带python web服务,通过python在控制台开启一个简单的web服务器，命令如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python m SimpleHTTPSwrver 8080,8080为端口号。</div></pre></td></tr></table></figure></p>\n<p>当然也可以使用nginx，apache等等开启一个本地web服务，只要能开启一个特定端口号的服务即可。</p>\n<p>2.按照mobi官方文档来，开启ngrok这个工具。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./ngrok -config ngrok.cfg -subdomain webywx-wechat 8080//ywx-wechat为子域名</div></pre></td></tr></table></figure></p>\n<p>开启成功之后，会得到两个链接，一个http的,一个https的，例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://webywx-wechat.tunnel.mobi-&gt;127.0.0.1:8080</div><div class=\"line\">https://webywx-wechat.tunnel.mobi-&gt;127.0.0.1:8080</div></pre></td></tr></table></figure></p>\n<p>注：当然端口号建议使用1234,4321等小数字的，有人碰到过使用大数字而导致代理失效</p>\n<p>3.复制链接能成功打开即说明成功了。不过有时候此网站使用的人也会很多，流量太大服务器直接挂了，或者作者把服务器关了，此时建议使用nodejs的第三方模块：localtunnel服务</p>\n<h4 id=\"建议使用localtunnel服务（比较方便）：方法如下：\"><a href=\"#建议使用localtunnel服务（比较方便）：方法如下：\" class=\"headerlink\" title=\"建议使用localtunnel服务（比较方便）：方法如下：\"></a>建议使用localtunnel服务（比较方便）：方法如下：</h4><p>安装：npm install -g localtunnel<br>安装成之后可以通过localtunnel的缩写lt来开启一个端口：lt –prot 8080<br>运行之后它会自动生成一个随机的二级域名。复制到浏览器能打开就成功了。<br>缺点就是不能指定特定的域名，它会随机生成。关闭服务重启url会变，所以还需要重新配置公众号后台的url。</p>\n"},{"title":"配置、接入微信公众号","date":"2017-01-10T09:01:10.000Z","_content":"#### 配置接入微信公众号\n1.按官方要求填写提交资料申请就可以了。\n2.可以申请测试公众帐号\n#### 申请测试公众号步骤\n1.打开wechat开发者官方文档，点击左侧菜单栏下的开始开发。\n2.再点击接口测试号申请\n3.点击登录，用手机扫描二维码\n4.填写配置信息即可了。\n\n#### 接入流程一共分为两步：\n1.配置我们的公众号后台\n2.验证公众号\n\n#### 配置公众号后台要填写url,token和encodingseskey.\nurl:就是开发者用来接收微信消息和事件的接口url，微信服务器会把这些事件或者说是这些数据给push到这个url里面。\n\ntoken:由开发者任意填写的，并会生成一个签名，这个token会和接口url中的token要进行一个比对，能保证安全性。\n\nencodingseskey：自己填写或者随机生成，并做消息体的加密或者解密密钥。消息体加密解密的方式：本项目采用明文模式。\n\n#### 验证公众号流程\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/testwechat.png-public)\n</div>\n第一步：将token,timestamp,nonce三个参数进行字典排序\n第二步：将三个参数字符串拼接成一个字符串进行sha1加密\n第三步：将加密后的字符串与signature对比，如果相同，表示这个请求来源于微信，我们直接原样返回echostr参数内容，接入验证就成功了。\n\n有了测试公众号，本地也跑通了ngrok代理环境（建议用localtunnel服务），填写完url和token,接下来就能模拟本地开发了。","source":"_posts/wechat1-5.md","raw":"---\ntitle: 配置、接入微信公众号\ndate: 2017-01-10 17:01:10\ntags: node wechat\n---\n#### 配置接入微信公众号\n1.按官方要求填写提交资料申请就可以了。\n2.可以申请测试公众帐号\n#### 申请测试公众号步骤\n1.打开wechat开发者官方文档，点击左侧菜单栏下的开始开发。\n2.再点击接口测试号申请\n3.点击登录，用手机扫描二维码\n4.填写配置信息即可了。\n\n#### 接入流程一共分为两步：\n1.配置我们的公众号后台\n2.验证公众号\n\n#### 配置公众号后台要填写url,token和encodingseskey.\nurl:就是开发者用来接收微信消息和事件的接口url，微信服务器会把这些事件或者说是这些数据给push到这个url里面。\n\ntoken:由开发者任意填写的，并会生成一个签名，这个token会和接口url中的token要进行一个比对，能保证安全性。\n\nencodingseskey：自己填写或者随机生成，并做消息体的加密或者解密密钥。消息体加密解密的方式：本项目采用明文模式。\n\n#### 验证公众号流程\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/testwechat.png-public)\n</div>\n第一步：将token,timestamp,nonce三个参数进行字典排序\n第二步：将三个参数字符串拼接成一个字符串进行sha1加密\n第三步：将加密后的字符串与signature对比，如果相同，表示这个请求来源于微信，我们直接原样返回echostr参数内容，接入验证就成功了。\n\n有了测试公众号，本地也跑通了ngrok代理环境（建议用localtunnel服务），填写完url和token,接下来就能模拟本地开发了。","slug":"wechat1-5","published":1,"updated":"2017-01-10T09:06:13.471Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv9s003ijgtuny5lyyfi","content":"<h4 id=\"配置接入微信公众号\"><a href=\"#配置接入微信公众号\" class=\"headerlink\" title=\"配置接入微信公众号\"></a>配置接入微信公众号</h4><p>1.按官方要求填写提交资料申请就可以了。<br>2.可以申请测试公众帐号</p>\n<h4 id=\"申请测试公众号步骤\"><a href=\"#申请测试公众号步骤\" class=\"headerlink\" title=\"申请测试公众号步骤\"></a>申请测试公众号步骤</h4><p>1.打开wechat开发者官方文档，点击左侧菜单栏下的开始开发。<br>2.再点击接口测试号申请<br>3.点击登录，用手机扫描二维码<br>4.填写配置信息即可了。</p>\n<h4 id=\"接入流程一共分为两步：\"><a href=\"#接入流程一共分为两步：\" class=\"headerlink\" title=\"接入流程一共分为两步：\"></a>接入流程一共分为两步：</h4><p>1.配置我们的公众号后台<br>2.验证公众号</p>\n<h4 id=\"配置公众号后台要填写url-token和encodingseskey\"><a href=\"#配置公众号后台要填写url-token和encodingseskey\" class=\"headerlink\" title=\"配置公众号后台要填写url,token和encodingseskey.\"></a>配置公众号后台要填写url,token和encodingseskey.</h4><p>url:就是开发者用来接收微信消息和事件的接口url，微信服务器会把这些事件或者说是这些数据给push到这个url里面。</p>\n<p>token:由开发者任意填写的，并会生成一个签名，这个token会和接口url中的token要进行一个比对，能保证安全性。</p>\n<p>encodingseskey：自己填写或者随机生成，并做消息体的加密或者解密密钥。消息体加密解密的方式：本项目采用明文模式。</p>\n<h4 id=\"验证公众号流程\"><a href=\"#验证公众号流程\" class=\"headerlink\" title=\"验证公众号流程\"></a>验证公众号流程</h4><p><div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/testwechat.png-public\" alt=\"\"><br></div><br>第一步：将token,timestamp,nonce三个参数进行字典排序<br>第二步：将三个参数字符串拼接成一个字符串进行sha1加密<br>第三步：将加密后的字符串与signature对比，如果相同，表示这个请求来源于微信，我们直接原样返回echostr参数内容，接入验证就成功了。</p>\n<p>有了测试公众号，本地也跑通了ngrok代理环境（建议用localtunnel服务），填写完url和token,接下来就能模拟本地开发了。</p>\n","excerpt":"","more":"<h4 id=\"配置接入微信公众号\"><a href=\"#配置接入微信公众号\" class=\"headerlink\" title=\"配置接入微信公众号\"></a>配置接入微信公众号</h4><p>1.按官方要求填写提交资料申请就可以了。<br>2.可以申请测试公众帐号</p>\n<h4 id=\"申请测试公众号步骤\"><a href=\"#申请测试公众号步骤\" class=\"headerlink\" title=\"申请测试公众号步骤\"></a>申请测试公众号步骤</h4><p>1.打开wechat开发者官方文档，点击左侧菜单栏下的开始开发。<br>2.再点击接口测试号申请<br>3.点击登录，用手机扫描二维码<br>4.填写配置信息即可了。</p>\n<h4 id=\"接入流程一共分为两步：\"><a href=\"#接入流程一共分为两步：\" class=\"headerlink\" title=\"接入流程一共分为两步：\"></a>接入流程一共分为两步：</h4><p>1.配置我们的公众号后台<br>2.验证公众号</p>\n<h4 id=\"配置公众号后台要填写url-token和encodingseskey\"><a href=\"#配置公众号后台要填写url-token和encodingseskey\" class=\"headerlink\" title=\"配置公众号后台要填写url,token和encodingseskey.\"></a>配置公众号后台要填写url,token和encodingseskey.</h4><p>url:就是开发者用来接收微信消息和事件的接口url，微信服务器会把这些事件或者说是这些数据给push到这个url里面。</p>\n<p>token:由开发者任意填写的，并会生成一个签名，这个token会和接口url中的token要进行一个比对，能保证安全性。</p>\n<p>encodingseskey：自己填写或者随机生成，并做消息体的加密或者解密密钥。消息体加密解密的方式：本项目采用明文模式。</p>\n<h4 id=\"验证公众号流程\"><a href=\"#验证公众号流程\" class=\"headerlink\" title=\"验证公众号流程\"></a>验证公众号流程</h4><p><div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/testwechat.png-public\" alt=\"\"><br></div><br>第一步：将token,timestamp,nonce三个参数进行字典排序<br>第二步：将三个参数字符串拼接成一个字符串进行sha1加密<br>第三步：将加密后的字符串与signature对比，如果相同，表示这个请求来源于微信，我们直接原样返回echostr参数内容，接入验证就成功了。</p>\n<p>有了测试公众号，本地也跑通了ngrok代理环境（建议用localtunnel服务），填写完url和token,接下来就能模拟本地开发了。</p>\n"},{"title":"写段代码实现加密认证逻辑","date":"2017-01-10T09:07:14.000Z","_content":"为什么使用koa而不是express,说通俗点就是装比。当然不只是装比，其实用koa框架，代码可以更精简，更易懂，对于反反复复的异步交互更适合用这个框架实现。\n```\n\"use strict\"\n// npm install koa sha1\nvar Koa=require('koa');\nvar sha1=require(\"sha1\");\nvar config={\n\twechat:{\n\t\tappID: '',//wechat管理页面的appid\n\t\tappsecret: '',//wechat管理页面的appSecret\n\t\ttoken: 'webywx',//wechat管理页面的token\n\t//这三个参数非常重要，不要轻易暴露给外网。\n\t}\n\t\n};\nvar app= new Koa();\napp.use(function * (next) {//koa的中间件只能写成generator函数形式。\n\t//console.log(this.query);\n\t//浏览器输入localhost:1234？a=1就可以在浏览器控制台看到查询参数了。{a:1}\n\t\n\tvar token=config.wechat.token;\n\tvar signature=this.query.signature;\n\tvar nonce =this.query.nonce;\n\tvar timestamp=this.query.timestamp;\n\tvar echostr=this.query.echostr;\n\n\t//字典排序\n\tvar str=[token,timestamp,nonce].sort().join('');\n\tvar sha=sha1(str);\n\tif(sha===signature){\n\t\tthis.body=echostr+'';\n\t}else{\n\t\tthis.body='wrong';\n\t}\n});\napp.listen(1234);\nconsole.log('Listening:1234');\n\n```\n注：版本必须是11以上才能使用koa框架。可以用node -v 查看node的版本号。//v0.12.4  这里显示的是12（0后面的），所以可以用。\n运行：node --harmony app.js  //以和谐模式启动app.js,保证node支持es6新特性：如generator等.  \n\n 填写完wechat管理页面的url和token，点击提交就可以进行公众号认证了。若点击后出现配置失败,可能出现的错误如下：虽然把本地的服务跑起来了（node --harmony app.js用此跑起来的），但是并没有把这个服务通过ngrok暴露到外网去，所以在点击提交的时候，微信服务器它并没有收到post请求，因为它没有连接到我们的本地。\n解决办法：把ngrok这个代理跑起来。用./ngrok -config ngrok.cfg -subdomain url中的子域名  app.js里监听的端口号\n\n当用./ngrok -config ngrok.cfg -subdomain url中的子域名  app.js里监听的端口号 这种方法开启时，若发现连接失败，可以使用另外一种方法，localhosttunnel服务，用这种方法时，记得把之前配置的url换成自动生成的这个即可。","source":"_posts/wechat1-6.md","raw":"---\ntitle: 写段代码实现加密认证逻辑\ndate: 2017-01-10 17:07:14\ntags: node wechat\n---\n为什么使用koa而不是express,说通俗点就是装比。当然不只是装比，其实用koa框架，代码可以更精简，更易懂，对于反反复复的异步交互更适合用这个框架实现。\n```\n\"use strict\"\n// npm install koa sha1\nvar Koa=require('koa');\nvar sha1=require(\"sha1\");\nvar config={\n\twechat:{\n\t\tappID: '',//wechat管理页面的appid\n\t\tappsecret: '',//wechat管理页面的appSecret\n\t\ttoken: 'webywx',//wechat管理页面的token\n\t//这三个参数非常重要，不要轻易暴露给外网。\n\t}\n\t\n};\nvar app= new Koa();\napp.use(function * (next) {//koa的中间件只能写成generator函数形式。\n\t//console.log(this.query);\n\t//浏览器输入localhost:1234？a=1就可以在浏览器控制台看到查询参数了。{a:1}\n\t\n\tvar token=config.wechat.token;\n\tvar signature=this.query.signature;\n\tvar nonce =this.query.nonce;\n\tvar timestamp=this.query.timestamp;\n\tvar echostr=this.query.echostr;\n\n\t//字典排序\n\tvar str=[token,timestamp,nonce].sort().join('');\n\tvar sha=sha1(str);\n\tif(sha===signature){\n\t\tthis.body=echostr+'';\n\t}else{\n\t\tthis.body='wrong';\n\t}\n});\napp.listen(1234);\nconsole.log('Listening:1234');\n\n```\n注：版本必须是11以上才能使用koa框架。可以用node -v 查看node的版本号。//v0.12.4  这里显示的是12（0后面的），所以可以用。\n运行：node --harmony app.js  //以和谐模式启动app.js,保证node支持es6新特性：如generator等.  \n\n 填写完wechat管理页面的url和token，点击提交就可以进行公众号认证了。若点击后出现配置失败,可能出现的错误如下：虽然把本地的服务跑起来了（node --harmony app.js用此跑起来的），但是并没有把这个服务通过ngrok暴露到外网去，所以在点击提交的时候，微信服务器它并没有收到post请求，因为它没有连接到我们的本地。\n解决办法：把ngrok这个代理跑起来。用./ngrok -config ngrok.cfg -subdomain url中的子域名  app.js里监听的端口号\n\n当用./ngrok -config ngrok.cfg -subdomain url中的子域名  app.js里监听的端口号 这种方法开启时，若发现连接失败，可以使用另外一种方法，localhosttunnel服务，用这种方法时，记得把之前配置的url换成自动生成的这个即可。","slug":"wechat1-6","published":1,"updated":"2017-01-10T09:15:36.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv9t003jjgtu53t1mqaq","content":"<p>为什么使用koa而不是express,说通俗点就是装比。当然不只是装比，其实用koa框架，代码可以更精简，更易懂，对于反反复复的异步交互更适合用这个框架实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;use strict&quot;</div><div class=\"line\">// npm install koa sha1</div><div class=\"line\">var Koa=require(&apos;koa&apos;);</div><div class=\"line\">var sha1=require(&quot;sha1&quot;);</div><div class=\"line\">var config=&#123;</div><div class=\"line\">\twechat:&#123;</div><div class=\"line\">\t\tappID: &apos;&apos;,//wechat管理页面的appid</div><div class=\"line\">\t\tappsecret: &apos;&apos;,//wechat管理页面的appSecret</div><div class=\"line\">\t\ttoken: &apos;webywx&apos;,//wechat管理页面的token</div><div class=\"line\">\t//这三个参数非常重要，不要轻易暴露给外网。</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;;</div><div class=\"line\">var app= new Koa();</div><div class=\"line\">app.use(function * (next) &#123;//koa的中间件只能写成generator函数形式。</div><div class=\"line\">\t//console.log(this.query);</div><div class=\"line\">\t//浏览器输入localhost:1234？a=1就可以在浏览器控制台看到查询参数了。&#123;a:1&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tvar token=config.wechat.token;</div><div class=\"line\">\tvar signature=this.query.signature;</div><div class=\"line\">\tvar nonce =this.query.nonce;</div><div class=\"line\">\tvar timestamp=this.query.timestamp;</div><div class=\"line\">\tvar echostr=this.query.echostr;</div><div class=\"line\"></div><div class=\"line\">\t//字典排序</div><div class=\"line\">\tvar str=[token,timestamp,nonce].sort().join(&apos;&apos;);</div><div class=\"line\">\tvar sha=sha1(str);</div><div class=\"line\">\tif(sha===signature)&#123;</div><div class=\"line\">\t\tthis.body=echostr+&apos;&apos;;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\tthis.body=&apos;wrong&apos;;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">app.listen(1234);</div><div class=\"line\">console.log(&apos;Listening:1234&apos;);</div></pre></td></tr></table></figure></p>\n<p>注：版本必须是11以上才能使用koa框架。可以用node -v 查看node的版本号。//v0.12.4  这里显示的是12（0后面的），所以可以用。<br>运行：node –harmony app.js  //以和谐模式启动app.js,保证node支持es6新特性：如generator等.  </p>\n<p> 填写完wechat管理页面的url和token，点击提交就可以进行公众号认证了。若点击后出现配置失败,可能出现的错误如下：虽然把本地的服务跑起来了（node –harmony app.js用此跑起来的），但是并没有把这个服务通过ngrok暴露到外网去，所以在点击提交的时候，微信服务器它并没有收到post请求，因为它没有连接到我们的本地。<br>解决办法：把ngrok这个代理跑起来。用./ngrok -config ngrok.cfg -subdomain url中的子域名  app.js里监听的端口号</p>\n<p>当用./ngrok -config ngrok.cfg -subdomain url中的子域名  app.js里监听的端口号 这种方法开启时，若发现连接失败，可以使用另外一种方法，localhosttunnel服务，用这种方法时，记得把之前配置的url换成自动生成的这个即可。</p>\n","excerpt":"","more":"<p>为什么使用koa而不是express,说通俗点就是装比。当然不只是装比，其实用koa框架，代码可以更精简，更易懂，对于反反复复的异步交互更适合用这个框架实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;use strict&quot;</div><div class=\"line\">// npm install koa sha1</div><div class=\"line\">var Koa=require(&apos;koa&apos;);</div><div class=\"line\">var sha1=require(&quot;sha1&quot;);</div><div class=\"line\">var config=&#123;</div><div class=\"line\">\twechat:&#123;</div><div class=\"line\">\t\tappID: &apos;&apos;,//wechat管理页面的appid</div><div class=\"line\">\t\tappsecret: &apos;&apos;,//wechat管理页面的appSecret</div><div class=\"line\">\t\ttoken: &apos;webywx&apos;,//wechat管理页面的token</div><div class=\"line\">\t//这三个参数非常重要，不要轻易暴露给外网。</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;;</div><div class=\"line\">var app= new Koa();</div><div class=\"line\">app.use(function * (next) &#123;//koa的中间件只能写成generator函数形式。</div><div class=\"line\">\t//console.log(this.query);</div><div class=\"line\">\t//浏览器输入localhost:1234？a=1就可以在浏览器控制台看到查询参数了。&#123;a:1&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tvar token=config.wechat.token;</div><div class=\"line\">\tvar signature=this.query.signature;</div><div class=\"line\">\tvar nonce =this.query.nonce;</div><div class=\"line\">\tvar timestamp=this.query.timestamp;</div><div class=\"line\">\tvar echostr=this.query.echostr;</div><div class=\"line\"></div><div class=\"line\">\t//字典排序</div><div class=\"line\">\tvar str=[token,timestamp,nonce].sort().join(&apos;&apos;);</div><div class=\"line\">\tvar sha=sha1(str);</div><div class=\"line\">\tif(sha===signature)&#123;</div><div class=\"line\">\t\tthis.body=echostr+&apos;&apos;;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\tthis.body=&apos;wrong&apos;;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">app.listen(1234);</div><div class=\"line\">console.log(&apos;Listening:1234&apos;);</div></pre></td></tr></table></figure></p>\n<p>注：版本必须是11以上才能使用koa框架。可以用node -v 查看node的版本号。//v0.12.4  这里显示的是12（0后面的），所以可以用。<br>运行：node –harmony app.js  //以和谐模式启动app.js,保证node支持es6新特性：如generator等.  </p>\n<p> 填写完wechat管理页面的url和token，点击提交就可以进行公众号认证了。若点击后出现配置失败,可能出现的错误如下：虽然把本地的服务跑起来了（node –harmony app.js用此跑起来的），但是并没有把这个服务通过ngrok暴露到外网去，所以在点击提交的时候，微信服务器它并没有收到post请求，因为它没有连接到我们的本地。<br>解决办法：把ngrok这个代理跑起来。用./ngrok -config ngrok.cfg -subdomain url中的子域名  app.js里监听的端口号</p>\n<p>当用./ngrok -config ngrok.cfg -subdomain url中的子域名  app.js里监听的端口号 这种方法开启时，若发现连接失败，可以使用另外一种方法，localhosttunnel服务，用这种方法时，记得把之前配置的url换成自动生成的这个即可。</p>\n"},{"title":"激活Win10内置版Linux （ubuntu）","date":"2016-12-16T02:13:44.000Z","_content":"### 微软自从14316版本后，win10就开始原生支持Linux Bash命令行。\n1. 首先开始菜单——设置——更新和安全——针对开发人员——选择开发者模式。\n2. 控制面板→程序和功能→启用或关闭Windows功能，勾选“适用于Linux的Windows子系统（Beta）\n3. 安装后需要重启\n4. 打开命令提示符，直接在管理员模式下输入Bash命令，提示需要从windows store下载，按y确认。\n    友情提醒：下载ubuntu会很慢，因为要在window 应用商店下，需要耐心等待，如果下载安装失败或者安装到最后突然跳出安装，可以在网络中心修改下的dns，这样为了使下载更快。不改dns一般在应用商店下载安装东西可以说是龟速！\n    可以手动设置DNS，将DNS设置为“114.114.114.114”或“4.2.2.2“。\n5. 安装成功就能使用bash了\n   载安装的过程中需要用户创建Unix账户，因此要设定账户密码，在输入密码的过程中，密码文字不可见，需要输入两遍。\n   等待漫长的下载过程完成后就会正式进入bash啦，输入lsb_release -a命令查看子系统版本。\n   功能命令可用bash --help来查询，在使用的话要在前面加上“bash”，例如：bash --debug\n   如果要运行Linux命令，可采用如下格式（注意 c 和前引号间的空格）：bash -c \"linux命令\"\n   例如：bash -c \"echo Hello from IThome\"。\n   \n   注：如果你的win10没找ubuntu，说明win10版本太低，升级下系统就可以了。","source":"_posts/win10-ubuntu.md","raw":"---\ntitle: 激活Win10内置版Linux （ubuntu）\ndate: 2016-12-16 10:13:44\ntags:  win10、linux\n---\n### 微软自从14316版本后，win10就开始原生支持Linux Bash命令行。\n1. 首先开始菜单——设置——更新和安全——针对开发人员——选择开发者模式。\n2. 控制面板→程序和功能→启用或关闭Windows功能，勾选“适用于Linux的Windows子系统（Beta）\n3. 安装后需要重启\n4. 打开命令提示符，直接在管理员模式下输入Bash命令，提示需要从windows store下载，按y确认。\n    友情提醒：下载ubuntu会很慢，因为要在window 应用商店下，需要耐心等待，如果下载安装失败或者安装到最后突然跳出安装，可以在网络中心修改下的dns，这样为了使下载更快。不改dns一般在应用商店下载安装东西可以说是龟速！\n    可以手动设置DNS，将DNS设置为“114.114.114.114”或“4.2.2.2“。\n5. 安装成功就能使用bash了\n   载安装的过程中需要用户创建Unix账户，因此要设定账户密码，在输入密码的过程中，密码文字不可见，需要输入两遍。\n   等待漫长的下载过程完成后就会正式进入bash啦，输入lsb_release -a命令查看子系统版本。\n   功能命令可用bash --help来查询，在使用的话要在前面加上“bash”，例如：bash --debug\n   如果要运行Linux命令，可采用如下格式（注意 c 和前引号间的空格）：bash -c \"linux命令\"\n   例如：bash -c \"echo Hello from IThome\"。\n   \n   注：如果你的win10没找ubuntu，说明win10版本太低，升级下系统就可以了。","slug":"win10-ubuntu","published":1,"updated":"2016-12-16T02:33:28.666Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv9w003mjgtu8a87pldm","content":"<h3 id=\"微软自从14316版本后，win10就开始原生支持Linux-Bash命令行。\"><a href=\"#微软自从14316版本后，win10就开始原生支持Linux-Bash命令行。\" class=\"headerlink\" title=\"微软自从14316版本后，win10就开始原生支持Linux Bash命令行。\"></a>微软自从14316版本后，win10就开始原生支持Linux Bash命令行。</h3><ol>\n<li>首先开始菜单——设置——更新和安全——针对开发人员——选择开发者模式。</li>\n<li>控制面板→程序和功能→启用或关闭Windows功能，勾选“适用于Linux的Windows子系统（Beta）</li>\n<li>安装后需要重启</li>\n<li>打开命令提示符，直接在管理员模式下输入Bash命令，提示需要从windows store下载，按y确认。<br> 友情提醒：下载ubuntu会很慢，因为要在window 应用商店下，需要耐心等待，如果下载安装失败或者安装到最后突然跳出安装，可以在网络中心修改下的dns，这样为了使下载更快。不改dns一般在应用商店下载安装东西可以说是龟速！<br> 可以手动设置DNS，将DNS设置为“114.114.114.114”或“4.2.2.2“。</li>\n<li><p>安装成功就能使用bash了<br>载安装的过程中需要用户创建Unix账户，因此要设定账户密码，在输入密码的过程中，密码文字不可见，需要输入两遍。<br>等待漫长的下载过程完成后就会正式进入bash啦，输入lsb_release -a命令查看子系统版本。<br>功能命令可用bash –help来查询，在使用的话要在前面加上“bash”，例如：bash –debug<br>如果要运行Linux命令，可采用如下格式（注意 c 和前引号间的空格）：bash -c “linux命令”<br>例如：bash -c “echo Hello from IThome”。</p>\n<p>注：如果你的win10没找ubuntu，说明win10版本太低，升级下系统就可以了。</p>\n</li>\n</ol>\n","excerpt":"","more":"<h3 id=\"微软自从14316版本后，win10就开始原生支持Linux-Bash命令行。\"><a href=\"#微软自从14316版本后，win10就开始原生支持Linux-Bash命令行。\" class=\"headerlink\" title=\"微软自从14316版本后，win10就开始原生支持Linux Bash命令行。\"></a>微软自从14316版本后，win10就开始原生支持Linux Bash命令行。</h3><ol>\n<li>首先开始菜单——设置——更新和安全——针对开发人员——选择开发者模式。</li>\n<li>控制面板→程序和功能→启用或关闭Windows功能，勾选“适用于Linux的Windows子系统（Beta）</li>\n<li>安装后需要重启</li>\n<li>打开命令提示符，直接在管理员模式下输入Bash命令，提示需要从windows store下载，按y确认。<br> 友情提醒：下载ubuntu会很慢，因为要在window 应用商店下，需要耐心等待，如果下载安装失败或者安装到最后突然跳出安装，可以在网络中心修改下的dns，这样为了使下载更快。不改dns一般在应用商店下载安装东西可以说是龟速！<br> 可以手动设置DNS，将DNS设置为“114.114.114.114”或“4.2.2.2“。</li>\n<li><p>安装成功就能使用bash了<br>载安装的过程中需要用户创建Unix账户，因此要设定账户密码，在输入密码的过程中，密码文字不可见，需要输入两遍。<br>等待漫长的下载过程完成后就会正式进入bash啦，输入lsb_release -a命令查看子系统版本。<br>功能命令可用bash –help来查询，在使用的话要在前面加上“bash”，例如：bash –debug<br>如果要运行Linux命令，可采用如下格式（注意 c 和前引号间的空格）：bash -c “linux命令”<br>例如：bash -c “echo Hello from IThome”。</p>\n<p>注：如果你的win10没找ubuntu，说明win10版本太低，升级下系统就可以了。</p>\n</li>\n</ol>\n"},{"title":"使浏览器后退按钮失效及HTML5-window.history","date":"2016-11-13T10:03:29.000Z","_content":"### 防止页面后退（使浏览器后退按钮失效）\n\n　　*原理*：用新页面的URL替换当前的历史纪录，这样浏览历史记录中就只有一个页面，后退按钮永远失效。\n\n　注：history.go和history.back（包括用户按浏览器历史前进后退按钮）触发，页面由于使用pushState修改了history，会触发popstate事件。【代码如下】\n```\n       <script type=\"text/javascript\">\n            jQuery(document).ready(function ($) {\n                if (window.history && window.history.pushState) {\n    　　　　$(window).on('popstate', function () {\n      　　    window.history.forward(1);\n    　　　　});\n  　　　　}\n　　　　});\n　　</script>\n```\n\n### 其中涉及到的方法详细介绍：\n\n1. window.history：表示window对象的历史记录\n\n2. 历史记录的前进和后退\n\n    window. history.forward() --- 此方法加载历史列表中的下一个 URL，同浏览器中点击向前按钮；\n    window. history.back() --- 此方法加载历史列表中的前一个 URL，同浏览器中点击后退按钮。\n - 可移动到指定历史记录点：\n    通过指定一个相对于当前页面位置的数值，你可以使用 go() 方法从当前会话的历史记录中加载页面,（当前页面位置索引值为0，上一页就是-1，下一页为1）  如：\n     要后退一页（相当于调用back()）： window.history.go(-1);\n       　　　　\n     向前移动一页（相当于调用forward()）：window.history.go(1);\n        　　　　\n　   window.history.length：可以查看length属性值，可知道历史记录栈中共有多少个记录点。\n\n3. 操作历史记录点\n\n    HTML5的新API扩展了window.history，可实现存储、替换当前历史记录点，以及监听历史记录点。\n\n　　1、存储、替换当前历史记录点\n        创建当前历史记录点pushState(state, title, url)：创建（添加）一个新的history实体，\n                    state：状态对象，记录历史记录点的额外对象（要跳转的URL），可以为空；\n                    title：页面标题，目前所有浏览器都不支持；\n                    url：可选的url，浏览器不会检查url是否存在，只改变url，url必须同域。\n                    window.history.pushState(json,”\",”http://www.qingdou.me/post-1.html”);\n        替换当前历史记录点replaceState()：修改当前的history实体，不会新增。\n                    类似replace(url)，要更新当前历史记录的状态对象或URL时，使用replaceState()方法会更合适。\n    \n　　2 、监听历史记录点onpopstate()\n\n　　　  当history实体被改变时，popstate事件将会发生； onhashchange()可监听URL的hash部分。\n     \n     3、读取现有state\n\n        当页面加载时，它可能会有一个非空的state对象。当页面重新加载，页面将收到onload事件，但不会有popstate事件。\n        然而，如果你读取history.state属性，将在popstate事件发生后得到这个state对象。\n\n   注：window.history.forward();确实这个方法在IE和谷歌浏览器中还是起作用的，但在火狐浏览器中却不起作用了\n    经过多次测试后发现加入window.onbeforeunload这个方法后在火狐中就起作用了。代码如下：\n   ```\n    <script language=\"JavaScript\">  \n          window.history.forward();  \n          window.onbeforeunload=function (){   \n                  \n            }  //onbeforeunload方法中什么也不用写。\n    </script>\n   ```\n#### 其他方法参考：\n\n 1. 利用JS产生一个“前进”的动作，以抵消后退功能，这种方法应该是最简洁的，并且不需要考虑用户连点两次或多次“后退”的情况，缺点是当用户端禁用了JavaScript之后即失效。 \n ```\n <script language=\"JavaScript\"> \n javascript:window.history.forward(1); \n </script> \n ```\n 2. 用location.replace从一个页面转到另一个页面。这种方法的原理是，用新页面的URL替换当前的历史纪录，这样浏览历史记录中就只有一个页面，后退按钮永远不会变为可用。我想这可能正是许多人所寻求的方法，但这种方法仍旧不是任何情况下的最好方法。这种方法的缺点在于：简单地运用Response.Redirect将不再有效，这是因为每次用户从一个页面转到另一个页面，我们都必须用客户端代码清除location.history。另外还要注意，这种方法清除的是最后一个访问历史记录，而不是全部的访问记录。 \n ```\n  <A HREF=\"logout.do\" onclick=\"javascript:location.replace(this.href); event.returnValue=false; \"> \n  Logout (Back Disabled) \n  </A> \n  ```","source":"_posts/window-back-disabled.md","raw":"---\ntitle: 使浏览器后退按钮失效及HTML5-window.history\ndate: 2016-11-13 18:03:29\ntags: window.history html5\n---\n### 防止页面后退（使浏览器后退按钮失效）\n\n　　*原理*：用新页面的URL替换当前的历史纪录，这样浏览历史记录中就只有一个页面，后退按钮永远失效。\n\n　注：history.go和history.back（包括用户按浏览器历史前进后退按钮）触发，页面由于使用pushState修改了history，会触发popstate事件。【代码如下】\n```\n       <script type=\"text/javascript\">\n            jQuery(document).ready(function ($) {\n                if (window.history && window.history.pushState) {\n    　　　　$(window).on('popstate', function () {\n      　　    window.history.forward(1);\n    　　　　});\n  　　　　}\n　　　　});\n　　</script>\n```\n\n### 其中涉及到的方法详细介绍：\n\n1. window.history：表示window对象的历史记录\n\n2. 历史记录的前进和后退\n\n    window. history.forward() --- 此方法加载历史列表中的下一个 URL，同浏览器中点击向前按钮；\n    window. history.back() --- 此方法加载历史列表中的前一个 URL，同浏览器中点击后退按钮。\n - 可移动到指定历史记录点：\n    通过指定一个相对于当前页面位置的数值，你可以使用 go() 方法从当前会话的历史记录中加载页面,（当前页面位置索引值为0，上一页就是-1，下一页为1）  如：\n     要后退一页（相当于调用back()）： window.history.go(-1);\n       　　　　\n     向前移动一页（相当于调用forward()）：window.history.go(1);\n        　　　　\n　   window.history.length：可以查看length属性值，可知道历史记录栈中共有多少个记录点。\n\n3. 操作历史记录点\n\n    HTML5的新API扩展了window.history，可实现存储、替换当前历史记录点，以及监听历史记录点。\n\n　　1、存储、替换当前历史记录点\n        创建当前历史记录点pushState(state, title, url)：创建（添加）一个新的history实体，\n                    state：状态对象，记录历史记录点的额外对象（要跳转的URL），可以为空；\n                    title：页面标题，目前所有浏览器都不支持；\n                    url：可选的url，浏览器不会检查url是否存在，只改变url，url必须同域。\n                    window.history.pushState(json,”\",”http://www.qingdou.me/post-1.html”);\n        替换当前历史记录点replaceState()：修改当前的history实体，不会新增。\n                    类似replace(url)，要更新当前历史记录的状态对象或URL时，使用replaceState()方法会更合适。\n    \n　　2 、监听历史记录点onpopstate()\n\n　　　  当history实体被改变时，popstate事件将会发生； onhashchange()可监听URL的hash部分。\n     \n     3、读取现有state\n\n        当页面加载时，它可能会有一个非空的state对象。当页面重新加载，页面将收到onload事件，但不会有popstate事件。\n        然而，如果你读取history.state属性，将在popstate事件发生后得到这个state对象。\n\n   注：window.history.forward();确实这个方法在IE和谷歌浏览器中还是起作用的，但在火狐浏览器中却不起作用了\n    经过多次测试后发现加入window.onbeforeunload这个方法后在火狐中就起作用了。代码如下：\n   ```\n    <script language=\"JavaScript\">  \n          window.history.forward();  \n          window.onbeforeunload=function (){   \n                  \n            }  //onbeforeunload方法中什么也不用写。\n    </script>\n   ```\n#### 其他方法参考：\n\n 1. 利用JS产生一个“前进”的动作，以抵消后退功能，这种方法应该是最简洁的，并且不需要考虑用户连点两次或多次“后退”的情况，缺点是当用户端禁用了JavaScript之后即失效。 \n ```\n <script language=\"JavaScript\"> \n javascript:window.history.forward(1); \n </script> \n ```\n 2. 用location.replace从一个页面转到另一个页面。这种方法的原理是，用新页面的URL替换当前的历史纪录，这样浏览历史记录中就只有一个页面，后退按钮永远不会变为可用。我想这可能正是许多人所寻求的方法，但这种方法仍旧不是任何情况下的最好方法。这种方法的缺点在于：简单地运用Response.Redirect将不再有效，这是因为每次用户从一个页面转到另一个页面，我们都必须用客户端代码清除location.history。另外还要注意，这种方法清除的是最后一个访问历史记录，而不是全部的访问记录。 \n ```\n  <A HREF=\"logout.do\" onclick=\"javascript:location.replace(this.href); event.returnValue=false; \"> \n  Logout (Back Disabled) \n  </A> \n  ```","slug":"window-back-disabled","published":1,"updated":"2016-12-16T03:54:19.790Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdv9y003njgtuhe1udgeo","content":"<h3 id=\"防止页面后退（使浏览器后退按钮失效）\"><a href=\"#防止页面后退（使浏览器后退按钮失效）\" class=\"headerlink\" title=\"防止页面后退（使浏览器后退按钮失效）\"></a>防止页面后退（使浏览器后退按钮失效）</h3><p>　　<em>原理</em>：用新页面的URL替换当前的历史纪录，这样浏览历史记录中就只有一个页面，后退按钮永远失效。</p>\n<p>　注：history.go和history.back（包括用户按浏览器历史前进后退按钮）触发，页面由于使用pushState修改了history，会触发popstate事件。【代码如下】<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">       &lt;script type=&quot;text/javascript&quot;&gt;</div><div class=\"line\">            jQuery(document).ready(function ($) &#123;</div><div class=\"line\">                if (window.history &amp;&amp; window.history.pushState) &#123;</div><div class=\"line\">    　　　　$(window).on(&apos;popstate&apos;, function () &#123;</div><div class=\"line\">      　　    window.history.forward(1);</div><div class=\"line\">    　　　　&#125;);</div><div class=\"line\">  　　　　&#125;</div><div class=\"line\">　　　　&#125;);</div><div class=\"line\">　　&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<h3 id=\"其中涉及到的方法详细介绍：\"><a href=\"#其中涉及到的方法详细介绍：\" class=\"headerlink\" title=\"其中涉及到的方法详细介绍：\"></a>其中涉及到的方法详细介绍：</h3><ol>\n<li><p>window.history：表示window对象的历史记录</p>\n</li>\n<li><p>历史记录的前进和后退</p>\n<p> window. history.forward() — 此方法加载历史列表中的下一个 URL，同浏览器中点击向前按钮；<br> window. history.back() — 此方法加载历史列表中的前一个 URL，同浏览器中点击后退按钮。</p>\n<ul>\n<li>可移动到指定历史记录点：<br>通过指定一个相对于当前页面位置的数值，你可以使用 go() 方法从当前会话的历史记录中加载页面,（当前页面位置索引值为0，上一页就是-1，下一页为1）  如：<br>要后退一页（相当于调用back()）： window.history.go(-1);<br>  　　　　<br>向前移动一页（相当于调用forward()）：window.history.go(1);<br>   　　　　<br>　   window.history.length：可以查看length属性值，可知道历史记录栈中共有多少个记录点。</li>\n</ul>\n</li>\n<li><p>操作历史记录点</p>\n<p> HTML5的新API扩展了window.history，可实现存储、替换当前历史记录点，以及监听历史记录点。</p>\n</li>\n</ol>\n<p>　　1、存储、替换当前历史记录点<br>        创建当前历史记录点pushState(state, title, url)：创建（添加）一个新的history实体，<br>                    state：状态对象，记录历史记录点的额外对象（要跳转的URL），可以为空；<br>                    title：页面标题，目前所有浏览器都不支持；<br>                    url：可选的url，浏览器不会检查url是否存在，只改变url，url必须同域。<br>                    window.history.pushState(json,””,”<a href=\"http://www.qingdou.me/post-1.html”\" target=\"_blank\" rel=\"external\">http://www.qingdou.me/post-1.html”</a>);<br>        替换当前历史记录点replaceState()：修改当前的history实体，不会新增。<br>                    类似replace(url)，要更新当前历史记录的状态对象或URL时，使用replaceState()方法会更合适。</p>\n<p>　　2 、监听历史记录点onpopstate()</p>\n<p>　　　  当history实体被改变时，popstate事件将会发生； onhashchange()可监听URL的hash部分。</p>\n<pre><code>3、读取现有state\n\n   当页面加载时，它可能会有一个非空的state对象。当页面重新加载，页面将收到onload事件，但不会有popstate事件。\n   然而，如果你读取history.state属性，将在popstate事件发生后得到这个state对象。\n</code></pre><p>   注：window.history.forward();确实这个方法在IE和谷歌浏览器中还是起作用的，但在火狐浏览器中却不起作用了<br>    经过多次测试后发现加入window.onbeforeunload这个方法后在火狐中就起作用了。代码如下：<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script language=&quot;JavaScript&quot;&gt;  </div><div class=\"line\">      window.history.forward();  </div><div class=\"line\">      window.onbeforeunload=function ()&#123;   </div><div class=\"line\">              </div><div class=\"line\">        &#125;  //onbeforeunload方法中什么也不用写。</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"其他方法参考：\"><a href=\"#其他方法参考：\" class=\"headerlink\" title=\"其他方法参考：\"></a>其他方法参考：</h4><ol>\n<li><p>利用JS产生一个“前进”的动作，以抵消后退功能，这种方法应该是最简洁的，并且不需要考虑用户连点两次或多次“后退”的情况，缺点是当用户端禁用了JavaScript之后即失效。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script language=&quot;JavaScript&quot;&gt; </div><div class=\"line\">javascript:window.history.forward(1); </div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>用location.replace从一个页面转到另一个页面。这种方法的原理是，用新页面的URL替换当前的历史纪录，这样浏览历史记录中就只有一个页面，后退按钮永远不会变为可用。我想这可能正是许多人所寻求的方法，但这种方法仍旧不是任何情况下的最好方法。这种方法的缺点在于：简单地运用Response.Redirect将不再有效，这是因为每次用户从一个页面转到另一个页面，我们都必须用客户端代码清除location.history。另外还要注意，这种方法清除的是最后一个访问历史记录，而不是全部的访问记录。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;A HREF=&quot;logout.do&quot; onclick=&quot;javascript:location.replace(this.href); event.returnValue=false; &quot;&gt; </div><div class=\"line\">Logout (Back Disabled) </div><div class=\"line\">&lt;/A&gt;</div></pre></td></tr></table></figure></li>\n</ol>\n","excerpt":"","more":"<h3 id=\"防止页面后退（使浏览器后退按钮失效）\"><a href=\"#防止页面后退（使浏览器后退按钮失效）\" class=\"headerlink\" title=\"防止页面后退（使浏览器后退按钮失效）\"></a>防止页面后退（使浏览器后退按钮失效）</h3><p>　　<em>原理</em>：用新页面的URL替换当前的历史纪录，这样浏览历史记录中就只有一个页面，后退按钮永远失效。</p>\n<p>　注：history.go和history.back（包括用户按浏览器历史前进后退按钮）触发，页面由于使用pushState修改了history，会触发popstate事件。【代码如下】<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">       &lt;script type=&quot;text/javascript&quot;&gt;</div><div class=\"line\">            jQuery(document).ready(function ($) &#123;</div><div class=\"line\">                if (window.history &amp;&amp; window.history.pushState) &#123;</div><div class=\"line\">    　　　　$(window).on(&apos;popstate&apos;, function () &#123;</div><div class=\"line\">      　　    window.history.forward(1);</div><div class=\"line\">    　　　　&#125;);</div><div class=\"line\">  　　　　&#125;</div><div class=\"line\">　　　　&#125;);</div><div class=\"line\">　　&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<h3 id=\"其中涉及到的方法详细介绍：\"><a href=\"#其中涉及到的方法详细介绍：\" class=\"headerlink\" title=\"其中涉及到的方法详细介绍：\"></a>其中涉及到的方法详细介绍：</h3><ol>\n<li><p>window.history：表示window对象的历史记录</p>\n</li>\n<li><p>历史记录的前进和后退</p>\n<p> window. history.forward() — 此方法加载历史列表中的下一个 URL，同浏览器中点击向前按钮；<br> window. history.back() — 此方法加载历史列表中的前一个 URL，同浏览器中点击后退按钮。</p>\n<ul>\n<li>可移动到指定历史记录点：<br>通过指定一个相对于当前页面位置的数值，你可以使用 go() 方法从当前会话的历史记录中加载页面,（当前页面位置索引值为0，上一页就是-1，下一页为1）  如：<br>要后退一页（相当于调用back()）： window.history.go(-1);<br>  　　　　<br>向前移动一页（相当于调用forward()）：window.history.go(1);<br>   　　　　<br>　   window.history.length：可以查看length属性值，可知道历史记录栈中共有多少个记录点。</li>\n</ul>\n</li>\n<li><p>操作历史记录点</p>\n<p> HTML5的新API扩展了window.history，可实现存储、替换当前历史记录点，以及监听历史记录点。</p>\n</li>\n</ol>\n<p>　　1、存储、替换当前历史记录点<br>        创建当前历史记录点pushState(state, title, url)：创建（添加）一个新的history实体，<br>                    state：状态对象，记录历史记录点的额外对象（要跳转的URL），可以为空；<br>                    title：页面标题，目前所有浏览器都不支持；<br>                    url：可选的url，浏览器不会检查url是否存在，只改变url，url必须同域。<br>                    window.history.pushState(json,””,”<a href=\"http://www.qingdou.me/post-1.html”\">http://www.qingdou.me/post-1.html”</a>);<br>        替换当前历史记录点replaceState()：修改当前的history实体，不会新增。<br>                    类似replace(url)，要更新当前历史记录的状态对象或URL时，使用replaceState()方法会更合适。</p>\n<p>　　2 、监听历史记录点onpopstate()</p>\n<p>　　　  当history实体被改变时，popstate事件将会发生； onhashchange()可监听URL的hash部分。</p>\n<pre><code>3、读取现有state\n\n   当页面加载时，它可能会有一个非空的state对象。当页面重新加载，页面将收到onload事件，但不会有popstate事件。\n   然而，如果你读取history.state属性，将在popstate事件发生后得到这个state对象。\n</code></pre><p>   注：window.history.forward();确实这个方法在IE和谷歌浏览器中还是起作用的，但在火狐浏览器中却不起作用了<br>    经过多次测试后发现加入window.onbeforeunload这个方法后在火狐中就起作用了。代码如下：<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script language=&quot;JavaScript&quot;&gt;  </div><div class=\"line\">      window.history.forward();  </div><div class=\"line\">      window.onbeforeunload=function ()&#123;   </div><div class=\"line\">              </div><div class=\"line\">        &#125;  //onbeforeunload方法中什么也不用写。</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"其他方法参考：\"><a href=\"#其他方法参考：\" class=\"headerlink\" title=\"其他方法参考：\"></a>其他方法参考：</h4><ol>\n<li><p>利用JS产生一个“前进”的动作，以抵消后退功能，这种方法应该是最简洁的，并且不需要考虑用户连点两次或多次“后退”的情况，缺点是当用户端禁用了JavaScript之后即失效。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script language=&quot;JavaScript&quot;&gt; </div><div class=\"line\">javascript:window.history.forward(1); </div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>用location.replace从一个页面转到另一个页面。这种方法的原理是，用新页面的URL替换当前的历史纪录，这样浏览历史记录中就只有一个页面，后退按钮永远不会变为可用。我想这可能正是许多人所寻求的方法，但这种方法仍旧不是任何情况下的最好方法。这种方法的缺点在于：简单地运用Response.Redirect将不再有效，这是因为每次用户从一个页面转到另一个页面，我们都必须用客户端代码清除location.history。另外还要注意，这种方法清除的是最后一个访问历史记录，而不是全部的访问记录。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;A HREF=&quot;logout.do&quot; onclick=&quot;javascript:location.replace(this.href); event.returnValue=false; &quot;&gt; </div><div class=\"line\">Logout (Back Disabled) </div><div class=\"line\">&lt;/A&gt;</div></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"杂七乱八小知识点","date":"2015-11-13T08:01:03.000Z","_content":"### 1、io.js\nio.js 是基于 V8 引擎的较新版本构建的。通过持续跟进最新版的 V8 引擎，我们可以保证及时地为开发者带来最新的 JavaScript ECMA规范 中的语言特性，同时也能得到性能和稳定性的提升。\n- 干掉 --harmony(第一种方式)\n   node koa-app.js --harmy   可以安装iojs,  用iojs koa-app.js   这样就不用写--harmy\n注：--harmy为和谐模式，意思是让node程序启动时兼容ECMA的新特性。\n- 第二种方式\nalias node='node --harmony'   alias：别名，化名\n在chrome中使用该特性需要先打开chrome://flags/, 搜索harmony, enable之, 重启chrome即可\n### 2、npm ls\n在当前项目下可以查看项目下哪些模块没有安装成功。 npm ls -g  查看全局安装了哪些模块，同理 bower ls可以查看bower管理的包哪些安装成功与否！\n### 经过测试IE6,7,8,9均不支持严格模式（\"use strict\"）。ie10在内的主流浏览器才支持.\n### 同构JavaScript应用\n指的是用JavaScript编写的应用，能够同时运行于客户端和服务器。这也让在客户端和服务器之间共享代码变成一种更普遍自然的选择。\n### 屏幕扩展，多屏开发\n### 伪类与伪元素\n伪类，就类似class这样，表示一些元素的状态的，但是无须标识的分类。例：a:hover;\n\n伪元素，就是一个元素，类似p标签元素，等等，逻辑上存在，但是实际并不存在在文档树中。\n\n伪类前面是一个冒号，伪元素前面是两个冒号。E:first-child 伪类，E::first-line为元素。\n::before 和 ::after 伪元素，before 和after是在元素前面和后面添加一些元素，因此是伪元素，为了区分伪类，CSS3选择器中已经将其前面变为两个冒号了。伪元素因为不在DOM里存在，也不会在调试工具里显示，所以不太好调试\n*在a标签hover状态下加一个小三角*，可用伪元素实现.\n```\na:hover::after{}\n```\n### 软件应用版本代号\n- alpha版：内部测试版。α是希腊字母的第一个，表示最早的版本，一般用户不要下载这个版本，这个版本包含很多BUG，功能也不全，主要是给开发人员和 测试人员测试和找BUG用的。\n\n- beta版：公开测试版。β是希腊字母的第二个，顾名思义，这个版本比alpha版发布得晚一些，主要是给“部落”用户和忠实用户测试用的，该版本任然存 在很多BUG，但是相对alpha版要稳定一些。这个阶段版本的软件还会不断增加新功能。如果你是发烧友，可以下载这个版本。\n\n- rc版：全写：Release Candidate（候选版本），该版本又较beta版更进一步了，该版本功能不再增加，和最终发布版功能一样。这个版本有点像最终发行版之前的一个类似 预览版，这个的发布就标明离最终发行版不远了。作为普通用户，如果你很急着用这个软件的话，也可以下载这个版本。\n\n- stable版：稳定版。在开源软件中，都有stable版，这个就是开源软件的最终发行版，用户可以放心大胆的用了。\n### 将类数组对象转换成数组\n扩展运算符可以将一个类数组对象中索引范围在[0,length)之间的所有属性的值添加到一个数组中,这样就可以得到一个真正的数组:\n```\nvar nodeList = document.querySelectorAll('div');\nvar array = [...nodeList];\n```\n当然也可以用es6的新方法：\n```\nvar array=Array.from(nodeList);\n```\n### assert断言库与钩子函数\nassert断言用于在开发阶段监测BUG，进行调试。其存在的意义在于检测代码在开发过程中是否出现了问题。\n*钩子函数*：hook function  钩子的本质是一段用以处理系统消息的程序，通过系统调用，把它挂入系统。\nReact中可以指定在组件的生命周期的不同阶段执行的函数，这些函数就是钩子函数。例：componentDidMount、shouldComponentUpdate等等\n### github pull request 贡献代码\n假设有一个仓库，叫Repo A。你如果要往里贡献代码，首先要Fork这个Repo，于是在你的Github账号下有了一个Repo A2,。然后你在这个A2下工作，Commit，push等。然后你希望原始仓库Repo A合并你的工作，你可以在Github上发起一个Pull Request，意思是请求Repo A的所有者从你的A2合并分支。如果被审核通过并正式合并，这样你就为项目A做贡献了\nGithub pull request 简写github pr 就是『请求代码合并』。\n### lodash\nlodash 是一个具有一致接口、模块化、高性能等特性的 JavaScript 工具库。\n```\n_.assign({ 'a': 1 }, { 'b': 2 }, { 'c': 3 });\n// → { 'a': 1, 'b': 2, 'c': 3 }\n_.map([1, 2, 3], function(n) { return n * 3; });\n// → [3, 6, 9]\n```\n### 箭头函数的使用注意点：\n1. 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\n\n2. 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n\n3. 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。\n\n4. 不可以使用yield命令，因此箭头函数不能用作Generator函数。\n\n上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。\n### 判断一个函数是否是generatorFunction的方法\n```\nfunction isGeneratorFunction(obj) {\n  return obj && obj.constructor && 'GeneratorFunction' === obj.constructor.name\n}\n```\n### ES7语法(async,await)\nkoa用generator这种处理异步方式估计会被es7里的async function 取代， 转义ES7语法(async,await)， 需要stage-3规则，stage-3规则是ES7的stage 0~3的第3阶段规则。 node现在还不支持es7。\n### 函数绑定（::）\n　　箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。\n\n　　函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。\n### jq中的回调\n　　$.ajax()操作完成后，如果使用的是低于1.5.0版本的jQuery，返回的是XHR对象，你没法进行链式操作；如果高于1.5.0版本，返回的是deferred对象，可以进行链式操作。deferred对象就是jQuery的回调函数解决方案\n### TypeScript\n　　TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，*TypeScript 通过类型注解提供编译时的静态类型检查*。TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。\n### prcoess\n  代码中用此取值：prcoess.env.PORT         控制台设置：set PORT=8080\n  prcoess.env.NODE_ENV    set NODE_ENV=production\n### hostAdmin\n   若C:\\Windows\\System32\\drivers\\etc正常访问能找到hosts文件，用hostAdmin访问不到etc这个文件夹，说明hostadmin没有权限访问，此时etc右击属性-共享里设置，将此文件的访问权限授权给everyone.这样就hostadmin能访问此文件夹了.\n### AngularJS 项目中如何实现按需加载js文件\nrequirejs实现angular js文件按需加载,RequireJS + AngularJS实施.\n#### 链式调用\n```\nABC.prototype.add=function(){\n....//some code\nreturn this; //实现链式调用的原理\n}\n```\n\n\n","source":"_posts/zaqiluanba.md","raw":"---\ntitle: 杂七乱八小知识点\ndate: 2015-11-13 16:01:03\ntags: \n---\n### 1、io.js\nio.js 是基于 V8 引擎的较新版本构建的。通过持续跟进最新版的 V8 引擎，我们可以保证及时地为开发者带来最新的 JavaScript ECMA规范 中的语言特性，同时也能得到性能和稳定性的提升。\n- 干掉 --harmony(第一种方式)\n   node koa-app.js --harmy   可以安装iojs,  用iojs koa-app.js   这样就不用写--harmy\n注：--harmy为和谐模式，意思是让node程序启动时兼容ECMA的新特性。\n- 第二种方式\nalias node='node --harmony'   alias：别名，化名\n在chrome中使用该特性需要先打开chrome://flags/, 搜索harmony, enable之, 重启chrome即可\n### 2、npm ls\n在当前项目下可以查看项目下哪些模块没有安装成功。 npm ls -g  查看全局安装了哪些模块，同理 bower ls可以查看bower管理的包哪些安装成功与否！\n### 经过测试IE6,7,8,9均不支持严格模式（\"use strict\"）。ie10在内的主流浏览器才支持.\n### 同构JavaScript应用\n指的是用JavaScript编写的应用，能够同时运行于客户端和服务器。这也让在客户端和服务器之间共享代码变成一种更普遍自然的选择。\n### 屏幕扩展，多屏开发\n### 伪类与伪元素\n伪类，就类似class这样，表示一些元素的状态的，但是无须标识的分类。例：a:hover;\n\n伪元素，就是一个元素，类似p标签元素，等等，逻辑上存在，但是实际并不存在在文档树中。\n\n伪类前面是一个冒号，伪元素前面是两个冒号。E:first-child 伪类，E::first-line为元素。\n::before 和 ::after 伪元素，before 和after是在元素前面和后面添加一些元素，因此是伪元素，为了区分伪类，CSS3选择器中已经将其前面变为两个冒号了。伪元素因为不在DOM里存在，也不会在调试工具里显示，所以不太好调试\n*在a标签hover状态下加一个小三角*，可用伪元素实现.\n```\na:hover::after{}\n```\n### 软件应用版本代号\n- alpha版：内部测试版。α是希腊字母的第一个，表示最早的版本，一般用户不要下载这个版本，这个版本包含很多BUG，功能也不全，主要是给开发人员和 测试人员测试和找BUG用的。\n\n- beta版：公开测试版。β是希腊字母的第二个，顾名思义，这个版本比alpha版发布得晚一些，主要是给“部落”用户和忠实用户测试用的，该版本任然存 在很多BUG，但是相对alpha版要稳定一些。这个阶段版本的软件还会不断增加新功能。如果你是发烧友，可以下载这个版本。\n\n- rc版：全写：Release Candidate（候选版本），该版本又较beta版更进一步了，该版本功能不再增加，和最终发布版功能一样。这个版本有点像最终发行版之前的一个类似 预览版，这个的发布就标明离最终发行版不远了。作为普通用户，如果你很急着用这个软件的话，也可以下载这个版本。\n\n- stable版：稳定版。在开源软件中，都有stable版，这个就是开源软件的最终发行版，用户可以放心大胆的用了。\n### 将类数组对象转换成数组\n扩展运算符可以将一个类数组对象中索引范围在[0,length)之间的所有属性的值添加到一个数组中,这样就可以得到一个真正的数组:\n```\nvar nodeList = document.querySelectorAll('div');\nvar array = [...nodeList];\n```\n当然也可以用es6的新方法：\n```\nvar array=Array.from(nodeList);\n```\n### assert断言库与钩子函数\nassert断言用于在开发阶段监测BUG，进行调试。其存在的意义在于检测代码在开发过程中是否出现了问题。\n*钩子函数*：hook function  钩子的本质是一段用以处理系统消息的程序，通过系统调用，把它挂入系统。\nReact中可以指定在组件的生命周期的不同阶段执行的函数，这些函数就是钩子函数。例：componentDidMount、shouldComponentUpdate等等\n### github pull request 贡献代码\n假设有一个仓库，叫Repo A。你如果要往里贡献代码，首先要Fork这个Repo，于是在你的Github账号下有了一个Repo A2,。然后你在这个A2下工作，Commit，push等。然后你希望原始仓库Repo A合并你的工作，你可以在Github上发起一个Pull Request，意思是请求Repo A的所有者从你的A2合并分支。如果被审核通过并正式合并，这样你就为项目A做贡献了\nGithub pull request 简写github pr 就是『请求代码合并』。\n### lodash\nlodash 是一个具有一致接口、模块化、高性能等特性的 JavaScript 工具库。\n```\n_.assign({ 'a': 1 }, { 'b': 2 }, { 'c': 3 });\n// → { 'a': 1, 'b': 2, 'c': 3 }\n_.map([1, 2, 3], function(n) { return n * 3; });\n// → [3, 6, 9]\n```\n### 箭头函数的使用注意点：\n1. 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\n\n2. 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n\n3. 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。\n\n4. 不可以使用yield命令，因此箭头函数不能用作Generator函数。\n\n上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。\n### 判断一个函数是否是generatorFunction的方法\n```\nfunction isGeneratorFunction(obj) {\n  return obj && obj.constructor && 'GeneratorFunction' === obj.constructor.name\n}\n```\n### ES7语法(async,await)\nkoa用generator这种处理异步方式估计会被es7里的async function 取代， 转义ES7语法(async,await)， 需要stage-3规则，stage-3规则是ES7的stage 0~3的第3阶段规则。 node现在还不支持es7。\n### 函数绑定（::）\n　　箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。\n\n　　函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。\n### jq中的回调\n　　$.ajax()操作完成后，如果使用的是低于1.5.0版本的jQuery，返回的是XHR对象，你没法进行链式操作；如果高于1.5.0版本，返回的是deferred对象，可以进行链式操作。deferred对象就是jQuery的回调函数解决方案\n### TypeScript\n　　TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，*TypeScript 通过类型注解提供编译时的静态类型检查*。TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。\n### prcoess\n  代码中用此取值：prcoess.env.PORT         控制台设置：set PORT=8080\n  prcoess.env.NODE_ENV    set NODE_ENV=production\n### hostAdmin\n   若C:\\Windows\\System32\\drivers\\etc正常访问能找到hosts文件，用hostAdmin访问不到etc这个文件夹，说明hostadmin没有权限访问，此时etc右击属性-共享里设置，将此文件的访问权限授权给everyone.这样就hostadmin能访问此文件夹了.\n### AngularJS 项目中如何实现按需加载js文件\nrequirejs实现angular js文件按需加载,RequireJS + AngularJS实施.\n#### 链式调用\n```\nABC.prototype.add=function(){\n....//some code\nreturn this; //实现链式调用的原理\n}\n```\n\n\n","slug":"zaqiluanba","published":1,"updated":"2017-01-03T03:50:45.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdva2003pjgtuio185td9","content":"<h3 id=\"1、io-js\"><a href=\"#1、io-js\" class=\"headerlink\" title=\"1、io.js\"></a>1、io.js</h3><p>io.js 是基于 V8 引擎的较新版本构建的。通过持续跟进最新版的 V8 引擎，我们可以保证及时地为开发者带来最新的 JavaScript ECMA规范 中的语言特性，同时也能得到性能和稳定性的提升。</p>\n<ul>\n<li>干掉 –harmony(第一种方式)<br> node koa-app.js –harmy   可以安装iojs,  用iojs koa-app.js   这样就不用写–harmy<br>注：–harmy为和谐模式，意思是让node程序启动时兼容ECMA的新特性。</li>\n<li>第二种方式<br>alias node=’node –harmony’   alias：别名，化名<br>在chrome中使用该特性需要先打开chrome://flags/, 搜索harmony, enable之, 重启chrome即可<h3 id=\"2、npm-ls\"><a href=\"#2、npm-ls\" class=\"headerlink\" title=\"2、npm ls\"></a>2、npm ls</h3>在当前项目下可以查看项目下哪些模块没有安装成功。 npm ls -g  查看全局安装了哪些模块，同理 bower ls可以查看bower管理的包哪些安装成功与否！<h3 id=\"经过测试IE6-7-8-9均不支持严格模式（”use-strict”）。ie10在内的主流浏览器才支持\"><a href=\"#经过测试IE6-7-8-9均不支持严格模式（”use-strict”）。ie10在内的主流浏览器才支持\" class=\"headerlink\" title=\"经过测试IE6,7,8,9均不支持严格模式（”use strict”）。ie10在内的主流浏览器才支持.\"></a>经过测试IE6,7,8,9均不支持严格模式（”use strict”）。ie10在内的主流浏览器才支持.</h3><h3 id=\"同构JavaScript应用\"><a href=\"#同构JavaScript应用\" class=\"headerlink\" title=\"同构JavaScript应用\"></a>同构JavaScript应用</h3>指的是用JavaScript编写的应用，能够同时运行于客户端和服务器。这也让在客户端和服务器之间共享代码变成一种更普遍自然的选择。<h3 id=\"屏幕扩展，多屏开发\"><a href=\"#屏幕扩展，多屏开发\" class=\"headerlink\" title=\"屏幕扩展，多屏开发\"></a>屏幕扩展，多屏开发</h3><h3 id=\"伪类与伪元素\"><a href=\"#伪类与伪元素\" class=\"headerlink\" title=\"伪类与伪元素\"></a>伪类与伪元素</h3>伪类，就类似class这样，表示一些元素的状态的，但是无须标识的分类。例：a:hover;</li>\n</ul>\n<p>伪元素，就是一个元素，类似p标签元素，等等，逻辑上存在，但是实际并不存在在文档树中。</p>\n<p>伪类前面是一个冒号，伪元素前面是两个冒号。E:first-child 伪类，E::first-line为元素。<br>::before 和 ::after 伪元素，before 和after是在元素前面和后面添加一些元素，因此是伪元素，为了区分伪类，CSS3选择器中已经将其前面变为两个冒号了。伪元素因为不在DOM里存在，也不会在调试工具里显示，所以不太好调试<br><em>在a标签hover状态下加一个小三角</em>，可用伪元素实现.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">a:hover::after&#123;&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"软件应用版本代号\"><a href=\"#软件应用版本代号\" class=\"headerlink\" title=\"软件应用版本代号\"></a>软件应用版本代号</h3><ul>\n<li><p>alpha版：内部测试版。α是希腊字母的第一个，表示最早的版本，一般用户不要下载这个版本，这个版本包含很多BUG，功能也不全，主要是给开发人员和 测试人员测试和找BUG用的。</p>\n</li>\n<li><p>beta版：公开测试版。β是希腊字母的第二个，顾名思义，这个版本比alpha版发布得晚一些，主要是给“部落”用户和忠实用户测试用的，该版本任然存 在很多BUG，但是相对alpha版要稳定一些。这个阶段版本的软件还会不断增加新功能。如果你是发烧友，可以下载这个版本。</p>\n</li>\n<li><p>rc版：全写：Release Candidate（候选版本），该版本又较beta版更进一步了，该版本功能不再增加，和最终发布版功能一样。这个版本有点像最终发行版之前的一个类似 预览版，这个的发布就标明离最终发行版不远了。作为普通用户，如果你很急着用这个软件的话，也可以下载这个版本。</p>\n</li>\n<li><p>stable版：稳定版。在开源软件中，都有stable版，这个就是开源软件的最终发行版，用户可以放心大胆的用了。</p>\n<h3 id=\"将类数组对象转换成数组\"><a href=\"#将类数组对象转换成数组\" class=\"headerlink\" title=\"将类数组对象转换成数组\"></a>将类数组对象转换成数组</h3><p>扩展运算符可以将一个类数组对象中索引范围在[0,length)之间的所有属性的值添加到一个数组中,这样就可以得到一个真正的数组:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var nodeList = document.querySelectorAll(&apos;div&apos;);</div><div class=\"line\">var array = [...nodeList];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>当然也可以用es6的新方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var array=Array.from(nodeList);</div></pre></td></tr></table></figure></p>\n<h3 id=\"assert断言库与钩子函数\"><a href=\"#assert断言库与钩子函数\" class=\"headerlink\" title=\"assert断言库与钩子函数\"></a>assert断言库与钩子函数</h3><p>assert断言用于在开发阶段监测BUG，进行调试。其存在的意义在于检测代码在开发过程中是否出现了问题。<br><em>钩子函数</em>：hook function  钩子的本质是一段用以处理系统消息的程序，通过系统调用，把它挂入系统。<br>React中可以指定在组件的生命周期的不同阶段执行的函数，这些函数就是钩子函数。例：componentDidMount、shouldComponentUpdate等等</p>\n<h3 id=\"github-pull-request-贡献代码\"><a href=\"#github-pull-request-贡献代码\" class=\"headerlink\" title=\"github pull request 贡献代码\"></a>github pull request 贡献代码</h3><p>假设有一个仓库，叫Repo A。你如果要往里贡献代码，首先要Fork这个Repo，于是在你的Github账号下有了一个Repo A2,。然后你在这个A2下工作，Commit，push等。然后你希望原始仓库Repo A合并你的工作，你可以在Github上发起一个Pull Request，意思是请求Repo A的所有者从你的A2合并分支。如果被审核通过并正式合并，这样你就为项目A做贡献了<br>Github pull request 简写github pr 就是『请求代码合并』。</p>\n<h3 id=\"lodash\"><a href=\"#lodash\" class=\"headerlink\" title=\"lodash\"></a>lodash</h3><p>lodash 是一个具有一致接口、模块化、高性能等特性的 JavaScript 工具库。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">_.assign(&#123; &apos;a&apos;: 1 &#125;, &#123; &apos;b&apos;: 2 &#125;, &#123; &apos;c&apos;: 3 &#125;);</div><div class=\"line\">// → &#123; &apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3 &#125;</div><div class=\"line\">_.map([1, 2, 3], function(n) &#123; return n * 3; &#125;);</div><div class=\"line\">// → [3, 6, 9]</div></pre></td></tr></table></figure></p>\n<h3 id=\"箭头函数的使用注意点：\"><a href=\"#箭头函数的使用注意点：\" class=\"headerlink\" title=\"箭头函数的使用注意点：\"></a>箭头函数的使用注意点：</h3><ol>\n<li><p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>\n</li>\n<li><p>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>\n</li>\n<li><p>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>\n</li>\n<li><p>不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>\n</li>\n</ol>\n<p>上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。</p>\n<h3 id=\"判断一个函数是否是generatorFunction的方法\"><a href=\"#判断一个函数是否是generatorFunction的方法\" class=\"headerlink\" title=\"判断一个函数是否是generatorFunction的方法\"></a>判断一个函数是否是generatorFunction的方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function isGeneratorFunction(obj) &#123;</div><div class=\"line\">  return obj &amp;&amp; obj.constructor &amp;&amp; &apos;GeneratorFunction&apos; === obj.constructor.name</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"ES7语法-async-await\"><a href=\"#ES7语法-async-await\" class=\"headerlink\" title=\"ES7语法(async,await)\"></a>ES7语法(async,await)</h3><p>koa用generator这种处理异步方式估计会被es7里的async function 取代， 转义ES7语法(async,await)， 需要stage-3规则，stage-3规则是ES7的stage 0~3的第3阶段规则。 node现在还不支持es7。</p>\n<h3 id=\"函数绑定（-）\"><a href=\"#函数绑定（-）\" class=\"headerlink\" title=\"函数绑定（::）\"></a>函数绑定（::）</h3><p>　　箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。</p>\n<p>　　函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p>\n<h3 id=\"jq中的回调\"><a href=\"#jq中的回调\" class=\"headerlink\" title=\"jq中的回调\"></a>jq中的回调</h3><p>　　$.ajax()操作完成后，如果使用的是低于1.5.0版本的jQuery，返回的是XHR对象，你没法进行链式操作；如果高于1.5.0版本，返回的是deferred对象，可以进行链式操作。deferred对象就是jQuery的回调函数解决方案</p>\n<h3 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h3><p>　　TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，<em>TypeScript 通过类型注解提供编译时的静态类型检查</em>。TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。</p>\n<h3 id=\"prcoess\"><a href=\"#prcoess\" class=\"headerlink\" title=\"prcoess\"></a>prcoess</h3><p>  代码中用此取值：prcoess.env.PORT         控制台设置：set PORT=8080<br>  prcoess.env.NODE_ENV    set NODE_ENV=production</p>\n<h3 id=\"hostAdmin\"><a href=\"#hostAdmin\" class=\"headerlink\" title=\"hostAdmin\"></a>hostAdmin</h3><p>   若C:\\Windows\\System32\\drivers\\etc正常访问能找到hosts文件，用hostAdmin访问不到etc这个文件夹，说明hostadmin没有权限访问，此时etc右击属性-共享里设置，将此文件的访问权限授权给everyone.这样就hostadmin能访问此文件夹了.</p>\n<h3 id=\"AngularJS-项目中如何实现按需加载js文件\"><a href=\"#AngularJS-项目中如何实现按需加载js文件\" class=\"headerlink\" title=\"AngularJS 项目中如何实现按需加载js文件\"></a>AngularJS 项目中如何实现按需加载js文件</h3><p>requirejs实现angular js文件按需加载,RequireJS + AngularJS实施.</p>\n<h4 id=\"链式调用\"><a href=\"#链式调用\" class=\"headerlink\" title=\"链式调用\"></a>链式调用</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ABC.prototype.add=function()&#123;</div><div class=\"line\">....//some code</div><div class=\"line\">return this; //实现链式调用的原理</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"1、io-js\"><a href=\"#1、io-js\" class=\"headerlink\" title=\"1、io.js\"></a>1、io.js</h3><p>io.js 是基于 V8 引擎的较新版本构建的。通过持续跟进最新版的 V8 引擎，我们可以保证及时地为开发者带来最新的 JavaScript ECMA规范 中的语言特性，同时也能得到性能和稳定性的提升。</p>\n<ul>\n<li>干掉 –harmony(第一种方式)<br> node koa-app.js –harmy   可以安装iojs,  用iojs koa-app.js   这样就不用写–harmy<br>注：–harmy为和谐模式，意思是让node程序启动时兼容ECMA的新特性。</li>\n<li>第二种方式<br>alias node=’node –harmony’   alias：别名，化名<br>在chrome中使用该特性需要先打开chrome://flags/, 搜索harmony, enable之, 重启chrome即可<h3 id=\"2、npm-ls\"><a href=\"#2、npm-ls\" class=\"headerlink\" title=\"2、npm ls\"></a>2、npm ls</h3>在当前项目下可以查看项目下哪些模块没有安装成功。 npm ls -g  查看全局安装了哪些模块，同理 bower ls可以查看bower管理的包哪些安装成功与否！<h3 id=\"经过测试IE6-7-8-9均不支持严格模式（”use-strict”）。ie10在内的主流浏览器才支持\"><a href=\"#经过测试IE6-7-8-9均不支持严格模式（”use-strict”）。ie10在内的主流浏览器才支持\" class=\"headerlink\" title=\"经过测试IE6,7,8,9均不支持严格模式（”use strict”）。ie10在内的主流浏览器才支持.\"></a>经过测试IE6,7,8,9均不支持严格模式（”use strict”）。ie10在内的主流浏览器才支持.</h3><h3 id=\"同构JavaScript应用\"><a href=\"#同构JavaScript应用\" class=\"headerlink\" title=\"同构JavaScript应用\"></a>同构JavaScript应用</h3>指的是用JavaScript编写的应用，能够同时运行于客户端和服务器。这也让在客户端和服务器之间共享代码变成一种更普遍自然的选择。<h3 id=\"屏幕扩展，多屏开发\"><a href=\"#屏幕扩展，多屏开发\" class=\"headerlink\" title=\"屏幕扩展，多屏开发\"></a>屏幕扩展，多屏开发</h3><h3 id=\"伪类与伪元素\"><a href=\"#伪类与伪元素\" class=\"headerlink\" title=\"伪类与伪元素\"></a>伪类与伪元素</h3>伪类，就类似class这样，表示一些元素的状态的，但是无须标识的分类。例：a:hover;</li>\n</ul>\n<p>伪元素，就是一个元素，类似p标签元素，等等，逻辑上存在，但是实际并不存在在文档树中。</p>\n<p>伪类前面是一个冒号，伪元素前面是两个冒号。E:first-child 伪类，E::first-line为元素。<br>::before 和 ::after 伪元素，before 和after是在元素前面和后面添加一些元素，因此是伪元素，为了区分伪类，CSS3选择器中已经将其前面变为两个冒号了。伪元素因为不在DOM里存在，也不会在调试工具里显示，所以不太好调试<br><em>在a标签hover状态下加一个小三角</em>，可用伪元素实现.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">a:hover::after&#123;&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"软件应用版本代号\"><a href=\"#软件应用版本代号\" class=\"headerlink\" title=\"软件应用版本代号\"></a>软件应用版本代号</h3><ul>\n<li><p>alpha版：内部测试版。α是希腊字母的第一个，表示最早的版本，一般用户不要下载这个版本，这个版本包含很多BUG，功能也不全，主要是给开发人员和 测试人员测试和找BUG用的。</p>\n</li>\n<li><p>beta版：公开测试版。β是希腊字母的第二个，顾名思义，这个版本比alpha版发布得晚一些，主要是给“部落”用户和忠实用户测试用的，该版本任然存 在很多BUG，但是相对alpha版要稳定一些。这个阶段版本的软件还会不断增加新功能。如果你是发烧友，可以下载这个版本。</p>\n</li>\n<li><p>rc版：全写：Release Candidate（候选版本），该版本又较beta版更进一步了，该版本功能不再增加，和最终发布版功能一样。这个版本有点像最终发行版之前的一个类似 预览版，这个的发布就标明离最终发行版不远了。作为普通用户，如果你很急着用这个软件的话，也可以下载这个版本。</p>\n</li>\n<li><p>stable版：稳定版。在开源软件中，都有stable版，这个就是开源软件的最终发行版，用户可以放心大胆的用了。</p>\n<h3 id=\"将类数组对象转换成数组\"><a href=\"#将类数组对象转换成数组\" class=\"headerlink\" title=\"将类数组对象转换成数组\"></a>将类数组对象转换成数组</h3><p>扩展运算符可以将一个类数组对象中索引范围在[0,length)之间的所有属性的值添加到一个数组中,这样就可以得到一个真正的数组:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var nodeList = document.querySelectorAll(&apos;div&apos;);</div><div class=\"line\">var array = [...nodeList];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>当然也可以用es6的新方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var array=Array.from(nodeList);</div></pre></td></tr></table></figure></p>\n<h3 id=\"assert断言库与钩子函数\"><a href=\"#assert断言库与钩子函数\" class=\"headerlink\" title=\"assert断言库与钩子函数\"></a>assert断言库与钩子函数</h3><p>assert断言用于在开发阶段监测BUG，进行调试。其存在的意义在于检测代码在开发过程中是否出现了问题。<br><em>钩子函数</em>：hook function  钩子的本质是一段用以处理系统消息的程序，通过系统调用，把它挂入系统。<br>React中可以指定在组件的生命周期的不同阶段执行的函数，这些函数就是钩子函数。例：componentDidMount、shouldComponentUpdate等等</p>\n<h3 id=\"github-pull-request-贡献代码\"><a href=\"#github-pull-request-贡献代码\" class=\"headerlink\" title=\"github pull request 贡献代码\"></a>github pull request 贡献代码</h3><p>假设有一个仓库，叫Repo A。你如果要往里贡献代码，首先要Fork这个Repo，于是在你的Github账号下有了一个Repo A2,。然后你在这个A2下工作，Commit，push等。然后你希望原始仓库Repo A合并你的工作，你可以在Github上发起一个Pull Request，意思是请求Repo A的所有者从你的A2合并分支。如果被审核通过并正式合并，这样你就为项目A做贡献了<br>Github pull request 简写github pr 就是『请求代码合并』。</p>\n<h3 id=\"lodash\"><a href=\"#lodash\" class=\"headerlink\" title=\"lodash\"></a>lodash</h3><p>lodash 是一个具有一致接口、模块化、高性能等特性的 JavaScript 工具库。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">_.assign(&#123; &apos;a&apos;: 1 &#125;, &#123; &apos;b&apos;: 2 &#125;, &#123; &apos;c&apos;: 3 &#125;);</div><div class=\"line\">// → &#123; &apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3 &#125;</div><div class=\"line\">_.map([1, 2, 3], function(n) &#123; return n * 3; &#125;);</div><div class=\"line\">// → [3, 6, 9]</div></pre></td></tr></table></figure></p>\n<h3 id=\"箭头函数的使用注意点：\"><a href=\"#箭头函数的使用注意点：\" class=\"headerlink\" title=\"箭头函数的使用注意点：\"></a>箭头函数的使用注意点：</h3><ol>\n<li><p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>\n</li>\n<li><p>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>\n</li>\n<li><p>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>\n</li>\n<li><p>不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>\n</li>\n</ol>\n<p>上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。</p>\n<h3 id=\"判断一个函数是否是generatorFunction的方法\"><a href=\"#判断一个函数是否是generatorFunction的方法\" class=\"headerlink\" title=\"判断一个函数是否是generatorFunction的方法\"></a>判断一个函数是否是generatorFunction的方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function isGeneratorFunction(obj) &#123;</div><div class=\"line\">  return obj &amp;&amp; obj.constructor &amp;&amp; &apos;GeneratorFunction&apos; === obj.constructor.name</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"ES7语法-async-await\"><a href=\"#ES7语法-async-await\" class=\"headerlink\" title=\"ES7语法(async,await)\"></a>ES7语法(async,await)</h3><p>koa用generator这种处理异步方式估计会被es7里的async function 取代， 转义ES7语法(async,await)， 需要stage-3规则，stage-3规则是ES7的stage 0~3的第3阶段规则。 node现在还不支持es7。</p>\n<h3 id=\"函数绑定（-）\"><a href=\"#函数绑定（-）\" class=\"headerlink\" title=\"函数绑定（::）\"></a>函数绑定（::）</h3><p>　　箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。</p>\n<p>　　函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p>\n<h3 id=\"jq中的回调\"><a href=\"#jq中的回调\" class=\"headerlink\" title=\"jq中的回调\"></a>jq中的回调</h3><p>　　$.ajax()操作完成后，如果使用的是低于1.5.0版本的jQuery，返回的是XHR对象，你没法进行链式操作；如果高于1.5.0版本，返回的是deferred对象，可以进行链式操作。deferred对象就是jQuery的回调函数解决方案</p>\n<h3 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h3><p>　　TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，<em>TypeScript 通过类型注解提供编译时的静态类型检查</em>。TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。</p>\n<h3 id=\"prcoess\"><a href=\"#prcoess\" class=\"headerlink\" title=\"prcoess\"></a>prcoess</h3><p>  代码中用此取值：prcoess.env.PORT         控制台设置：set PORT=8080<br>  prcoess.env.NODE_ENV    set NODE_ENV=production</p>\n<h3 id=\"hostAdmin\"><a href=\"#hostAdmin\" class=\"headerlink\" title=\"hostAdmin\"></a>hostAdmin</h3><p>   若C:\\Windows\\System32\\drivers\\etc正常访问能找到hosts文件，用hostAdmin访问不到etc这个文件夹，说明hostadmin没有权限访问，此时etc右击属性-共享里设置，将此文件的访问权限授权给everyone.这样就hostadmin能访问此文件夹了.</p>\n<h3 id=\"AngularJS-项目中如何实现按需加载js文件\"><a href=\"#AngularJS-项目中如何实现按需加载js文件\" class=\"headerlink\" title=\"AngularJS 项目中如何实现按需加载js文件\"></a>AngularJS 项目中如何实现按需加载js文件</h3><p>requirejs实现angular js文件按需加载,RequireJS + AngularJS实施.</p>\n<h4 id=\"链式调用\"><a href=\"#链式调用\" class=\"headerlink\" title=\"链式调用\"></a>链式调用</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ABC.prototype.add=function()&#123;</div><div class=\"line\">....//some code</div><div class=\"line\">return this; //实现链式调用的原理</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"你的人生如此着急，你过好了吗？","date":"2015-03-27T01:20:24.000Z","_content":"我读后感觉写得很好，所以记录下来分享给大家，希望有所感悟，能对你起到一定的帮助！\n\n我所看到的人，都在急，特别的急！急着要男朋友，急着要女朋友，女朋友着急要房子，要车子，想旅游，又想享受生活，想安逸，男朋友又得拼命工作，阅历不深却又着急看透世界，甚至于连一篇文章都没有时间读完，告诉我，你们究竟急的是什么？\n\n**别着急，慢慢来**\n\n我不知道这代人怎么想的，我并不认同八零后和七零后还有六零后的区别，现在的八零后当务之急便是房子了，还有那可怜的爱情，这在七零后和六零后的时候，是根本不需要操心的，你说，这社会是进步了？还是退步了？我也是个八零后，同样想着各种各样的事，同样急着这社会上大多数人急的事。\n\n看了一篇文章，似乎有些释然，文章上说“你所急的事，一定是最不需要快速解决的，你所不在乎的事，恰恰需要你马上行动。”起初看到这句话，没办法理解，可是接下来的一句话却让我如梦初醒，“因为一粒种子，就是要慢慢成熟，谁也决定不了它成长的速度，而你手里的苹果，耽搁了时间，就不再好吃了，还原世界本来的面目，一切慢慢来”。\n\n现在的爱情也是，急的不行，男人们遇见姑娘急着上床，姑娘们遇见男人，急着迅速掀底，到底值不值得交往，即便是交往了，也急着结婚，父母催，亲戚催，结婚了，马上要了孩子，孩子出来了，马上急着别落在起跑线上，各种补习班，上了小学，急着中学，上了高中，急着大学，上了大学，又急工作，循环往复，周而复始，人们早都忘了事物的本来面目。\n\n爱情就该慢慢来，在我刚刚遇见你的时候，你也刚好爱上我，就在一起吧，想厮守一辈子了，管它嫁妆房子，有你就好，结婚生子，顺其自然，孩子有它的童年，就像我们有过的童年一样，事情本来就该慢慢来，可是现在的时代，都提前了，屁股上都着火了，可是谁都找不到灭火器。\n\n**亲爱的，你慢慢飞**\n\n中国的改革开放太快了，快的让民众来不及反映，地图上圈里的城市，深圳， 上海 ，发了。所有的中国人都开始急了，急下海，急炒股。\n\n中国用火箭的速度在发展着，却忽略了一批又一批的善良的人们，那些点燃火箭升空的人，早已消失在火箭腾空时，激起的尘土中了。\n\n所有的速度都让民众目不暇接，所有的变化让孩子们甚至找不到家的方向，那些迎着朝阳出门的人，背着月光回家的时候，可能看到的只是废墟，因为这一切都来不急让你等待，因为，高楼大厦崛起的速度，一定快过你回家的速度。\n\n每当下班的时候站在天桥上，或是地铁里，看着低头行走的年轻人，每个人的脸上都是一种表情，麻木，平淡，疲惫，又无奈，我想上前拽住每个人，告诉他们，慢慢飞，可是，我办不到，我不是精神病人，我只是旁观者，看着人群在我身边走过，而我也只能跟随人群的脚步，因为慢了，我赶不上回家的最后一班车。\n\n**你猜，我是走，还是跑？**\n\n很多事情，很多人，都已不是原来的样子，朋友说，计划永远没有变化快，我说，那是你的钱没的太快，在这个时代，好人和坏人，没办法区分，就像“狼”和“哈士奇”也没办法区分一样，只是希望，“狼别生气，人把你当狗，也愿狗别高兴，人心虚了，才把你当狼”。\n\n现在的人太容易孤独，彷徨，烦躁，急迫，其实，你之所以感到孤独，并不是没有人关心你，而是你在乎的那个人没有关心你。\n\n很多刚毕业的学生，都急着奔向远方，认为他的理想都在远方，而有的同学，却慢慢的回家，想想自己到底要做什么，该做什么，三年后，当年去找理想的人，把自己也丢了，当年慢慢的人，做了老板，开了个小店，娶了媳妇，生了孩子，虽然他可能没吃过太多次的肯德基，没去过太多次的咖啡厅，也没有带着媳妇去吃必胜客，可是，谁能说他走的慢了？\n\n有的时候，走，真的比跑快，因为走着，不会错过风景，知道目标；而跑的人，会落下太多的人，最后孤独一人，因为你跑的太快，别人跟不上。\n\n**安静，我们都该休息了**\n\n一个人，一辈子最重要的事，其实就是选对身边的人，炊烟起了，我在门口等你。夕阳下了，我在山边等你。叶子黄了，我在树下等你。月儿弯了，我在十五等你。细雨来了，我在伞下等你。流水冻了，我在河畔等你。生命累了，我在天堂等你。我们老了，我在来生等你。\n\n我们都累了，是时候慢慢的停下来，放慢脚步，好好的看一本书，好好的听听爱你的人，要对你说的话，看看我们在急着往前走的时候，落下了什么东西，到底是朋友，还是父母，还是你最珍贵的爱情。。。\n\n这个时代，无论多快，我们总该找到自己的节奏——试着寻找一个“灭火器”，把身后的“火”灭了吧。\n","source":"_posts/zhaoji-life.md","raw":"---\ntitle: 你的人生如此着急，你过好了吗？\ndate: 2015-03-27 09:20:24\ntags: 人生\n---\n我读后感觉写得很好，所以记录下来分享给大家，希望有所感悟，能对你起到一定的帮助！\n\n我所看到的人，都在急，特别的急！急着要男朋友，急着要女朋友，女朋友着急要房子，要车子，想旅游，又想享受生活，想安逸，男朋友又得拼命工作，阅历不深却又着急看透世界，甚至于连一篇文章都没有时间读完，告诉我，你们究竟急的是什么？\n\n**别着急，慢慢来**\n\n我不知道这代人怎么想的，我并不认同八零后和七零后还有六零后的区别，现在的八零后当务之急便是房子了，还有那可怜的爱情，这在七零后和六零后的时候，是根本不需要操心的，你说，这社会是进步了？还是退步了？我也是个八零后，同样想着各种各样的事，同样急着这社会上大多数人急的事。\n\n看了一篇文章，似乎有些释然，文章上说“你所急的事，一定是最不需要快速解决的，你所不在乎的事，恰恰需要你马上行动。”起初看到这句话，没办法理解，可是接下来的一句话却让我如梦初醒，“因为一粒种子，就是要慢慢成熟，谁也决定不了它成长的速度，而你手里的苹果，耽搁了时间，就不再好吃了，还原世界本来的面目，一切慢慢来”。\n\n现在的爱情也是，急的不行，男人们遇见姑娘急着上床，姑娘们遇见男人，急着迅速掀底，到底值不值得交往，即便是交往了，也急着结婚，父母催，亲戚催，结婚了，马上要了孩子，孩子出来了，马上急着别落在起跑线上，各种补习班，上了小学，急着中学，上了高中，急着大学，上了大学，又急工作，循环往复，周而复始，人们早都忘了事物的本来面目。\n\n爱情就该慢慢来，在我刚刚遇见你的时候，你也刚好爱上我，就在一起吧，想厮守一辈子了，管它嫁妆房子，有你就好，结婚生子，顺其自然，孩子有它的童年，就像我们有过的童年一样，事情本来就该慢慢来，可是现在的时代，都提前了，屁股上都着火了，可是谁都找不到灭火器。\n\n**亲爱的，你慢慢飞**\n\n中国的改革开放太快了，快的让民众来不及反映，地图上圈里的城市，深圳， 上海 ，发了。所有的中国人都开始急了，急下海，急炒股。\n\n中国用火箭的速度在发展着，却忽略了一批又一批的善良的人们，那些点燃火箭升空的人，早已消失在火箭腾空时，激起的尘土中了。\n\n所有的速度都让民众目不暇接，所有的变化让孩子们甚至找不到家的方向，那些迎着朝阳出门的人，背着月光回家的时候，可能看到的只是废墟，因为这一切都来不急让你等待，因为，高楼大厦崛起的速度，一定快过你回家的速度。\n\n每当下班的时候站在天桥上，或是地铁里，看着低头行走的年轻人，每个人的脸上都是一种表情，麻木，平淡，疲惫，又无奈，我想上前拽住每个人，告诉他们，慢慢飞，可是，我办不到，我不是精神病人，我只是旁观者，看着人群在我身边走过，而我也只能跟随人群的脚步，因为慢了，我赶不上回家的最后一班车。\n\n**你猜，我是走，还是跑？**\n\n很多事情，很多人，都已不是原来的样子，朋友说，计划永远没有变化快，我说，那是你的钱没的太快，在这个时代，好人和坏人，没办法区分，就像“狼”和“哈士奇”也没办法区分一样，只是希望，“狼别生气，人把你当狗，也愿狗别高兴，人心虚了，才把你当狼”。\n\n现在的人太容易孤独，彷徨，烦躁，急迫，其实，你之所以感到孤独，并不是没有人关心你，而是你在乎的那个人没有关心你。\n\n很多刚毕业的学生，都急着奔向远方，认为他的理想都在远方，而有的同学，却慢慢的回家，想想自己到底要做什么，该做什么，三年后，当年去找理想的人，把自己也丢了，当年慢慢的人，做了老板，开了个小店，娶了媳妇，生了孩子，虽然他可能没吃过太多次的肯德基，没去过太多次的咖啡厅，也没有带着媳妇去吃必胜客，可是，谁能说他走的慢了？\n\n有的时候，走，真的比跑快，因为走着，不会错过风景，知道目标；而跑的人，会落下太多的人，最后孤独一人，因为你跑的太快，别人跟不上。\n\n**安静，我们都该休息了**\n\n一个人，一辈子最重要的事，其实就是选对身边的人，炊烟起了，我在门口等你。夕阳下了，我在山边等你。叶子黄了，我在树下等你。月儿弯了，我在十五等你。细雨来了，我在伞下等你。流水冻了，我在河畔等你。生命累了，我在天堂等你。我们老了，我在来生等你。\n\n我们都累了，是时候慢慢的停下来，放慢脚步，好好的看一本书，好好的听听爱你的人，要对你说的话，看看我们在急着往前走的时候，落下了什么东西，到底是朋友，还是父母，还是你最珍贵的爱情。。。\n\n这个时代，无论多快，我们总该找到自己的节奏——试着寻找一个“灭火器”，把身后的“火”灭了吧。\n","slug":"zhaoji-life","published":1,"updated":"2016-12-27T01:26:30.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdva5003rjgtuqighgxsk","content":"<p>我读后感觉写得很好，所以记录下来分享给大家，希望有所感悟，能对你起到一定的帮助！</p>\n<p>我所看到的人，都在急，特别的急！急着要男朋友，急着要女朋友，女朋友着急要房子，要车子，想旅游，又想享受生活，想安逸，男朋友又得拼命工作，阅历不深却又着急看透世界，甚至于连一篇文章都没有时间读完，告诉我，你们究竟急的是什么？</p>\n<p><strong>别着急，慢慢来</strong></p>\n<p>我不知道这代人怎么想的，我并不认同八零后和七零后还有六零后的区别，现在的八零后当务之急便是房子了，还有那可怜的爱情，这在七零后和六零后的时候，是根本不需要操心的，你说，这社会是进步了？还是退步了？我也是个八零后，同样想着各种各样的事，同样急着这社会上大多数人急的事。</p>\n<p>看了一篇文章，似乎有些释然，文章上说“你所急的事，一定是最不需要快速解决的，你所不在乎的事，恰恰需要你马上行动。”起初看到这句话，没办法理解，可是接下来的一句话却让我如梦初醒，“因为一粒种子，就是要慢慢成熟，谁也决定不了它成长的速度，而你手里的苹果，耽搁了时间，就不再好吃了，还原世界本来的面目，一切慢慢来”。</p>\n<p>现在的爱情也是，急的不行，男人们遇见姑娘急着上床，姑娘们遇见男人，急着迅速掀底，到底值不值得交往，即便是交往了，也急着结婚，父母催，亲戚催，结婚了，马上要了孩子，孩子出来了，马上急着别落在起跑线上，各种补习班，上了小学，急着中学，上了高中，急着大学，上了大学，又急工作，循环往复，周而复始，人们早都忘了事物的本来面目。</p>\n<p>爱情就该慢慢来，在我刚刚遇见你的时候，你也刚好爱上我，就在一起吧，想厮守一辈子了，管它嫁妆房子，有你就好，结婚生子，顺其自然，孩子有它的童年，就像我们有过的童年一样，事情本来就该慢慢来，可是现在的时代，都提前了，屁股上都着火了，可是谁都找不到灭火器。</p>\n<p><strong>亲爱的，你慢慢飞</strong></p>\n<p>中国的改革开放太快了，快的让民众来不及反映，地图上圈里的城市，深圳， 上海 ，发了。所有的中国人都开始急了，急下海，急炒股。</p>\n<p>中国用火箭的速度在发展着，却忽略了一批又一批的善良的人们，那些点燃火箭升空的人，早已消失在火箭腾空时，激起的尘土中了。</p>\n<p>所有的速度都让民众目不暇接，所有的变化让孩子们甚至找不到家的方向，那些迎着朝阳出门的人，背着月光回家的时候，可能看到的只是废墟，因为这一切都来不急让你等待，因为，高楼大厦崛起的速度，一定快过你回家的速度。</p>\n<p>每当下班的时候站在天桥上，或是地铁里，看着低头行走的年轻人，每个人的脸上都是一种表情，麻木，平淡，疲惫，又无奈，我想上前拽住每个人，告诉他们，慢慢飞，可是，我办不到，我不是精神病人，我只是旁观者，看着人群在我身边走过，而我也只能跟随人群的脚步，因为慢了，我赶不上回家的最后一班车。</p>\n<p><strong>你猜，我是走，还是跑？</strong></p>\n<p>很多事情，很多人，都已不是原来的样子，朋友说，计划永远没有变化快，我说，那是你的钱没的太快，在这个时代，好人和坏人，没办法区分，就像“狼”和“哈士奇”也没办法区分一样，只是希望，“狼别生气，人把你当狗，也愿狗别高兴，人心虚了，才把你当狼”。</p>\n<p>现在的人太容易孤独，彷徨，烦躁，急迫，其实，你之所以感到孤独，并不是没有人关心你，而是你在乎的那个人没有关心你。</p>\n<p>很多刚毕业的学生，都急着奔向远方，认为他的理想都在远方，而有的同学，却慢慢的回家，想想自己到底要做什么，该做什么，三年后，当年去找理想的人，把自己也丢了，当年慢慢的人，做了老板，开了个小店，娶了媳妇，生了孩子，虽然他可能没吃过太多次的肯德基，没去过太多次的咖啡厅，也没有带着媳妇去吃必胜客，可是，谁能说他走的慢了？</p>\n<p>有的时候，走，真的比跑快，因为走着，不会错过风景，知道目标；而跑的人，会落下太多的人，最后孤独一人，因为你跑的太快，别人跟不上。</p>\n<p><strong>安静，我们都该休息了</strong></p>\n<p>一个人，一辈子最重要的事，其实就是选对身边的人，炊烟起了，我在门口等你。夕阳下了，我在山边等你。叶子黄了，我在树下等你。月儿弯了，我在十五等你。细雨来了，我在伞下等你。流水冻了，我在河畔等你。生命累了，我在天堂等你。我们老了，我在来生等你。</p>\n<p>我们都累了，是时候慢慢的停下来，放慢脚步，好好的看一本书，好好的听听爱你的人，要对你说的话，看看我们在急着往前走的时候，落下了什么东西，到底是朋友，还是父母，还是你最珍贵的爱情。。。</p>\n<p>这个时代，无论多快，我们总该找到自己的节奏——试着寻找一个“灭火器”，把身后的“火”灭了吧。</p>\n","excerpt":"","more":"<p>我读后感觉写得很好，所以记录下来分享给大家，希望有所感悟，能对你起到一定的帮助！</p>\n<p>我所看到的人，都在急，特别的急！急着要男朋友，急着要女朋友，女朋友着急要房子，要车子，想旅游，又想享受生活，想安逸，男朋友又得拼命工作，阅历不深却又着急看透世界，甚至于连一篇文章都没有时间读完，告诉我，你们究竟急的是什么？</p>\n<p><strong>别着急，慢慢来</strong></p>\n<p>我不知道这代人怎么想的，我并不认同八零后和七零后还有六零后的区别，现在的八零后当务之急便是房子了，还有那可怜的爱情，这在七零后和六零后的时候，是根本不需要操心的，你说，这社会是进步了？还是退步了？我也是个八零后，同样想着各种各样的事，同样急着这社会上大多数人急的事。</p>\n<p>看了一篇文章，似乎有些释然，文章上说“你所急的事，一定是最不需要快速解决的，你所不在乎的事，恰恰需要你马上行动。”起初看到这句话，没办法理解，可是接下来的一句话却让我如梦初醒，“因为一粒种子，就是要慢慢成熟，谁也决定不了它成长的速度，而你手里的苹果，耽搁了时间，就不再好吃了，还原世界本来的面目，一切慢慢来”。</p>\n<p>现在的爱情也是，急的不行，男人们遇见姑娘急着上床，姑娘们遇见男人，急着迅速掀底，到底值不值得交往，即便是交往了，也急着结婚，父母催，亲戚催，结婚了，马上要了孩子，孩子出来了，马上急着别落在起跑线上，各种补习班，上了小学，急着中学，上了高中，急着大学，上了大学，又急工作，循环往复，周而复始，人们早都忘了事物的本来面目。</p>\n<p>爱情就该慢慢来，在我刚刚遇见你的时候，你也刚好爱上我，就在一起吧，想厮守一辈子了，管它嫁妆房子，有你就好，结婚生子，顺其自然，孩子有它的童年，就像我们有过的童年一样，事情本来就该慢慢来，可是现在的时代，都提前了，屁股上都着火了，可是谁都找不到灭火器。</p>\n<p><strong>亲爱的，你慢慢飞</strong></p>\n<p>中国的改革开放太快了，快的让民众来不及反映，地图上圈里的城市，深圳， 上海 ，发了。所有的中国人都开始急了，急下海，急炒股。</p>\n<p>中国用火箭的速度在发展着，却忽略了一批又一批的善良的人们，那些点燃火箭升空的人，早已消失在火箭腾空时，激起的尘土中了。</p>\n<p>所有的速度都让民众目不暇接，所有的变化让孩子们甚至找不到家的方向，那些迎着朝阳出门的人，背着月光回家的时候，可能看到的只是废墟，因为这一切都来不急让你等待，因为，高楼大厦崛起的速度，一定快过你回家的速度。</p>\n<p>每当下班的时候站在天桥上，或是地铁里，看着低头行走的年轻人，每个人的脸上都是一种表情，麻木，平淡，疲惫，又无奈，我想上前拽住每个人，告诉他们，慢慢飞，可是，我办不到，我不是精神病人，我只是旁观者，看着人群在我身边走过，而我也只能跟随人群的脚步，因为慢了，我赶不上回家的最后一班车。</p>\n<p><strong>你猜，我是走，还是跑？</strong></p>\n<p>很多事情，很多人，都已不是原来的样子，朋友说，计划永远没有变化快，我说，那是你的钱没的太快，在这个时代，好人和坏人，没办法区分，就像“狼”和“哈士奇”也没办法区分一样，只是希望，“狼别生气，人把你当狗，也愿狗别高兴，人心虚了，才把你当狼”。</p>\n<p>现在的人太容易孤独，彷徨，烦躁，急迫，其实，你之所以感到孤独，并不是没有人关心你，而是你在乎的那个人没有关心你。</p>\n<p>很多刚毕业的学生，都急着奔向远方，认为他的理想都在远方，而有的同学，却慢慢的回家，想想自己到底要做什么，该做什么，三年后，当年去找理想的人，把自己也丢了，当年慢慢的人，做了老板，开了个小店，娶了媳妇，生了孩子，虽然他可能没吃过太多次的肯德基，没去过太多次的咖啡厅，也没有带着媳妇去吃必胜客，可是，谁能说他走的慢了？</p>\n<p>有的时候，走，真的比跑快，因为走着，不会错过风景，知道目标；而跑的人，会落下太多的人，最后孤独一人，因为你跑的太快，别人跟不上。</p>\n<p><strong>安静，我们都该休息了</strong></p>\n<p>一个人，一辈子最重要的事，其实就是选对身边的人，炊烟起了，我在门口等你。夕阳下了，我在山边等你。叶子黄了，我在树下等你。月儿弯了，我在十五等你。细雨来了，我在伞下等你。流水冻了，我在河畔等你。生命累了，我在天堂等你。我们老了，我在来生等你。</p>\n<p>我们都累了，是时候慢慢的停下来，放慢脚步，好好的看一本书，好好的听听爱你的人，要对你说的话，看看我们在急着往前走的时候，落下了什么东西，到底是朋友，还是父母，还是你最珍贵的爱情。。。</p>\n<p>这个时代，无论多快，我们总该找到自己的节奏——试着寻找一个“灭火器”，把身后的“火”灭了吧。</p>\n"},{"title":"雾霾引起的思考","date":"2016-12-22T15:49:22.000Z","_content":"   2016年12月19日到21号，全国的雾霾都比较严重，当然很多地方都限行了，北京的学校都放假了，其余地方的学校据有所知没有放假了，不得不感叹北京的孩子是祖国的花朵，其他地方的孩子是吸毒的绿萝卜。\n   \n   一向不爱戴口罩的我当然这几天也没有戴口罩，一是因为戴口罩太憋屈，感觉有点上不来气。二是我一直以来感觉戴口罩的那些人比较矫情。听一个做环境的朋友说，其余带这玩意也不管用，你该吸的还是能吸进去，你对这件事有什么看法？我一向向在雾霾里不带口罩而且不吸烟的大哥大姐们看齐，我跟他们一比，感觉我好多了，最起码我不抽烟啊。21号晚上，我擦鼻子的时候，一看卫生纸上都是灰，这时我才意识到问题的严重性，我擦嘞。。。。此时我才意识到自己之前的想法太二比了。\n    \n   雾霾为什么来呢？难道是汽车尾气太多了，不应该啊，大家开的车都是合格的，排放的尾气也合格，燃烧的机油也合格，从某种意义上这种解释有点说不过去。后来我看了一篇文章，觉得挺有道理。主要是因为中国近几年的发展速度太快了，现在中国也是第二经济强国，国家大力号召发展经济，几乎很少听见过治理下环境，有也是当环境已经被污染了，才开始治理，在环境污染没有这么草蛋之前，反正我没听到过。当然我不是批评党，说国家怎么怎么样，那样就扯远了，在另一个角度上说我也没有资格。\n    \n   一切事情有好就有坏，应该能用佛教的因果报应来解释这个问题，中国大力发展经济，环境要是再好，你让世界人民怎么看，怎么能让世界人民感觉到上天是公平的。所有呢，我们今天享受的美好生活都是建立在破坏环境之上的，这一切都是中国人自己走出来的路，所以我们应该承担，不能抱怨。一方面想着享受高科技便捷的生活，一方面又好活在蓝蓝的天空下，用网络语来说就是你怎么不上天呢？\n    \n   我们享受着现在的一切都是科技带来的进步，随之而来让我们蛋疼的是环境。既然环境已经这样了，再怎么抱怨它也是这样了，抱怨半毛线用也没有，有抱怨的这功夫你还不如少造点白色污染了，你也算是为国家环境做了点贡献，总之比在那嘴炮强多了。如果你不想吸雾霾，你就去三亚啊，你就移民啊，有人会说我没钱啊，你没钱你还有空抱怨啊，还不敢紧搬砖挣钱去，总比你抱怨有意义多了。这个世界上我没有看到绝对的好事，也没看到绝对的坏事，有人会说了，懒肯定是坏事啊，其实不是啊，懒可以让你变胖啊，让你在风中吹不跑啊。。。。。哈哈哈哈哈哈。。\n    \n   下面说说抱怨，之前我也是一个很爱抱怨的人，吃着锅里的，看着碗里的，出了问题不是愿这就愿那，好像没有真正找过自身的原因，这一点是一个非常致命的错误，抱怨只会让你变得更加消极。要想改正自身的缺点首先要认识到自己的缺点，一个连缺点都不敢承认的人我认为是最可怜的。如果一个人想要成长，就要接受别人的批评，在批评中吸取教训，找到不足，这样才能遇到更好的自己。所以我一般很喜欢别人指出自己的不足，骂我二比，因为我确实做的不好，骂你是为了让你找到更好的自己。相反那些在职场中天天笑呵呵说你好的人，他说你好你就真的那么好么，有时候只不过是出于讨你喜欢。说出的好听的话正好对接了你心里的虚伪，你想想你会成长么？\n   \n   有人会说了你说实话容易伤人，说话不能太耿直，说话太耿直的人情商低，反正我不是这么认为的，我认为这跟情商没半毛线关系。如果在商务场合，说话还是拐弯抹角地好些，说话委婉些也比较得体，因为那是出于尊重。在平时的交往中如果没有长辈，就实话实说比什么不强，如果真是自己的原因你应该感恩提出你缺点的人，而不是憎恨。只有你意识到自己的缺点，你才有机会去改正。在此之前，你要明白一个道理：别人说你SB你就sb了？说你好你就好了？\n 其实有时候你骂别人SB的时候，说实话你还不如一个SB了。有些时候互骂纯属争个面子罢了。\n \n   什么叫敢于正式自己的缺点？前一段林丹出轨了，看见很多喷子都骂。。。我认为在骂的人当中百分之90以上的人都很无聊，自己那点事还没整明白了哪有空管人家。站在人性的角度上，我其实挺羡慕林丹的，当然不是羡慕他出轨，不是号召学习他这种精神，我羡慕人家牛比，人家有本事接触到嫩模，很多男人估计面对那样的诱惑时，10个里得有9.5个都会像林丹那样，反正我没那么高尚，不知道你会怎样？估计喷子们接触不到只能在这喷了，只能用显得自己高尚的精神来证明我比林丹牛比，我是一个好男人！现实生活中好多消极的人也是如此，当别人犯了一个错误的时候就很喷，你不过就是想来证明我比他做地好而已，其实呢？林丹最后道歉了没有离婚，虽然跟我没关系但是我心喜挺高兴的，因为他能有一个睿智的妻子。真的，在这个草蛋的社会里，你必须有一个坚强的心，别人说你丑没关系，我丑碍你屁事了，吃你家的了还是喝你家的了？说你丑的人不一定是坏人，那才是真心对你好的人，不像一些人当面说你漂亮死了，背后。。。。这两种人你更喜欢哪一种？有些人愿意沉浸在被很多人喜欢的虚荣里，其实是因为缺乏安全感。\n    \n   写到最后，发现严重跑题了。。。。。。来，喷我啊，来，互相伤害啊\n    ","source":"_posts/wumai.md","raw":"---\ntitle: 雾霾引起的思考\ndate: 2016-12-22 23:49:22\ntags: 生活\n---\n   2016年12月19日到21号，全国的雾霾都比较严重，当然很多地方都限行了，北京的学校都放假了，其余地方的学校据有所知没有放假了，不得不感叹北京的孩子是祖国的花朵，其他地方的孩子是吸毒的绿萝卜。\n   \n   一向不爱戴口罩的我当然这几天也没有戴口罩，一是因为戴口罩太憋屈，感觉有点上不来气。二是我一直以来感觉戴口罩的那些人比较矫情。听一个做环境的朋友说，其余带这玩意也不管用，你该吸的还是能吸进去，你对这件事有什么看法？我一向向在雾霾里不带口罩而且不吸烟的大哥大姐们看齐，我跟他们一比，感觉我好多了，最起码我不抽烟啊。21号晚上，我擦鼻子的时候，一看卫生纸上都是灰，这时我才意识到问题的严重性，我擦嘞。。。。此时我才意识到自己之前的想法太二比了。\n    \n   雾霾为什么来呢？难道是汽车尾气太多了，不应该啊，大家开的车都是合格的，排放的尾气也合格，燃烧的机油也合格，从某种意义上这种解释有点说不过去。后来我看了一篇文章，觉得挺有道理。主要是因为中国近几年的发展速度太快了，现在中国也是第二经济强国，国家大力号召发展经济，几乎很少听见过治理下环境，有也是当环境已经被污染了，才开始治理，在环境污染没有这么草蛋之前，反正我没听到过。当然我不是批评党，说国家怎么怎么样，那样就扯远了，在另一个角度上说我也没有资格。\n    \n   一切事情有好就有坏，应该能用佛教的因果报应来解释这个问题，中国大力发展经济，环境要是再好，你让世界人民怎么看，怎么能让世界人民感觉到上天是公平的。所有呢，我们今天享受的美好生活都是建立在破坏环境之上的，这一切都是中国人自己走出来的路，所以我们应该承担，不能抱怨。一方面想着享受高科技便捷的生活，一方面又好活在蓝蓝的天空下，用网络语来说就是你怎么不上天呢？\n    \n   我们享受着现在的一切都是科技带来的进步，随之而来让我们蛋疼的是环境。既然环境已经这样了，再怎么抱怨它也是这样了，抱怨半毛线用也没有，有抱怨的这功夫你还不如少造点白色污染了，你也算是为国家环境做了点贡献，总之比在那嘴炮强多了。如果你不想吸雾霾，你就去三亚啊，你就移民啊，有人会说我没钱啊，你没钱你还有空抱怨啊，还不敢紧搬砖挣钱去，总比你抱怨有意义多了。这个世界上我没有看到绝对的好事，也没看到绝对的坏事，有人会说了，懒肯定是坏事啊，其实不是啊，懒可以让你变胖啊，让你在风中吹不跑啊。。。。。哈哈哈哈哈哈。。\n    \n   下面说说抱怨，之前我也是一个很爱抱怨的人，吃着锅里的，看着碗里的，出了问题不是愿这就愿那，好像没有真正找过自身的原因，这一点是一个非常致命的错误，抱怨只会让你变得更加消极。要想改正自身的缺点首先要认识到自己的缺点，一个连缺点都不敢承认的人我认为是最可怜的。如果一个人想要成长，就要接受别人的批评，在批评中吸取教训，找到不足，这样才能遇到更好的自己。所以我一般很喜欢别人指出自己的不足，骂我二比，因为我确实做的不好，骂你是为了让你找到更好的自己。相反那些在职场中天天笑呵呵说你好的人，他说你好你就真的那么好么，有时候只不过是出于讨你喜欢。说出的好听的话正好对接了你心里的虚伪，你想想你会成长么？\n   \n   有人会说了你说实话容易伤人，说话不能太耿直，说话太耿直的人情商低，反正我不是这么认为的，我认为这跟情商没半毛线关系。如果在商务场合，说话还是拐弯抹角地好些，说话委婉些也比较得体，因为那是出于尊重。在平时的交往中如果没有长辈，就实话实说比什么不强，如果真是自己的原因你应该感恩提出你缺点的人，而不是憎恨。只有你意识到自己的缺点，你才有机会去改正。在此之前，你要明白一个道理：别人说你SB你就sb了？说你好你就好了？\n 其实有时候你骂别人SB的时候，说实话你还不如一个SB了。有些时候互骂纯属争个面子罢了。\n \n   什么叫敢于正式自己的缺点？前一段林丹出轨了，看见很多喷子都骂。。。我认为在骂的人当中百分之90以上的人都很无聊，自己那点事还没整明白了哪有空管人家。站在人性的角度上，我其实挺羡慕林丹的，当然不是羡慕他出轨，不是号召学习他这种精神，我羡慕人家牛比，人家有本事接触到嫩模，很多男人估计面对那样的诱惑时，10个里得有9.5个都会像林丹那样，反正我没那么高尚，不知道你会怎样？估计喷子们接触不到只能在这喷了，只能用显得自己高尚的精神来证明我比林丹牛比，我是一个好男人！现实生活中好多消极的人也是如此，当别人犯了一个错误的时候就很喷，你不过就是想来证明我比他做地好而已，其实呢？林丹最后道歉了没有离婚，虽然跟我没关系但是我心喜挺高兴的，因为他能有一个睿智的妻子。真的，在这个草蛋的社会里，你必须有一个坚强的心，别人说你丑没关系，我丑碍你屁事了，吃你家的了还是喝你家的了？说你丑的人不一定是坏人，那才是真心对你好的人，不像一些人当面说你漂亮死了，背后。。。。这两种人你更喜欢哪一种？有些人愿意沉浸在被很多人喜欢的虚荣里，其实是因为缺乏安全感。\n    \n   写到最后，发现严重跑题了。。。。。。来，喷我啊，来，互相伤害啊\n    ","slug":"wumai","published":1,"updated":"2016-12-23T01:48:45.061Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixrcdva9003tjgtu1e2oy1g9","content":"<p>   2016年12月19日到21号，全国的雾霾都比较严重，当然很多地方都限行了，北京的学校都放假了，其余地方的学校据有所知没有放假了，不得不感叹北京的孩子是祖国的花朵，其他地方的孩子是吸毒的绿萝卜。</p>\n<p>   一向不爱戴口罩的我当然这几天也没有戴口罩，一是因为戴口罩太憋屈，感觉有点上不来气。二是我一直以来感觉戴口罩的那些人比较矫情。听一个做环境的朋友说，其余带这玩意也不管用，你该吸的还是能吸进去，你对这件事有什么看法？我一向向在雾霾里不带口罩而且不吸烟的大哥大姐们看齐，我跟他们一比，感觉我好多了，最起码我不抽烟啊。21号晚上，我擦鼻子的时候，一看卫生纸上都是灰，这时我才意识到问题的严重性，我擦嘞。。。。此时我才意识到自己之前的想法太二比了。</p>\n<p>   雾霾为什么来呢？难道是汽车尾气太多了，不应该啊，大家开的车都是合格的，排放的尾气也合格，燃烧的机油也合格，从某种意义上这种解释有点说不过去。后来我看了一篇文章，觉得挺有道理。主要是因为中国近几年的发展速度太快了，现在中国也是第二经济强国，国家大力号召发展经济，几乎很少听见过治理下环境，有也是当环境已经被污染了，才开始治理，在环境污染没有这么草蛋之前，反正我没听到过。当然我不是批评党，说国家怎么怎么样，那样就扯远了，在另一个角度上说我也没有资格。</p>\n<p>   一切事情有好就有坏，应该能用佛教的因果报应来解释这个问题，中国大力发展经济，环境要是再好，你让世界人民怎么看，怎么能让世界人民感觉到上天是公平的。所有呢，我们今天享受的美好生活都是建立在破坏环境之上的，这一切都是中国人自己走出来的路，所以我们应该承担，不能抱怨。一方面想着享受高科技便捷的生活，一方面又好活在蓝蓝的天空下，用网络语来说就是你怎么不上天呢？</p>\n<p>   我们享受着现在的一切都是科技带来的进步，随之而来让我们蛋疼的是环境。既然环境已经这样了，再怎么抱怨它也是这样了，抱怨半毛线用也没有，有抱怨的这功夫你还不如少造点白色污染了，你也算是为国家环境做了点贡献，总之比在那嘴炮强多了。如果你不想吸雾霾，你就去三亚啊，你就移民啊，有人会说我没钱啊，你没钱你还有空抱怨啊，还不敢紧搬砖挣钱去，总比你抱怨有意义多了。这个世界上我没有看到绝对的好事，也没看到绝对的坏事，有人会说了，懒肯定是坏事啊，其实不是啊，懒可以让你变胖啊，让你在风中吹不跑啊。。。。。哈哈哈哈哈哈。。</p>\n<p>   下面说说抱怨，之前我也是一个很爱抱怨的人，吃着锅里的，看着碗里的，出了问题不是愿这就愿那，好像没有真正找过自身的原因，这一点是一个非常致命的错误，抱怨只会让你变得更加消极。要想改正自身的缺点首先要认识到自己的缺点，一个连缺点都不敢承认的人我认为是最可怜的。如果一个人想要成长，就要接受别人的批评，在批评中吸取教训，找到不足，这样才能遇到更好的自己。所以我一般很喜欢别人指出自己的不足，骂我二比，因为我确实做的不好，骂你是为了让你找到更好的自己。相反那些在职场中天天笑呵呵说你好的人，他说你好你就真的那么好么，有时候只不过是出于讨你喜欢。说出的好听的话正好对接了你心里的虚伪，你想想你会成长么？</p>\n<p>   有人会说了你说实话容易伤人，说话不能太耿直，说话太耿直的人情商低，反正我不是这么认为的，我认为这跟情商没半毛线关系。如果在商务场合，说话还是拐弯抹角地好些，说话委婉些也比较得体，因为那是出于尊重。在平时的交往中如果没有长辈，就实话实说比什么不强，如果真是自己的原因你应该感恩提出你缺点的人，而不是憎恨。只有你意识到自己的缺点，你才有机会去改正。在此之前，你要明白一个道理：别人说你SB你就sb了？说你好你就好了？<br> 其实有时候你骂别人SB的时候，说实话你还不如一个SB了。有些时候互骂纯属争个面子罢了。</p>\n<p>   什么叫敢于正式自己的缺点？前一段林丹出轨了，看见很多喷子都骂。。。我认为在骂的人当中百分之90以上的人都很无聊，自己那点事还没整明白了哪有空管人家。站在人性的角度上，我其实挺羡慕林丹的，当然不是羡慕他出轨，不是号召学习他这种精神，我羡慕人家牛比，人家有本事接触到嫩模，很多男人估计面对那样的诱惑时，10个里得有9.5个都会像林丹那样，反正我没那么高尚，不知道你会怎样？估计喷子们接触不到只能在这喷了，只能用显得自己高尚的精神来证明我比林丹牛比，我是一个好男人！现实生活中好多消极的人也是如此，当别人犯了一个错误的时候就很喷，你不过就是想来证明我比他做地好而已，其实呢？林丹最后道歉了没有离婚，虽然跟我没关系但是我心喜挺高兴的，因为他能有一个睿智的妻子。真的，在这个草蛋的社会里，你必须有一个坚强的心，别人说你丑没关系，我丑碍你屁事了，吃你家的了还是喝你家的了？说你丑的人不一定是坏人，那才是真心对你好的人，不像一些人当面说你漂亮死了，背后。。。。这两种人你更喜欢哪一种？有些人愿意沉浸在被很多人喜欢的虚荣里，其实是因为缺乏安全感。</p>\n<p>   写到最后，发现严重跑题了。。。。。。来，喷我啊，来，互相伤害啊</p>\n","excerpt":"","more":"<p>   2016年12月19日到21号，全国的雾霾都比较严重，当然很多地方都限行了，北京的学校都放假了，其余地方的学校据有所知没有放假了，不得不感叹北京的孩子是祖国的花朵，其他地方的孩子是吸毒的绿萝卜。</p>\n<p>   一向不爱戴口罩的我当然这几天也没有戴口罩，一是因为戴口罩太憋屈，感觉有点上不来气。二是我一直以来感觉戴口罩的那些人比较矫情。听一个做环境的朋友说，其余带这玩意也不管用，你该吸的还是能吸进去，你对这件事有什么看法？我一向向在雾霾里不带口罩而且不吸烟的大哥大姐们看齐，我跟他们一比，感觉我好多了，最起码我不抽烟啊。21号晚上，我擦鼻子的时候，一看卫生纸上都是灰，这时我才意识到问题的严重性，我擦嘞。。。。此时我才意识到自己之前的想法太二比了。</p>\n<p>   雾霾为什么来呢？难道是汽车尾气太多了，不应该啊，大家开的车都是合格的，排放的尾气也合格，燃烧的机油也合格，从某种意义上这种解释有点说不过去。后来我看了一篇文章，觉得挺有道理。主要是因为中国近几年的发展速度太快了，现在中国也是第二经济强国，国家大力号召发展经济，几乎很少听见过治理下环境，有也是当环境已经被污染了，才开始治理，在环境污染没有这么草蛋之前，反正我没听到过。当然我不是批评党，说国家怎么怎么样，那样就扯远了，在另一个角度上说我也没有资格。</p>\n<p>   一切事情有好就有坏，应该能用佛教的因果报应来解释这个问题，中国大力发展经济，环境要是再好，你让世界人民怎么看，怎么能让世界人民感觉到上天是公平的。所有呢，我们今天享受的美好生活都是建立在破坏环境之上的，这一切都是中国人自己走出来的路，所以我们应该承担，不能抱怨。一方面想着享受高科技便捷的生活，一方面又好活在蓝蓝的天空下，用网络语来说就是你怎么不上天呢？</p>\n<p>   我们享受着现在的一切都是科技带来的进步，随之而来让我们蛋疼的是环境。既然环境已经这样了，再怎么抱怨它也是这样了，抱怨半毛线用也没有，有抱怨的这功夫你还不如少造点白色污染了，你也算是为国家环境做了点贡献，总之比在那嘴炮强多了。如果你不想吸雾霾，你就去三亚啊，你就移民啊，有人会说我没钱啊，你没钱你还有空抱怨啊，还不敢紧搬砖挣钱去，总比你抱怨有意义多了。这个世界上我没有看到绝对的好事，也没看到绝对的坏事，有人会说了，懒肯定是坏事啊，其实不是啊，懒可以让你变胖啊，让你在风中吹不跑啊。。。。。哈哈哈哈哈哈。。</p>\n<p>   下面说说抱怨，之前我也是一个很爱抱怨的人，吃着锅里的，看着碗里的，出了问题不是愿这就愿那，好像没有真正找过自身的原因，这一点是一个非常致命的错误，抱怨只会让你变得更加消极。要想改正自身的缺点首先要认识到自己的缺点，一个连缺点都不敢承认的人我认为是最可怜的。如果一个人想要成长，就要接受别人的批评，在批评中吸取教训，找到不足，这样才能遇到更好的自己。所以我一般很喜欢别人指出自己的不足，骂我二比，因为我确实做的不好，骂你是为了让你找到更好的自己。相反那些在职场中天天笑呵呵说你好的人，他说你好你就真的那么好么，有时候只不过是出于讨你喜欢。说出的好听的话正好对接了你心里的虚伪，你想想你会成长么？</p>\n<p>   有人会说了你说实话容易伤人，说话不能太耿直，说话太耿直的人情商低，反正我不是这么认为的，我认为这跟情商没半毛线关系。如果在商务场合，说话还是拐弯抹角地好些，说话委婉些也比较得体，因为那是出于尊重。在平时的交往中如果没有长辈，就实话实说比什么不强，如果真是自己的原因你应该感恩提出你缺点的人，而不是憎恨。只有你意识到自己的缺点，你才有机会去改正。在此之前，你要明白一个道理：别人说你SB你就sb了？说你好你就好了？<br> 其实有时候你骂别人SB的时候，说实话你还不如一个SB了。有些时候互骂纯属争个面子罢了。</p>\n<p>   什么叫敢于正式自己的缺点？前一段林丹出轨了，看见很多喷子都骂。。。我认为在骂的人当中百分之90以上的人都很无聊，自己那点事还没整明白了哪有空管人家。站在人性的角度上，我其实挺羡慕林丹的，当然不是羡慕他出轨，不是号召学习他这种精神，我羡慕人家牛比，人家有本事接触到嫩模，很多男人估计面对那样的诱惑时，10个里得有9.5个都会像林丹那样，反正我没那么高尚，不知道你会怎样？估计喷子们接触不到只能在这喷了，只能用显得自己高尚的精神来证明我比林丹牛比，我是一个好男人！现实生活中好多消极的人也是如此，当别人犯了一个错误的时候就很喷，你不过就是想来证明我比他做地好而已，其实呢？林丹最后道歉了没有离婚，虽然跟我没关系但是我心喜挺高兴的，因为他能有一个睿智的妻子。真的，在这个草蛋的社会里，你必须有一个坚强的心，别人说你丑没关系，我丑碍你屁事了，吃你家的了还是喝你家的了？说你丑的人不一定是坏人，那才是真心对你好的人，不像一些人当面说你漂亮死了，背后。。。。这两种人你更喜欢哪一种？有些人愿意沉浸在被很多人喜欢的虚荣里，其实是因为缺乏安全感。</p>\n<p>   写到最后，发现严重跑题了。。。。。。来，喷我啊，来，互相伤害啊</p>\n"},{"title":"Lodash的学习笔记-一些常用的API","date":"2017-01-11T05:37:06.000Z","_content":"#### Array\n- _.head/_.last\n```\n_.head([1, 2, 3]);\n// → 1\n\n_.last([1, 2, 3]);\n// → 3\n```\n分别可以抽取数组第一个元素的值和最后一个元素的值。咋看之下觉得很无聊。但是跟下面两个结合起来就厉害。\n\n- _.tail/_.initial\n```\n_.tail([1, 2, 3]); //tail 尾部，尾\n// → [2, 3]   获取数组 array第一个元素除外的所有元素.\n\n_.initial([1, 2, 3]);  //initial  最初的，开始的\n// → [1, 2]  去除数组最后一个元素array.\n```\n结合上面的两个函数就产生很大作用：首先看一个针对数组尾部特殊化处理的例子：\n```\nlet names=['fred', 'barney', 'pebbles'];\n\n_.initial(names).join(', ') +\n(_.size(names) > 1 ? ', & ' : '') + _.last(names);\n\n// → 'fred, barney, & pebbles'\n```\n怎么样比简单的写for+if else优雅很多吧。接着我们来看看递归求和：\n```\nfunction sum(arr){\n return _.head(arr) ? \n ( _.head(arr) + sum( _.tail(arr) ) ) :\n0;\n}\n```\n注：\n1）其实好像数组都可以表现为\n```\n[a, [b, [c .....]]]\n```\n然后再将其扁平化的结果。 是不是？所以结合这四个函数，很多数组遍历的操作都可以改写成递归的方式。虽然性能可能略差，但是可读性反而更强了(并非所有的递归都一定损耗性能，详细可以去了解下JIT优化)。\n\n2）但是在ES6中，更推荐优先使用数组的解构。\n- _.zip\n```\n_.zip(['fred', 'barney'], [30, 40]);\n// → [['fred', 30], ['barney', 40]]\n```\n_.zip(*array) 将几个数组按照位置组成新的数组，返回数组列表。此方法对重组数据结构非常有帮助。\n\n- _.unzip\n既然lodash是个函数库，那有zip肯定也有他的逆运算unzip。unzip其实可以看作对ES6数组解构的补充，应用的场景也是十分相似的。\n```\nvar zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);\n// => [['fred', 30, true], ['barney', 40, false]]\n\n_.unzip(zipped);\n// => [['fred', 'barney'], [30, 40], [true, false]]\n```\n- _.without\n```\n_.without([1, 2, 1, 3], 1, 2);\n// => [3]\n```\n#### Collection\n- _.map/_.reduce/_.filter\n这三个函数其实早就名声在外，遍历集合可不仅仅只有_.each。任何时候都优先考虑这些函数。\n```\nfunction timesThree(n) {\n  return n * 3;\n}\n\n_.map([1, 2], timesThree);\n// => [3, 6]\n\n_.map({ 'a': 1, 'b': 2 }, timesThree);\n// => [3, 6] (iteration order is not guaranteed)译：迭代顺序不保证\n\nvar users = [\n  { 'user': 'barney' },\n  { 'user': 'fred' }\n];\n\n// using the `_.property` callback shorthand\n_.map(users, 'user');\n// => ['barney', 'fred']\n```\n```\n_.reduce([1, 2], function(total, n) {\n  return total + n;\n});\n// => 3\n\n_.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {\n  result[key] = n * 3;\n  return result;\n}, {});\n// => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)\n```\n```\n_.filter([4, 5, 6], function(n) {\n  return n % 2 == 0;\n});\n// => [4, 6]\n\nvar users = [\n  { 'user': 'barney', 'age': 36, 'active': true },\n  { 'user': 'fred',   'age': 40, 'active': false }\n];\n\n// using the `_.matches` callback shorthand\n_.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');\n// => ['barney']\n\n// using the `_.matchesProperty` callback shorthand\n_.pluck(_.filter(users, 'active', false), 'user');\n// => ['fred']\n\n// using the `_.property` callback shorthand\n_.pluck(_.filter(users, 'active'), 'user');\n// => ['barney']\n```\n- _.every/_.some\n```\nlet users = [\n { 'user': 'barney', 'active': true },\n { 'user': 'fred', 'active': false }\n];\n\n_.every(users, { 'user': 'barney', 'active': false });\n// → false\n\n_.some(users, ['active', false]);\n// → true\n\n其实作用相当于：\n_.every => && \n_.some => ||\n```\n#### Function\n- _.curry\n是函数柯里化的函数。\n```\nlet abc = function(a, b, c) {\n return [a, b, c];\n};\n\nlet curried = _.curry(abc);\n\ncurried(1)(2)(3);\n// → [1, 2, 3]\n\ncurried(1, 2)(3);\n// → [1, 2, 3]\n\ncurried(1, 2, 3);\n// → [1, 2, 3]\n\n// Curried with placeholders.\ncurried(1)(_, 3)(2);\n// → [1, 2, 3]\n```\n柯里化有3个常见作用：1. 参数复用；2. 构建高阶函数；3. 延迟计算。 参数复用的例子：\n```\nlet parse = function(data, config){\n    xxxx\n return xxxx;\n};\n\nlet config = {};\nlet parseByConfig = _.curryRight(parse)(config);\n```\n如代码所示，这是一个数据解析函数，通过某些配置按照一定的规则去解析数据。如果在某个场景下参数配置都一样。那可以用柯里化先引入一个参数。然后再接收不同的数据。这样就不用在每次调用时都引入同样的config参数。\n\n- _.curryRight\n```\nvar abc = function(a, b, c) {\n  return [a, b, c];\n};\n\nvar curried = _.curryRight(abc);\n\ncurried(3)(2)(1);\n// => [1, 2, 3]\n\ncurried(2, 3)(1);\n// => [1, 2, 3]\n\ncurried(1, 2, 3);\n// => [1, 2, 3]\n\n// using placeholders\ncurried(3)(1, _)(2);\n// => [1, 2, 3]\n```\n- _.partial\n便于理解可以叫它部分函数，还是先看例子。\n```\nlet greet = function(greeting, name) {\n return greeting + ' ' + name;\n};\n\nlet sayHelloTo = _.partial(greet, 'hello');\nsayHelloTo('fred');\n// → 'hello fred'\n\n// Partially applied with placeholders.\nlet greetFred = _.partial(greet, _, 'fred');\ngreetFred('hi');\n// → 'hi fred'\nlet greet = function(greeting, name) {\n return greeting + ' ' + name;\n};\n\nlet sayHelloTo = _.partial(greet, 'hello');\nsayHelloTo('fred');\n// → 'hello fred'\n\n// Partially applied with placeholders.\nlet greetFred = _.partial(greet, _, 'fred');\ngreetFred('hi');\n// → 'hi fred'\n```\n好像跟柯里化很像。是的，它其实就是柯里化的具体应用——构建高阶函数。_.curry会把一个函数转化成可以柯里化函数，而当这个柯里化函数接受了一定的参数后，它就变成了一个部分应用函数了。\n\n- _.flow\n```\nfunction square(n) {\n  return n * n;\n}\n\nvar addSquare = _.flow(_.add, square);\naddSquare(1, 2);\n// => 9\n```\n这是用来组合高阶函数的一个方法。如果用数学的角度去思考的话，就有点像, 把函数 f(), g(), 和h() 组合起来可以得到复合函数 f( g( h() ) )。\n\n- _.flowRight\n```\nfunction square(n) {\n  return n * n;\n}\n\nvar addSquare = _.flowRight(square, _.add);\naddSquare(1, 2);\n// => 9\n```\n\n#### Chain\n- _.chain\n```\n$('div').css('color','red')\n .on('click', function(){})\n.fadeIn();\n```\n作为一个合格的前端攻城狮，你对这个一定不陌生。它一定给你带来过很多美好的记忆。那我们如何让这样一段优雅的代码应用到非DOM对象上呢。用_.chain就行了。\n```\n_.head(\n_.map(\n _.sortBy('users', 'age'),\n function(o) {\n return `${o.user} is ${o.age}`;\n}\n)\n)\n\n_.chain(users)\n.sortBy('age')\n .map(function(o) {\n return o.user + ' is ' + o.age;\n})\n.head()\n.value();\n```\n两段代码在做一样的事情。你更喜欢哪个呢。不过要注意_.chain最后的value。因为_.chain用一个容器包装了你的对象，最后需要通过value返回出真正的值。如果不能理解，联想一下下面这段代码：\n```\n$('div')[0].classList\n```\n用jQuery选择器筛选到的是jQuery对象，而如果要调用真正的DOM对象的属性的话，还要用索引去调用它。\n\n","source":"_posts/lodash-api.md","raw":"---\ntitle: Lodash的学习笔记-一些常用的API\ndate: 2017-01-11 13:37:06\ntags: Lodash\n---\n#### Array\n- _.head/_.last\n```\n_.head([1, 2, 3]);\n// → 1\n\n_.last([1, 2, 3]);\n// → 3\n```\n分别可以抽取数组第一个元素的值和最后一个元素的值。咋看之下觉得很无聊。但是跟下面两个结合起来就厉害。\n\n- _.tail/_.initial\n```\n_.tail([1, 2, 3]); //tail 尾部，尾\n// → [2, 3]   获取数组 array第一个元素除外的所有元素.\n\n_.initial([1, 2, 3]);  //initial  最初的，开始的\n// → [1, 2]  去除数组最后一个元素array.\n```\n结合上面的两个函数就产生很大作用：首先看一个针对数组尾部特殊化处理的例子：\n```\nlet names=['fred', 'barney', 'pebbles'];\n\n_.initial(names).join(', ') +\n(_.size(names) > 1 ? ', & ' : '') + _.last(names);\n\n// → 'fred, barney, & pebbles'\n```\n怎么样比简单的写for+if else优雅很多吧。接着我们来看看递归求和：\n```\nfunction sum(arr){\n return _.head(arr) ? \n ( _.head(arr) + sum( _.tail(arr) ) ) :\n0;\n}\n```\n注：\n1）其实好像数组都可以表现为\n```\n[a, [b, [c .....]]]\n```\n然后再将其扁平化的结果。 是不是？所以结合这四个函数，很多数组遍历的操作都可以改写成递归的方式。虽然性能可能略差，但是可读性反而更强了(并非所有的递归都一定损耗性能，详细可以去了解下JIT优化)。\n\n2）但是在ES6中，更推荐优先使用数组的解构。\n- _.zip\n```\n_.zip(['fred', 'barney'], [30, 40]);\n// → [['fred', 30], ['barney', 40]]\n```\n_.zip(*array) 将几个数组按照位置组成新的数组，返回数组列表。此方法对重组数据结构非常有帮助。\n\n- _.unzip\n既然lodash是个函数库，那有zip肯定也有他的逆运算unzip。unzip其实可以看作对ES6数组解构的补充，应用的场景也是十分相似的。\n```\nvar zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);\n// => [['fred', 30, true], ['barney', 40, false]]\n\n_.unzip(zipped);\n// => [['fred', 'barney'], [30, 40], [true, false]]\n```\n- _.without\n```\n_.without([1, 2, 1, 3], 1, 2);\n// => [3]\n```\n#### Collection\n- _.map/_.reduce/_.filter\n这三个函数其实早就名声在外，遍历集合可不仅仅只有_.each。任何时候都优先考虑这些函数。\n```\nfunction timesThree(n) {\n  return n * 3;\n}\n\n_.map([1, 2], timesThree);\n// => [3, 6]\n\n_.map({ 'a': 1, 'b': 2 }, timesThree);\n// => [3, 6] (iteration order is not guaranteed)译：迭代顺序不保证\n\nvar users = [\n  { 'user': 'barney' },\n  { 'user': 'fred' }\n];\n\n// using the `_.property` callback shorthand\n_.map(users, 'user');\n// => ['barney', 'fred']\n```\n```\n_.reduce([1, 2], function(total, n) {\n  return total + n;\n});\n// => 3\n\n_.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {\n  result[key] = n * 3;\n  return result;\n}, {});\n// => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)\n```\n```\n_.filter([4, 5, 6], function(n) {\n  return n % 2 == 0;\n});\n// => [4, 6]\n\nvar users = [\n  { 'user': 'barney', 'age': 36, 'active': true },\n  { 'user': 'fred',   'age': 40, 'active': false }\n];\n\n// using the `_.matches` callback shorthand\n_.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');\n// => ['barney']\n\n// using the `_.matchesProperty` callback shorthand\n_.pluck(_.filter(users, 'active', false), 'user');\n// => ['fred']\n\n// using the `_.property` callback shorthand\n_.pluck(_.filter(users, 'active'), 'user');\n// => ['barney']\n```\n- _.every/_.some\n```\nlet users = [\n { 'user': 'barney', 'active': true },\n { 'user': 'fred', 'active': false }\n];\n\n_.every(users, { 'user': 'barney', 'active': false });\n// → false\n\n_.some(users, ['active', false]);\n// → true\n\n其实作用相当于：\n_.every => && \n_.some => ||\n```\n#### Function\n- _.curry\n是函数柯里化的函数。\n```\nlet abc = function(a, b, c) {\n return [a, b, c];\n};\n\nlet curried = _.curry(abc);\n\ncurried(1)(2)(3);\n// → [1, 2, 3]\n\ncurried(1, 2)(3);\n// → [1, 2, 3]\n\ncurried(1, 2, 3);\n// → [1, 2, 3]\n\n// Curried with placeholders.\ncurried(1)(_, 3)(2);\n// → [1, 2, 3]\n```\n柯里化有3个常见作用：1. 参数复用；2. 构建高阶函数；3. 延迟计算。 参数复用的例子：\n```\nlet parse = function(data, config){\n    xxxx\n return xxxx;\n};\n\nlet config = {};\nlet parseByConfig = _.curryRight(parse)(config);\n```\n如代码所示，这是一个数据解析函数，通过某些配置按照一定的规则去解析数据。如果在某个场景下参数配置都一样。那可以用柯里化先引入一个参数。然后再接收不同的数据。这样就不用在每次调用时都引入同样的config参数。\n\n- _.curryRight\n```\nvar abc = function(a, b, c) {\n  return [a, b, c];\n};\n\nvar curried = _.curryRight(abc);\n\ncurried(3)(2)(1);\n// => [1, 2, 3]\n\ncurried(2, 3)(1);\n// => [1, 2, 3]\n\ncurried(1, 2, 3);\n// => [1, 2, 3]\n\n// using placeholders\ncurried(3)(1, _)(2);\n// => [1, 2, 3]\n```\n- _.partial\n便于理解可以叫它部分函数，还是先看例子。\n```\nlet greet = function(greeting, name) {\n return greeting + ' ' + name;\n};\n\nlet sayHelloTo = _.partial(greet, 'hello');\nsayHelloTo('fred');\n// → 'hello fred'\n\n// Partially applied with placeholders.\nlet greetFred = _.partial(greet, _, 'fred');\ngreetFred('hi');\n// → 'hi fred'\nlet greet = function(greeting, name) {\n return greeting + ' ' + name;\n};\n\nlet sayHelloTo = _.partial(greet, 'hello');\nsayHelloTo('fred');\n// → 'hello fred'\n\n// Partially applied with placeholders.\nlet greetFred = _.partial(greet, _, 'fred');\ngreetFred('hi');\n// → 'hi fred'\n```\n好像跟柯里化很像。是的，它其实就是柯里化的具体应用——构建高阶函数。_.curry会把一个函数转化成可以柯里化函数，而当这个柯里化函数接受了一定的参数后，它就变成了一个部分应用函数了。\n\n- _.flow\n```\nfunction square(n) {\n  return n * n;\n}\n\nvar addSquare = _.flow(_.add, square);\naddSquare(1, 2);\n// => 9\n```\n这是用来组合高阶函数的一个方法。如果用数学的角度去思考的话，就有点像, 把函数 f(), g(), 和h() 组合起来可以得到复合函数 f( g( h() ) )。\n\n- _.flowRight\n```\nfunction square(n) {\n  return n * n;\n}\n\nvar addSquare = _.flowRight(square, _.add);\naddSquare(1, 2);\n// => 9\n```\n\n#### Chain\n- _.chain\n```\n$('div').css('color','red')\n .on('click', function(){})\n.fadeIn();\n```\n作为一个合格的前端攻城狮，你对这个一定不陌生。它一定给你带来过很多美好的记忆。那我们如何让这样一段优雅的代码应用到非DOM对象上呢。用_.chain就行了。\n```\n_.head(\n_.map(\n _.sortBy('users', 'age'),\n function(o) {\n return `${o.user} is ${o.age}`;\n}\n)\n)\n\n_.chain(users)\n.sortBy('age')\n .map(function(o) {\n return o.user + ' is ' + o.age;\n})\n.head()\n.value();\n```\n两段代码在做一样的事情。你更喜欢哪个呢。不过要注意_.chain最后的value。因为_.chain用一个容器包装了你的对象，最后需要通过value返回出真正的值。如果不能理解，联想一下下面这段代码：\n```\n$('div')[0].classList\n```\n用jQuery选择器筛选到的是jQuery对象，而如果要调用真正的DOM对象的属性的话，还要用索引去调用它。\n\n","slug":"lodash-api","published":1,"updated":"2017-01-11T09:18:05.901Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixtsystn0000pktup10kvynw","content":"<h4 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h4><ul>\n<li><em>.head/</em>.last<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">_.head([1, 2, 3]);</div><div class=\"line\">// → 1</div><div class=\"line\"></div><div class=\"line\">_.last([1, 2, 3]);</div><div class=\"line\">// → 3</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>分别可以抽取数组第一个元素的值和最后一个元素的值。咋看之下觉得很无聊。但是跟下面两个结合起来就厉害。</p>\n<ul>\n<li><em>.tail/</em>.initial<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">_.tail([1, 2, 3]); //tail 尾部，尾</div><div class=\"line\">// → [2, 3]   获取数组 array第一个元素除外的所有元素.</div><div class=\"line\"></div><div class=\"line\">_.initial([1, 2, 3]);  //initial  最初的，开始的</div><div class=\"line\">// → [1, 2]  去除数组最后一个元素array.</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>结合上面的两个函数就产生很大作用：首先看一个针对数组尾部特殊化处理的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">let names=[&apos;fred&apos;, &apos;barney&apos;, &apos;pebbles&apos;];</div><div class=\"line\"></div><div class=\"line\">_.initial(names).join(&apos;, &apos;) +</div><div class=\"line\">(_.size(names) &gt; 1 ? &apos;, &amp; &apos; : &apos;&apos;) + _.last(names);</div><div class=\"line\"></div><div class=\"line\">// → &apos;fred, barney, &amp; pebbles&apos;</div></pre></td></tr></table></figure></p>\n<p>怎么样比简单的写for+if else优雅很多吧。接着我们来看看递归求和：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sum(arr)&#123;</div><div class=\"line\"> return _.head(arr) ? </div><div class=\"line\"> ( _.head(arr) + sum( _.tail(arr) ) ) :</div><div class=\"line\">0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注：<br>1）其实好像数组都可以表现为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[a, [b, [c .....]]]</div></pre></td></tr></table></figure></p>\n<p>然后再将其扁平化的结果。 是不是？所以结合这四个函数，很多数组遍历的操作都可以改写成递归的方式。虽然性能可能略差，但是可读性反而更强了(并非所有的递归都一定损耗性能，详细可以去了解下JIT优化)。</p>\n<p>2）但是在ES6中，更推荐优先使用数组的解构。</p>\n<ul>\n<li>_.zip<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">_.zip([&apos;fred&apos;, &apos;barney&apos;], [30, 40]);</div><div class=\"line\">// → [[&apos;fred&apos;, 30], [&apos;barney&apos;, 40]]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>_.zip(*array) 将几个数组按照位置组成新的数组，返回数组列表。此方法对重组数据结构非常有帮助。</p>\n<ul>\n<li><p>_.unzip<br>既然lodash是个函数库，那有zip肯定也有他的逆运算unzip。unzip其实可以看作对ES6数组解构的补充，应用的场景也是十分相似的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var zipped = _.zip([&apos;fred&apos;, &apos;barney&apos;], [30, 40], [true, false]);</div><div class=\"line\">// =&gt; [[&apos;fred&apos;, 30, true], [&apos;barney&apos;, 40, false]]</div><div class=\"line\"></div><div class=\"line\">_.unzip(zipped);</div><div class=\"line\">// =&gt; [[&apos;fred&apos;, &apos;barney&apos;], [30, 40], [true, false]]</div></pre></td></tr></table></figure>\n</li>\n<li><p>_.without</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">_.without([1, 2, 1, 3], 1, 2);</div><div class=\"line\">// =&gt; [3]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h4><ul>\n<li><em>.map/</em>.reduce/<em>.filter<br>这三个函数其实早就名声在外，遍历集合可不仅仅只有</em>.each。任何时候都优先考虑这些函数。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">function timesThree(n) &#123;</div><div class=\"line\">  return n * 3;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_.map([1, 2], timesThree);</div><div class=\"line\">// =&gt; [3, 6]</div><div class=\"line\"></div><div class=\"line\">_.map(&#123; &apos;a&apos;: 1, &apos;b&apos;: 2 &#125;, timesThree);</div><div class=\"line\">// =&gt; [3, 6] (iteration order is not guaranteed)译：迭代顺序不保证</div><div class=\"line\"></div><div class=\"line\">var users = [</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;barney&apos; &#125;,</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;fred&apos; &#125;</div><div class=\"line\">];</div><div class=\"line\"></div><div class=\"line\">// using the `_.property` callback shorthand</div><div class=\"line\">_.map(users, &apos;user&apos;);</div><div class=\"line\">// =&gt; [&apos;barney&apos;, &apos;fred&apos;]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">_.reduce([1, 2], function(total, n) &#123;</div><div class=\"line\">  return total + n;</div><div class=\"line\">&#125;);</div><div class=\"line\">// =&gt; 3</div><div class=\"line\"></div><div class=\"line\">_.reduce(&#123; &apos;a&apos;: 1, &apos;b&apos;: 2 &#125;, function(result, n, key) &#123;</div><div class=\"line\">  result[key] = n * 3;</div><div class=\"line\">  return result;</div><div class=\"line\">&#125;, &#123;&#125;);</div><div class=\"line\">// =&gt; &#123; &apos;a&apos;: 3, &apos;b&apos;: 6 &#125; (iteration order is not guaranteed)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">_.filter([4, 5, 6], function(n) &#123;</div><div class=\"line\">  return n % 2 == 0;</div><div class=\"line\">&#125;);</div><div class=\"line\">// =&gt; [4, 6]</div><div class=\"line\"></div><div class=\"line\">var users = [</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;barney&apos;, &apos;age&apos;: 36, &apos;active&apos;: true &#125;,</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;fred&apos;,   &apos;age&apos;: 40, &apos;active&apos;: false &#125;</div><div class=\"line\">];</div><div class=\"line\"></div><div class=\"line\">// using the `_.matches` callback shorthand</div><div class=\"line\">_.pluck(_.filter(users, &#123; &apos;age&apos;: 36, &apos;active&apos;: true &#125;), &apos;user&apos;);</div><div class=\"line\">// =&gt; [&apos;barney&apos;]</div><div class=\"line\"></div><div class=\"line\">// using the `_.matchesProperty` callback shorthand</div><div class=\"line\">_.pluck(_.filter(users, &apos;active&apos;, false), &apos;user&apos;);</div><div class=\"line\">// =&gt; [&apos;fred&apos;]</div><div class=\"line\"></div><div class=\"line\">// using the `_.property` callback shorthand</div><div class=\"line\">_.pluck(_.filter(users, &apos;active&apos;), &apos;user&apos;);</div><div class=\"line\">// =&gt; [&apos;barney&apos;]</div></pre></td></tr></table></figure>\n<ul>\n<li><em>.every/</em>.some<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">let users = [</div><div class=\"line\"> &#123; &apos;user&apos;: &apos;barney&apos;, &apos;active&apos;: true &#125;,</div><div class=\"line\"> &#123; &apos;user&apos;: &apos;fred&apos;, &apos;active&apos;: false &#125;</div><div class=\"line\">];</div><div class=\"line\"></div><div class=\"line\">_.every(users, &#123; &apos;user&apos;: &apos;barney&apos;, &apos;active&apos;: false &#125;);</div><div class=\"line\">// → false</div><div class=\"line\"></div><div class=\"line\">_.some(users, [&apos;active&apos;, false]);</div><div class=\"line\">// → true</div><div class=\"line\"></div><div class=\"line\">其实作用相当于：</div><div class=\"line\">_.every =&gt; &amp;&amp; </div><div class=\"line\">_.some =&gt; ||</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h4><ul>\n<li>_.curry<br>是函数柯里化的函数。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">let abc = function(a, b, c) &#123;</div><div class=\"line\"> return [a, b, c];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">let curried = _.curry(abc);</div><div class=\"line\"></div><div class=\"line\">curried(1)(2)(3);</div><div class=\"line\">// → [1, 2, 3]</div><div class=\"line\"></div><div class=\"line\">curried(1, 2)(3);</div><div class=\"line\">// → [1, 2, 3]</div><div class=\"line\"></div><div class=\"line\">curried(1, 2, 3);</div><div class=\"line\">// → [1, 2, 3]</div><div class=\"line\"></div><div class=\"line\">// Curried with placeholders.</div><div class=\"line\">curried(1)(_, 3)(2);</div><div class=\"line\">// → [1, 2, 3]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>柯里化有3个常见作用：1. 参数复用；2. 构建高阶函数；3. 延迟计算。 参数复用的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">let parse = function(data, config)&#123;</div><div class=\"line\">    xxxx</div><div class=\"line\"> return xxxx;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">let config = &#123;&#125;;</div><div class=\"line\">let parseByConfig = _.curryRight(parse)(config);</div></pre></td></tr></table></figure></p>\n<p>如代码所示，这是一个数据解析函数，通过某些配置按照一定的规则去解析数据。如果在某个场景下参数配置都一样。那可以用柯里化先引入一个参数。然后再接收不同的数据。这样就不用在每次调用时都引入同样的config参数。</p>\n<ul>\n<li><p>_.curryRight</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var abc = function(a, b, c) &#123;</div><div class=\"line\">  return [a, b, c];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var curried = _.curryRight(abc);</div><div class=\"line\"></div><div class=\"line\">curried(3)(2)(1);</div><div class=\"line\">// =&gt; [1, 2, 3]</div><div class=\"line\"></div><div class=\"line\">curried(2, 3)(1);</div><div class=\"line\">// =&gt; [1, 2, 3]</div><div class=\"line\"></div><div class=\"line\">curried(1, 2, 3);</div><div class=\"line\">// =&gt; [1, 2, 3]</div><div class=\"line\"></div><div class=\"line\">// using placeholders</div><div class=\"line\">curried(3)(1, _)(2);</div><div class=\"line\">// =&gt; [1, 2, 3]</div></pre></td></tr></table></figure>\n</li>\n<li><p>_.partial<br>便于理解可以叫它部分函数，还是先看例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">let greet = function(greeting, name) &#123;</div><div class=\"line\"> return greeting + &apos; &apos; + name;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">let sayHelloTo = _.partial(greet, &apos;hello&apos;);</div><div class=\"line\">sayHelloTo(&apos;fred&apos;);</div><div class=\"line\">// → &apos;hello fred&apos;</div><div class=\"line\"></div><div class=\"line\">// Partially applied with placeholders.</div><div class=\"line\">let greetFred = _.partial(greet, _, &apos;fred&apos;);</div><div class=\"line\">greetFred(&apos;hi&apos;);</div><div class=\"line\">// → &apos;hi fred&apos;</div><div class=\"line\">let greet = function(greeting, name) &#123;</div><div class=\"line\"> return greeting + &apos; &apos; + name;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">let sayHelloTo = _.partial(greet, &apos;hello&apos;);</div><div class=\"line\">sayHelloTo(&apos;fred&apos;);</div><div class=\"line\">// → &apos;hello fred&apos;</div><div class=\"line\"></div><div class=\"line\">// Partially applied with placeholders.</div><div class=\"line\">let greetFred = _.partial(greet, _, &apos;fred&apos;);</div><div class=\"line\">greetFred(&apos;hi&apos;);</div><div class=\"line\">// → &apos;hi fred&apos;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>好像跟柯里化很像。是的，它其实就是柯里化的具体应用——构建高阶函数。_.curry会把一个函数转化成可以柯里化函数，而当这个柯里化函数接受了一定的参数后，它就变成了一个部分应用函数了。</p>\n<ul>\n<li>_.flow<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function square(n) &#123;</div><div class=\"line\">  return n * n;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var addSquare = _.flow(_.add, square);</div><div class=\"line\">addSquare(1, 2);</div><div class=\"line\">// =&gt; 9</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这是用来组合高阶函数的一个方法。如果用数学的角度去思考的话，就有点像, 把函数 f(), g(), 和h() 组合起来可以得到复合函数 f( g( h() ) )。</p>\n<ul>\n<li>_.flowRight<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function square(n) &#123;</div><div class=\"line\">  return n * n;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var addSquare = _.flowRight(square, _.add);</div><div class=\"line\">addSquare(1, 2);</div><div class=\"line\">// =&gt; 9</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Chain\"><a href=\"#Chain\" class=\"headerlink\" title=\"Chain\"></a>Chain</h4><ul>\n<li>_.chain<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div&apos;).css(&apos;color&apos;,&apos;red&apos;)</div><div class=\"line\"> .on(&apos;click&apos;, function()&#123;&#125;)</div><div class=\"line\">.fadeIn();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>作为一个合格的前端攻城狮，你对这个一定不陌生。它一定给你带来过很多美好的记忆。那我们如何让这样一段优雅的代码应用到非DOM对象上呢。用_.chain就行了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">_.head(</div><div class=\"line\">_.map(</div><div class=\"line\"> _.sortBy(&apos;users&apos;, &apos;age&apos;),</div><div class=\"line\"> function(o) &#123;</div><div class=\"line\"> return `$&#123;o.user&#125; is $&#123;o.age&#125;`;</div><div class=\"line\">&#125;</div><div class=\"line\">)</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">_.chain(users)</div><div class=\"line\">.sortBy(&apos;age&apos;)</div><div class=\"line\"> .map(function(o) &#123;</div><div class=\"line\"> return o.user + &apos; is &apos; + o.age;</div><div class=\"line\">&#125;)</div><div class=\"line\">.head()</div><div class=\"line\">.value();</div></pre></td></tr></table></figure></p>\n<p>两段代码在做一样的事情。你更喜欢哪个呢。不过要注意<em>.chain最后的value。因为</em>.chain用一个容器包装了你的对象，最后需要通过value返回出真正的值。如果不能理解，联想一下下面这段代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div&apos;)[0].classList</div></pre></td></tr></table></figure></p>\n<p>用jQuery选择器筛选到的是jQuery对象，而如果要调用真正的DOM对象的属性的话，还要用索引去调用它。</p>\n","excerpt":"","more":"<h4 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h4><ul>\n<li><em>.head/</em>.last<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">_.head([1, 2, 3]);</div><div class=\"line\">// → 1</div><div class=\"line\"></div><div class=\"line\">_.last([1, 2, 3]);</div><div class=\"line\">// → 3</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>分别可以抽取数组第一个元素的值和最后一个元素的值。咋看之下觉得很无聊。但是跟下面两个结合起来就厉害。</p>\n<ul>\n<li><em>.tail/</em>.initial<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">_.tail([1, 2, 3]); //tail 尾部，尾</div><div class=\"line\">// → [2, 3]   获取数组 array第一个元素除外的所有元素.</div><div class=\"line\"></div><div class=\"line\">_.initial([1, 2, 3]);  //initial  最初的，开始的</div><div class=\"line\">// → [1, 2]  去除数组最后一个元素array.</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>结合上面的两个函数就产生很大作用：首先看一个针对数组尾部特殊化处理的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">let names=[&apos;fred&apos;, &apos;barney&apos;, &apos;pebbles&apos;];</div><div class=\"line\"></div><div class=\"line\">_.initial(names).join(&apos;, &apos;) +</div><div class=\"line\">(_.size(names) &gt; 1 ? &apos;, &amp; &apos; : &apos;&apos;) + _.last(names);</div><div class=\"line\"></div><div class=\"line\">// → &apos;fred, barney, &amp; pebbles&apos;</div></pre></td></tr></table></figure></p>\n<p>怎么样比简单的写for+if else优雅很多吧。接着我们来看看递归求和：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sum(arr)&#123;</div><div class=\"line\"> return _.head(arr) ? </div><div class=\"line\"> ( _.head(arr) + sum( _.tail(arr) ) ) :</div><div class=\"line\">0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注：<br>1）其实好像数组都可以表现为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[a, [b, [c .....]]]</div></pre></td></tr></table></figure></p>\n<p>然后再将其扁平化的结果。 是不是？所以结合这四个函数，很多数组遍历的操作都可以改写成递归的方式。虽然性能可能略差，但是可读性反而更强了(并非所有的递归都一定损耗性能，详细可以去了解下JIT优化)。</p>\n<p>2）但是在ES6中，更推荐优先使用数组的解构。</p>\n<ul>\n<li>_.zip<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">_.zip([&apos;fred&apos;, &apos;barney&apos;], [30, 40]);</div><div class=\"line\">// → [[&apos;fred&apos;, 30], [&apos;barney&apos;, 40]]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>_.zip(*array) 将几个数组按照位置组成新的数组，返回数组列表。此方法对重组数据结构非常有帮助。</p>\n<ul>\n<li><p>_.unzip<br>既然lodash是个函数库，那有zip肯定也有他的逆运算unzip。unzip其实可以看作对ES6数组解构的补充，应用的场景也是十分相似的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var zipped = _.zip([&apos;fred&apos;, &apos;barney&apos;], [30, 40], [true, false]);</div><div class=\"line\">// =&gt; [[&apos;fred&apos;, 30, true], [&apos;barney&apos;, 40, false]]</div><div class=\"line\"></div><div class=\"line\">_.unzip(zipped);</div><div class=\"line\">// =&gt; [[&apos;fred&apos;, &apos;barney&apos;], [30, 40], [true, false]]</div></pre></td></tr></table></figure>\n</li>\n<li><p>_.without</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">_.without([1, 2, 1, 3], 1, 2);</div><div class=\"line\">// =&gt; [3]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h4><ul>\n<li><em>.map/</em>.reduce/<em>.filter<br>这三个函数其实早就名声在外，遍历集合可不仅仅只有</em>.each。任何时候都优先考虑这些函数。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">function timesThree(n) &#123;</div><div class=\"line\">  return n * 3;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_.map([1, 2], timesThree);</div><div class=\"line\">// =&gt; [3, 6]</div><div class=\"line\"></div><div class=\"line\">_.map(&#123; &apos;a&apos;: 1, &apos;b&apos;: 2 &#125;, timesThree);</div><div class=\"line\">// =&gt; [3, 6] (iteration order is not guaranteed)译：迭代顺序不保证</div><div class=\"line\"></div><div class=\"line\">var users = [</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;barney&apos; &#125;,</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;fred&apos; &#125;</div><div class=\"line\">];</div><div class=\"line\"></div><div class=\"line\">// using the `_.property` callback shorthand</div><div class=\"line\">_.map(users, &apos;user&apos;);</div><div class=\"line\">// =&gt; [&apos;barney&apos;, &apos;fred&apos;]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">_.reduce([1, 2], function(total, n) &#123;</div><div class=\"line\">  return total + n;</div><div class=\"line\">&#125;);</div><div class=\"line\">// =&gt; 3</div><div class=\"line\"></div><div class=\"line\">_.reduce(&#123; &apos;a&apos;: 1, &apos;b&apos;: 2 &#125;, function(result, n, key) &#123;</div><div class=\"line\">  result[key] = n * 3;</div><div class=\"line\">  return result;</div><div class=\"line\">&#125;, &#123;&#125;);</div><div class=\"line\">// =&gt; &#123; &apos;a&apos;: 3, &apos;b&apos;: 6 &#125; (iteration order is not guaranteed)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">_.filter([4, 5, 6], function(n) &#123;</div><div class=\"line\">  return n % 2 == 0;</div><div class=\"line\">&#125;);</div><div class=\"line\">// =&gt; [4, 6]</div><div class=\"line\"></div><div class=\"line\">var users = [</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;barney&apos;, &apos;age&apos;: 36, &apos;active&apos;: true &#125;,</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;fred&apos;,   &apos;age&apos;: 40, &apos;active&apos;: false &#125;</div><div class=\"line\">];</div><div class=\"line\"></div><div class=\"line\">// using the `_.matches` callback shorthand</div><div class=\"line\">_.pluck(_.filter(users, &#123; &apos;age&apos;: 36, &apos;active&apos;: true &#125;), &apos;user&apos;);</div><div class=\"line\">// =&gt; [&apos;barney&apos;]</div><div class=\"line\"></div><div class=\"line\">// using the `_.matchesProperty` callback shorthand</div><div class=\"line\">_.pluck(_.filter(users, &apos;active&apos;, false), &apos;user&apos;);</div><div class=\"line\">// =&gt; [&apos;fred&apos;]</div><div class=\"line\"></div><div class=\"line\">// using the `_.property` callback shorthand</div><div class=\"line\">_.pluck(_.filter(users, &apos;active&apos;), &apos;user&apos;);</div><div class=\"line\">// =&gt; [&apos;barney&apos;]</div></pre></td></tr></table></figure>\n<ul>\n<li><em>.every/</em>.some<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">let users = [</div><div class=\"line\"> &#123; &apos;user&apos;: &apos;barney&apos;, &apos;active&apos;: true &#125;,</div><div class=\"line\"> &#123; &apos;user&apos;: &apos;fred&apos;, &apos;active&apos;: false &#125;</div><div class=\"line\">];</div><div class=\"line\"></div><div class=\"line\">_.every(users, &#123; &apos;user&apos;: &apos;barney&apos;, &apos;active&apos;: false &#125;);</div><div class=\"line\">// → false</div><div class=\"line\"></div><div class=\"line\">_.some(users, [&apos;active&apos;, false]);</div><div class=\"line\">// → true</div><div class=\"line\"></div><div class=\"line\">其实作用相当于：</div><div class=\"line\">_.every =&gt; &amp;&amp; </div><div class=\"line\">_.some =&gt; ||</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h4><ul>\n<li>_.curry<br>是函数柯里化的函数。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">let abc = function(a, b, c) &#123;</div><div class=\"line\"> return [a, b, c];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">let curried = _.curry(abc);</div><div class=\"line\"></div><div class=\"line\">curried(1)(2)(3);</div><div class=\"line\">// → [1, 2, 3]</div><div class=\"line\"></div><div class=\"line\">curried(1, 2)(3);</div><div class=\"line\">// → [1, 2, 3]</div><div class=\"line\"></div><div class=\"line\">curried(1, 2, 3);</div><div class=\"line\">// → [1, 2, 3]</div><div class=\"line\"></div><div class=\"line\">// Curried with placeholders.</div><div class=\"line\">curried(1)(_, 3)(2);</div><div class=\"line\">// → [1, 2, 3]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>柯里化有3个常见作用：1. 参数复用；2. 构建高阶函数；3. 延迟计算。 参数复用的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">let parse = function(data, config)&#123;</div><div class=\"line\">    xxxx</div><div class=\"line\"> return xxxx;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">let config = &#123;&#125;;</div><div class=\"line\">let parseByConfig = _.curryRight(parse)(config);</div></pre></td></tr></table></figure></p>\n<p>如代码所示，这是一个数据解析函数，通过某些配置按照一定的规则去解析数据。如果在某个场景下参数配置都一样。那可以用柯里化先引入一个参数。然后再接收不同的数据。这样就不用在每次调用时都引入同样的config参数。</p>\n<ul>\n<li><p>_.curryRight</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var abc = function(a, b, c) &#123;</div><div class=\"line\">  return [a, b, c];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var curried = _.curryRight(abc);</div><div class=\"line\"></div><div class=\"line\">curried(3)(2)(1);</div><div class=\"line\">// =&gt; [1, 2, 3]</div><div class=\"line\"></div><div class=\"line\">curried(2, 3)(1);</div><div class=\"line\">// =&gt; [1, 2, 3]</div><div class=\"line\"></div><div class=\"line\">curried(1, 2, 3);</div><div class=\"line\">// =&gt; [1, 2, 3]</div><div class=\"line\"></div><div class=\"line\">// using placeholders</div><div class=\"line\">curried(3)(1, _)(2);</div><div class=\"line\">// =&gt; [1, 2, 3]</div></pre></td></tr></table></figure>\n</li>\n<li><p>_.partial<br>便于理解可以叫它部分函数，还是先看例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">let greet = function(greeting, name) &#123;</div><div class=\"line\"> return greeting + &apos; &apos; + name;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">let sayHelloTo = _.partial(greet, &apos;hello&apos;);</div><div class=\"line\">sayHelloTo(&apos;fred&apos;);</div><div class=\"line\">// → &apos;hello fred&apos;</div><div class=\"line\"></div><div class=\"line\">// Partially applied with placeholders.</div><div class=\"line\">let greetFred = _.partial(greet, _, &apos;fred&apos;);</div><div class=\"line\">greetFred(&apos;hi&apos;);</div><div class=\"line\">// → &apos;hi fred&apos;</div><div class=\"line\">let greet = function(greeting, name) &#123;</div><div class=\"line\"> return greeting + &apos; &apos; + name;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">let sayHelloTo = _.partial(greet, &apos;hello&apos;);</div><div class=\"line\">sayHelloTo(&apos;fred&apos;);</div><div class=\"line\">// → &apos;hello fred&apos;</div><div class=\"line\"></div><div class=\"line\">// Partially applied with placeholders.</div><div class=\"line\">let greetFred = _.partial(greet, _, &apos;fred&apos;);</div><div class=\"line\">greetFred(&apos;hi&apos;);</div><div class=\"line\">// → &apos;hi fred&apos;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>好像跟柯里化很像。是的，它其实就是柯里化的具体应用——构建高阶函数。_.curry会把一个函数转化成可以柯里化函数，而当这个柯里化函数接受了一定的参数后，它就变成了一个部分应用函数了。</p>\n<ul>\n<li>_.flow<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function square(n) &#123;</div><div class=\"line\">  return n * n;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var addSquare = _.flow(_.add, square);</div><div class=\"line\">addSquare(1, 2);</div><div class=\"line\">// =&gt; 9</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这是用来组合高阶函数的一个方法。如果用数学的角度去思考的话，就有点像, 把函数 f(), g(), 和h() 组合起来可以得到复合函数 f( g( h() ) )。</p>\n<ul>\n<li>_.flowRight<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function square(n) &#123;</div><div class=\"line\">  return n * n;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var addSquare = _.flowRight(square, _.add);</div><div class=\"line\">addSquare(1, 2);</div><div class=\"line\">// =&gt; 9</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Chain\"><a href=\"#Chain\" class=\"headerlink\" title=\"Chain\"></a>Chain</h4><ul>\n<li>_.chain<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div&apos;).css(&apos;color&apos;,&apos;red&apos;)</div><div class=\"line\"> .on(&apos;click&apos;, function()&#123;&#125;)</div><div class=\"line\">.fadeIn();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>作为一个合格的前端攻城狮，你对这个一定不陌生。它一定给你带来过很多美好的记忆。那我们如何让这样一段优雅的代码应用到非DOM对象上呢。用_.chain就行了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">_.head(</div><div class=\"line\">_.map(</div><div class=\"line\"> _.sortBy(&apos;users&apos;, &apos;age&apos;),</div><div class=\"line\"> function(o) &#123;</div><div class=\"line\"> return `$&#123;o.user&#125; is $&#123;o.age&#125;`;</div><div class=\"line\">&#125;</div><div class=\"line\">)</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">_.chain(users)</div><div class=\"line\">.sortBy(&apos;age&apos;)</div><div class=\"line\"> .map(function(o) &#123;</div><div class=\"line\"> return o.user + &apos; is &apos; + o.age;</div><div class=\"line\">&#125;)</div><div class=\"line\">.head()</div><div class=\"line\">.value();</div></pre></td></tr></table></figure></p>\n<p>两段代码在做一样的事情。你更喜欢哪个呢。不过要注意<em>.chain最后的value。因为</em>.chain用一个容器包装了你的对象，最后需要通过value返回出真正的值。如果不能理解，联想一下下面这段代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div&apos;)[0].classList</div></pre></td></tr></table></figure></p>\n<p>用jQuery选择器筛选到的是jQuery对象，而如果要调用真正的DOM对象的属性的话，还要用索引去调用它。</p>\n"},{"title":"JavaScript工具库之Lodash","date":"2017-01-11T02:56:07.000Z","_content":"你还在为JavaScript中的数据转换、匹配、查找等烦恼吗？一堆看似简单的foreach，却冗长无趣，可仍还在不停的repeat it！也许你已经用上了Underscore.js，不错，你已经进步很大一步了。然而今天我希望你能更进一步，利用lodash替换掉Underscore。\n\nlodash一开始是Underscore.js库的一个fork，因为和其他(Underscore.js的)贡献者意见相左。John-David Dalton的最初目标，是提供更多“一致的跨浏览器行为……，并改善性能”。之后，该项目在现有成功的基础之上取得了更大的成果。最近lodash成为了npm包仓库中依赖最多的库。它正在摆脱屌丝身份，成为开发者的常规的选择之一。\n\n现在我们所熟知的很多开源项目都已经使用或者转到了lodash阵营之上。比如JavaScript转译器Babel、博客平台Ghost，和项目脚手架工具Yeoman。特别Ghost是从Underscore迁移到了lodash，Ghost的创始人John O’Nolan对于此曾评价到：“这是一个非常明智的选择，它几乎完全是由我们开源开发社区推动的。我们发现lodash包含更多的功能，更好的性能、恰到好处地使用了semver，并且在Node.js社区（以及其他依赖）中越来越抢眼“。\n\n#### lodash演练\nlodash主要使用了延迟计算，使得lodash其性能远远超过Underscore。在lodash中延迟计算意味着在我们的链式方法在显示或隐式的value()调用之前是不会执行的。由于这种执行的延后，因此lodash可以进行shortcut fusion这样的优化，通过合并链式iteratee大大降低迭代的次数。从而大大提供其执行性能。\n\n百说不如一练，下面我们以用户信息为例：\n```\nvar users = [\n  { 'user': 'barney',  'age': 36 },\n  { 'user': 'fred',    'age': 40 },\n  { 'user': 'pebbles', 'age': 18 }\n];\n```\n1.获取所有用户名字，并以”，“分割\n```\nvar names = _.chain(users)\n  .map(function(user){\n    return user.user;\n  })\n  .join(\" , \")\n  .value();\nconsole.log(names);\n```\n在这里首先将users对象包装成为lodash对象，再map获取所有用户的名称，并最后利用join将用户名称以”，“连接在一起。注意这里只是一串方法链，如果你没有显样的调用value方法，使其立即执行的话，你将会得到如下的LodashWrapper延迟表达式：\n```\n LodashWrapper {__wrapped__: LazyWrapper, __actions__: Array[1], __chain__: true, constructor: function, after: function…}\n ```\n 因为延迟表达式的存在，因此我们可以多次增加方法链，但这并不会被执行，所以不会存在性能的问题，最后知道我们需要使用的时候，使用value显式立即执行即可。\n \n2.获取最年轻的用户\n ```\n  var youngest = _.chain(users)\n   .min(function(user){\n     return user.age;\n   })\n   .value();\n console.log(youngest);\n ```\n 这里利用了lodash提供的min函数可以轻易的解决。min方法可以找到数组中最小的那一项。\n ```\n //min使用例子：\n _.min([4, 2, 8, 6]);\n // => 2\n \n _.min([]);\n // => Infinity\n \n var users = [\n   { 'user': 'barney', 'age': 36 },\n   { 'user': 'fred',   'age': 40 }\n ];\n \n _.min(users, function(chr) {\n   return chr.age;\n });\n // => { 'user': 'barney', 'age': 36 }\n \n // using the `_.property` callback shorthand\n _.min(users, 'age');\n // => { 'user': 'barney', 'age': 36 }\n ```\n \n 此处还希望用另外一个方式解释lodash方法链的优化,上面的方法可以等价为下面的方式，以age排序的第一个user：\n ```\n var youngest2 = _.chain(users)\n   .sortBy(\"age\")\n   .map(function(user){\n     console.log(\"map\", user);\n     return user;\n   })\n   .first()\n   .value();\n console.log(youngest2);\n ```\n 在这里多加了一个map作为log输出，如果你执行这行代码的时候，你会惊奇的看见这里只会有一个user的输出，这点可以证明在立即执行的时候lodash为我们的方法链做了可靠的优化；如果我们去掉first函数你则会看见有3个user对象的输出。\n \n3.获取最年长的用户\n```\nvar oldest  = _.chain(users)\n  .max(function(user){\n    return user.age;\n  })\n  .value();\nconsole.log(oldest );\n```\n这里则使用lodash的max函数。用法同上面的min方法。\n\n4.用户数组到用户Map的转换\n\n在开发中我们经常会有把一堆素组形式的数据转换为Object形式的数组，便于根据属性key值查找，下面将以user对象来演示：\n```\nvar userObj = _.chain(users)\n  .map(function(user){\n    return [user.user, user.age];\n  })\n  .zipObject()\n  .value();\nconsole.log(userObj);\n利用lodash首先将user数组map为[key, value]的数组集合，最后利用zipObject将结果转换为Object对象，zipObject会利用结果集的第一项作为key，第二项作为value生产Object。\n```\n```\n//zipObject方法使用如下：\n_.zipObject([['fred', 30], ['barney', 40]]);\n// => { 'fred': 30, 'barney': 40 }\n\n_.zipObject(['fred', 'barney'], [30, 40]);\n// => { 'fred': 30, 'barney': 40 }\n```\n#### 结尾\n在这里展示知识lodash中很小一部分的API，正如开始所说：lodash是为了提供更多“一致的跨浏览器行为……，并改善性能”API。所有的lodash API你可以在这里https://lodash.com/docs#matches查找。\n ","source":"_posts/lodashjieshao.md","raw":"---\ntitle: JavaScript工具库之Lodash\ndate: 2017-01-11 10:56:07\ntags: js lodash\n---\n你还在为JavaScript中的数据转换、匹配、查找等烦恼吗？一堆看似简单的foreach，却冗长无趣，可仍还在不停的repeat it！也许你已经用上了Underscore.js，不错，你已经进步很大一步了。然而今天我希望你能更进一步，利用lodash替换掉Underscore。\n\nlodash一开始是Underscore.js库的一个fork，因为和其他(Underscore.js的)贡献者意见相左。John-David Dalton的最初目标，是提供更多“一致的跨浏览器行为……，并改善性能”。之后，该项目在现有成功的基础之上取得了更大的成果。最近lodash成为了npm包仓库中依赖最多的库。它正在摆脱屌丝身份，成为开发者的常规的选择之一。\n\n现在我们所熟知的很多开源项目都已经使用或者转到了lodash阵营之上。比如JavaScript转译器Babel、博客平台Ghost，和项目脚手架工具Yeoman。特别Ghost是从Underscore迁移到了lodash，Ghost的创始人John O’Nolan对于此曾评价到：“这是一个非常明智的选择，它几乎完全是由我们开源开发社区推动的。我们发现lodash包含更多的功能，更好的性能、恰到好处地使用了semver，并且在Node.js社区（以及其他依赖）中越来越抢眼“。\n\n#### lodash演练\nlodash主要使用了延迟计算，使得lodash其性能远远超过Underscore。在lodash中延迟计算意味着在我们的链式方法在显示或隐式的value()调用之前是不会执行的。由于这种执行的延后，因此lodash可以进行shortcut fusion这样的优化，通过合并链式iteratee大大降低迭代的次数。从而大大提供其执行性能。\n\n百说不如一练，下面我们以用户信息为例：\n```\nvar users = [\n  { 'user': 'barney',  'age': 36 },\n  { 'user': 'fred',    'age': 40 },\n  { 'user': 'pebbles', 'age': 18 }\n];\n```\n1.获取所有用户名字，并以”，“分割\n```\nvar names = _.chain(users)\n  .map(function(user){\n    return user.user;\n  })\n  .join(\" , \")\n  .value();\nconsole.log(names);\n```\n在这里首先将users对象包装成为lodash对象，再map获取所有用户的名称，并最后利用join将用户名称以”，“连接在一起。注意这里只是一串方法链，如果你没有显样的调用value方法，使其立即执行的话，你将会得到如下的LodashWrapper延迟表达式：\n```\n LodashWrapper {__wrapped__: LazyWrapper, __actions__: Array[1], __chain__: true, constructor: function, after: function…}\n ```\n 因为延迟表达式的存在，因此我们可以多次增加方法链，但这并不会被执行，所以不会存在性能的问题，最后知道我们需要使用的时候，使用value显式立即执行即可。\n \n2.获取最年轻的用户\n ```\n  var youngest = _.chain(users)\n   .min(function(user){\n     return user.age;\n   })\n   .value();\n console.log(youngest);\n ```\n 这里利用了lodash提供的min函数可以轻易的解决。min方法可以找到数组中最小的那一项。\n ```\n //min使用例子：\n _.min([4, 2, 8, 6]);\n // => 2\n \n _.min([]);\n // => Infinity\n \n var users = [\n   { 'user': 'barney', 'age': 36 },\n   { 'user': 'fred',   'age': 40 }\n ];\n \n _.min(users, function(chr) {\n   return chr.age;\n });\n // => { 'user': 'barney', 'age': 36 }\n \n // using the `_.property` callback shorthand\n _.min(users, 'age');\n // => { 'user': 'barney', 'age': 36 }\n ```\n \n 此处还希望用另外一个方式解释lodash方法链的优化,上面的方法可以等价为下面的方式，以age排序的第一个user：\n ```\n var youngest2 = _.chain(users)\n   .sortBy(\"age\")\n   .map(function(user){\n     console.log(\"map\", user);\n     return user;\n   })\n   .first()\n   .value();\n console.log(youngest2);\n ```\n 在这里多加了一个map作为log输出，如果你执行这行代码的时候，你会惊奇的看见这里只会有一个user的输出，这点可以证明在立即执行的时候lodash为我们的方法链做了可靠的优化；如果我们去掉first函数你则会看见有3个user对象的输出。\n \n3.获取最年长的用户\n```\nvar oldest  = _.chain(users)\n  .max(function(user){\n    return user.age;\n  })\n  .value();\nconsole.log(oldest );\n```\n这里则使用lodash的max函数。用法同上面的min方法。\n\n4.用户数组到用户Map的转换\n\n在开发中我们经常会有把一堆素组形式的数据转换为Object形式的数组，便于根据属性key值查找，下面将以user对象来演示：\n```\nvar userObj = _.chain(users)\n  .map(function(user){\n    return [user.user, user.age];\n  })\n  .zipObject()\n  .value();\nconsole.log(userObj);\n利用lodash首先将user数组map为[key, value]的数组集合，最后利用zipObject将结果转换为Object对象，zipObject会利用结果集的第一项作为key，第二项作为value生产Object。\n```\n```\n//zipObject方法使用如下：\n_.zipObject([['fred', 30], ['barney', 40]]);\n// => { 'fred': 30, 'barney': 40 }\n\n_.zipObject(['fred', 'barney'], [30, 40]);\n// => { 'fred': 30, 'barney': 40 }\n```\n#### 结尾\n在这里展示知识lodash中很小一部分的API，正如开始所说：lodash是为了提供更多“一致的跨浏览器行为……，并改善性能”API。所有的lodash API你可以在这里https://lodash.com/docs#matches查找。\n ","slug":"lodashjieshao","published":1,"updated":"2017-01-11T05:34:37.271Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixtsysu60001pktu0nqlsbyw","content":"<p>你还在为JavaScript中的数据转换、匹配、查找等烦恼吗？一堆看似简单的foreach，却冗长无趣，可仍还在不停的repeat it！也许你已经用上了Underscore.js，不错，你已经进步很大一步了。然而今天我希望你能更进一步，利用lodash替换掉Underscore。</p>\n<p>lodash一开始是Underscore.js库的一个fork，因为和其他(Underscore.js的)贡献者意见相左。John-David Dalton的最初目标，是提供更多“一致的跨浏览器行为……，并改善性能”。之后，该项目在现有成功的基础之上取得了更大的成果。最近lodash成为了npm包仓库中依赖最多的库。它正在摆脱屌丝身份，成为开发者的常规的选择之一。</p>\n<p>现在我们所熟知的很多开源项目都已经使用或者转到了lodash阵营之上。比如JavaScript转译器Babel、博客平台Ghost，和项目脚手架工具Yeoman。特别Ghost是从Underscore迁移到了lodash，Ghost的创始人John O’Nolan对于此曾评价到：“这是一个非常明智的选择，它几乎完全是由我们开源开发社区推动的。我们发现lodash包含更多的功能，更好的性能、恰到好处地使用了semver，并且在Node.js社区（以及其他依赖）中越来越抢眼“。</p>\n<h4 id=\"lodash演练\"><a href=\"#lodash演练\" class=\"headerlink\" title=\"lodash演练\"></a>lodash演练</h4><p>lodash主要使用了延迟计算，使得lodash其性能远远超过Underscore。在lodash中延迟计算意味着在我们的链式方法在显示或隐式的value()调用之前是不会执行的。由于这种执行的延后，因此lodash可以进行shortcut fusion这样的优化，通过合并链式iteratee大大降低迭代的次数。从而大大提供其执行性能。</p>\n<p>百说不如一练，下面我们以用户信息为例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var users = [</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;barney&apos;,  &apos;age&apos;: 36 &#125;,</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;fred&apos;,    &apos;age&apos;: 40 &#125;,</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;pebbles&apos;, &apos;age&apos;: 18 &#125;</div><div class=\"line\">];</div></pre></td></tr></table></figure></p>\n<p>1.获取所有用户名字，并以”，“分割<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var names = _.chain(users)</div><div class=\"line\">  .map(function(user)&#123;</div><div class=\"line\">    return user.user;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .join(&quot; , &quot;)</div><div class=\"line\">  .value();</div><div class=\"line\">console.log(names);</div></pre></td></tr></table></figure></p>\n<p>在这里首先将users对象包装成为lodash对象，再map获取所有用户的名称，并最后利用join将用户名称以”，“连接在一起。注意这里只是一串方法链，如果你没有显样的调用value方法，使其立即执行的话，你将会得到如下的LodashWrapper延迟表达式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LodashWrapper &#123;__wrapped__: LazyWrapper, __actions__: Array[1], __chain__: true, constructor: function, after: function…&#125;</div></pre></td></tr></table></figure></p>\n<p> 因为延迟表达式的存在，因此我们可以多次增加方法链，但这并不会被执行，所以不会存在性能的问题，最后知道我们需要使用的时候，使用value显式立即执行即可。</p>\n<p>2.获取最年轻的用户<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"> var youngest = _.chain(users)</div><div class=\"line\">  .min(function(user)&#123;</div><div class=\"line\">    return user.age;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .value();</div><div class=\"line\">console.log(youngest);</div></pre></td></tr></table></figure></p>\n<p> 这里利用了lodash提供的min函数可以轻易的解决。min方法可以找到数组中最小的那一项。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">//min使用例子：</div><div class=\"line\">_.min([4, 2, 8, 6]);</div><div class=\"line\">// =&gt; 2</div><div class=\"line\"></div><div class=\"line\">_.min([]);</div><div class=\"line\">// =&gt; Infinity</div><div class=\"line\"></div><div class=\"line\">var users = [</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;barney&apos;, &apos;age&apos;: 36 &#125;,</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;fred&apos;,   &apos;age&apos;: 40 &#125;</div><div class=\"line\">];</div><div class=\"line\"></div><div class=\"line\">_.min(users, function(chr) &#123;</div><div class=\"line\">  return chr.age;</div><div class=\"line\">&#125;);</div><div class=\"line\">// =&gt; &#123; &apos;user&apos;: &apos;barney&apos;, &apos;age&apos;: 36 &#125;</div><div class=\"line\"></div><div class=\"line\">// using the `_.property` callback shorthand</div><div class=\"line\">_.min(users, &apos;age&apos;);</div><div class=\"line\">// =&gt; &#123; &apos;user&apos;: &apos;barney&apos;, &apos;age&apos;: 36 &#125;</div></pre></td></tr></table></figure></p>\n<p> 此处还希望用另外一个方式解释lodash方法链的优化,上面的方法可以等价为下面的方式，以age排序的第一个user：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var youngest2 = _.chain(users)</div><div class=\"line\">  .sortBy(&quot;age&quot;)</div><div class=\"line\">  .map(function(user)&#123;</div><div class=\"line\">    console.log(&quot;map&quot;, user);</div><div class=\"line\">    return user;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .first()</div><div class=\"line\">  .value();</div><div class=\"line\">console.log(youngest2);</div></pre></td></tr></table></figure></p>\n<p> 在这里多加了一个map作为log输出，如果你执行这行代码的时候，你会惊奇的看见这里只会有一个user的输出，这点可以证明在立即执行的时候lodash为我们的方法链做了可靠的优化；如果我们去掉first函数你则会看见有3个user对象的输出。</p>\n<p>3.获取最年长的用户<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var oldest  = _.chain(users)</div><div class=\"line\">  .max(function(user)&#123;</div><div class=\"line\">    return user.age;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .value();</div><div class=\"line\">console.log(oldest );</div></pre></td></tr></table></figure></p>\n<p>这里则使用lodash的max函数。用法同上面的min方法。</p>\n<p>4.用户数组到用户Map的转换</p>\n<p>在开发中我们经常会有把一堆素组形式的数据转换为Object形式的数组，便于根据属性key值查找，下面将以user对象来演示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var userObj = _.chain(users)</div><div class=\"line\">  .map(function(user)&#123;</div><div class=\"line\">    return [user.user, user.age];</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .zipObject()</div><div class=\"line\">  .value();</div><div class=\"line\">console.log(userObj);</div><div class=\"line\">利用lodash首先将user数组map为[key, value]的数组集合，最后利用zipObject将结果转换为Object对象，zipObject会利用结果集的第一项作为key，第二项作为value生产Object。</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//zipObject方法使用如下：</div><div class=\"line\">_.zipObject([[&apos;fred&apos;, 30], [&apos;barney&apos;, 40]]);</div><div class=\"line\">// =&gt; &#123; &apos;fred&apos;: 30, &apos;barney&apos;: 40 &#125;</div><div class=\"line\"></div><div class=\"line\">_.zipObject([&apos;fred&apos;, &apos;barney&apos;], [30, 40]);</div><div class=\"line\">// =&gt; &#123; &apos;fred&apos;: 30, &apos;barney&apos;: 40 &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h4><p>在这里展示知识lodash中很小一部分的API，正如开始所说：lodash是为了提供更多“一致的跨浏览器行为……，并改善性能”API。所有的lodash API你可以在这里<a href=\"https://lodash.com/docs#matches查找。\" target=\"_blank\" rel=\"external\">https://lodash.com/docs#matches查找。</a></p>\n","excerpt":"","more":"<p>你还在为JavaScript中的数据转换、匹配、查找等烦恼吗？一堆看似简单的foreach，却冗长无趣，可仍还在不停的repeat it！也许你已经用上了Underscore.js，不错，你已经进步很大一步了。然而今天我希望你能更进一步，利用lodash替换掉Underscore。</p>\n<p>lodash一开始是Underscore.js库的一个fork，因为和其他(Underscore.js的)贡献者意见相左。John-David Dalton的最初目标，是提供更多“一致的跨浏览器行为……，并改善性能”。之后，该项目在现有成功的基础之上取得了更大的成果。最近lodash成为了npm包仓库中依赖最多的库。它正在摆脱屌丝身份，成为开发者的常规的选择之一。</p>\n<p>现在我们所熟知的很多开源项目都已经使用或者转到了lodash阵营之上。比如JavaScript转译器Babel、博客平台Ghost，和项目脚手架工具Yeoman。特别Ghost是从Underscore迁移到了lodash，Ghost的创始人John O’Nolan对于此曾评价到：“这是一个非常明智的选择，它几乎完全是由我们开源开发社区推动的。我们发现lodash包含更多的功能，更好的性能、恰到好处地使用了semver，并且在Node.js社区（以及其他依赖）中越来越抢眼“。</p>\n<h4 id=\"lodash演练\"><a href=\"#lodash演练\" class=\"headerlink\" title=\"lodash演练\"></a>lodash演练</h4><p>lodash主要使用了延迟计算，使得lodash其性能远远超过Underscore。在lodash中延迟计算意味着在我们的链式方法在显示或隐式的value()调用之前是不会执行的。由于这种执行的延后，因此lodash可以进行shortcut fusion这样的优化，通过合并链式iteratee大大降低迭代的次数。从而大大提供其执行性能。</p>\n<p>百说不如一练，下面我们以用户信息为例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var users = [</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;barney&apos;,  &apos;age&apos;: 36 &#125;,</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;fred&apos;,    &apos;age&apos;: 40 &#125;,</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;pebbles&apos;, &apos;age&apos;: 18 &#125;</div><div class=\"line\">];</div></pre></td></tr></table></figure></p>\n<p>1.获取所有用户名字，并以”，“分割<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var names = _.chain(users)</div><div class=\"line\">  .map(function(user)&#123;</div><div class=\"line\">    return user.user;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .join(&quot; , &quot;)</div><div class=\"line\">  .value();</div><div class=\"line\">console.log(names);</div></pre></td></tr></table></figure></p>\n<p>在这里首先将users对象包装成为lodash对象，再map获取所有用户的名称，并最后利用join将用户名称以”，“连接在一起。注意这里只是一串方法链，如果你没有显样的调用value方法，使其立即执行的话，你将会得到如下的LodashWrapper延迟表达式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LodashWrapper &#123;__wrapped__: LazyWrapper, __actions__: Array[1], __chain__: true, constructor: function, after: function…&#125;</div></pre></td></tr></table></figure></p>\n<p> 因为延迟表达式的存在，因此我们可以多次增加方法链，但这并不会被执行，所以不会存在性能的问题，最后知道我们需要使用的时候，使用value显式立即执行即可。</p>\n<p>2.获取最年轻的用户<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"> var youngest = _.chain(users)</div><div class=\"line\">  .min(function(user)&#123;</div><div class=\"line\">    return user.age;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .value();</div><div class=\"line\">console.log(youngest);</div></pre></td></tr></table></figure></p>\n<p> 这里利用了lodash提供的min函数可以轻易的解决。min方法可以找到数组中最小的那一项。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">//min使用例子：</div><div class=\"line\">_.min([4, 2, 8, 6]);</div><div class=\"line\">// =&gt; 2</div><div class=\"line\"></div><div class=\"line\">_.min([]);</div><div class=\"line\">// =&gt; Infinity</div><div class=\"line\"></div><div class=\"line\">var users = [</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;barney&apos;, &apos;age&apos;: 36 &#125;,</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;fred&apos;,   &apos;age&apos;: 40 &#125;</div><div class=\"line\">];</div><div class=\"line\"></div><div class=\"line\">_.min(users, function(chr) &#123;</div><div class=\"line\">  return chr.age;</div><div class=\"line\">&#125;);</div><div class=\"line\">// =&gt; &#123; &apos;user&apos;: &apos;barney&apos;, &apos;age&apos;: 36 &#125;</div><div class=\"line\"></div><div class=\"line\">// using the `_.property` callback shorthand</div><div class=\"line\">_.min(users, &apos;age&apos;);</div><div class=\"line\">// =&gt; &#123; &apos;user&apos;: &apos;barney&apos;, &apos;age&apos;: 36 &#125;</div></pre></td></tr></table></figure></p>\n<p> 此处还希望用另外一个方式解释lodash方法链的优化,上面的方法可以等价为下面的方式，以age排序的第一个user：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var youngest2 = _.chain(users)</div><div class=\"line\">  .sortBy(&quot;age&quot;)</div><div class=\"line\">  .map(function(user)&#123;</div><div class=\"line\">    console.log(&quot;map&quot;, user);</div><div class=\"line\">    return user;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .first()</div><div class=\"line\">  .value();</div><div class=\"line\">console.log(youngest2);</div></pre></td></tr></table></figure></p>\n<p> 在这里多加了一个map作为log输出，如果你执行这行代码的时候，你会惊奇的看见这里只会有一个user的输出，这点可以证明在立即执行的时候lodash为我们的方法链做了可靠的优化；如果我们去掉first函数你则会看见有3个user对象的输出。</p>\n<p>3.获取最年长的用户<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var oldest  = _.chain(users)</div><div class=\"line\">  .max(function(user)&#123;</div><div class=\"line\">    return user.age;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .value();</div><div class=\"line\">console.log(oldest );</div></pre></td></tr></table></figure></p>\n<p>这里则使用lodash的max函数。用法同上面的min方法。</p>\n<p>4.用户数组到用户Map的转换</p>\n<p>在开发中我们经常会有把一堆素组形式的数据转换为Object形式的数组，便于根据属性key值查找，下面将以user对象来演示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var userObj = _.chain(users)</div><div class=\"line\">  .map(function(user)&#123;</div><div class=\"line\">    return [user.user, user.age];</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .zipObject()</div><div class=\"line\">  .value();</div><div class=\"line\">console.log(userObj);</div><div class=\"line\">利用lodash首先将user数组map为[key, value]的数组集合，最后利用zipObject将结果转换为Object对象，zipObject会利用结果集的第一项作为key，第二项作为value生产Object。</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//zipObject方法使用如下：</div><div class=\"line\">_.zipObject([[&apos;fred&apos;, 30], [&apos;barney&apos;, 40]]);</div><div class=\"line\">// =&gt; &#123; &apos;fred&apos;: 30, &apos;barney&apos;: 40 &#125;</div><div class=\"line\"></div><div class=\"line\">_.zipObject([&apos;fred&apos;, &apos;barney&apos;], [30, 40]);</div><div class=\"line\">// =&gt; &#123; &apos;fred&apos;: 30, &apos;barney&apos;: 40 &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h4><p>在这里展示知识lodash中很小一部分的API，正如开始所说：lodash是为了提供更多“一致的跨浏览器行为……，并改善性能”API。所有的lodash API你可以在这里<a href=\"https://lodash.com/docs#matches查找。\">https://lodash.com/docs#matches查找。</a></p>\n"},{"title":"Lodash 学习笔记 - Chain 方法","date":"2017-01-11T03:23:52.000Z","_content":"#### Chain\n可以说是 lodash 中最为重要的部件，想要用lodash进行复杂的多步操作都离不开chain的帮助。\n首先说说Chain的调用方式有两种：一种是显式调用(Explicit Chaining)，一种是隐式调用(Implicit Chaining)。\n```\n//显式调用例子如下:\n//下面的例子采用了ECMAScript2015的语法：\nlet numbers = [1, 2, 3, 4, 5];\nlet sumOfEvenSquares = _.chain(numbers) //注意numbers放置的位置\n    .filter(n => n % 2 === 0)\n    .map(n => n * n)\n    .sum()\n    .value();    \n//sumOfEvenSquares: 20\n//特别要注意结尾的那个.value()\n```\n```\n//隐式调用例子如下：\nlet sumOfEvenSquares = _(numbers) //注意numbers的位置，不需要显式的使用chain关键字\n    .filter(n => n % 2 === 0)\n    .map(n => n * n)\n    .sum()\n```\n```\n//隐式调用另一个写法：\nlet isEven = n => n % 2 === 0;\nlet square = n => n * n;\nlet sumOfEvenSquares = _(numbers).filter(isEven).map(square).sum();\n```\n为什么要多出来一个 .value()，而不是直接出结果呢？那是因为可能要等待延时(Deferred execution)数据的到来，再执行取值。这就是我们常说的Lazy evaluation （延迟计算/惰性求值）\n```\n//如下面的例子：首先生成链式表达式\nvar wallet = _(assets).filter(ownedBy('me'))\n                      .pluck('value')\n                      .reduce(sum);\n\n$json.get(\"/new/assets\").success(function(data) {\n    assets.push.apply(assets, data);     // 然后更新数据\n    wallet.value();                      // 最后求值\n});\n```\n#### _(value)\n参数:value (*) : 待包装至 lodash 实例的值\n返回:(Object) : 返回一个新的 lodash 包装集实例\n\n创建一个包含 value 的 lodash 对象以开启内置的方法链。方法链对返回数组、集合或函数的方法产生作用，并且方法可以被链式调用。那些获取单值或可能返回一个原始值的方法将自动结束方法链并且返回一个未包裹成 lodash 对象的值。如果明确需要链式调用可以使用 _.chain。而显式链则用_.chain的方式实现延迟计算，即：求值操作等到 .value()被调用时再执行。\n\n延迟计算支持一些方法快速合并。快速合并是一个最优合并迭代器调用的策略。这样做可以帮助避免一些计算中间生成的数据结构，并且能够大大降低迭代器的执行次数。\n```\nvar wrapped = _([1, 2, 3]);\n\n// 返回一个未包装的值\nwrapped.reduce(function(total, n) {\n  return total + n;// JavaScript 数组reduce()方法同时应用一个函数针对数组的两个值(从左到右)，以减至一个值。\n});\n// → 6\n\n// 返回一个包装值\nvar squares = wrapped.map(function(n) {\n  return n * n;\n});\n\n_.isArray(squares);\n// → false\n\n_.isArray(squares.value());\n// → true\n```\n\n#### _.chain(value)\n参数:value (*) : 待包装的值\n返回:(Object) : 返回一个新的 lodash 包装实例\n创建一个明确能够被链式调用的 lodash 对象.\n```\nvar users = [\n  { 'user': 'barney',  'age': 36 },\n  { 'user': 'fred',    'age': 40 },\n  { 'user': 'pebbles', 'age': 1 }\n];\n\nvar youngest = _.chain(users)\n  .sortBy('age')\n  .map(function(chr) {\n    return chr.user + ' is ' + chr.age;\n  })\n  .first()\n  .value();\n// → 'pebbles is 1'\n```\n\n","source":"_posts/lodash-chain.md","raw":"---\ntitle: Lodash 学习笔记 - Chain 方法\ndate: 2017-01-11 11:23:52\ntags: lodash chain\n---\n#### Chain\n可以说是 lodash 中最为重要的部件，想要用lodash进行复杂的多步操作都离不开chain的帮助。\n首先说说Chain的调用方式有两种：一种是显式调用(Explicit Chaining)，一种是隐式调用(Implicit Chaining)。\n```\n//显式调用例子如下:\n//下面的例子采用了ECMAScript2015的语法：\nlet numbers = [1, 2, 3, 4, 5];\nlet sumOfEvenSquares = _.chain(numbers) //注意numbers放置的位置\n    .filter(n => n % 2 === 0)\n    .map(n => n * n)\n    .sum()\n    .value();    \n//sumOfEvenSquares: 20\n//特别要注意结尾的那个.value()\n```\n```\n//隐式调用例子如下：\nlet sumOfEvenSquares = _(numbers) //注意numbers的位置，不需要显式的使用chain关键字\n    .filter(n => n % 2 === 0)\n    .map(n => n * n)\n    .sum()\n```\n```\n//隐式调用另一个写法：\nlet isEven = n => n % 2 === 0;\nlet square = n => n * n;\nlet sumOfEvenSquares = _(numbers).filter(isEven).map(square).sum();\n```\n为什么要多出来一个 .value()，而不是直接出结果呢？那是因为可能要等待延时(Deferred execution)数据的到来，再执行取值。这就是我们常说的Lazy evaluation （延迟计算/惰性求值）\n```\n//如下面的例子：首先生成链式表达式\nvar wallet = _(assets).filter(ownedBy('me'))\n                      .pluck('value')\n                      .reduce(sum);\n\n$json.get(\"/new/assets\").success(function(data) {\n    assets.push.apply(assets, data);     // 然后更新数据\n    wallet.value();                      // 最后求值\n});\n```\n#### _(value)\n参数:value (*) : 待包装至 lodash 实例的值\n返回:(Object) : 返回一个新的 lodash 包装集实例\n\n创建一个包含 value 的 lodash 对象以开启内置的方法链。方法链对返回数组、集合或函数的方法产生作用，并且方法可以被链式调用。那些获取单值或可能返回一个原始值的方法将自动结束方法链并且返回一个未包裹成 lodash 对象的值。如果明确需要链式调用可以使用 _.chain。而显式链则用_.chain的方式实现延迟计算，即：求值操作等到 .value()被调用时再执行。\n\n延迟计算支持一些方法快速合并。快速合并是一个最优合并迭代器调用的策略。这样做可以帮助避免一些计算中间生成的数据结构，并且能够大大降低迭代器的执行次数。\n```\nvar wrapped = _([1, 2, 3]);\n\n// 返回一个未包装的值\nwrapped.reduce(function(total, n) {\n  return total + n;// JavaScript 数组reduce()方法同时应用一个函数针对数组的两个值(从左到右)，以减至一个值。\n});\n// → 6\n\n// 返回一个包装值\nvar squares = wrapped.map(function(n) {\n  return n * n;\n});\n\n_.isArray(squares);\n// → false\n\n_.isArray(squares.value());\n// → true\n```\n\n#### _.chain(value)\n参数:value (*) : 待包装的值\n返回:(Object) : 返回一个新的 lodash 包装实例\n创建一个明确能够被链式调用的 lodash 对象.\n```\nvar users = [\n  { 'user': 'barney',  'age': 36 },\n  { 'user': 'fred',    'age': 40 },\n  { 'user': 'pebbles', 'age': 1 }\n];\n\nvar youngest = _.chain(users)\n  .sortBy('age')\n  .map(function(chr) {\n    return chr.user + ' is ' + chr.age;\n  })\n  .first()\n  .value();\n// → 'pebbles is 1'\n```\n\n","slug":"lodash-chain","published":1,"updated":"2017-01-11T03:54:36.861Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixtsysvj0003pktu5uf51ejp","content":"<h4 id=\"Chain\"><a href=\"#Chain\" class=\"headerlink\" title=\"Chain\"></a>Chain</h4><p>可以说是 lodash 中最为重要的部件，想要用lodash进行复杂的多步操作都离不开chain的帮助。<br>首先说说Chain的调用方式有两种：一种是显式调用(Explicit Chaining)，一种是隐式调用(Implicit Chaining)。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//显式调用例子如下:</div><div class=\"line\">//下面的例子采用了ECMAScript2015的语法：</div><div class=\"line\">let numbers = [1, 2, 3, 4, 5];</div><div class=\"line\">let sumOfEvenSquares = _.chain(numbers) //注意numbers放置的位置</div><div class=\"line\">    .filter(n =&gt; n % 2 === 0)</div><div class=\"line\">    .map(n =&gt; n * n)</div><div class=\"line\">    .sum()</div><div class=\"line\">    .value();    </div><div class=\"line\">//sumOfEvenSquares: 20</div><div class=\"line\">//特别要注意结尾的那个.value()</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//隐式调用例子如下：</div><div class=\"line\">let sumOfEvenSquares = _(numbers) //注意numbers的位置，不需要显式的使用chain关键字</div><div class=\"line\">    .filter(n =&gt; n % 2 === 0)</div><div class=\"line\">    .map(n =&gt; n * n)</div><div class=\"line\">    .sum()</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//隐式调用另一个写法：</div><div class=\"line\">let isEven = n =&gt; n % 2 === 0;</div><div class=\"line\">let square = n =&gt; n * n;</div><div class=\"line\">let sumOfEvenSquares = _(numbers).filter(isEven).map(square).sum();</div></pre></td></tr></table></figure>\n<p>为什么要多出来一个 .value()，而不是直接出结果呢？那是因为可能要等待延时(Deferred execution)数据的到来，再执行取值。这就是我们常说的Lazy evaluation （延迟计算/惰性求值）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//如下面的例子：首先生成链式表达式</div><div class=\"line\">var wallet = _(assets).filter(ownedBy(&apos;me&apos;))</div><div class=\"line\">                      .pluck(&apos;value&apos;)</div><div class=\"line\">                      .reduce(sum);</div><div class=\"line\"></div><div class=\"line\">$json.get(&quot;/new/assets&quot;).success(function(data) &#123;</div><div class=\"line\">    assets.push.apply(assets, data);     // 然后更新数据</div><div class=\"line\">    wallet.value();                      // 最后求值</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"value\"><a href=\"#value\" class=\"headerlink\" title=\"_(value)\"></a>_(value)</h4><p>参数:value (*) : 待包装至 lodash 实例的值<br>返回:(Object) : 返回一个新的 lodash 包装集实例</p>\n<p>创建一个包含 value 的 lodash 对象以开启内置的方法链。方法链对返回数组、集合或函数的方法产生作用，并且方法可以被链式调用。那些获取单值或可能返回一个原始值的方法将自动结束方法链并且返回一个未包裹成 lodash 对象的值。如果明确需要链式调用可以使用 <em>.chain。而显式链则用</em>.chain的方式实现延迟计算，即：求值操作等到 .value()被调用时再执行。</p>\n<p>延迟计算支持一些方法快速合并。快速合并是一个最优合并迭代器调用的策略。这样做可以帮助避免一些计算中间生成的数据结构，并且能够大大降低迭代器的执行次数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var wrapped = _([1, 2, 3]);</div><div class=\"line\"></div><div class=\"line\">// 返回一个未包装的值</div><div class=\"line\">wrapped.reduce(function(total, n) &#123;</div><div class=\"line\">  return total + n;// JavaScript 数组reduce()方法同时应用一个函数针对数组的两个值(从左到右)，以减至一个值。</div><div class=\"line\">&#125;);</div><div class=\"line\">// → 6</div><div class=\"line\"></div><div class=\"line\">// 返回一个包装值</div><div class=\"line\">var squares = wrapped.map(function(n) &#123;</div><div class=\"line\">  return n * n;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">_.isArray(squares);</div><div class=\"line\">// → false</div><div class=\"line\"></div><div class=\"line\">_.isArray(squares.value());</div><div class=\"line\">// → true</div></pre></td></tr></table></figure></p>\n<h4 id=\"chain-value\"><a href=\"#chain-value\" class=\"headerlink\" title=\"_.chain(value)\"></a>_.chain(value)</h4><p>参数:value (*) : 待包装的值<br>返回:(Object) : 返回一个新的 lodash 包装实例<br>创建一个明确能够被链式调用的 lodash 对象.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var users = [</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;barney&apos;,  &apos;age&apos;: 36 &#125;,</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;fred&apos;,    &apos;age&apos;: 40 &#125;,</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;pebbles&apos;, &apos;age&apos;: 1 &#125;</div><div class=\"line\">];</div><div class=\"line\"></div><div class=\"line\">var youngest = _.chain(users)</div><div class=\"line\">  .sortBy(&apos;age&apos;)</div><div class=\"line\">  .map(function(chr) &#123;</div><div class=\"line\">    return chr.user + &apos; is &apos; + chr.age;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .first()</div><div class=\"line\">  .value();</div><div class=\"line\">// → &apos;pebbles is 1&apos;</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<h4 id=\"Chain\"><a href=\"#Chain\" class=\"headerlink\" title=\"Chain\"></a>Chain</h4><p>可以说是 lodash 中最为重要的部件，想要用lodash进行复杂的多步操作都离不开chain的帮助。<br>首先说说Chain的调用方式有两种：一种是显式调用(Explicit Chaining)，一种是隐式调用(Implicit Chaining)。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//显式调用例子如下:</div><div class=\"line\">//下面的例子采用了ECMAScript2015的语法：</div><div class=\"line\">let numbers = [1, 2, 3, 4, 5];</div><div class=\"line\">let sumOfEvenSquares = _.chain(numbers) //注意numbers放置的位置</div><div class=\"line\">    .filter(n =&gt; n % 2 === 0)</div><div class=\"line\">    .map(n =&gt; n * n)</div><div class=\"line\">    .sum()</div><div class=\"line\">    .value();    </div><div class=\"line\">//sumOfEvenSquares: 20</div><div class=\"line\">//特别要注意结尾的那个.value()</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//隐式调用例子如下：</div><div class=\"line\">let sumOfEvenSquares = _(numbers) //注意numbers的位置，不需要显式的使用chain关键字</div><div class=\"line\">    .filter(n =&gt; n % 2 === 0)</div><div class=\"line\">    .map(n =&gt; n * n)</div><div class=\"line\">    .sum()</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//隐式调用另一个写法：</div><div class=\"line\">let isEven = n =&gt; n % 2 === 0;</div><div class=\"line\">let square = n =&gt; n * n;</div><div class=\"line\">let sumOfEvenSquares = _(numbers).filter(isEven).map(square).sum();</div></pre></td></tr></table></figure>\n<p>为什么要多出来一个 .value()，而不是直接出结果呢？那是因为可能要等待延时(Deferred execution)数据的到来，再执行取值。这就是我们常说的Lazy evaluation （延迟计算/惰性求值）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//如下面的例子：首先生成链式表达式</div><div class=\"line\">var wallet = _(assets).filter(ownedBy(&apos;me&apos;))</div><div class=\"line\">                      .pluck(&apos;value&apos;)</div><div class=\"line\">                      .reduce(sum);</div><div class=\"line\"></div><div class=\"line\">$json.get(&quot;/new/assets&quot;).success(function(data) &#123;</div><div class=\"line\">    assets.push.apply(assets, data);     // 然后更新数据</div><div class=\"line\">    wallet.value();                      // 最后求值</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"value\"><a href=\"#value\" class=\"headerlink\" title=\"_(value)\"></a>_(value)</h4><p>参数:value (*) : 待包装至 lodash 实例的值<br>返回:(Object) : 返回一个新的 lodash 包装集实例</p>\n<p>创建一个包含 value 的 lodash 对象以开启内置的方法链。方法链对返回数组、集合或函数的方法产生作用，并且方法可以被链式调用。那些获取单值或可能返回一个原始值的方法将自动结束方法链并且返回一个未包裹成 lodash 对象的值。如果明确需要链式调用可以使用 <em>.chain。而显式链则用</em>.chain的方式实现延迟计算，即：求值操作等到 .value()被调用时再执行。</p>\n<p>延迟计算支持一些方法快速合并。快速合并是一个最优合并迭代器调用的策略。这样做可以帮助避免一些计算中间生成的数据结构，并且能够大大降低迭代器的执行次数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var wrapped = _([1, 2, 3]);</div><div class=\"line\"></div><div class=\"line\">// 返回一个未包装的值</div><div class=\"line\">wrapped.reduce(function(total, n) &#123;</div><div class=\"line\">  return total + n;// JavaScript 数组reduce()方法同时应用一个函数针对数组的两个值(从左到右)，以减至一个值。</div><div class=\"line\">&#125;);</div><div class=\"line\">// → 6</div><div class=\"line\"></div><div class=\"line\">// 返回一个包装值</div><div class=\"line\">var squares = wrapped.map(function(n) &#123;</div><div class=\"line\">  return n * n;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">_.isArray(squares);</div><div class=\"line\">// → false</div><div class=\"line\"></div><div class=\"line\">_.isArray(squares.value());</div><div class=\"line\">// → true</div></pre></td></tr></table></figure></p>\n<h4 id=\"chain-value\"><a href=\"#chain-value\" class=\"headerlink\" title=\"_.chain(value)\"></a>_.chain(value)</h4><p>参数:value (*) : 待包装的值<br>返回:(Object) : 返回一个新的 lodash 包装实例<br>创建一个明确能够被链式调用的 lodash 对象.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var users = [</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;barney&apos;,  &apos;age&apos;: 36 &#125;,</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;fred&apos;,    &apos;age&apos;: 40 &#125;,</div><div class=\"line\">  &#123; &apos;user&apos;: &apos;pebbles&apos;, &apos;age&apos;: 1 &#125;</div><div class=\"line\">];</div><div class=\"line\"></div><div class=\"line\">var youngest = _.chain(users)</div><div class=\"line\">  .sortBy(&apos;age&apos;)</div><div class=\"line\">  .map(function(chr) &#123;</div><div class=\"line\">    return chr.user + &apos; is &apos; + chr.age;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .first()</div><div class=\"line\">  .value();</div><div class=\"line\">// → &apos;pebbles is 1&apos;</div></pre></td></tr></table></figure></p>\n"},{"title":"Node.js 面试问题及答案","date":"2017-01-11T09:21:52.000Z","_content":"#### Node.js 面试问题预览(来源于网络)\n- 什么是 error-first 回调模式？\n- 如何避免“回调地狱”？\n- 什么是 Promises？\n- 什么工具统一团队的代码风格？为什么统一的代码风格很重要？\n- 什么时候应当用 npm？什么时候应当用 yarn？\n- 什么是桩代码（stub）？ 请描述一个应用场景！\n- 什么是测试金字塔？请举例说明！\n- 你最欣赏的 HTTP 框架是什么？为什么？\n- 如果保证你的 cookie 安全？如何阻止 XSS 攻击？\n- 如何确认项目的相关依赖安全？\n#### 什么是 error-first 回调模式？\n应用 error-first 回调模式是为了更好的进行错误和数据的传递。第一个参数保留给一个错误 error 对象，一旦出错，错误将通过第一个参数 error 返回。其余的参数将用作数据的传递。\n```\nfs.readFile(filePath,function (err,data) {\n    if(err){\n        //handle the error code.\n        return console.log(err);\n    }\n    console.log(data);\n});\n```\n\n#### 如何避免“回调地狱”?\n解决这个问题的方法有很多:\n\n- 模块化设计: 讲回调拆分成几个独立的函数\n- 使用 流程控制库, 比如 async\n- 组合使用 generators 和 Promises\n- 使用 async/await 函数 (只能在Node v7 release版本运行， Node LTS版本尚不支持 )\n\n#### 什么是 Promises?\npromise的概念早在上个世纪八十年代就被提出，现在已经是大多数现代编程语言中支持的特性，让你能更轻松地实现异步模型。\n\n举个简单的例子, 正常来说100ms 之后将会输出 result 。一旦失败, catch可以抛出异常。Promises允许链式操作。\n```\nnew Promise(()=>{\n    setTimeout(()=>{\n        resolve('result')\n    },100)})\n    .then((data)=>{\n        console.log(data);\n    })\n    .catch();\n```\n#### 什么工具统一团队的代码风格? 为什么统一的代码风格很重要？\n\n团队协作时，始终如一的代码风格十分重要，代码风格一致，团队成员可以更轻松的构建项目，不用为每次构建项目都使用新的代码风格而担心。\n同时, 始终如一的代码风格，可以通过静态分析排除代码问题。\n\n帮助规范代码的工具: 1.ESLint 2.Standard\n如果你想更上一层楼，可以学习 JavaScript Clean Coding 原则。\n\n#### 什么时候应当用 npm？什么时候应当用 yarn？\n相同点：都是javascript包管理器。\nyarn 解决了npm历史遗留下来的痛点。\nyarn特点：多平台精确校准，只要将yarn.lock保存到源码库里，在任何地方用yarn安装，版本都不会偏差。从而避免了package.json原来经常出现小版本差异而导致程序无法正常运行的情况。\n缓存已经下载过的包，避免重复下载\n下载前会检查签名及包的完整性\n可靠可确定性，保证各平台依赖的一致性\n网络优化，力求网络资源最大利用化，让资源下载完美队列执行，避免大量的无用请求，下载失败会自动重新请求，避免整个安装过程失败\n扁平化模式，对于不匹配的依赖版本的包创立一个独立的包，避免创建重复的。（可以做个测试当时加载某个项目 用了86秒，后面又用npm测试，用了 190秒，之后在用yarn.lock 的情况下，加载用了46秒）\n\n#### 什么是桩代码（stub）? 请描述一个应用场景！\n桩代码（stub）就是在某些组件或模块中，模拟某些功能的代码。桩代码（stub）的作用是占位，让代码在测试过程中顺利运行。\n\n一个例子，它实际的作用是写一个文件，但是这段代码并没有真正的做这件事。\n```\nvar fs = require('fs');\nvar writeFileStub = sinon.stub(fs,'writeFile',function (path,data,cb) {\n    return cb(null);\n});\nexpect(writeFileStub).to.be.called\nwriteFileStub.restore();\n```\n#### 什么是测试金字塔？请举例说明！\n测试金字塔描述了单元测试（unit test），集成测试（integration tests），端到端测试（end-to-end test）在测试中占的比例。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/testjinzita.jpg-public)\n</div>\n\n举个例子，测试一个 HTTP API 需要:\n1.大量关于 models 的单元测试(使用桩代码处理),\n2.一些关于 models 如何和其他 models 交互的集成测试 (未使用桩代码处理),\n3.少量的端到端测试，也就是真实环境下的调用 ( 未使用桩代码处理).\n\n#### 你最欣赏的 HTTP 框架是什么？为什么？\n这道题没有标准答案。出这道题的目的是，看看面试者对他所使用框架，理解的有多深。只要面试者回答出框架的优缺点，为什么使用这个框架就可以了。\n\n#### 什么时候应该在后台进程中使用消息服务？怎么处理工作线程的任务/怎么给 worker 安排任务？\n消息队列适用于后台数据传输服务，比如发送邮件和数据图像处理。\n\n消息队列有很多解决方案，比如 RabbitMQ 和 Kafka.\n\n#### 如何保证你的 cookie 安全？如何阻止 XSS 攻击？\n\nXSS 攻击是指攻击者向Html页面里插入恶意 JavaScript 代码。\n\n为了防止攻击，你需要对 HTTP header 里的 set-cookie 进行处理:\n1、HttpOnly - 这个属性帮助防止跨站脚本攻击，它禁止通过 JavaScript 访问 cookie。\n2、secure - 这个属性告诉浏览器，仅允许通过 HTTPS 协议访问 cookie。\n\n所以，你需要做的是在请求头里写 Set-Cookie: sid=; HttpOnly。如果你正在使用 Express 框架，可以使用 express-cookie session，他会默认做出上述防止 XSS 攻击的设置。\n\n#### 如何确认项目的相关依赖安全？\n使用 Node.js 开发, 很容易出现有成百上千个依赖的情况。\n\n举例来说，如果你依赖 Express，准确的说这意味着也依赖 27 个其他的模块 , 手动检测更新这些模块不是一个正确的选择！\n\n唯一的选择就是自动的安全的更新你的依赖，你有如下免费或付费的选择：\n1、pm outdated\n2、race by RisingStack\n3、SP\n4、reenKeeper\n5、nyk\n#### 下面的代码有什么错误？\n```\nnew Promise((resolve,reject)=>{\n    throw new Error('error')\n}).then(console.log)\n//在 then 后没有 catch ，没有捕捉异常。这样做会造成故障沉默，不会抛出异常。\n//如果你调试一个巨大的代码库，并且不知道哪个 Promise 函数有潜在的问题, 你可以使用 unhandledRejection 这个工具。它将会打印出所有未处理的 reject 状态的 Promise。\nprocess.on('unhandleRejection',(err)=>{\n    console.log(err);\n})\n```\n```\nfunction checkApiKey(apiKeyFromDb,apiKeyReceived) {\n    if(apiKeyFromDb===apiKeyReceived){\n        return true;\n    }\n    return false;\n}\n//在进行数据校验(security credentials)时，避免任何信息泄露是最重要的。所以，我们要控制数据校验的执行时间。我们要保证，不管传过来的数据是什么，我们校验数据消耗的时间是相同的。如果你做不到这一点，你的程序对时序攻击的抵抗力很低。\n\n为什么会有这种现象?\nNode.js 使用 JavaScript V8 引擎, 为了高速运行网页而开发的，性能优异。 V8 引擎比较数据的方式是字节比较, 一旦发现有一个字节不一致, 比较运算就会停止。 因此，攻击者传入的 password 校验时间越长，说明明 password 正确的部分越多。\n为了修复这个问题, 你可以使用 npm 模块 cryptiles。\n\nfunction checkApiKey(apiKeyFromDb,apiKeyReceived) {\n    return cryptiles.fixedTimeComparison(apiKeyFromDb,apiKeyReceived)\n}\n```\n```\n下面这段代码输出的是什么?\nPromise.resolve(1)\n    .then((x)=>x+1)\n    .then((x)=>{throw new Error('My Error')})\n    .catch(()=>1)\n    .then((x)=>x+1)\n    .then((x)=>console.log(x))\n    .catch(console.error)\n答案是 2. 每行代码对应解释如下：\n创建一个 Promise 对象，输出 1\n创建一个 Promise 对象，输出 1\n结果 +1，现在的输出为2\n输出结果被抛弃，抛出一个 error\nerror 被丢弃, 返回一个新的 value (1)\ncatch 进行异常处理，但 catch 后程序不停止执行, 返回一个信息+1之后的 value (2)\nvalue 正常输出\nvalue 已正常输出，这一行不会执行\n```","source":"_posts/node-interview.md","raw":"---\ntitle: Node.js 面试问题及答案\ndate: 2017-01-11 17:21:52\ntags: nodejs\n---\n#### Node.js 面试问题预览(来源于网络)\n- 什么是 error-first 回调模式？\n- 如何避免“回调地狱”？\n- 什么是 Promises？\n- 什么工具统一团队的代码风格？为什么统一的代码风格很重要？\n- 什么时候应当用 npm？什么时候应当用 yarn？\n- 什么是桩代码（stub）？ 请描述一个应用场景！\n- 什么是测试金字塔？请举例说明！\n- 你最欣赏的 HTTP 框架是什么？为什么？\n- 如果保证你的 cookie 安全？如何阻止 XSS 攻击？\n- 如何确认项目的相关依赖安全？\n#### 什么是 error-first 回调模式？\n应用 error-first 回调模式是为了更好的进行错误和数据的传递。第一个参数保留给一个错误 error 对象，一旦出错，错误将通过第一个参数 error 返回。其余的参数将用作数据的传递。\n```\nfs.readFile(filePath,function (err,data) {\n    if(err){\n        //handle the error code.\n        return console.log(err);\n    }\n    console.log(data);\n});\n```\n\n#### 如何避免“回调地狱”?\n解决这个问题的方法有很多:\n\n- 模块化设计: 讲回调拆分成几个独立的函数\n- 使用 流程控制库, 比如 async\n- 组合使用 generators 和 Promises\n- 使用 async/await 函数 (只能在Node v7 release版本运行， Node LTS版本尚不支持 )\n\n#### 什么是 Promises?\npromise的概念早在上个世纪八十年代就被提出，现在已经是大多数现代编程语言中支持的特性，让你能更轻松地实现异步模型。\n\n举个简单的例子, 正常来说100ms 之后将会输出 result 。一旦失败, catch可以抛出异常。Promises允许链式操作。\n```\nnew Promise(()=>{\n    setTimeout(()=>{\n        resolve('result')\n    },100)})\n    .then((data)=>{\n        console.log(data);\n    })\n    .catch();\n```\n#### 什么工具统一团队的代码风格? 为什么统一的代码风格很重要？\n\n团队协作时，始终如一的代码风格十分重要，代码风格一致，团队成员可以更轻松的构建项目，不用为每次构建项目都使用新的代码风格而担心。\n同时, 始终如一的代码风格，可以通过静态分析排除代码问题。\n\n帮助规范代码的工具: 1.ESLint 2.Standard\n如果你想更上一层楼，可以学习 JavaScript Clean Coding 原则。\n\n#### 什么时候应当用 npm？什么时候应当用 yarn？\n相同点：都是javascript包管理器。\nyarn 解决了npm历史遗留下来的痛点。\nyarn特点：多平台精确校准，只要将yarn.lock保存到源码库里，在任何地方用yarn安装，版本都不会偏差。从而避免了package.json原来经常出现小版本差异而导致程序无法正常运行的情况。\n缓存已经下载过的包，避免重复下载\n下载前会检查签名及包的完整性\n可靠可确定性，保证各平台依赖的一致性\n网络优化，力求网络资源最大利用化，让资源下载完美队列执行，避免大量的无用请求，下载失败会自动重新请求，避免整个安装过程失败\n扁平化模式，对于不匹配的依赖版本的包创立一个独立的包，避免创建重复的。（可以做个测试当时加载某个项目 用了86秒，后面又用npm测试，用了 190秒，之后在用yarn.lock 的情况下，加载用了46秒）\n\n#### 什么是桩代码（stub）? 请描述一个应用场景！\n桩代码（stub）就是在某些组件或模块中，模拟某些功能的代码。桩代码（stub）的作用是占位，让代码在测试过程中顺利运行。\n\n一个例子，它实际的作用是写一个文件，但是这段代码并没有真正的做这件事。\n```\nvar fs = require('fs');\nvar writeFileStub = sinon.stub(fs,'writeFile',function (path,data,cb) {\n    return cb(null);\n});\nexpect(writeFileStub).to.be.called\nwriteFileStub.restore();\n```\n#### 什么是测试金字塔？请举例说明！\n测试金字塔描述了单元测试（unit test），集成测试（integration tests），端到端测试（end-to-end test）在测试中占的比例。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/testjinzita.jpg-public)\n</div>\n\n举个例子，测试一个 HTTP API 需要:\n1.大量关于 models 的单元测试(使用桩代码处理),\n2.一些关于 models 如何和其他 models 交互的集成测试 (未使用桩代码处理),\n3.少量的端到端测试，也就是真实环境下的调用 ( 未使用桩代码处理).\n\n#### 你最欣赏的 HTTP 框架是什么？为什么？\n这道题没有标准答案。出这道题的目的是，看看面试者对他所使用框架，理解的有多深。只要面试者回答出框架的优缺点，为什么使用这个框架就可以了。\n\n#### 什么时候应该在后台进程中使用消息服务？怎么处理工作线程的任务/怎么给 worker 安排任务？\n消息队列适用于后台数据传输服务，比如发送邮件和数据图像处理。\n\n消息队列有很多解决方案，比如 RabbitMQ 和 Kafka.\n\n#### 如何保证你的 cookie 安全？如何阻止 XSS 攻击？\n\nXSS 攻击是指攻击者向Html页面里插入恶意 JavaScript 代码。\n\n为了防止攻击，你需要对 HTTP header 里的 set-cookie 进行处理:\n1、HttpOnly - 这个属性帮助防止跨站脚本攻击，它禁止通过 JavaScript 访问 cookie。\n2、secure - 这个属性告诉浏览器，仅允许通过 HTTPS 协议访问 cookie。\n\n所以，你需要做的是在请求头里写 Set-Cookie: sid=; HttpOnly。如果你正在使用 Express 框架，可以使用 express-cookie session，他会默认做出上述防止 XSS 攻击的设置。\n\n#### 如何确认项目的相关依赖安全？\n使用 Node.js 开发, 很容易出现有成百上千个依赖的情况。\n\n举例来说，如果你依赖 Express，准确的说这意味着也依赖 27 个其他的模块 , 手动检测更新这些模块不是一个正确的选择！\n\n唯一的选择就是自动的安全的更新你的依赖，你有如下免费或付费的选择：\n1、pm outdated\n2、race by RisingStack\n3、SP\n4、reenKeeper\n5、nyk\n#### 下面的代码有什么错误？\n```\nnew Promise((resolve,reject)=>{\n    throw new Error('error')\n}).then(console.log)\n//在 then 后没有 catch ，没有捕捉异常。这样做会造成故障沉默，不会抛出异常。\n//如果你调试一个巨大的代码库，并且不知道哪个 Promise 函数有潜在的问题, 你可以使用 unhandledRejection 这个工具。它将会打印出所有未处理的 reject 状态的 Promise。\nprocess.on('unhandleRejection',(err)=>{\n    console.log(err);\n})\n```\n```\nfunction checkApiKey(apiKeyFromDb,apiKeyReceived) {\n    if(apiKeyFromDb===apiKeyReceived){\n        return true;\n    }\n    return false;\n}\n//在进行数据校验(security credentials)时，避免任何信息泄露是最重要的。所以，我们要控制数据校验的执行时间。我们要保证，不管传过来的数据是什么，我们校验数据消耗的时间是相同的。如果你做不到这一点，你的程序对时序攻击的抵抗力很低。\n\n为什么会有这种现象?\nNode.js 使用 JavaScript V8 引擎, 为了高速运行网页而开发的，性能优异。 V8 引擎比较数据的方式是字节比较, 一旦发现有一个字节不一致, 比较运算就会停止。 因此，攻击者传入的 password 校验时间越长，说明明 password 正确的部分越多。\n为了修复这个问题, 你可以使用 npm 模块 cryptiles。\n\nfunction checkApiKey(apiKeyFromDb,apiKeyReceived) {\n    return cryptiles.fixedTimeComparison(apiKeyFromDb,apiKeyReceived)\n}\n```\n```\n下面这段代码输出的是什么?\nPromise.resolve(1)\n    .then((x)=>x+1)\n    .then((x)=>{throw new Error('My Error')})\n    .catch(()=>1)\n    .then((x)=>x+1)\n    .then((x)=>console.log(x))\n    .catch(console.error)\n答案是 2. 每行代码对应解释如下：\n创建一个 Promise 对象，输出 1\n创建一个 Promise 对象，输出 1\n结果 +1，现在的输出为2\n输出结果被抛弃，抛出一个 error\nerror 被丢弃, 返回一个新的 value (1)\ncatch 进行异常处理，但 catch 后程序不停止执行, 返回一个信息+1之后的 value (2)\nvalue 正常输出\nvalue 已正常输出，这一行不会执行\n```","slug":"node-interview","published":1,"updated":"2017-01-12T02:50:11.777Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixtsysvm0004pktuzafgot5w","content":"<h4 id=\"Node-js-面试问题预览-来源于网络\"><a href=\"#Node-js-面试问题预览-来源于网络\" class=\"headerlink\" title=\"Node.js 面试问题预览(来源于网络)\"></a>Node.js 面试问题预览(来源于网络)</h4><ul>\n<li>什么是 error-first 回调模式？</li>\n<li>如何避免“回调地狱”？</li>\n<li>什么是 Promises？</li>\n<li>什么工具统一团队的代码风格？为什么统一的代码风格很重要？</li>\n<li>什么时候应当用 npm？什么时候应当用 yarn？</li>\n<li>什么是桩代码（stub）？ 请描述一个应用场景！</li>\n<li>什么是测试金字塔？请举例说明！</li>\n<li>你最欣赏的 HTTP 框架是什么？为什么？</li>\n<li>如果保证你的 cookie 安全？如何阻止 XSS 攻击？</li>\n<li>如何确认项目的相关依赖安全？<h4 id=\"什么是-error-first-回调模式？\"><a href=\"#什么是-error-first-回调模式？\" class=\"headerlink\" title=\"什么是 error-first 回调模式？\"></a>什么是 error-first 回调模式？</h4>应用 error-first 回调模式是为了更好的进行错误和数据的传递。第一个参数保留给一个错误 error 对象，一旦出错，错误将通过第一个参数 error 返回。其余的参数将用作数据的传递。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">fs.readFile(filePath,function (err,data) &#123;</div><div class=\"line\">    if(err)&#123;</div><div class=\"line\">        //handle the error code.</div><div class=\"line\">        return console.log(err);</div><div class=\"line\">    &#125;</div><div class=\"line\">    console.log(data);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"如何避免“回调地狱”\"><a href=\"#如何避免“回调地狱”\" class=\"headerlink\" title=\"如何避免“回调地狱”?\"></a>如何避免“回调地狱”?</h4><p>解决这个问题的方法有很多:</p>\n<ul>\n<li>模块化设计: 讲回调拆分成几个独立的函数</li>\n<li>使用 流程控制库, 比如 async</li>\n<li>组合使用 generators 和 Promises</li>\n<li>使用 async/await 函数 (只能在Node v7 release版本运行， Node LTS版本尚不支持 )</li>\n</ul>\n<h4 id=\"什么是-Promises\"><a href=\"#什么是-Promises\" class=\"headerlink\" title=\"什么是 Promises?\"></a>什么是 Promises?</h4><p>promise的概念早在上个世纪八十年代就被提出，现在已经是大多数现代编程语言中支持的特性，让你能更轻松地实现异步模型。</p>\n<p>举个简单的例子, 正常来说100ms 之后将会输出 result 。一旦失败, catch可以抛出异常。Promises允许链式操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">new Promise(()=&gt;&#123;</div><div class=\"line\">    setTimeout(()=&gt;&#123;</div><div class=\"line\">        resolve(&apos;result&apos;)</div><div class=\"line\">    &#125;,100)&#125;)</div><div class=\"line\">    .then((data)=&gt;&#123;</div><div class=\"line\">        console.log(data);</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .catch();</div></pre></td></tr></table></figure></p>\n<h4 id=\"什么工具统一团队的代码风格-为什么统一的代码风格很重要？\"><a href=\"#什么工具统一团队的代码风格-为什么统一的代码风格很重要？\" class=\"headerlink\" title=\"什么工具统一团队的代码风格? 为什么统一的代码风格很重要？\"></a>什么工具统一团队的代码风格? 为什么统一的代码风格很重要？</h4><p>团队协作时，始终如一的代码风格十分重要，代码风格一致，团队成员可以更轻松的构建项目，不用为每次构建项目都使用新的代码风格而担心。<br>同时, 始终如一的代码风格，可以通过静态分析排除代码问题。</p>\n<p>帮助规范代码的工具: 1.ESLint 2.Standard<br>如果你想更上一层楼，可以学习 JavaScript Clean Coding 原则。</p>\n<h4 id=\"什么时候应当用-npm？什么时候应当用-yarn？\"><a href=\"#什么时候应当用-npm？什么时候应当用-yarn？\" class=\"headerlink\" title=\"什么时候应当用 npm？什么时候应当用 yarn？\"></a>什么时候应当用 npm？什么时候应当用 yarn？</h4><p>相同点：都是javascript包管理器。<br>yarn 解决了npm历史遗留下来的痛点。<br>yarn特点：多平台精确校准，只要将yarn.lock保存到源码库里，在任何地方用yarn安装，版本都不会偏差。从而避免了package.json原来经常出现小版本差异而导致程序无法正常运行的情况。<br>缓存已经下载过的包，避免重复下载<br>下载前会检查签名及包的完整性<br>可靠可确定性，保证各平台依赖的一致性<br>网络优化，力求网络资源最大利用化，让资源下载完美队列执行，避免大量的无用请求，下载失败会自动重新请求，避免整个安装过程失败<br>扁平化模式，对于不匹配的依赖版本的包创立一个独立的包，避免创建重复的。（可以做个测试当时加载某个项目 用了86秒，后面又用npm测试，用了 190秒，之后在用yarn.lock 的情况下，加载用了46秒）</p>\n<h4 id=\"什么是桩代码（stub）-请描述一个应用场景！\"><a href=\"#什么是桩代码（stub）-请描述一个应用场景！\" class=\"headerlink\" title=\"什么是桩代码（stub）? 请描述一个应用场景！\"></a>什么是桩代码（stub）? 请描述一个应用场景！</h4><p>桩代码（stub）就是在某些组件或模块中，模拟某些功能的代码。桩代码（stub）的作用是占位，让代码在测试过程中顺利运行。</p>\n<p>一个例子，它实际的作用是写一个文件，但是这段代码并没有真正的做这件事。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var fs = require(&apos;fs&apos;);</div><div class=\"line\">var writeFileStub = sinon.stub(fs,&apos;writeFile&apos;,function (path,data,cb) &#123;</div><div class=\"line\">    return cb(null);</div><div class=\"line\">&#125;);</div><div class=\"line\">expect(writeFileStub).to.be.called</div><div class=\"line\">writeFileStub.restore();</div></pre></td></tr></table></figure></p>\n<h4 id=\"什么是测试金字塔？请举例说明！\"><a href=\"#什么是测试金字塔？请举例说明！\" class=\"headerlink\" title=\"什么是测试金字塔？请举例说明！\"></a>什么是测试金字塔？请举例说明！</h4><p>测试金字塔描述了单元测试（unit test），集成测试（integration tests），端到端测试（end-to-end test）在测试中占的比例。</p>\n<div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/testjinzita.jpg-public\" alt=\"\"><br></div>\n\n<p>举个例子，测试一个 HTTP API 需要:<br>1.大量关于 models 的单元测试(使用桩代码处理),<br>2.一些关于 models 如何和其他 models 交互的集成测试 (未使用桩代码处理),<br>3.少量的端到端测试，也就是真实环境下的调用 ( 未使用桩代码处理).</p>\n<h4 id=\"你最欣赏的-HTTP-框架是什么？为什么？\"><a href=\"#你最欣赏的-HTTP-框架是什么？为什么？\" class=\"headerlink\" title=\"你最欣赏的 HTTP 框架是什么？为什么？\"></a>你最欣赏的 HTTP 框架是什么？为什么？</h4><p>这道题没有标准答案。出这道题的目的是，看看面试者对他所使用框架，理解的有多深。只要面试者回答出框架的优缺点，为什么使用这个框架就可以了。</p>\n<h4 id=\"什么时候应该在后台进程中使用消息服务？怎么处理工作线程的任务-怎么给-worker-安排任务？\"><a href=\"#什么时候应该在后台进程中使用消息服务？怎么处理工作线程的任务-怎么给-worker-安排任务？\" class=\"headerlink\" title=\"什么时候应该在后台进程中使用消息服务？怎么处理工作线程的任务/怎么给 worker 安排任务？\"></a>什么时候应该在后台进程中使用消息服务？怎么处理工作线程的任务/怎么给 worker 安排任务？</h4><p>消息队列适用于后台数据传输服务，比如发送邮件和数据图像处理。</p>\n<p>消息队列有很多解决方案，比如 RabbitMQ 和 Kafka.</p>\n<h4 id=\"如何保证你的-cookie-安全？如何阻止-XSS-攻击？\"><a href=\"#如何保证你的-cookie-安全？如何阻止-XSS-攻击？\" class=\"headerlink\" title=\"如何保证你的 cookie 安全？如何阻止 XSS 攻击？\"></a>如何保证你的 cookie 安全？如何阻止 XSS 攻击？</h4><p>XSS 攻击是指攻击者向Html页面里插入恶意 JavaScript 代码。</p>\n<p>为了防止攻击，你需要对 HTTP header 里的 set-cookie 进行处理:<br>1、HttpOnly - 这个属性帮助防止跨站脚本攻击，它禁止通过 JavaScript 访问 cookie。<br>2、secure - 这个属性告诉浏览器，仅允许通过 HTTPS 协议访问 cookie。</p>\n<p>所以，你需要做的是在请求头里写 Set-Cookie: sid=; HttpOnly。如果你正在使用 Express 框架，可以使用 express-cookie session，他会默认做出上述防止 XSS 攻击的设置。</p>\n<h4 id=\"如何确认项目的相关依赖安全？\"><a href=\"#如何确认项目的相关依赖安全？\" class=\"headerlink\" title=\"如何确认项目的相关依赖安全？\"></a>如何确认项目的相关依赖安全？</h4><p>使用 Node.js 开发, 很容易出现有成百上千个依赖的情况。</p>\n<p>举例来说，如果你依赖 Express，准确的说这意味着也依赖 27 个其他的模块 , 手动检测更新这些模块不是一个正确的选择！</p>\n<p>唯一的选择就是自动的安全的更新你的依赖，你有如下免费或付费的选择：<br>1、pm outdated<br>2、race by RisingStack<br>3、SP<br>4、reenKeeper<br>5、nyk</p>\n<h4 id=\"下面的代码有什么错误？\"><a href=\"#下面的代码有什么错误？\" class=\"headerlink\" title=\"下面的代码有什么错误？\"></a>下面的代码有什么错误？</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">new Promise((resolve,reject)=&gt;&#123;</div><div class=\"line\">    throw new Error(&apos;error&apos;)</div><div class=\"line\">&#125;).then(console.log)</div><div class=\"line\">//在 then 后没有 catch ，没有捕捉异常。这样做会造成故障沉默，不会抛出异常。</div><div class=\"line\">//如果你调试一个巨大的代码库，并且不知道哪个 Promise 函数有潜在的问题, 你可以使用 unhandledRejection 这个工具。它将会打印出所有未处理的 reject 状态的 Promise。</div><div class=\"line\">process.on(&apos;unhandleRejection&apos;,(err)=&gt;&#123;</div><div class=\"line\">    console.log(err);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function checkApiKey(apiKeyFromDb,apiKeyReceived) &#123;</div><div class=\"line\">    if(apiKeyFromDb===apiKeyReceived)&#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div><div class=\"line\">//在进行数据校验(security credentials)时，避免任何信息泄露是最重要的。所以，我们要控制数据校验的执行时间。我们要保证，不管传过来的数据是什么，我们校验数据消耗的时间是相同的。如果你做不到这一点，你的程序对时序攻击的抵抗力很低。</div><div class=\"line\"></div><div class=\"line\">为什么会有这种现象?</div><div class=\"line\">Node.js 使用 JavaScript V8 引擎, 为了高速运行网页而开发的，性能优异。 V8 引擎比较数据的方式是字节比较, 一旦发现有一个字节不一致, 比较运算就会停止。 因此，攻击者传入的 password 校验时间越长，说明明 password 正确的部分越多。</div><div class=\"line\">为了修复这个问题, 你可以使用 npm 模块 cryptiles。</div><div class=\"line\"></div><div class=\"line\">function checkApiKey(apiKeyFromDb,apiKeyReceived) &#123;</div><div class=\"line\">    return cryptiles.fixedTimeComparison(apiKeyFromDb,apiKeyReceived)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">下面这段代码输出的是什么?</div><div class=\"line\">Promise.resolve(1)</div><div class=\"line\">    .then((x)=&gt;x+1)</div><div class=\"line\">    .then((x)=&gt;&#123;throw new Error(&apos;My Error&apos;)&#125;)</div><div class=\"line\">    .catch(()=&gt;1)</div><div class=\"line\">    .then((x)=&gt;x+1)</div><div class=\"line\">    .then((x)=&gt;console.log(x))</div><div class=\"line\">    .catch(console.error)</div><div class=\"line\">答案是 2. 每行代码对应解释如下：</div><div class=\"line\">创建一个 Promise 对象，输出 1</div><div class=\"line\">创建一个 Promise 对象，输出 1</div><div class=\"line\">结果 +1，现在的输出为2</div><div class=\"line\">输出结果被抛弃，抛出一个 error</div><div class=\"line\">error 被丢弃, 返回一个新的 value (1)</div><div class=\"line\">catch 进行异常处理，但 catch 后程序不停止执行, 返回一个信息+1之后的 value (2)</div><div class=\"line\">value 正常输出</div><div class=\"line\">value 已正常输出，这一行不会执行</div></pre></td></tr></table></figure>","excerpt":"","more":"<h4 id=\"Node-js-面试问题预览-来源于网络\"><a href=\"#Node-js-面试问题预览-来源于网络\" class=\"headerlink\" title=\"Node.js 面试问题预览(来源于网络)\"></a>Node.js 面试问题预览(来源于网络)</h4><ul>\n<li>什么是 error-first 回调模式？</li>\n<li>如何避免“回调地狱”？</li>\n<li>什么是 Promises？</li>\n<li>什么工具统一团队的代码风格？为什么统一的代码风格很重要？</li>\n<li>什么时候应当用 npm？什么时候应当用 yarn？</li>\n<li>什么是桩代码（stub）？ 请描述一个应用场景！</li>\n<li>什么是测试金字塔？请举例说明！</li>\n<li>你最欣赏的 HTTP 框架是什么？为什么？</li>\n<li>如果保证你的 cookie 安全？如何阻止 XSS 攻击？</li>\n<li>如何确认项目的相关依赖安全？<h4 id=\"什么是-error-first-回调模式？\"><a href=\"#什么是-error-first-回调模式？\" class=\"headerlink\" title=\"什么是 error-first 回调模式？\"></a>什么是 error-first 回调模式？</h4>应用 error-first 回调模式是为了更好的进行错误和数据的传递。第一个参数保留给一个错误 error 对象，一旦出错，错误将通过第一个参数 error 返回。其余的参数将用作数据的传递。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">fs.readFile(filePath,function (err,data) &#123;</div><div class=\"line\">    if(err)&#123;</div><div class=\"line\">        //handle the error code.</div><div class=\"line\">        return console.log(err);</div><div class=\"line\">    &#125;</div><div class=\"line\">    console.log(data);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"如何避免“回调地狱”\"><a href=\"#如何避免“回调地狱”\" class=\"headerlink\" title=\"如何避免“回调地狱”?\"></a>如何避免“回调地狱”?</h4><p>解决这个问题的方法有很多:</p>\n<ul>\n<li>模块化设计: 讲回调拆分成几个独立的函数</li>\n<li>使用 流程控制库, 比如 async</li>\n<li>组合使用 generators 和 Promises</li>\n<li>使用 async/await 函数 (只能在Node v7 release版本运行， Node LTS版本尚不支持 )</li>\n</ul>\n<h4 id=\"什么是-Promises\"><a href=\"#什么是-Promises\" class=\"headerlink\" title=\"什么是 Promises?\"></a>什么是 Promises?</h4><p>promise的概念早在上个世纪八十年代就被提出，现在已经是大多数现代编程语言中支持的特性，让你能更轻松地实现异步模型。</p>\n<p>举个简单的例子, 正常来说100ms 之后将会输出 result 。一旦失败, catch可以抛出异常。Promises允许链式操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">new Promise(()=&gt;&#123;</div><div class=\"line\">    setTimeout(()=&gt;&#123;</div><div class=\"line\">        resolve(&apos;result&apos;)</div><div class=\"line\">    &#125;,100)&#125;)</div><div class=\"line\">    .then((data)=&gt;&#123;</div><div class=\"line\">        console.log(data);</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .catch();</div></pre></td></tr></table></figure></p>\n<h4 id=\"什么工具统一团队的代码风格-为什么统一的代码风格很重要？\"><a href=\"#什么工具统一团队的代码风格-为什么统一的代码风格很重要？\" class=\"headerlink\" title=\"什么工具统一团队的代码风格? 为什么统一的代码风格很重要？\"></a>什么工具统一团队的代码风格? 为什么统一的代码风格很重要？</h4><p>团队协作时，始终如一的代码风格十分重要，代码风格一致，团队成员可以更轻松的构建项目，不用为每次构建项目都使用新的代码风格而担心。<br>同时, 始终如一的代码风格，可以通过静态分析排除代码问题。</p>\n<p>帮助规范代码的工具: 1.ESLint 2.Standard<br>如果你想更上一层楼，可以学习 JavaScript Clean Coding 原则。</p>\n<h4 id=\"什么时候应当用-npm？什么时候应当用-yarn？\"><a href=\"#什么时候应当用-npm？什么时候应当用-yarn？\" class=\"headerlink\" title=\"什么时候应当用 npm？什么时候应当用 yarn？\"></a>什么时候应当用 npm？什么时候应当用 yarn？</h4><p>相同点：都是javascript包管理器。<br>yarn 解决了npm历史遗留下来的痛点。<br>yarn特点：多平台精确校准，只要将yarn.lock保存到源码库里，在任何地方用yarn安装，版本都不会偏差。从而避免了package.json原来经常出现小版本差异而导致程序无法正常运行的情况。<br>缓存已经下载过的包，避免重复下载<br>下载前会检查签名及包的完整性<br>可靠可确定性，保证各平台依赖的一致性<br>网络优化，力求网络资源最大利用化，让资源下载完美队列执行，避免大量的无用请求，下载失败会自动重新请求，避免整个安装过程失败<br>扁平化模式，对于不匹配的依赖版本的包创立一个独立的包，避免创建重复的。（可以做个测试当时加载某个项目 用了86秒，后面又用npm测试，用了 190秒，之后在用yarn.lock 的情况下，加载用了46秒）</p>\n<h4 id=\"什么是桩代码（stub）-请描述一个应用场景！\"><a href=\"#什么是桩代码（stub）-请描述一个应用场景！\" class=\"headerlink\" title=\"什么是桩代码（stub）? 请描述一个应用场景！\"></a>什么是桩代码（stub）? 请描述一个应用场景！</h4><p>桩代码（stub）就是在某些组件或模块中，模拟某些功能的代码。桩代码（stub）的作用是占位，让代码在测试过程中顺利运行。</p>\n<p>一个例子，它实际的作用是写一个文件，但是这段代码并没有真正的做这件事。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var fs = require(&apos;fs&apos;);</div><div class=\"line\">var writeFileStub = sinon.stub(fs,&apos;writeFile&apos;,function (path,data,cb) &#123;</div><div class=\"line\">    return cb(null);</div><div class=\"line\">&#125;);</div><div class=\"line\">expect(writeFileStub).to.be.called</div><div class=\"line\">writeFileStub.restore();</div></pre></td></tr></table></figure></p>\n<h4 id=\"什么是测试金字塔？请举例说明！\"><a href=\"#什么是测试金字塔？请举例说明！\" class=\"headerlink\" title=\"什么是测试金字塔？请举例说明！\"></a>什么是测试金字塔？请举例说明！</h4><p>测试金字塔描述了单元测试（unit test），集成测试（integration tests），端到端测试（end-to-end test）在测试中占的比例。</p>\n<div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/testjinzita.jpg-public\" alt=\"\"><br></div>\n\n<p>举个例子，测试一个 HTTP API 需要:<br>1.大量关于 models 的单元测试(使用桩代码处理),<br>2.一些关于 models 如何和其他 models 交互的集成测试 (未使用桩代码处理),<br>3.少量的端到端测试，也就是真实环境下的调用 ( 未使用桩代码处理).</p>\n<h4 id=\"你最欣赏的-HTTP-框架是什么？为什么？\"><a href=\"#你最欣赏的-HTTP-框架是什么？为什么？\" class=\"headerlink\" title=\"你最欣赏的 HTTP 框架是什么？为什么？\"></a>你最欣赏的 HTTP 框架是什么？为什么？</h4><p>这道题没有标准答案。出这道题的目的是，看看面试者对他所使用框架，理解的有多深。只要面试者回答出框架的优缺点，为什么使用这个框架就可以了。</p>\n<h4 id=\"什么时候应该在后台进程中使用消息服务？怎么处理工作线程的任务-怎么给-worker-安排任务？\"><a href=\"#什么时候应该在后台进程中使用消息服务？怎么处理工作线程的任务-怎么给-worker-安排任务？\" class=\"headerlink\" title=\"什么时候应该在后台进程中使用消息服务？怎么处理工作线程的任务/怎么给 worker 安排任务？\"></a>什么时候应该在后台进程中使用消息服务？怎么处理工作线程的任务/怎么给 worker 安排任务？</h4><p>消息队列适用于后台数据传输服务，比如发送邮件和数据图像处理。</p>\n<p>消息队列有很多解决方案，比如 RabbitMQ 和 Kafka.</p>\n<h4 id=\"如何保证你的-cookie-安全？如何阻止-XSS-攻击？\"><a href=\"#如何保证你的-cookie-安全？如何阻止-XSS-攻击？\" class=\"headerlink\" title=\"如何保证你的 cookie 安全？如何阻止 XSS 攻击？\"></a>如何保证你的 cookie 安全？如何阻止 XSS 攻击？</h4><p>XSS 攻击是指攻击者向Html页面里插入恶意 JavaScript 代码。</p>\n<p>为了防止攻击，你需要对 HTTP header 里的 set-cookie 进行处理:<br>1、HttpOnly - 这个属性帮助防止跨站脚本攻击，它禁止通过 JavaScript 访问 cookie。<br>2、secure - 这个属性告诉浏览器，仅允许通过 HTTPS 协议访问 cookie。</p>\n<p>所以，你需要做的是在请求头里写 Set-Cookie: sid=; HttpOnly。如果你正在使用 Express 框架，可以使用 express-cookie session，他会默认做出上述防止 XSS 攻击的设置。</p>\n<h4 id=\"如何确认项目的相关依赖安全？\"><a href=\"#如何确认项目的相关依赖安全？\" class=\"headerlink\" title=\"如何确认项目的相关依赖安全？\"></a>如何确认项目的相关依赖安全？</h4><p>使用 Node.js 开发, 很容易出现有成百上千个依赖的情况。</p>\n<p>举例来说，如果你依赖 Express，准确的说这意味着也依赖 27 个其他的模块 , 手动检测更新这些模块不是一个正确的选择！</p>\n<p>唯一的选择就是自动的安全的更新你的依赖，你有如下免费或付费的选择：<br>1、pm outdated<br>2、race by RisingStack<br>3、SP<br>4、reenKeeper<br>5、nyk</p>\n<h4 id=\"下面的代码有什么错误？\"><a href=\"#下面的代码有什么错误？\" class=\"headerlink\" title=\"下面的代码有什么错误？\"></a>下面的代码有什么错误？</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">new Promise((resolve,reject)=&gt;&#123;</div><div class=\"line\">    throw new Error(&apos;error&apos;)</div><div class=\"line\">&#125;).then(console.log)</div><div class=\"line\">//在 then 后没有 catch ，没有捕捉异常。这样做会造成故障沉默，不会抛出异常。</div><div class=\"line\">//如果你调试一个巨大的代码库，并且不知道哪个 Promise 函数有潜在的问题, 你可以使用 unhandledRejection 这个工具。它将会打印出所有未处理的 reject 状态的 Promise。</div><div class=\"line\">process.on(&apos;unhandleRejection&apos;,(err)=&gt;&#123;</div><div class=\"line\">    console.log(err);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function checkApiKey(apiKeyFromDb,apiKeyReceived) &#123;</div><div class=\"line\">    if(apiKeyFromDb===apiKeyReceived)&#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div><div class=\"line\">//在进行数据校验(security credentials)时，避免任何信息泄露是最重要的。所以，我们要控制数据校验的执行时间。我们要保证，不管传过来的数据是什么，我们校验数据消耗的时间是相同的。如果你做不到这一点，你的程序对时序攻击的抵抗力很低。</div><div class=\"line\"></div><div class=\"line\">为什么会有这种现象?</div><div class=\"line\">Node.js 使用 JavaScript V8 引擎, 为了高速运行网页而开发的，性能优异。 V8 引擎比较数据的方式是字节比较, 一旦发现有一个字节不一致, 比较运算就会停止。 因此，攻击者传入的 password 校验时间越长，说明明 password 正确的部分越多。</div><div class=\"line\">为了修复这个问题, 你可以使用 npm 模块 cryptiles。</div><div class=\"line\"></div><div class=\"line\">function checkApiKey(apiKeyFromDb,apiKeyReceived) &#123;</div><div class=\"line\">    return cryptiles.fixedTimeComparison(apiKeyFromDb,apiKeyReceived)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">下面这段代码输出的是什么?</div><div class=\"line\">Promise.resolve(1)</div><div class=\"line\">    .then((x)=&gt;x+1)</div><div class=\"line\">    .then((x)=&gt;&#123;throw new Error(&apos;My Error&apos;)&#125;)</div><div class=\"line\">    .catch(()=&gt;1)</div><div class=\"line\">    .then((x)=&gt;x+1)</div><div class=\"line\">    .then((x)=&gt;console.log(x))</div><div class=\"line\">    .catch(console.error)</div><div class=\"line\">答案是 2. 每行代码对应解释如下：</div><div class=\"line\">创建一个 Promise 对象，输出 1</div><div class=\"line\">创建一个 Promise 对象，输出 1</div><div class=\"line\">结果 +1，现在的输出为2</div><div class=\"line\">输出结果被抛弃，抛出一个 error</div><div class=\"line\">error 被丢弃, 返回一个新的 value (1)</div><div class=\"line\">catch 进行异常处理，但 catch 后程序不停止执行, 返回一个信息+1之后的 value (2)</div><div class=\"line\">value 正常输出</div><div class=\"line\">value 已正常输出，这一行不会执行</div></pre></td></tr></table></figure>"},{"title":"YARN, 一个可能取代npm的javascript包管理","date":"2017-01-12T02:55:40.000Z","_content":"Facebook刚刚推出了一款名叫Yarn的开源JavaScript包管理器，承诺比各大流行npm包的安装更可靠，且速度更快。根据你所选的工作包的不同，该公司称Yarn可以将安装时间从数分钟减少至几秒钟.\n\n它的目的是解决这些团队使用 npm 面临的少数问题，即：\n1.安装的时候无法保证速度/一致性\n2.安全问题，因为 npm 安装时允许运行代码\n\n#### yarn.lock 文件\nnpm 和 Yarn 都使用 package.json 来跟踪项目的依赖，版本号并非一直准确，因为你可以定义版本号范围，这样你可以选择一个主版本和次要版本的包，但让 npm 安装最新的补丁也许可以修改一些 bug。\n\n理想状态下使用语义化版本发布补丁不会包含大的变化，但不幸的是这必非真理。npm 的这种策略可能导致两台拥有相同 package.json 文件的机子安装了不同版本的包，这可能导致一些错误。\n\n为了避免包版本的错误匹配，一个确定的安装版本被固定在一个锁文件中。每次模块被添加时，Yarn 就会创建（或更新）yarn.lock 文件，这样你就可以保证其它机子也安装相同版本的包，同时包含了 package.json 中定义的一系列允许的版本。\n\n在 npm 中同样可以使用 npm shrinkwrap 命令来生成一个锁文件，这样在使用 npm install 时会在读取 package.json 前先读取这个文件，就像 Yarn 会先读取yarn.lock 一样。这里的区别是 Yarn 总会自动更新 yarn.lock，而 npm 需要你重新操作。\n\nyarn管理器有一个很重要的文件需要注意，就是yarn.lock，这个是用来依赖的正确性，快速可靠安装的；是执行cli的时候自动生成的，在项目的根目录下，需要保留！！！！不要编辑它，这是自动生成的.在其他电脑初始化，必须记得把package.json和yarn.lock复制过去，简直就是秒下载【缓存机制】.\n\n#### 并行安装\n每当 npm 或 Yarn 需要安装一个包时，它会进行一系列的任务。在 npm 中这些任务是按包的顺序一个个执行，这意味着必须等待上一个包被完整安装才会进入下一个；Yarn 则并行的执行这些任务，提高了性能。\n\n#### Yarn vs npm: CLI 的差异\n除了一些功能差异，Yarn 命令也存在一些区别。例如移除或修改了一些 npm 命令以及添加了几个有趣的命令。\n- yarn global\n不像 npm 添加 -g 或 --global 可以进行全局安装，Yarn 使用的是 global 前缀。不过与 npm 类似，项目依赖不推荐全局安装。\n\nglobal 前缀只能用于 yarn add, yarn bin, yarn ls 和 yarn remove，除yarn add 外，这些命令都和 npm 等效。\n\n- npm install\nnpm install 命令会根据 package.json 安装依赖以及允许你添加新的模块；yarn install 仅会按 yarn.lock 或 package.json 里面的依赖顺序来安装模块。\n\n- yarn add [–dev]\n\n与 npm install 类似，yarn add 允许你添加与安装模块，就像命令的名称一样，添加依赖意味着也会算定将依赖写入 package.json，类似 npm 的 --save 参数；Yarn 的 --dev 参数则是添加开发依赖，类似 npm 的 --save-dev 参数。\n\n- yarn licenses [ls|generate-disclaimer]\n\nnpm 没有类似命令来方便编写自己的包。yarn licenses ls 列出所有已安装包的许可协议。yarn licenses generate-disclaimer 生成包含已安装包许可协议的免责声明。某些协议要求使用者必须在项目中包含该协议，这时候该命令将变得非常好用。\n\n- yarn why\n\n该命令会查找依赖关系并找出为什么会将某些包安装在你的项目中。也许你明确为什么添加，也许它只是你安装包中的一个依赖，yarn why 可以帮你弄找出。\n\n- yarn upgrade\n\n该命令会根据符合 package.json 设定的规则而不是 yarn.lock 定义的确切版本来将包更新到最新版本。如果想用 npm 来实现相同目的，可以这样执行：\n```\nrm -rf node_modules\nnpm install\n```\n不要将该命令与 npm update 混淆，它指的是更新到自己的最新版。\n\n- yarn generate-lock-entry\n\nyarn generate-lock-entry 会基于 package.json 设置的依赖生成 yarn.lock 文件，该命令与 npm shrinkwrap 类似，但应该小心使用，因为通过 yarn add 和 yarn upgrade 命令添加或更新依赖时会自动更新生成该锁文件。\n\n#### 快速安装\nnpm install -g yarn\n#### 常用命令快速对比\nnpm install  => yarn install\nnpm install --save => yarn add\nnpm install --save-dev => yarn add -dev\n#### 针对国内的设置\n如果没有出现网络问题，请直接忽略下面的内容。如果出现错误可以考虑设置一下npm源，代码如下\n```\nyarn config set registry https://registry.npm.taobao.org\n```\n","source":"_posts/yarn-introduction.md","raw":"---\ntitle: YARN, 一个可能取代npm的javascript包管理\ndate: 2017-01-12 10:55:40\ntags: yarn npm\n---\nFacebook刚刚推出了一款名叫Yarn的开源JavaScript包管理器，承诺比各大流行npm包的安装更可靠，且速度更快。根据你所选的工作包的不同，该公司称Yarn可以将安装时间从数分钟减少至几秒钟.\n\n它的目的是解决这些团队使用 npm 面临的少数问题，即：\n1.安装的时候无法保证速度/一致性\n2.安全问题，因为 npm 安装时允许运行代码\n\n#### yarn.lock 文件\nnpm 和 Yarn 都使用 package.json 来跟踪项目的依赖，版本号并非一直准确，因为你可以定义版本号范围，这样你可以选择一个主版本和次要版本的包，但让 npm 安装最新的补丁也许可以修改一些 bug。\n\n理想状态下使用语义化版本发布补丁不会包含大的变化，但不幸的是这必非真理。npm 的这种策略可能导致两台拥有相同 package.json 文件的机子安装了不同版本的包，这可能导致一些错误。\n\n为了避免包版本的错误匹配，一个确定的安装版本被固定在一个锁文件中。每次模块被添加时，Yarn 就会创建（或更新）yarn.lock 文件，这样你就可以保证其它机子也安装相同版本的包，同时包含了 package.json 中定义的一系列允许的版本。\n\n在 npm 中同样可以使用 npm shrinkwrap 命令来生成一个锁文件，这样在使用 npm install 时会在读取 package.json 前先读取这个文件，就像 Yarn 会先读取yarn.lock 一样。这里的区别是 Yarn 总会自动更新 yarn.lock，而 npm 需要你重新操作。\n\nyarn管理器有一个很重要的文件需要注意，就是yarn.lock，这个是用来依赖的正确性，快速可靠安装的；是执行cli的时候自动生成的，在项目的根目录下，需要保留！！！！不要编辑它，这是自动生成的.在其他电脑初始化，必须记得把package.json和yarn.lock复制过去，简直就是秒下载【缓存机制】.\n\n#### 并行安装\n每当 npm 或 Yarn 需要安装一个包时，它会进行一系列的任务。在 npm 中这些任务是按包的顺序一个个执行，这意味着必须等待上一个包被完整安装才会进入下一个；Yarn 则并行的执行这些任务，提高了性能。\n\n#### Yarn vs npm: CLI 的差异\n除了一些功能差异，Yarn 命令也存在一些区别。例如移除或修改了一些 npm 命令以及添加了几个有趣的命令。\n- yarn global\n不像 npm 添加 -g 或 --global 可以进行全局安装，Yarn 使用的是 global 前缀。不过与 npm 类似，项目依赖不推荐全局安装。\n\nglobal 前缀只能用于 yarn add, yarn bin, yarn ls 和 yarn remove，除yarn add 外，这些命令都和 npm 等效。\n\n- npm install\nnpm install 命令会根据 package.json 安装依赖以及允许你添加新的模块；yarn install 仅会按 yarn.lock 或 package.json 里面的依赖顺序来安装模块。\n\n- yarn add [–dev]\n\n与 npm install 类似，yarn add 允许你添加与安装模块，就像命令的名称一样，添加依赖意味着也会算定将依赖写入 package.json，类似 npm 的 --save 参数；Yarn 的 --dev 参数则是添加开发依赖，类似 npm 的 --save-dev 参数。\n\n- yarn licenses [ls|generate-disclaimer]\n\nnpm 没有类似命令来方便编写自己的包。yarn licenses ls 列出所有已安装包的许可协议。yarn licenses generate-disclaimer 生成包含已安装包许可协议的免责声明。某些协议要求使用者必须在项目中包含该协议，这时候该命令将变得非常好用。\n\n- yarn why\n\n该命令会查找依赖关系并找出为什么会将某些包安装在你的项目中。也许你明确为什么添加，也许它只是你安装包中的一个依赖，yarn why 可以帮你弄找出。\n\n- yarn upgrade\n\n该命令会根据符合 package.json 设定的规则而不是 yarn.lock 定义的确切版本来将包更新到最新版本。如果想用 npm 来实现相同目的，可以这样执行：\n```\nrm -rf node_modules\nnpm install\n```\n不要将该命令与 npm update 混淆，它指的是更新到自己的最新版。\n\n- yarn generate-lock-entry\n\nyarn generate-lock-entry 会基于 package.json 设置的依赖生成 yarn.lock 文件，该命令与 npm shrinkwrap 类似，但应该小心使用，因为通过 yarn add 和 yarn upgrade 命令添加或更新依赖时会自动更新生成该锁文件。\n\n#### 快速安装\nnpm install -g yarn\n#### 常用命令快速对比\nnpm install  => yarn install\nnpm install --save => yarn add\nnpm install --save-dev => yarn add -dev\n#### 针对国内的设置\n如果没有出现网络问题，请直接忽略下面的内容。如果出现错误可以考虑设置一下npm源，代码如下\n```\nyarn config set registry https://registry.npm.taobao.org\n```\n","slug":"yarn-introduction","published":1,"updated":"2017-01-12T03:11:58.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixtsysvq0005pktu5t7fwlsc","content":"<p>Facebook刚刚推出了一款名叫Yarn的开源JavaScript包管理器，承诺比各大流行npm包的安装更可靠，且速度更快。根据你所选的工作包的不同，该公司称Yarn可以将安装时间从数分钟减少至几秒钟.</p>\n<p>它的目的是解决这些团队使用 npm 面临的少数问题，即：<br>1.安装的时候无法保证速度/一致性<br>2.安全问题，因为 npm 安装时允许运行代码</p>\n<h4 id=\"yarn-lock-文件\"><a href=\"#yarn-lock-文件\" class=\"headerlink\" title=\"yarn.lock 文件\"></a>yarn.lock 文件</h4><p>npm 和 Yarn 都使用 package.json 来跟踪项目的依赖，版本号并非一直准确，因为你可以定义版本号范围，这样你可以选择一个主版本和次要版本的包，但让 npm 安装最新的补丁也许可以修改一些 bug。</p>\n<p>理想状态下使用语义化版本发布补丁不会包含大的变化，但不幸的是这必非真理。npm 的这种策略可能导致两台拥有相同 package.json 文件的机子安装了不同版本的包，这可能导致一些错误。</p>\n<p>为了避免包版本的错误匹配，一个确定的安装版本被固定在一个锁文件中。每次模块被添加时，Yarn 就会创建（或更新）yarn.lock 文件，这样你就可以保证其它机子也安装相同版本的包，同时包含了 package.json 中定义的一系列允许的版本。</p>\n<p>在 npm 中同样可以使用 npm shrinkwrap 命令来生成一个锁文件，这样在使用 npm install 时会在读取 package.json 前先读取这个文件，就像 Yarn 会先读取yarn.lock 一样。这里的区别是 Yarn 总会自动更新 yarn.lock，而 npm 需要你重新操作。</p>\n<p>yarn管理器有一个很重要的文件需要注意，就是yarn.lock，这个是用来依赖的正确性，快速可靠安装的；是执行cli的时候自动生成的，在项目的根目录下，需要保留！！！！不要编辑它，这是自动生成的.在其他电脑初始化，必须记得把package.json和yarn.lock复制过去，简直就是秒下载【缓存机制】.</p>\n<h4 id=\"并行安装\"><a href=\"#并行安装\" class=\"headerlink\" title=\"并行安装\"></a>并行安装</h4><p>每当 npm 或 Yarn 需要安装一个包时，它会进行一系列的任务。在 npm 中这些任务是按包的顺序一个个执行，这意味着必须等待上一个包被完整安装才会进入下一个；Yarn 则并行的执行这些任务，提高了性能。</p>\n<h4 id=\"Yarn-vs-npm-CLI-的差异\"><a href=\"#Yarn-vs-npm-CLI-的差异\" class=\"headerlink\" title=\"Yarn vs npm: CLI 的差异\"></a>Yarn vs npm: CLI 的差异</h4><p>除了一些功能差异，Yarn 命令也存在一些区别。例如移除或修改了一些 npm 命令以及添加了几个有趣的命令。</p>\n<ul>\n<li>yarn global<br>不像 npm 添加 -g 或 –global 可以进行全局安装，Yarn 使用的是 global 前缀。不过与 npm 类似，项目依赖不推荐全局安装。</li>\n</ul>\n<p>global 前缀只能用于 yarn add, yarn bin, yarn ls 和 yarn remove，除yarn add 外，这些命令都和 npm 等效。</p>\n<ul>\n<li><p>npm install<br>npm install 命令会根据 package.json 安装依赖以及允许你添加新的模块；yarn install 仅会按 yarn.lock 或 package.json 里面的依赖顺序来安装模块。</p>\n</li>\n<li><p>yarn add [–dev]</p>\n</li>\n</ul>\n<p>与 npm install 类似，yarn add 允许你添加与安装模块，就像命令的名称一样，添加依赖意味着也会算定将依赖写入 package.json，类似 npm 的 –save 参数；Yarn 的 –dev 参数则是添加开发依赖，类似 npm 的 –save-dev 参数。</p>\n<ul>\n<li>yarn licenses [ls|generate-disclaimer]</li>\n</ul>\n<p>npm 没有类似命令来方便编写自己的包。yarn licenses ls 列出所有已安装包的许可协议。yarn licenses generate-disclaimer 生成包含已安装包许可协议的免责声明。某些协议要求使用者必须在项目中包含该协议，这时候该命令将变得非常好用。</p>\n<ul>\n<li>yarn why</li>\n</ul>\n<p>该命令会查找依赖关系并找出为什么会将某些包安装在你的项目中。也许你明确为什么添加，也许它只是你安装包中的一个依赖，yarn why 可以帮你弄找出。</p>\n<ul>\n<li>yarn upgrade</li>\n</ul>\n<p>该命令会根据符合 package.json 设定的规则而不是 yarn.lock 定义的确切版本来将包更新到最新版本。如果想用 npm 来实现相同目的，可以这样执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">rm -rf node_modules</div><div class=\"line\">npm install</div></pre></td></tr></table></figure></p>\n<p>不要将该命令与 npm update 混淆，它指的是更新到自己的最新版。</p>\n<ul>\n<li>yarn generate-lock-entry</li>\n</ul>\n<p>yarn generate-lock-entry 会基于 package.json 设置的依赖生成 yarn.lock 文件，该命令与 npm shrinkwrap 类似，但应该小心使用，因为通过 yarn add 和 yarn upgrade 命令添加或更新依赖时会自动更新生成该锁文件。</p>\n<h4 id=\"快速安装\"><a href=\"#快速安装\" class=\"headerlink\" title=\"快速安装\"></a>快速安装</h4><p>npm install -g yarn</p>\n<h4 id=\"常用命令快速对比\"><a href=\"#常用命令快速对比\" class=\"headerlink\" title=\"常用命令快速对比\"></a>常用命令快速对比</h4><p>npm install  =&gt; yarn install<br>npm install –save =&gt; yarn add<br>npm install –save-dev =&gt; yarn add -dev</p>\n<h4 id=\"针对国内的设置\"><a href=\"#针对国内的设置\" class=\"headerlink\" title=\"针对国内的设置\"></a>针对国内的设置</h4><p>如果没有出现网络问题，请直接忽略下面的内容。如果出现错误可以考虑设置一下npm源，代码如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yarn config set registry https://registry.npm.taobao.org</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>Facebook刚刚推出了一款名叫Yarn的开源JavaScript包管理器，承诺比各大流行npm包的安装更可靠，且速度更快。根据你所选的工作包的不同，该公司称Yarn可以将安装时间从数分钟减少至几秒钟.</p>\n<p>它的目的是解决这些团队使用 npm 面临的少数问题，即：<br>1.安装的时候无法保证速度/一致性<br>2.安全问题，因为 npm 安装时允许运行代码</p>\n<h4 id=\"yarn-lock-文件\"><a href=\"#yarn-lock-文件\" class=\"headerlink\" title=\"yarn.lock 文件\"></a>yarn.lock 文件</h4><p>npm 和 Yarn 都使用 package.json 来跟踪项目的依赖，版本号并非一直准确，因为你可以定义版本号范围，这样你可以选择一个主版本和次要版本的包，但让 npm 安装最新的补丁也许可以修改一些 bug。</p>\n<p>理想状态下使用语义化版本发布补丁不会包含大的变化，但不幸的是这必非真理。npm 的这种策略可能导致两台拥有相同 package.json 文件的机子安装了不同版本的包，这可能导致一些错误。</p>\n<p>为了避免包版本的错误匹配，一个确定的安装版本被固定在一个锁文件中。每次模块被添加时，Yarn 就会创建（或更新）yarn.lock 文件，这样你就可以保证其它机子也安装相同版本的包，同时包含了 package.json 中定义的一系列允许的版本。</p>\n<p>在 npm 中同样可以使用 npm shrinkwrap 命令来生成一个锁文件，这样在使用 npm install 时会在读取 package.json 前先读取这个文件，就像 Yarn 会先读取yarn.lock 一样。这里的区别是 Yarn 总会自动更新 yarn.lock，而 npm 需要你重新操作。</p>\n<p>yarn管理器有一个很重要的文件需要注意，就是yarn.lock，这个是用来依赖的正确性，快速可靠安装的；是执行cli的时候自动生成的，在项目的根目录下，需要保留！！！！不要编辑它，这是自动生成的.在其他电脑初始化，必须记得把package.json和yarn.lock复制过去，简直就是秒下载【缓存机制】.</p>\n<h4 id=\"并行安装\"><a href=\"#并行安装\" class=\"headerlink\" title=\"并行安装\"></a>并行安装</h4><p>每当 npm 或 Yarn 需要安装一个包时，它会进行一系列的任务。在 npm 中这些任务是按包的顺序一个个执行，这意味着必须等待上一个包被完整安装才会进入下一个；Yarn 则并行的执行这些任务，提高了性能。</p>\n<h4 id=\"Yarn-vs-npm-CLI-的差异\"><a href=\"#Yarn-vs-npm-CLI-的差异\" class=\"headerlink\" title=\"Yarn vs npm: CLI 的差异\"></a>Yarn vs npm: CLI 的差异</h4><p>除了一些功能差异，Yarn 命令也存在一些区别。例如移除或修改了一些 npm 命令以及添加了几个有趣的命令。</p>\n<ul>\n<li>yarn global<br>不像 npm 添加 -g 或 –global 可以进行全局安装，Yarn 使用的是 global 前缀。不过与 npm 类似，项目依赖不推荐全局安装。</li>\n</ul>\n<p>global 前缀只能用于 yarn add, yarn bin, yarn ls 和 yarn remove，除yarn add 外，这些命令都和 npm 等效。</p>\n<ul>\n<li><p>npm install<br>npm install 命令会根据 package.json 安装依赖以及允许你添加新的模块；yarn install 仅会按 yarn.lock 或 package.json 里面的依赖顺序来安装模块。</p>\n</li>\n<li><p>yarn add [–dev]</p>\n</li>\n</ul>\n<p>与 npm install 类似，yarn add 允许你添加与安装模块，就像命令的名称一样，添加依赖意味着也会算定将依赖写入 package.json，类似 npm 的 –save 参数；Yarn 的 –dev 参数则是添加开发依赖，类似 npm 的 –save-dev 参数。</p>\n<ul>\n<li>yarn licenses [ls|generate-disclaimer]</li>\n</ul>\n<p>npm 没有类似命令来方便编写自己的包。yarn licenses ls 列出所有已安装包的许可协议。yarn licenses generate-disclaimer 生成包含已安装包许可协议的免责声明。某些协议要求使用者必须在项目中包含该协议，这时候该命令将变得非常好用。</p>\n<ul>\n<li>yarn why</li>\n</ul>\n<p>该命令会查找依赖关系并找出为什么会将某些包安装在你的项目中。也许你明确为什么添加，也许它只是你安装包中的一个依赖，yarn why 可以帮你弄找出。</p>\n<ul>\n<li>yarn upgrade</li>\n</ul>\n<p>该命令会根据符合 package.json 设定的规则而不是 yarn.lock 定义的确切版本来将包更新到最新版本。如果想用 npm 来实现相同目的，可以这样执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">rm -rf node_modules</div><div class=\"line\">npm install</div></pre></td></tr></table></figure></p>\n<p>不要将该命令与 npm update 混淆，它指的是更新到自己的最新版。</p>\n<ul>\n<li>yarn generate-lock-entry</li>\n</ul>\n<p>yarn generate-lock-entry 会基于 package.json 设置的依赖生成 yarn.lock 文件，该命令与 npm shrinkwrap 类似，但应该小心使用，因为通过 yarn add 和 yarn upgrade 命令添加或更新依赖时会自动更新生成该锁文件。</p>\n<h4 id=\"快速安装\"><a href=\"#快速安装\" class=\"headerlink\" title=\"快速安装\"></a>快速安装</h4><p>npm install -g yarn</p>\n<h4 id=\"常用命令快速对比\"><a href=\"#常用命令快速对比\" class=\"headerlink\" title=\"常用命令快速对比\"></a>常用命令快速对比</h4><p>npm install  =&gt; yarn install<br>npm install –save =&gt; yarn add<br>npm install –save-dev =&gt; yarn add -dev</p>\n<h4 id=\"针对国内的设置\"><a href=\"#针对国内的设置\" class=\"headerlink\" title=\"针对国内的设置\"></a>针对国内的设置</h4><p>如果没有出现网络问题，请直接忽略下面的内容。如果出现错误可以考虑设置一下npm源，代码如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yarn config set registry https://registry.npm.taobao.org</div></pre></td></tr></table></figure></p>\n"},{"title":"APP推广第一步:五大ASO优化方法","date":"2015-06-16T02:40:50.000Z","_content":"ASO,全称(AppStoreOptimization),俗称应用市场优化,是一项让开发者的APP更容易被用户在App Store内搜索到的APP推广技术。第一次听别人说这个词的时候还不了解，度娘了解了下在此记录，和seo理论差不太多，操作方法应该还是有不少差异的！\n　　APP上架后的曝光度,是所有资金短缺的开发者让自己的应用进入市场的一大短板。那么你该如何在App Store获得曝光度?如果你认为ASO是一个选择,那么你就走对路了!更多用户主要是通过检索来发现应用。通过这一途径获得曝光度的应用数量远甚于口头传播,以及浏览热门榜单等途径。\n　　下面就来介绍IOS的ASO优化的五大方法:\n\n#### 1. 关键词\n　　关键词虽然无趣,但你提升排名就是离不开关键词。关键词决定了人们在App Store进行搜索时,你的应用出现在检索结果列表中的排名情况。因为较高的排名可以让你的游戏获得更高的曝光度,所以有必要知道如何在为应用命名时,以及在iTunes Connect表格中使用关键词。\n　　为了获得最大数量的关键词,你必须分析自己的竞争对手,看看最适合它们的关键词是什么。我们还要查看行业顶级工作室所使用的是哪类关键词,以借鉴他们的关键词策略。\n　　在此你要用100个字符来描述与应用最为相关的关键词。\n　　不要使用空格,要用逗号隔开关键词。\n　　用普遍的语言和简短的文字。\n　　要从用户角度出发,想想如果是你在寻找一款APP,你如何检索?\n\n#### 2. 应用标题\n　　你的应用名称是VITAL,尽量简化它。\n　　虽然它并不一定是独特的,但要让它具有描述性。\n　　要令其与应用类型或者你的目标用户想要的结果相关。\n　　你的应用名称字符在检索结果中只会出现25个。要确保显示其中最重要的信息,以免漏掉重要内容。\n　　你并不需要使用“免费”一词。如果你的应用是免费的,App Store在分类时会自动将其归入“免费”类型。\n\n#### 3. 应用描述\n　　虽然它并不会编入App Store索引,但仍然会发挥作用。\n　　文本的第一行内容相当重要,因为它代表你从群体中脱颖而出的机会。\n　　描述你应用的内容,并重复你应用中最重要的关键字。\n\n#### 4.评分和评价\n　　你无法完全掌控它们,但你还是可以让形势朝有利于自己的方向发展。\n　　创造优秀的内容可以产生好评。\n　　在用户“感到快乐”的时候请求其评价,例如,在用户完成一个奖励任务或者击败一次高分时。记住要引导,而不是强迫。\n\n#### 5. 下载量\n　　你可能没有足够的财力购买安装量,所以在设计上多花点心思吧。\n　　让你的应用图标在同类产品中脱颖而出。\n　　用截图来显示应用的自然流程,以便用户一眼就能看出它的运行方式。\n\n#### 总结\n　　一定要记住要同时运用这些影响ASO的不同层面,不可偏废其中之一,它们是相辅相成的!ASO优化并不是一撮而就,这是一个长期的工作,我们需要的是一步一步的去完善它,在不久的将来你一定会成功。参考来源于网络。","source":"_posts/aso.md","raw":"---\ntitle: APP推广第一步:五大ASO优化方法\ndate: 2015-06-16 10:40:50\ntags: aso\n---\nASO,全称(AppStoreOptimization),俗称应用市场优化,是一项让开发者的APP更容易被用户在App Store内搜索到的APP推广技术。第一次听别人说这个词的时候还不了解，度娘了解了下在此记录，和seo理论差不太多，操作方法应该还是有不少差异的！\n　　APP上架后的曝光度,是所有资金短缺的开发者让自己的应用进入市场的一大短板。那么你该如何在App Store获得曝光度?如果你认为ASO是一个选择,那么你就走对路了!更多用户主要是通过检索来发现应用。通过这一途径获得曝光度的应用数量远甚于口头传播,以及浏览热门榜单等途径。\n　　下面就来介绍IOS的ASO优化的五大方法:\n\n#### 1. 关键词\n　　关键词虽然无趣,但你提升排名就是离不开关键词。关键词决定了人们在App Store进行搜索时,你的应用出现在检索结果列表中的排名情况。因为较高的排名可以让你的游戏获得更高的曝光度,所以有必要知道如何在为应用命名时,以及在iTunes Connect表格中使用关键词。\n　　为了获得最大数量的关键词,你必须分析自己的竞争对手,看看最适合它们的关键词是什么。我们还要查看行业顶级工作室所使用的是哪类关键词,以借鉴他们的关键词策略。\n　　在此你要用100个字符来描述与应用最为相关的关键词。\n　　不要使用空格,要用逗号隔开关键词。\n　　用普遍的语言和简短的文字。\n　　要从用户角度出发,想想如果是你在寻找一款APP,你如何检索?\n\n#### 2. 应用标题\n　　你的应用名称是VITAL,尽量简化它。\n　　虽然它并不一定是独特的,但要让它具有描述性。\n　　要令其与应用类型或者你的目标用户想要的结果相关。\n　　你的应用名称字符在检索结果中只会出现25个。要确保显示其中最重要的信息,以免漏掉重要内容。\n　　你并不需要使用“免费”一词。如果你的应用是免费的,App Store在分类时会自动将其归入“免费”类型。\n\n#### 3. 应用描述\n　　虽然它并不会编入App Store索引,但仍然会发挥作用。\n　　文本的第一行内容相当重要,因为它代表你从群体中脱颖而出的机会。\n　　描述你应用的内容,并重复你应用中最重要的关键字。\n\n#### 4.评分和评价\n　　你无法完全掌控它们,但你还是可以让形势朝有利于自己的方向发展。\n　　创造优秀的内容可以产生好评。\n　　在用户“感到快乐”的时候请求其评价,例如,在用户完成一个奖励任务或者击败一次高分时。记住要引导,而不是强迫。\n\n#### 5. 下载量\n　　你可能没有足够的财力购买安装量,所以在设计上多花点心思吧。\n　　让你的应用图标在同类产品中脱颖而出。\n　　用截图来显示应用的自然流程,以便用户一眼就能看出它的运行方式。\n\n#### 总结\n　　一定要记住要同时运用这些影响ASO的不同层面,不可偏废其中之一,它们是相辅相成的!ASO优化并不是一撮而就,这是一个长期的工作,我们需要的是一步一步的去完善它,在不久的将来你一定会成功。参考来源于网络。","slug":"aso","published":1,"updated":"2017-01-16T02:45:28.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixzjjbk80000mgtuzim1mpsj","content":"<p>ASO,全称(AppStoreOptimization),俗称应用市场优化,是一项让开发者的APP更容易被用户在App Store内搜索到的APP推广技术。第一次听别人说这个词的时候还不了解，度娘了解了下在此记录，和seo理论差不太多，操作方法应该还是有不少差异的！<br>　　APP上架后的曝光度,是所有资金短缺的开发者让自己的应用进入市场的一大短板。那么你该如何在App Store获得曝光度?如果你认为ASO是一个选择,那么你就走对路了!更多用户主要是通过检索来发现应用。通过这一途径获得曝光度的应用数量远甚于口头传播,以及浏览热门榜单等途径。<br>　　下面就来介绍IOS的ASO优化的五大方法:</p>\n<h4 id=\"1-关键词\"><a href=\"#1-关键词\" class=\"headerlink\" title=\"1. 关键词\"></a>1. 关键词</h4><p>　　关键词虽然无趣,但你提升排名就是离不开关键词。关键词决定了人们在App Store进行搜索时,你的应用出现在检索结果列表中的排名情况。因为较高的排名可以让你的游戏获得更高的曝光度,所以有必要知道如何在为应用命名时,以及在iTunes Connect表格中使用关键词。<br>　　为了获得最大数量的关键词,你必须分析自己的竞争对手,看看最适合它们的关键词是什么。我们还要查看行业顶级工作室所使用的是哪类关键词,以借鉴他们的关键词策略。<br>　　在此你要用100个字符来描述与应用最为相关的关键词。<br>　　不要使用空格,要用逗号隔开关键词。<br>　　用普遍的语言和简短的文字。<br>　　要从用户角度出发,想想如果是你在寻找一款APP,你如何检索?</p>\n<h4 id=\"2-应用标题\"><a href=\"#2-应用标题\" class=\"headerlink\" title=\"2. 应用标题\"></a>2. 应用标题</h4><p>　　你的应用名称是VITAL,尽量简化它。<br>　　虽然它并不一定是独特的,但要让它具有描述性。<br>　　要令其与应用类型或者你的目标用户想要的结果相关。<br>　　你的应用名称字符在检索结果中只会出现25个。要确保显示其中最重要的信息,以免漏掉重要内容。<br>　　你并不需要使用“免费”一词。如果你的应用是免费的,App Store在分类时会自动将其归入“免费”类型。</p>\n<h4 id=\"3-应用描述\"><a href=\"#3-应用描述\" class=\"headerlink\" title=\"3. 应用描述\"></a>3. 应用描述</h4><p>　　虽然它并不会编入App Store索引,但仍然会发挥作用。<br>　　文本的第一行内容相当重要,因为它代表你从群体中脱颖而出的机会。<br>　　描述你应用的内容,并重复你应用中最重要的关键字。</p>\n<h4 id=\"4-评分和评价\"><a href=\"#4-评分和评价\" class=\"headerlink\" title=\"4.评分和评价\"></a>4.评分和评价</h4><p>　　你无法完全掌控它们,但你还是可以让形势朝有利于自己的方向发展。<br>　　创造优秀的内容可以产生好评。<br>　　在用户“感到快乐”的时候请求其评价,例如,在用户完成一个奖励任务或者击败一次高分时。记住要引导,而不是强迫。</p>\n<h4 id=\"5-下载量\"><a href=\"#5-下载量\" class=\"headerlink\" title=\"5. 下载量\"></a>5. 下载量</h4><p>　　你可能没有足够的财力购买安装量,所以在设计上多花点心思吧。<br>　　让你的应用图标在同类产品中脱颖而出。<br>　　用截图来显示应用的自然流程,以便用户一眼就能看出它的运行方式。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>　　一定要记住要同时运用这些影响ASO的不同层面,不可偏废其中之一,它们是相辅相成的!ASO优化并不是一撮而就,这是一个长期的工作,我们需要的是一步一步的去完善它,在不久的将来你一定会成功。参考来源于网络。</p>\n","excerpt":"","more":"<p>ASO,全称(AppStoreOptimization),俗称应用市场优化,是一项让开发者的APP更容易被用户在App Store内搜索到的APP推广技术。第一次听别人说这个词的时候还不了解，度娘了解了下在此记录，和seo理论差不太多，操作方法应该还是有不少差异的！<br>　　APP上架后的曝光度,是所有资金短缺的开发者让自己的应用进入市场的一大短板。那么你该如何在App Store获得曝光度?如果你认为ASO是一个选择,那么你就走对路了!更多用户主要是通过检索来发现应用。通过这一途径获得曝光度的应用数量远甚于口头传播,以及浏览热门榜单等途径。<br>　　下面就来介绍IOS的ASO优化的五大方法:</p>\n<h4 id=\"1-关键词\"><a href=\"#1-关键词\" class=\"headerlink\" title=\"1. 关键词\"></a>1. 关键词</h4><p>　　关键词虽然无趣,但你提升排名就是离不开关键词。关键词决定了人们在App Store进行搜索时,你的应用出现在检索结果列表中的排名情况。因为较高的排名可以让你的游戏获得更高的曝光度,所以有必要知道如何在为应用命名时,以及在iTunes Connect表格中使用关键词。<br>　　为了获得最大数量的关键词,你必须分析自己的竞争对手,看看最适合它们的关键词是什么。我们还要查看行业顶级工作室所使用的是哪类关键词,以借鉴他们的关键词策略。<br>　　在此你要用100个字符来描述与应用最为相关的关键词。<br>　　不要使用空格,要用逗号隔开关键词。<br>　　用普遍的语言和简短的文字。<br>　　要从用户角度出发,想想如果是你在寻找一款APP,你如何检索?</p>\n<h4 id=\"2-应用标题\"><a href=\"#2-应用标题\" class=\"headerlink\" title=\"2. 应用标题\"></a>2. 应用标题</h4><p>　　你的应用名称是VITAL,尽量简化它。<br>　　虽然它并不一定是独特的,但要让它具有描述性。<br>　　要令其与应用类型或者你的目标用户想要的结果相关。<br>　　你的应用名称字符在检索结果中只会出现25个。要确保显示其中最重要的信息,以免漏掉重要内容。<br>　　你并不需要使用“免费”一词。如果你的应用是免费的,App Store在分类时会自动将其归入“免费”类型。</p>\n<h4 id=\"3-应用描述\"><a href=\"#3-应用描述\" class=\"headerlink\" title=\"3. 应用描述\"></a>3. 应用描述</h4><p>　　虽然它并不会编入App Store索引,但仍然会发挥作用。<br>　　文本的第一行内容相当重要,因为它代表你从群体中脱颖而出的机会。<br>　　描述你应用的内容,并重复你应用中最重要的关键字。</p>\n<h4 id=\"4-评分和评价\"><a href=\"#4-评分和评价\" class=\"headerlink\" title=\"4.评分和评价\"></a>4.评分和评价</h4><p>　　你无法完全掌控它们,但你还是可以让形势朝有利于自己的方向发展。<br>　　创造优秀的内容可以产生好评。<br>　　在用户“感到快乐”的时候请求其评价,例如,在用户完成一个奖励任务或者击败一次高分时。记住要引导,而不是强迫。</p>\n<h4 id=\"5-下载量\"><a href=\"#5-下载量\" class=\"headerlink\" title=\"5. 下载量\"></a>5. 下载量</h4><p>　　你可能没有足够的财力购买安装量,所以在设计上多花点心思吧。<br>　　让你的应用图标在同类产品中脱颖而出。<br>　　用截图来显示应用的自然流程,以便用户一眼就能看出它的运行方式。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>　　一定要记住要同时运用这些影响ASO的不同层面,不可偏废其中之一,它们是相辅相成的!ASO优化并不是一撮而就,这是一个长期的工作,我们需要的是一步一步的去完善它,在不久的将来你一定会成功。参考来源于网络。</p>\n"},{"title":"怎么利用新闻源让关键词有好的排名","date":"2014-07-16T02:31:35.000Z","_content":"新闻源平台往往都是高权重的平台，只要发布的新闻源内容大多都会被百度收录，那么除了收录之余怎么做到上首页呢?这里教大家几个方法，如何利用高权重平台发布新闻源并获得较好排名。\n#### 一、内容具备新闻的特性\n    新闻的最大价值在于是否有新闻的价值，而百度对新闻源的收录也不是做到百分百。因为百度有属于自己的收录机制，如果没有发现此新闻是已经重复的或者已经不具备新闻的价值的时候，百度往往不会收录此内容。而且新闻内容相关这个是必须的，还有个很重要的相关就是区域，比如我搜索北京的新闻，那北京的网站发布的估计就比其他城市的网站发布的排名好，大网站当然是例外了。\n#### 二、选择高权重新闻源平台\n    发布新闻源的朋友应该知道，新闻源平台权重最高的分别是新浪、搜狐、网易、凤凰。而这四个平台的收录往往也是最贵的，那么除了其他新闻源平台之外，如何对高权重的平台进行选择呢?首先考虑平台内容的垂直性，虽然每个平台涉及的范围都很广，但是哪个平台对应板块的权重越高哪个就是首选，然后对这些发布过的平台进行收录以及排名的统计，结合数据分析分别投放什么平台比较好。\n#### 三、新闻发布符合SEO\n    这一点其实也是出了本身新闻以及平台之外最重要的一点，因为当平台选择以及新闻的特性都满足的时候，往往发布的内容还是没有出现在百度首页。那么该怎么办呢?针对这个问题就必须对本身发布的内容进行调整，对单篇文章来说，标题、关键词、描述的写法尤为重要。因为关键词百度前几年已经明确表示不纳入考核范围了。那么从SEO角度分析三点希望对你们有用。1、标题描述的写法针对关键词互相对应。2、关键词在文中的密度大约在8%左右。3、利用新闻源平台发布可带超链接的内容变相为想上首页的内容做外链+普通高权重外链。\n\n    很多时候考虑到购买新闻源比较贵，那么就想物尽其用。第一是想把关键词在百度首页展示，展示的同时呢，最好能带上品牌词，因为这样才是最大程度的曝光以及品牌推广。那么如果是想关键词上首页同时展示品牌词的话，估计在内容以及文章SEO方面需要好好的衡量一下。","source":"_posts/newsyuanseo.md","raw":"---\ntitle: 怎么利用新闻源让关键词有好的排名\ndate: 2014-07-16 10:31:35\ntags: seo 新闻源\n---\n新闻源平台往往都是高权重的平台，只要发布的新闻源内容大多都会被百度收录，那么除了收录之余怎么做到上首页呢?这里教大家几个方法，如何利用高权重平台发布新闻源并获得较好排名。\n#### 一、内容具备新闻的特性\n    新闻的最大价值在于是否有新闻的价值，而百度对新闻源的收录也不是做到百分百。因为百度有属于自己的收录机制，如果没有发现此新闻是已经重复的或者已经不具备新闻的价值的时候，百度往往不会收录此内容。而且新闻内容相关这个是必须的，还有个很重要的相关就是区域，比如我搜索北京的新闻，那北京的网站发布的估计就比其他城市的网站发布的排名好，大网站当然是例外了。\n#### 二、选择高权重新闻源平台\n    发布新闻源的朋友应该知道，新闻源平台权重最高的分别是新浪、搜狐、网易、凤凰。而这四个平台的收录往往也是最贵的，那么除了其他新闻源平台之外，如何对高权重的平台进行选择呢?首先考虑平台内容的垂直性，虽然每个平台涉及的范围都很广，但是哪个平台对应板块的权重越高哪个就是首选，然后对这些发布过的平台进行收录以及排名的统计，结合数据分析分别投放什么平台比较好。\n#### 三、新闻发布符合SEO\n    这一点其实也是出了本身新闻以及平台之外最重要的一点，因为当平台选择以及新闻的特性都满足的时候，往往发布的内容还是没有出现在百度首页。那么该怎么办呢?针对这个问题就必须对本身发布的内容进行调整，对单篇文章来说，标题、关键词、描述的写法尤为重要。因为关键词百度前几年已经明确表示不纳入考核范围了。那么从SEO角度分析三点希望对你们有用。1、标题描述的写法针对关键词互相对应。2、关键词在文中的密度大约在8%左右。3、利用新闻源平台发布可带超链接的内容变相为想上首页的内容做外链+普通高权重外链。\n\n    很多时候考虑到购买新闻源比较贵，那么就想物尽其用。第一是想把关键词在百度首页展示，展示的同时呢，最好能带上品牌词，因为这样才是最大程度的曝光以及品牌推广。那么如果是想关键词上首页同时展示品牌词的话，估计在内容以及文章SEO方面需要好好的衡量一下。","slug":"newsyuanseo","published":1,"updated":"2017-01-16T02:36:49.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixzjjbkr0001mgtufk234wo1","content":"<p>新闻源平台往往都是高权重的平台，只要发布的新闻源内容大多都会被百度收录，那么除了收录之余怎么做到上首页呢?这里教大家几个方法，如何利用高权重平台发布新闻源并获得较好排名。</p>\n<h4 id=\"一、内容具备新闻的特性\"><a href=\"#一、内容具备新闻的特性\" class=\"headerlink\" title=\"一、内容具备新闻的特性\"></a>一、内容具备新闻的特性</h4><pre><code>新闻的最大价值在于是否有新闻的价值，而百度对新闻源的收录也不是做到百分百。因为百度有属于自己的收录机制，如果没有发现此新闻是已经重复的或者已经不具备新闻的价值的时候，百度往往不会收录此内容。而且新闻内容相关这个是必须的，还有个很重要的相关就是区域，比如我搜索北京的新闻，那北京的网站发布的估计就比其他城市的网站发布的排名好，大网站当然是例外了。\n</code></pre><h4 id=\"二、选择高权重新闻源平台\"><a href=\"#二、选择高权重新闻源平台\" class=\"headerlink\" title=\"二、选择高权重新闻源平台\"></a>二、选择高权重新闻源平台</h4><pre><code>发布新闻源的朋友应该知道，新闻源平台权重最高的分别是新浪、搜狐、网易、凤凰。而这四个平台的收录往往也是最贵的，那么除了其他新闻源平台之外，如何对高权重的平台进行选择呢?首先考虑平台内容的垂直性，虽然每个平台涉及的范围都很广，但是哪个平台对应板块的权重越高哪个就是首选，然后对这些发布过的平台进行收录以及排名的统计，结合数据分析分别投放什么平台比较好。\n</code></pre><h4 id=\"三、新闻发布符合SEO\"><a href=\"#三、新闻发布符合SEO\" class=\"headerlink\" title=\"三、新闻发布符合SEO\"></a>三、新闻发布符合SEO</h4><pre><code>这一点其实也是出了本身新闻以及平台之外最重要的一点，因为当平台选择以及新闻的特性都满足的时候，往往发布的内容还是没有出现在百度首页。那么该怎么办呢?针对这个问题就必须对本身发布的内容进行调整，对单篇文章来说，标题、关键词、描述的写法尤为重要。因为关键词百度前几年已经明确表示不纳入考核范围了。那么从SEO角度分析三点希望对你们有用。1、标题描述的写法针对关键词互相对应。2、关键词在文中的密度大约在8%左右。3、利用新闻源平台发布可带超链接的内容变相为想上首页的内容做外链+普通高权重外链。\n\n很多时候考虑到购买新闻源比较贵，那么就想物尽其用。第一是想把关键词在百度首页展示，展示的同时呢，最好能带上品牌词，因为这样才是最大程度的曝光以及品牌推广。那么如果是想关键词上首页同时展示品牌词的话，估计在内容以及文章SEO方面需要好好的衡量一下。\n</code></pre>","excerpt":"","more":"<p>新闻源平台往往都是高权重的平台，只要发布的新闻源内容大多都会被百度收录，那么除了收录之余怎么做到上首页呢?这里教大家几个方法，如何利用高权重平台发布新闻源并获得较好排名。</p>\n<h4 id=\"一、内容具备新闻的特性\"><a href=\"#一、内容具备新闻的特性\" class=\"headerlink\" title=\"一、内容具备新闻的特性\"></a>一、内容具备新闻的特性</h4><pre><code>新闻的最大价值在于是否有新闻的价值，而百度对新闻源的收录也不是做到百分百。因为百度有属于自己的收录机制，如果没有发现此新闻是已经重复的或者已经不具备新闻的价值的时候，百度往往不会收录此内容。而且新闻内容相关这个是必须的，还有个很重要的相关就是区域，比如我搜索北京的新闻，那北京的网站发布的估计就比其他城市的网站发布的排名好，大网站当然是例外了。\n</code></pre><h4 id=\"二、选择高权重新闻源平台\"><a href=\"#二、选择高权重新闻源平台\" class=\"headerlink\" title=\"二、选择高权重新闻源平台\"></a>二、选择高权重新闻源平台</h4><pre><code>发布新闻源的朋友应该知道，新闻源平台权重最高的分别是新浪、搜狐、网易、凤凰。而这四个平台的收录往往也是最贵的，那么除了其他新闻源平台之外，如何对高权重的平台进行选择呢?首先考虑平台内容的垂直性，虽然每个平台涉及的范围都很广，但是哪个平台对应板块的权重越高哪个就是首选，然后对这些发布过的平台进行收录以及排名的统计，结合数据分析分别投放什么平台比较好。\n</code></pre><h4 id=\"三、新闻发布符合SEO\"><a href=\"#三、新闻发布符合SEO\" class=\"headerlink\" title=\"三、新闻发布符合SEO\"></a>三、新闻发布符合SEO</h4><pre><code>这一点其实也是出了本身新闻以及平台之外最重要的一点，因为当平台选择以及新闻的特性都满足的时候，往往发布的内容还是没有出现在百度首页。那么该怎么办呢?针对这个问题就必须对本身发布的内容进行调整，对单篇文章来说，标题、关键词、描述的写法尤为重要。因为关键词百度前几年已经明确表示不纳入考核范围了。那么从SEO角度分析三点希望对你们有用。1、标题描述的写法针对关键词互相对应。2、关键词在文中的密度大约在8%左右。3、利用新闻源平台发布可带超链接的内容变相为想上首页的内容做外链+普通高权重外链。\n\n很多时候考虑到购买新闻源比较贵，那么就想物尽其用。第一是想把关键词在百度首页展示，展示的同时呢，最好能带上品牌词，因为这样才是最大程度的曝光以及品牌推广。那么如果是想关键词上首页同时展示品牌词的话，估计在内容以及文章SEO方面需要好好的衡量一下。\n</code></pre>"},{"title":"前端人员应注意的几点细节","date":"2015-09-29T03:20:27.000Z","_content":"合格前端开发工程师应该注意一些网页制作细节问题。细节如下：\n\n#### 一、缺少网站必备的三要素\n可能很多人做网站，都是直接用DW或者其它工具生成的网页，网站只有一个title。而缺少keywords(关键词)、description（描述）。为什么一个网页要加这三要素呢？可能很多人都不是很明白。因为我们所做出来的网站是为了做SEO优化的，为了提升网站在百度和其它搜索引擎的排名。如果没这三要素，请问你的网站怎么去做排名，又怎么去盈利呢？\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/sitesanyaosu.png-public)\n</div>\n\n#### 二、代码方面\n1.给代码加注释\n身为一个合格的web前端人员，我认为首先第一点：得为html代码加注释，为什么说要给html代码加注释呢？是为了给后台程序人员写动态网页节省工作量，如果说你整个网页都没加注释，别人又怎么知道你这段代码表示的是什么？别人还要重新去了解你这段代码的意思是什么，是不是无意间给别人增加了工作量。以后前后端分离了就没有这么麻烦了，期待那一天的到来。\n\n2.代码命名\n在代码命名上，我们最好采用见名知意的英语单词，或者拼音简写来命名。让别人第一眼看你带就觉得你是一个专业的人士，而并非业余人员。比如：头部：header 尾部：footer 内容：content 关于我们：about....\n\n3.代码美化上\n在代码美化上，我觉得做到最好让别人一眼就可以看出来你这块是表明的是什么。\n\n4.图片优化上\n很多人可能对插入一张图片，就只有一个src(引用地址)。而缺少其它三大属性。一个<img/>标签，包含四大要素，分别为：src(引用地址)、width(宽度)、height（高度）、alt(描述)，alt描述也是最为重要的一点。因为搜索引擎不识别图片，只有靠alt属性来告诉搜索引擎这张图片代表什么含义。同时也符合SEO优化。\n\n#### 总结：\n其实不管是做什么事情，细节真的很重要。细节决定成败，在高手与高手的较量中，往往是细节方面的处理。","source":"_posts/qianduanxijie.md","raw":"---\ntitle: 前端人员应注意的几点细节\ndate: 2015-09-29 11:20:27\ntags: web\n---\n合格前端开发工程师应该注意一些网页制作细节问题。细节如下：\n\n#### 一、缺少网站必备的三要素\n可能很多人做网站，都是直接用DW或者其它工具生成的网页，网站只有一个title。而缺少keywords(关键词)、description（描述）。为什么一个网页要加这三要素呢？可能很多人都不是很明白。因为我们所做出来的网站是为了做SEO优化的，为了提升网站在百度和其它搜索引擎的排名。如果没这三要素，请问你的网站怎么去做排名，又怎么去盈利呢？\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/sitesanyaosu.png-public)\n</div>\n\n#### 二、代码方面\n1.给代码加注释\n身为一个合格的web前端人员，我认为首先第一点：得为html代码加注释，为什么说要给html代码加注释呢？是为了给后台程序人员写动态网页节省工作量，如果说你整个网页都没加注释，别人又怎么知道你这段代码表示的是什么？别人还要重新去了解你这段代码的意思是什么，是不是无意间给别人增加了工作量。以后前后端分离了就没有这么麻烦了，期待那一天的到来。\n\n2.代码命名\n在代码命名上，我们最好采用见名知意的英语单词，或者拼音简写来命名。让别人第一眼看你带就觉得你是一个专业的人士，而并非业余人员。比如：头部：header 尾部：footer 内容：content 关于我们：about....\n\n3.代码美化上\n在代码美化上，我觉得做到最好让别人一眼就可以看出来你这块是表明的是什么。\n\n4.图片优化上\n很多人可能对插入一张图片，就只有一个src(引用地址)。而缺少其它三大属性。一个<img/>标签，包含四大要素，分别为：src(引用地址)、width(宽度)、height（高度）、alt(描述)，alt描述也是最为重要的一点。因为搜索引擎不识别图片，只有靠alt属性来告诉搜索引擎这张图片代表什么含义。同时也符合SEO优化。\n\n#### 总结：\n其实不管是做什么事情，细节真的很重要。细节决定成败，在高手与高手的较量中，往往是细节方面的处理。","slug":"qianduanxijie","published":1,"updated":"2017-01-16T03:32:40.902Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixzjjblt0003mgtumuqfp1gi","content":"<p>合格前端开发工程师应该注意一些网页制作细节问题。细节如下：</p>\n<h4 id=\"一、缺少网站必备的三要素\"><a href=\"#一、缺少网站必备的三要素\" class=\"headerlink\" title=\"一、缺少网站必备的三要素\"></a>一、缺少网站必备的三要素</h4><p>可能很多人做网站，都是直接用DW或者其它工具生成的网页，网站只有一个title。而缺少keywords(关键词)、description（描述）。为什么一个网页要加这三要素呢？可能很多人都不是很明白。因为我们所做出来的网站是为了做SEO优化的，为了提升网站在百度和其它搜索引擎的排名。如果没这三要素，请问你的网站怎么去做排名，又怎么去盈利呢？</p>\n<div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/sitesanyaosu.png-public\" alt=\"\"><br></div>\n\n<h4 id=\"二、代码方面\"><a href=\"#二、代码方面\" class=\"headerlink\" title=\"二、代码方面\"></a>二、代码方面</h4><p>1.给代码加注释<br>身为一个合格的web前端人员，我认为首先第一点：得为html代码加注释，为什么说要给html代码加注释呢？是为了给后台程序人员写动态网页节省工作量，如果说你整个网页都没加注释，别人又怎么知道你这段代码表示的是什么？别人还要重新去了解你这段代码的意思是什么，是不是无意间给别人增加了工作量。以后前后端分离了就没有这么麻烦了，期待那一天的到来。</p>\n<p>2.代码命名<br>在代码命名上，我们最好采用见名知意的英语单词，或者拼音简写来命名。让别人第一眼看你带就觉得你是一个专业的人士，而并非业余人员。比如：头部：header 尾部：footer 内容：content 关于我们：about….</p>\n<p>3.代码美化上<br>在代码美化上，我觉得做到最好让别人一眼就可以看出来你这块是表明的是什么。</p>\n<p>4.图片优化上<br>很多人可能对插入一张图片，就只有一个src(引用地址)。而缺少其它三大属性。一个<img>标签，包含四大要素，分别为：src(引用地址)、width(宽度)、height（高度）、alt(描述)，alt描述也是最为重要的一点。因为搜索引擎不识别图片，只有靠alt属性来告诉搜索引擎这张图片代表什么含义。同时也符合SEO优化。</p>\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>其实不管是做什么事情，细节真的很重要。细节决定成败，在高手与高手的较量中，往往是细节方面的处理。</p>\n","excerpt":"","more":"<p>合格前端开发工程师应该注意一些网页制作细节问题。细节如下：</p>\n<h4 id=\"一、缺少网站必备的三要素\"><a href=\"#一、缺少网站必备的三要素\" class=\"headerlink\" title=\"一、缺少网站必备的三要素\"></a>一、缺少网站必备的三要素</h4><p>可能很多人做网站，都是直接用DW或者其它工具生成的网页，网站只有一个title。而缺少keywords(关键词)、description（描述）。为什么一个网页要加这三要素呢？可能很多人都不是很明白。因为我们所做出来的网站是为了做SEO优化的，为了提升网站在百度和其它搜索引擎的排名。如果没这三要素，请问你的网站怎么去做排名，又怎么去盈利呢？</p>\n<div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/sitesanyaosu.png-public\" alt=\"\"><br></div>\n\n<h4 id=\"二、代码方面\"><a href=\"#二、代码方面\" class=\"headerlink\" title=\"二、代码方面\"></a>二、代码方面</h4><p>1.给代码加注释<br>身为一个合格的web前端人员，我认为首先第一点：得为html代码加注释，为什么说要给html代码加注释呢？是为了给后台程序人员写动态网页节省工作量，如果说你整个网页都没加注释，别人又怎么知道你这段代码表示的是什么？别人还要重新去了解你这段代码的意思是什么，是不是无意间给别人增加了工作量。以后前后端分离了就没有这么麻烦了，期待那一天的到来。</p>\n<p>2.代码命名<br>在代码命名上，我们最好采用见名知意的英语单词，或者拼音简写来命名。让别人第一眼看你带就觉得你是一个专业的人士，而并非业余人员。比如：头部：header 尾部：footer 内容：content 关于我们：about….</p>\n<p>3.代码美化上<br>在代码美化上，我觉得做到最好让别人一眼就可以看出来你这块是表明的是什么。</p>\n<p>4.图片优化上<br>很多人可能对插入一张图片，就只有一个src(引用地址)。而缺少其它三大属性。一个<img/>标签，包含四大要素，分别为：src(引用地址)、width(宽度)、height（高度）、alt(描述)，alt描述也是最为重要的一点。因为搜索引擎不识别图片，只有靠alt属性来告诉搜索引擎这张图片代表什么含义。同时也符合SEO优化。</p>\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>其实不管是做什么事情，细节真的很重要。细节决定成败，在高手与高手的较量中，往往是细节方面的处理。</p>\n"},{"title":"网站SEO优化常见问题汇总1","date":"2015-01-16T01:56:47.000Z","_content":"为解决网站seo优化问题，特在此记录，共同学习，如有不足或错误之处，欢迎指正。\n\n#### 百度每更新一次，网站的收录就减少很多，但是我每天都增加伪原创的内容啊？\n　　这个问题大多数是因为网站权重导致百度不够重视你；另外就是文章质量度不高，没有可读性或是原创度太低，尽管百度会收录，但是经过一次更新后可能会太淘汰，你的文章质量越高，收录的可能性越高；还有就是网站网页的重复度过高，百度更新后直接删除重复的内容；当然也有可能是百度自身算法更新，你的网站某些文章受更新影响。\n#### 今天百度更新了，关键词排名掉下去了，快照竟然慢下来了，这该怎么办啊?\n　　这是一个经常被问3到的问题，首先我们要了解百度的最新更新和更新的内容，判断排名下降的原因，继续做该做的事情，不要怨天尤人，不要轻言放弃，坚持下去会恢复到以前甚至更好。\n#### 网站内容几乎每天都有更新，外链也一直在做，可最近流量怎么老是停滞不前呢？\n　　内容更新和外链确实可以为网站带来流量，主要是让网站在搜索引擎有一个好的排名，通过搜索引擎带来流量，从而达到转化率！属于一个长期的培养的过程!但是获得流量的方式很多，并不仅限于搜索引擎。\n#### 百度和Google是不是抓取关键字原理上有什么差别啊？\n　　谷歌和百度的算法确实是不大相同的，百度人工干涉太多，但是最终的原理是一样的。只要内容好，不作弊，更新及时，原创多，优质外链多，在任何一个搜索引擎，都会取得好的排名的。\n#### 百度K了网站，请问如何让其重新收录啊？\n　　做内容做用户，不要有任何被搜索引擎认为是作弊的行为，另外网站访问速度要有保证，要稳定。在此期间网站波动一定要小。\n#### 我的网站被降权了，我想问一下有什么好的办法可以让网站排名回来，同时我想问一下要多长时间才能达到以前的排名？\n　　关于降权的恢复和第五个问题的da安是一样的，而至于多久才能达到以前的排名是不确定的，可以是几天也可以是几个月，所以一定要有耐心。\n#### google和百度大概什么时候更新一次啊？\n　　这跟你网站的权重和质量有关，你网站权重高搜索引擎蜘蛛几分钟来一次，你的更新也快。权重不高也许很久都不更新你的站。现在大多数站的情况是一周更新一次，百度在周四凌晨有一次小更新，每月底又一次大更新，而谷歌是三个月更新一次。\n#### 百度快照日更新但就是不收录，这个是什么原因呢？\n　　快照总在更新说明至少蜘蛛是经常来你的网站觅食的，但是至于收录不收录就要看你网站页面的内容，网站布局、加载速度、网站结构等等方面，快照更新并不等于收录快。\n#### 网站打不开，蜘蛛还会来吗？\n　　时间长了的话，可能会影响的，因为长期打不开就相当于被屏蔽了。这就是服务器不稳定，蜘蛛会认为你的站有问题，以后就很少会来了，甚至降权。所以网站服务器和解析等一定要稳定。\n#### 百度快照很久没更新了，为什么？\n　　快照更新的影响因素包括：站内链接，网站更新，外链更新频度，是否作弊等等。很多时候操作不当都会造成百度快照不更新或其他异常。\n#### 由于公司网络调整，服务器停了几天，网站一直打不开。今天在百度搜索公司网站，可是一条都没找到。然后site域名，发现网站被K掉了。这可怎么办呀？\n　　不要着急，这是由于服务器不稳定造成的，这种情况下的降权问题一般不打，继续坚持更新内容，正常更新优质外链，只要再不出现被搜索引擎认为是作弊的行为，就会恢复的，时间应该不会太久。\n#### 网站交换友情链接，对方的网址是.net的，有没有问题？\n　　答：只要对方网站收录正常、没有被K就可以了,用正常交换友情链接的流程判断交换就可以了，至于网站域名的后缀是什么，跟换友情链接没有半毛钱关系，所以不要带有色眼镜看不同后缀的域名。\n#### 网站被K后,现在重新收录了，是不是表示恢复了权重？\n　　网站被降权后恢复收录只是证明搜索引擎还在继续抓取你的网页而已，这和权重是不是要恢复没什么直接关系。看权重恢复可以去查看流量、百度权重、关键词排名等等，网站在收录仅仅是一个好的征兆，如果每天持续更新，并且稳定收录那就会越来越得到搜索引擎好感，离恢复权重也会越来越近!总之网站被降权不等于不收录，收录也不等于权重恢复。\n#### 如何设置关键词密度？\n　　关键字密度是看整个页面的密度，不是仅仅看这两个代码中的密度的。有的人认为密度2%-8%之间最好，有的认为3%-7%，各种各样的都有。其实关键不在密度，文章中自然布局关键词就好，不要刻意去堆砌，现在的搜索引擎新技术是用户体验，抓住用户才能抓住流量，不要为了seo而得罪用户。\n#### 请问怎么样可以有效的增加反链数量？\n　　这个是需要长时间去积累资源和增加反链的，不是说一下子就增加很多反链，在一方面，不要去追求反链的量而忽视了它的质，在百度多次更新后，反链质高于量的声音越来越大。\n#### 做了个网站，没留下任何外链地址，也没向百度谷歌提交收录，为什么就收录了的呢，蜘蜘是从哪爬来的？\n　　这你就太天真了，没有提交百度就不知道吗？当你申请新域名，百度就开始关注你了，并且当你开通虚拟服务器后，搜索引擎会随着IP爬行，爬虫会由其他网站爬到了你的!还有就是很多蜘蛛入口不用我们留也会自动有的，比如说ALEXA这样的排名网站、一些域名信息查询、外链查询的网站都有可能有咱们的外链。所以说蜘蛛的入口是很多的，你没有邀请它，但你也没有拒绝它。\n#### 论坛推广该注意些什么问题?如何植入广告信息或网址?如果找适合自己产品推广的论坛？\n　　首先如果说你做论坛推广的目的还是简单的植入广告，我只能说这就是该注意的地方，论坛推广准则是：重在于质，不在于量。要想把论坛推广做好，不仅仅是发贴子和写软文，一次成功的论坛推广，要融合好多东西进去的。比如：\n　　精准营销：论坛推广应该是精准的，比如我们是汽车网站，那就应该找汽车类的论坛进行营销推广。\n　　口碑营销：论坛营销的目的是为了让用户对产品产生正面的认知，产生口碑的效果。\n　　病毒营销：成功的营销贴，甚至会被大量转载，产生病毒传播的效果。\n　　事件营销：很多时候，一次成功的论坛营销往往需要一个事件来配合。\n　　其它：比体验营销、新闻营销等等。\n#### 网站标题和关键词有什么区别吗？\n　　对于网站SEO优化，特别是关键字优化，网站标题是最关键的，关键词应该包含在标题里面，增加关键词权重和网页的相关性，网站标题和关键词同为SEO优化网页三大要素之一，根本谈不上什么区别，压根就没有任何可比性。\n#### 想知道自己网站的PR值和百度权重，但是不知道怎么看？\n　　这个问题可以说是完全不会seo的人文的，怎么看，直接在百度搜索百度权重或PR查询，你就会了。要说的是pr值是谷歌官方的，但现在谷歌有意慢慢淡出pr值，并且很久都没更新，站长也开始不再非常关注这个。至于百度权重，只是工具上的一种说法，不是百度官方的，所以特别在查询别人权重的时候要注意结合网站其他指标。\n#### 网站标题多长最好？\n　　百度搜索结果标题最多显示30个中文字符，谷歌是32个中文字符，所以标题标签最好不要超过30个中文字，但是为了提高用户体验和突出目标关键词，我们建议长度最好在20个左右。为什么这么说，因为当标题过长的时候，标题头尾很可能被切断，不利于用户深入查看；其次标题过长，无关字必然会多，这样不利于突出目标关键词，降低相关性；还有就是标题过长会分散关键词权重。","source":"_posts/siteseo1.md","raw":"---\ntitle: 网站SEO优化常见问题汇总1\ndate: 2015-01-16 09:56:47\ntags: seo\n---\n为解决网站seo优化问题，特在此记录，共同学习，如有不足或错误之处，欢迎指正。\n\n#### 百度每更新一次，网站的收录就减少很多，但是我每天都增加伪原创的内容啊？\n　　这个问题大多数是因为网站权重导致百度不够重视你；另外就是文章质量度不高，没有可读性或是原创度太低，尽管百度会收录，但是经过一次更新后可能会太淘汰，你的文章质量越高，收录的可能性越高；还有就是网站网页的重复度过高，百度更新后直接删除重复的内容；当然也有可能是百度自身算法更新，你的网站某些文章受更新影响。\n#### 今天百度更新了，关键词排名掉下去了，快照竟然慢下来了，这该怎么办啊?\n　　这是一个经常被问3到的问题，首先我们要了解百度的最新更新和更新的内容，判断排名下降的原因，继续做该做的事情，不要怨天尤人，不要轻言放弃，坚持下去会恢复到以前甚至更好。\n#### 网站内容几乎每天都有更新，外链也一直在做，可最近流量怎么老是停滞不前呢？\n　　内容更新和外链确实可以为网站带来流量，主要是让网站在搜索引擎有一个好的排名，通过搜索引擎带来流量，从而达到转化率！属于一个长期的培养的过程!但是获得流量的方式很多，并不仅限于搜索引擎。\n#### 百度和Google是不是抓取关键字原理上有什么差别啊？\n　　谷歌和百度的算法确实是不大相同的，百度人工干涉太多，但是最终的原理是一样的。只要内容好，不作弊，更新及时，原创多，优质外链多，在任何一个搜索引擎，都会取得好的排名的。\n#### 百度K了网站，请问如何让其重新收录啊？\n　　做内容做用户，不要有任何被搜索引擎认为是作弊的行为，另外网站访问速度要有保证，要稳定。在此期间网站波动一定要小。\n#### 我的网站被降权了，我想问一下有什么好的办法可以让网站排名回来，同时我想问一下要多长时间才能达到以前的排名？\n　　关于降权的恢复和第五个问题的da安是一样的，而至于多久才能达到以前的排名是不确定的，可以是几天也可以是几个月，所以一定要有耐心。\n#### google和百度大概什么时候更新一次啊？\n　　这跟你网站的权重和质量有关，你网站权重高搜索引擎蜘蛛几分钟来一次，你的更新也快。权重不高也许很久都不更新你的站。现在大多数站的情况是一周更新一次，百度在周四凌晨有一次小更新，每月底又一次大更新，而谷歌是三个月更新一次。\n#### 百度快照日更新但就是不收录，这个是什么原因呢？\n　　快照总在更新说明至少蜘蛛是经常来你的网站觅食的，但是至于收录不收录就要看你网站页面的内容，网站布局、加载速度、网站结构等等方面，快照更新并不等于收录快。\n#### 网站打不开，蜘蛛还会来吗？\n　　时间长了的话，可能会影响的，因为长期打不开就相当于被屏蔽了。这就是服务器不稳定，蜘蛛会认为你的站有问题，以后就很少会来了，甚至降权。所以网站服务器和解析等一定要稳定。\n#### 百度快照很久没更新了，为什么？\n　　快照更新的影响因素包括：站内链接，网站更新，外链更新频度，是否作弊等等。很多时候操作不当都会造成百度快照不更新或其他异常。\n#### 由于公司网络调整，服务器停了几天，网站一直打不开。今天在百度搜索公司网站，可是一条都没找到。然后site域名，发现网站被K掉了。这可怎么办呀？\n　　不要着急，这是由于服务器不稳定造成的，这种情况下的降权问题一般不打，继续坚持更新内容，正常更新优质外链，只要再不出现被搜索引擎认为是作弊的行为，就会恢复的，时间应该不会太久。\n#### 网站交换友情链接，对方的网址是.net的，有没有问题？\n　　答：只要对方网站收录正常、没有被K就可以了,用正常交换友情链接的流程判断交换就可以了，至于网站域名的后缀是什么，跟换友情链接没有半毛钱关系，所以不要带有色眼镜看不同后缀的域名。\n#### 网站被K后,现在重新收录了，是不是表示恢复了权重？\n　　网站被降权后恢复收录只是证明搜索引擎还在继续抓取你的网页而已，这和权重是不是要恢复没什么直接关系。看权重恢复可以去查看流量、百度权重、关键词排名等等，网站在收录仅仅是一个好的征兆，如果每天持续更新，并且稳定收录那就会越来越得到搜索引擎好感，离恢复权重也会越来越近!总之网站被降权不等于不收录，收录也不等于权重恢复。\n#### 如何设置关键词密度？\n　　关键字密度是看整个页面的密度，不是仅仅看这两个代码中的密度的。有的人认为密度2%-8%之间最好，有的认为3%-7%，各种各样的都有。其实关键不在密度，文章中自然布局关键词就好，不要刻意去堆砌，现在的搜索引擎新技术是用户体验，抓住用户才能抓住流量，不要为了seo而得罪用户。\n#### 请问怎么样可以有效的增加反链数量？\n　　这个是需要长时间去积累资源和增加反链的，不是说一下子就增加很多反链，在一方面，不要去追求反链的量而忽视了它的质，在百度多次更新后，反链质高于量的声音越来越大。\n#### 做了个网站，没留下任何外链地址，也没向百度谷歌提交收录，为什么就收录了的呢，蜘蜘是从哪爬来的？\n　　这你就太天真了，没有提交百度就不知道吗？当你申请新域名，百度就开始关注你了，并且当你开通虚拟服务器后，搜索引擎会随着IP爬行，爬虫会由其他网站爬到了你的!还有就是很多蜘蛛入口不用我们留也会自动有的，比如说ALEXA这样的排名网站、一些域名信息查询、外链查询的网站都有可能有咱们的外链。所以说蜘蛛的入口是很多的，你没有邀请它，但你也没有拒绝它。\n#### 论坛推广该注意些什么问题?如何植入广告信息或网址?如果找适合自己产品推广的论坛？\n　　首先如果说你做论坛推广的目的还是简单的植入广告，我只能说这就是该注意的地方，论坛推广准则是：重在于质，不在于量。要想把论坛推广做好，不仅仅是发贴子和写软文，一次成功的论坛推广，要融合好多东西进去的。比如：\n　　精准营销：论坛推广应该是精准的，比如我们是汽车网站，那就应该找汽车类的论坛进行营销推广。\n　　口碑营销：论坛营销的目的是为了让用户对产品产生正面的认知，产生口碑的效果。\n　　病毒营销：成功的营销贴，甚至会被大量转载，产生病毒传播的效果。\n　　事件营销：很多时候，一次成功的论坛营销往往需要一个事件来配合。\n　　其它：比体验营销、新闻营销等等。\n#### 网站标题和关键词有什么区别吗？\n　　对于网站SEO优化，特别是关键字优化，网站标题是最关键的，关键词应该包含在标题里面，增加关键词权重和网页的相关性，网站标题和关键词同为SEO优化网页三大要素之一，根本谈不上什么区别，压根就没有任何可比性。\n#### 想知道自己网站的PR值和百度权重，但是不知道怎么看？\n　　这个问题可以说是完全不会seo的人文的，怎么看，直接在百度搜索百度权重或PR查询，你就会了。要说的是pr值是谷歌官方的，但现在谷歌有意慢慢淡出pr值，并且很久都没更新，站长也开始不再非常关注这个。至于百度权重，只是工具上的一种说法，不是百度官方的，所以特别在查询别人权重的时候要注意结合网站其他指标。\n#### 网站标题多长最好？\n　　百度搜索结果标题最多显示30个中文字符，谷歌是32个中文字符，所以标题标签最好不要超过30个中文字，但是为了提高用户体验和突出目标关键词，我们建议长度最好在20个左右。为什么这么说，因为当标题过长的时候，标题头尾很可能被切断，不利于用户深入查看；其次标题过长，无关字必然会多，这样不利于突出目标关键词，降低相关性；还有就是标题过长会分散关键词权重。","slug":"siteseo1","published":1,"updated":"2017-01-16T02:04:00.589Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixzjjblx0004mgtuj32v3bv0","content":"<p>为解决网站seo优化问题，特在此记录，共同学习，如有不足或错误之处，欢迎指正。</p>\n<h4 id=\"百度每更新一次，网站的收录就减少很多，但是我每天都增加伪原创的内容啊？\"><a href=\"#百度每更新一次，网站的收录就减少很多，但是我每天都增加伪原创的内容啊？\" class=\"headerlink\" title=\"百度每更新一次，网站的收录就减少很多，但是我每天都增加伪原创的内容啊？\"></a>百度每更新一次，网站的收录就减少很多，但是我每天都增加伪原创的内容啊？</h4><p>　　这个问题大多数是因为网站权重导致百度不够重视你；另外就是文章质量度不高，没有可读性或是原创度太低，尽管百度会收录，但是经过一次更新后可能会太淘汰，你的文章质量越高，收录的可能性越高；还有就是网站网页的重复度过高，百度更新后直接删除重复的内容；当然也有可能是百度自身算法更新，你的网站某些文章受更新影响。</p>\n<h4 id=\"今天百度更新了，关键词排名掉下去了，快照竟然慢下来了，这该怎么办啊\"><a href=\"#今天百度更新了，关键词排名掉下去了，快照竟然慢下来了，这该怎么办啊\" class=\"headerlink\" title=\"今天百度更新了，关键词排名掉下去了，快照竟然慢下来了，这该怎么办啊?\"></a>今天百度更新了，关键词排名掉下去了，快照竟然慢下来了，这该怎么办啊?</h4><p>　　这是一个经常被问3到的问题，首先我们要了解百度的最新更新和更新的内容，判断排名下降的原因，继续做该做的事情，不要怨天尤人，不要轻言放弃，坚持下去会恢复到以前甚至更好。</p>\n<h4 id=\"网站内容几乎每天都有更新，外链也一直在做，可最近流量怎么老是停滞不前呢？\"><a href=\"#网站内容几乎每天都有更新，外链也一直在做，可最近流量怎么老是停滞不前呢？\" class=\"headerlink\" title=\"网站内容几乎每天都有更新，外链也一直在做，可最近流量怎么老是停滞不前呢？\"></a>网站内容几乎每天都有更新，外链也一直在做，可最近流量怎么老是停滞不前呢？</h4><p>　　内容更新和外链确实可以为网站带来流量，主要是让网站在搜索引擎有一个好的排名，通过搜索引擎带来流量，从而达到转化率！属于一个长期的培养的过程!但是获得流量的方式很多，并不仅限于搜索引擎。</p>\n<h4 id=\"百度和Google是不是抓取关键字原理上有什么差别啊？\"><a href=\"#百度和Google是不是抓取关键字原理上有什么差别啊？\" class=\"headerlink\" title=\"百度和Google是不是抓取关键字原理上有什么差别啊？\"></a>百度和Google是不是抓取关键字原理上有什么差别啊？</h4><p>　　谷歌和百度的算法确实是不大相同的，百度人工干涉太多，但是最终的原理是一样的。只要内容好，不作弊，更新及时，原创多，优质外链多，在任何一个搜索引擎，都会取得好的排名的。</p>\n<h4 id=\"百度K了网站，请问如何让其重新收录啊？\"><a href=\"#百度K了网站，请问如何让其重新收录啊？\" class=\"headerlink\" title=\"百度K了网站，请问如何让其重新收录啊？\"></a>百度K了网站，请问如何让其重新收录啊？</h4><p>　　做内容做用户，不要有任何被搜索引擎认为是作弊的行为，另外网站访问速度要有保证，要稳定。在此期间网站波动一定要小。</p>\n<h4 id=\"我的网站被降权了，我想问一下有什么好的办法可以让网站排名回来，同时我想问一下要多长时间才能达到以前的排名？\"><a href=\"#我的网站被降权了，我想问一下有什么好的办法可以让网站排名回来，同时我想问一下要多长时间才能达到以前的排名？\" class=\"headerlink\" title=\"我的网站被降权了，我想问一下有什么好的办法可以让网站排名回来，同时我想问一下要多长时间才能达到以前的排名？\"></a>我的网站被降权了，我想问一下有什么好的办法可以让网站排名回来，同时我想问一下要多长时间才能达到以前的排名？</h4><p>　　关于降权的恢复和第五个问题的da安是一样的，而至于多久才能达到以前的排名是不确定的，可以是几天也可以是几个月，所以一定要有耐心。</p>\n<h4 id=\"google和百度大概什么时候更新一次啊？\"><a href=\"#google和百度大概什么时候更新一次啊？\" class=\"headerlink\" title=\"google和百度大概什么时候更新一次啊？\"></a>google和百度大概什么时候更新一次啊？</h4><p>　　这跟你网站的权重和质量有关，你网站权重高搜索引擎蜘蛛几分钟来一次，你的更新也快。权重不高也许很久都不更新你的站。现在大多数站的情况是一周更新一次，百度在周四凌晨有一次小更新，每月底又一次大更新，而谷歌是三个月更新一次。</p>\n<h4 id=\"百度快照日更新但就是不收录，这个是什么原因呢？\"><a href=\"#百度快照日更新但就是不收录，这个是什么原因呢？\" class=\"headerlink\" title=\"百度快照日更新但就是不收录，这个是什么原因呢？\"></a>百度快照日更新但就是不收录，这个是什么原因呢？</h4><p>　　快照总在更新说明至少蜘蛛是经常来你的网站觅食的，但是至于收录不收录就要看你网站页面的内容，网站布局、加载速度、网站结构等等方面，快照更新并不等于收录快。</p>\n<h4 id=\"网站打不开，蜘蛛还会来吗？\"><a href=\"#网站打不开，蜘蛛还会来吗？\" class=\"headerlink\" title=\"网站打不开，蜘蛛还会来吗？\"></a>网站打不开，蜘蛛还会来吗？</h4><p>　　时间长了的话，可能会影响的，因为长期打不开就相当于被屏蔽了。这就是服务器不稳定，蜘蛛会认为你的站有问题，以后就很少会来了，甚至降权。所以网站服务器和解析等一定要稳定。</p>\n<h4 id=\"百度快照很久没更新了，为什么？\"><a href=\"#百度快照很久没更新了，为什么？\" class=\"headerlink\" title=\"百度快照很久没更新了，为什么？\"></a>百度快照很久没更新了，为什么？</h4><p>　　快照更新的影响因素包括：站内链接，网站更新，外链更新频度，是否作弊等等。很多时候操作不当都会造成百度快照不更新或其他异常。</p>\n<h4 id=\"由于公司网络调整，服务器停了几天，网站一直打不开。今天在百度搜索公司网站，可是一条都没找到。然后site域名，发现网站被K掉了。这可怎么办呀？\"><a href=\"#由于公司网络调整，服务器停了几天，网站一直打不开。今天在百度搜索公司网站，可是一条都没找到。然后site域名，发现网站被K掉了。这可怎么办呀？\" class=\"headerlink\" title=\"由于公司网络调整，服务器停了几天，网站一直打不开。今天在百度搜索公司网站，可是一条都没找到。然后site域名，发现网站被K掉了。这可怎么办呀？\"></a>由于公司网络调整，服务器停了几天，网站一直打不开。今天在百度搜索公司网站，可是一条都没找到。然后site域名，发现网站被K掉了。这可怎么办呀？</h4><p>　　不要着急，这是由于服务器不稳定造成的，这种情况下的降权问题一般不打，继续坚持更新内容，正常更新优质外链，只要再不出现被搜索引擎认为是作弊的行为，就会恢复的，时间应该不会太久。</p>\n<h4 id=\"网站交换友情链接，对方的网址是-net的，有没有问题？\"><a href=\"#网站交换友情链接，对方的网址是-net的，有没有问题？\" class=\"headerlink\" title=\"网站交换友情链接，对方的网址是.net的，有没有问题？\"></a>网站交换友情链接，对方的网址是.net的，有没有问题？</h4><p>　　答：只要对方网站收录正常、没有被K就可以了,用正常交换友情链接的流程判断交换就可以了，至于网站域名的后缀是什么，跟换友情链接没有半毛钱关系，所以不要带有色眼镜看不同后缀的域名。</p>\n<h4 id=\"网站被K后-现在重新收录了，是不是表示恢复了权重？\"><a href=\"#网站被K后-现在重新收录了，是不是表示恢复了权重？\" class=\"headerlink\" title=\"网站被K后,现在重新收录了，是不是表示恢复了权重？\"></a>网站被K后,现在重新收录了，是不是表示恢复了权重？</h4><p>　　网站被降权后恢复收录只是证明搜索引擎还在继续抓取你的网页而已，这和权重是不是要恢复没什么直接关系。看权重恢复可以去查看流量、百度权重、关键词排名等等，网站在收录仅仅是一个好的征兆，如果每天持续更新，并且稳定收录那就会越来越得到搜索引擎好感，离恢复权重也会越来越近!总之网站被降权不等于不收录，收录也不等于权重恢复。</p>\n<h4 id=\"如何设置关键词密度？\"><a href=\"#如何设置关键词密度？\" class=\"headerlink\" title=\"如何设置关键词密度？\"></a>如何设置关键词密度？</h4><p>　　关键字密度是看整个页面的密度，不是仅仅看这两个代码中的密度的。有的人认为密度2%-8%之间最好，有的认为3%-7%，各种各样的都有。其实关键不在密度，文章中自然布局关键词就好，不要刻意去堆砌，现在的搜索引擎新技术是用户体验，抓住用户才能抓住流量，不要为了seo而得罪用户。</p>\n<h4 id=\"请问怎么样可以有效的增加反链数量？\"><a href=\"#请问怎么样可以有效的增加反链数量？\" class=\"headerlink\" title=\"请问怎么样可以有效的增加反链数量？\"></a>请问怎么样可以有效的增加反链数量？</h4><p>　　这个是需要长时间去积累资源和增加反链的，不是说一下子就增加很多反链，在一方面，不要去追求反链的量而忽视了它的质，在百度多次更新后，反链质高于量的声音越来越大。</p>\n<h4 id=\"做了个网站，没留下任何外链地址，也没向百度谷歌提交收录，为什么就收录了的呢，蜘蜘是从哪爬来的？\"><a href=\"#做了个网站，没留下任何外链地址，也没向百度谷歌提交收录，为什么就收录了的呢，蜘蜘是从哪爬来的？\" class=\"headerlink\" title=\"做了个网站，没留下任何外链地址，也没向百度谷歌提交收录，为什么就收录了的呢，蜘蜘是从哪爬来的？\"></a>做了个网站，没留下任何外链地址，也没向百度谷歌提交收录，为什么就收录了的呢，蜘蜘是从哪爬来的？</h4><p>　　这你就太天真了，没有提交百度就不知道吗？当你申请新域名，百度就开始关注你了，并且当你开通虚拟服务器后，搜索引擎会随着IP爬行，爬虫会由其他网站爬到了你的!还有就是很多蜘蛛入口不用我们留也会自动有的，比如说ALEXA这样的排名网站、一些域名信息查询、外链查询的网站都有可能有咱们的外链。所以说蜘蛛的入口是很多的，你没有邀请它，但你也没有拒绝它。</p>\n<h4 id=\"论坛推广该注意些什么问题-如何植入广告信息或网址-如果找适合自己产品推广的论坛？\"><a href=\"#论坛推广该注意些什么问题-如何植入广告信息或网址-如果找适合自己产品推广的论坛？\" class=\"headerlink\" title=\"论坛推广该注意些什么问题?如何植入广告信息或网址?如果找适合自己产品推广的论坛？\"></a>论坛推广该注意些什么问题?如何植入广告信息或网址?如果找适合自己产品推广的论坛？</h4><p>　　首先如果说你做论坛推广的目的还是简单的植入广告，我只能说这就是该注意的地方，论坛推广准则是：重在于质，不在于量。要想把论坛推广做好，不仅仅是发贴子和写软文，一次成功的论坛推广，要融合好多东西进去的。比如：<br>　　精准营销：论坛推广应该是精准的，比如我们是汽车网站，那就应该找汽车类的论坛进行营销推广。<br>　　口碑营销：论坛营销的目的是为了让用户对产品产生正面的认知，产生口碑的效果。<br>　　病毒营销：成功的营销贴，甚至会被大量转载，产生病毒传播的效果。<br>　　事件营销：很多时候，一次成功的论坛营销往往需要一个事件来配合。<br>　　其它：比体验营销、新闻营销等等。</p>\n<h4 id=\"网站标题和关键词有什么区别吗？\"><a href=\"#网站标题和关键词有什么区别吗？\" class=\"headerlink\" title=\"网站标题和关键词有什么区别吗？\"></a>网站标题和关键词有什么区别吗？</h4><p>　　对于网站SEO优化，特别是关键字优化，网站标题是最关键的，关键词应该包含在标题里面，增加关键词权重和网页的相关性，网站标题和关键词同为SEO优化网页三大要素之一，根本谈不上什么区别，压根就没有任何可比性。</p>\n<h4 id=\"想知道自己网站的PR值和百度权重，但是不知道怎么看？\"><a href=\"#想知道自己网站的PR值和百度权重，但是不知道怎么看？\" class=\"headerlink\" title=\"想知道自己网站的PR值和百度权重，但是不知道怎么看？\"></a>想知道自己网站的PR值和百度权重，但是不知道怎么看？</h4><p>　　这个问题可以说是完全不会seo的人文的，怎么看，直接在百度搜索百度权重或PR查询，你就会了。要说的是pr值是谷歌官方的，但现在谷歌有意慢慢淡出pr值，并且很久都没更新，站长也开始不再非常关注这个。至于百度权重，只是工具上的一种说法，不是百度官方的，所以特别在查询别人权重的时候要注意结合网站其他指标。</p>\n<h4 id=\"网站标题多长最好？\"><a href=\"#网站标题多长最好？\" class=\"headerlink\" title=\"网站标题多长最好？\"></a>网站标题多长最好？</h4><p>　　百度搜索结果标题最多显示30个中文字符，谷歌是32个中文字符，所以标题标签最好不要超过30个中文字，但是为了提高用户体验和突出目标关键词，我们建议长度最好在20个左右。为什么这么说，因为当标题过长的时候，标题头尾很可能被切断，不利于用户深入查看；其次标题过长，无关字必然会多，这样不利于突出目标关键词，降低相关性；还有就是标题过长会分散关键词权重。</p>\n","excerpt":"","more":"<p>为解决网站seo优化问题，特在此记录，共同学习，如有不足或错误之处，欢迎指正。</p>\n<h4 id=\"百度每更新一次，网站的收录就减少很多，但是我每天都增加伪原创的内容啊？\"><a href=\"#百度每更新一次，网站的收录就减少很多，但是我每天都增加伪原创的内容啊？\" class=\"headerlink\" title=\"百度每更新一次，网站的收录就减少很多，但是我每天都增加伪原创的内容啊？\"></a>百度每更新一次，网站的收录就减少很多，但是我每天都增加伪原创的内容啊？</h4><p>　　这个问题大多数是因为网站权重导致百度不够重视你；另外就是文章质量度不高，没有可读性或是原创度太低，尽管百度会收录，但是经过一次更新后可能会太淘汰，你的文章质量越高，收录的可能性越高；还有就是网站网页的重复度过高，百度更新后直接删除重复的内容；当然也有可能是百度自身算法更新，你的网站某些文章受更新影响。</p>\n<h4 id=\"今天百度更新了，关键词排名掉下去了，快照竟然慢下来了，这该怎么办啊\"><a href=\"#今天百度更新了，关键词排名掉下去了，快照竟然慢下来了，这该怎么办啊\" class=\"headerlink\" title=\"今天百度更新了，关键词排名掉下去了，快照竟然慢下来了，这该怎么办啊?\"></a>今天百度更新了，关键词排名掉下去了，快照竟然慢下来了，这该怎么办啊?</h4><p>　　这是一个经常被问3到的问题，首先我们要了解百度的最新更新和更新的内容，判断排名下降的原因，继续做该做的事情，不要怨天尤人，不要轻言放弃，坚持下去会恢复到以前甚至更好。</p>\n<h4 id=\"网站内容几乎每天都有更新，外链也一直在做，可最近流量怎么老是停滞不前呢？\"><a href=\"#网站内容几乎每天都有更新，外链也一直在做，可最近流量怎么老是停滞不前呢？\" class=\"headerlink\" title=\"网站内容几乎每天都有更新，外链也一直在做，可最近流量怎么老是停滞不前呢？\"></a>网站内容几乎每天都有更新，外链也一直在做，可最近流量怎么老是停滞不前呢？</h4><p>　　内容更新和外链确实可以为网站带来流量，主要是让网站在搜索引擎有一个好的排名，通过搜索引擎带来流量，从而达到转化率！属于一个长期的培养的过程!但是获得流量的方式很多，并不仅限于搜索引擎。</p>\n<h4 id=\"百度和Google是不是抓取关键字原理上有什么差别啊？\"><a href=\"#百度和Google是不是抓取关键字原理上有什么差别啊？\" class=\"headerlink\" title=\"百度和Google是不是抓取关键字原理上有什么差别啊？\"></a>百度和Google是不是抓取关键字原理上有什么差别啊？</h4><p>　　谷歌和百度的算法确实是不大相同的，百度人工干涉太多，但是最终的原理是一样的。只要内容好，不作弊，更新及时，原创多，优质外链多，在任何一个搜索引擎，都会取得好的排名的。</p>\n<h4 id=\"百度K了网站，请问如何让其重新收录啊？\"><a href=\"#百度K了网站，请问如何让其重新收录啊？\" class=\"headerlink\" title=\"百度K了网站，请问如何让其重新收录啊？\"></a>百度K了网站，请问如何让其重新收录啊？</h4><p>　　做内容做用户，不要有任何被搜索引擎认为是作弊的行为，另外网站访问速度要有保证，要稳定。在此期间网站波动一定要小。</p>\n<h4 id=\"我的网站被降权了，我想问一下有什么好的办法可以让网站排名回来，同时我想问一下要多长时间才能达到以前的排名？\"><a href=\"#我的网站被降权了，我想问一下有什么好的办法可以让网站排名回来，同时我想问一下要多长时间才能达到以前的排名？\" class=\"headerlink\" title=\"我的网站被降权了，我想问一下有什么好的办法可以让网站排名回来，同时我想问一下要多长时间才能达到以前的排名？\"></a>我的网站被降权了，我想问一下有什么好的办法可以让网站排名回来，同时我想问一下要多长时间才能达到以前的排名？</h4><p>　　关于降权的恢复和第五个问题的da安是一样的，而至于多久才能达到以前的排名是不确定的，可以是几天也可以是几个月，所以一定要有耐心。</p>\n<h4 id=\"google和百度大概什么时候更新一次啊？\"><a href=\"#google和百度大概什么时候更新一次啊？\" class=\"headerlink\" title=\"google和百度大概什么时候更新一次啊？\"></a>google和百度大概什么时候更新一次啊？</h4><p>　　这跟你网站的权重和质量有关，你网站权重高搜索引擎蜘蛛几分钟来一次，你的更新也快。权重不高也许很久都不更新你的站。现在大多数站的情况是一周更新一次，百度在周四凌晨有一次小更新，每月底又一次大更新，而谷歌是三个月更新一次。</p>\n<h4 id=\"百度快照日更新但就是不收录，这个是什么原因呢？\"><a href=\"#百度快照日更新但就是不收录，这个是什么原因呢？\" class=\"headerlink\" title=\"百度快照日更新但就是不收录，这个是什么原因呢？\"></a>百度快照日更新但就是不收录，这个是什么原因呢？</h4><p>　　快照总在更新说明至少蜘蛛是经常来你的网站觅食的，但是至于收录不收录就要看你网站页面的内容，网站布局、加载速度、网站结构等等方面，快照更新并不等于收录快。</p>\n<h4 id=\"网站打不开，蜘蛛还会来吗？\"><a href=\"#网站打不开，蜘蛛还会来吗？\" class=\"headerlink\" title=\"网站打不开，蜘蛛还会来吗？\"></a>网站打不开，蜘蛛还会来吗？</h4><p>　　时间长了的话，可能会影响的，因为长期打不开就相当于被屏蔽了。这就是服务器不稳定，蜘蛛会认为你的站有问题，以后就很少会来了，甚至降权。所以网站服务器和解析等一定要稳定。</p>\n<h4 id=\"百度快照很久没更新了，为什么？\"><a href=\"#百度快照很久没更新了，为什么？\" class=\"headerlink\" title=\"百度快照很久没更新了，为什么？\"></a>百度快照很久没更新了，为什么？</h4><p>　　快照更新的影响因素包括：站内链接，网站更新，外链更新频度，是否作弊等等。很多时候操作不当都会造成百度快照不更新或其他异常。</p>\n<h4 id=\"由于公司网络调整，服务器停了几天，网站一直打不开。今天在百度搜索公司网站，可是一条都没找到。然后site域名，发现网站被K掉了。这可怎么办呀？\"><a href=\"#由于公司网络调整，服务器停了几天，网站一直打不开。今天在百度搜索公司网站，可是一条都没找到。然后site域名，发现网站被K掉了。这可怎么办呀？\" class=\"headerlink\" title=\"由于公司网络调整，服务器停了几天，网站一直打不开。今天在百度搜索公司网站，可是一条都没找到。然后site域名，发现网站被K掉了。这可怎么办呀？\"></a>由于公司网络调整，服务器停了几天，网站一直打不开。今天在百度搜索公司网站，可是一条都没找到。然后site域名，发现网站被K掉了。这可怎么办呀？</h4><p>　　不要着急，这是由于服务器不稳定造成的，这种情况下的降权问题一般不打，继续坚持更新内容，正常更新优质外链，只要再不出现被搜索引擎认为是作弊的行为，就会恢复的，时间应该不会太久。</p>\n<h4 id=\"网站交换友情链接，对方的网址是-net的，有没有问题？\"><a href=\"#网站交换友情链接，对方的网址是-net的，有没有问题？\" class=\"headerlink\" title=\"网站交换友情链接，对方的网址是.net的，有没有问题？\"></a>网站交换友情链接，对方的网址是.net的，有没有问题？</h4><p>　　答：只要对方网站收录正常、没有被K就可以了,用正常交换友情链接的流程判断交换就可以了，至于网站域名的后缀是什么，跟换友情链接没有半毛钱关系，所以不要带有色眼镜看不同后缀的域名。</p>\n<h4 id=\"网站被K后-现在重新收录了，是不是表示恢复了权重？\"><a href=\"#网站被K后-现在重新收录了，是不是表示恢复了权重？\" class=\"headerlink\" title=\"网站被K后,现在重新收录了，是不是表示恢复了权重？\"></a>网站被K后,现在重新收录了，是不是表示恢复了权重？</h4><p>　　网站被降权后恢复收录只是证明搜索引擎还在继续抓取你的网页而已，这和权重是不是要恢复没什么直接关系。看权重恢复可以去查看流量、百度权重、关键词排名等等，网站在收录仅仅是一个好的征兆，如果每天持续更新，并且稳定收录那就会越来越得到搜索引擎好感，离恢复权重也会越来越近!总之网站被降权不等于不收录，收录也不等于权重恢复。</p>\n<h4 id=\"如何设置关键词密度？\"><a href=\"#如何设置关键词密度？\" class=\"headerlink\" title=\"如何设置关键词密度？\"></a>如何设置关键词密度？</h4><p>　　关键字密度是看整个页面的密度，不是仅仅看这两个代码中的密度的。有的人认为密度2%-8%之间最好，有的认为3%-7%，各种各样的都有。其实关键不在密度，文章中自然布局关键词就好，不要刻意去堆砌，现在的搜索引擎新技术是用户体验，抓住用户才能抓住流量，不要为了seo而得罪用户。</p>\n<h4 id=\"请问怎么样可以有效的增加反链数量？\"><a href=\"#请问怎么样可以有效的增加反链数量？\" class=\"headerlink\" title=\"请问怎么样可以有效的增加反链数量？\"></a>请问怎么样可以有效的增加反链数量？</h4><p>　　这个是需要长时间去积累资源和增加反链的，不是说一下子就增加很多反链，在一方面，不要去追求反链的量而忽视了它的质，在百度多次更新后，反链质高于量的声音越来越大。</p>\n<h4 id=\"做了个网站，没留下任何外链地址，也没向百度谷歌提交收录，为什么就收录了的呢，蜘蜘是从哪爬来的？\"><a href=\"#做了个网站，没留下任何外链地址，也没向百度谷歌提交收录，为什么就收录了的呢，蜘蜘是从哪爬来的？\" class=\"headerlink\" title=\"做了个网站，没留下任何外链地址，也没向百度谷歌提交收录，为什么就收录了的呢，蜘蜘是从哪爬来的？\"></a>做了个网站，没留下任何外链地址，也没向百度谷歌提交收录，为什么就收录了的呢，蜘蜘是从哪爬来的？</h4><p>　　这你就太天真了，没有提交百度就不知道吗？当你申请新域名，百度就开始关注你了，并且当你开通虚拟服务器后，搜索引擎会随着IP爬行，爬虫会由其他网站爬到了你的!还有就是很多蜘蛛入口不用我们留也会自动有的，比如说ALEXA这样的排名网站、一些域名信息查询、外链查询的网站都有可能有咱们的外链。所以说蜘蛛的入口是很多的，你没有邀请它，但你也没有拒绝它。</p>\n<h4 id=\"论坛推广该注意些什么问题-如何植入广告信息或网址-如果找适合自己产品推广的论坛？\"><a href=\"#论坛推广该注意些什么问题-如何植入广告信息或网址-如果找适合自己产品推广的论坛？\" class=\"headerlink\" title=\"论坛推广该注意些什么问题?如何植入广告信息或网址?如果找适合自己产品推广的论坛？\"></a>论坛推广该注意些什么问题?如何植入广告信息或网址?如果找适合自己产品推广的论坛？</h4><p>　　首先如果说你做论坛推广的目的还是简单的植入广告，我只能说这就是该注意的地方，论坛推广准则是：重在于质，不在于量。要想把论坛推广做好，不仅仅是发贴子和写软文，一次成功的论坛推广，要融合好多东西进去的。比如：<br>　　精准营销：论坛推广应该是精准的，比如我们是汽车网站，那就应该找汽车类的论坛进行营销推广。<br>　　口碑营销：论坛营销的目的是为了让用户对产品产生正面的认知，产生口碑的效果。<br>　　病毒营销：成功的营销贴，甚至会被大量转载，产生病毒传播的效果。<br>　　事件营销：很多时候，一次成功的论坛营销往往需要一个事件来配合。<br>　　其它：比体验营销、新闻营销等等。</p>\n<h4 id=\"网站标题和关键词有什么区别吗？\"><a href=\"#网站标题和关键词有什么区别吗？\" class=\"headerlink\" title=\"网站标题和关键词有什么区别吗？\"></a>网站标题和关键词有什么区别吗？</h4><p>　　对于网站SEO优化，特别是关键字优化，网站标题是最关键的，关键词应该包含在标题里面，增加关键词权重和网页的相关性，网站标题和关键词同为SEO优化网页三大要素之一，根本谈不上什么区别，压根就没有任何可比性。</p>\n<h4 id=\"想知道自己网站的PR值和百度权重，但是不知道怎么看？\"><a href=\"#想知道自己网站的PR值和百度权重，但是不知道怎么看？\" class=\"headerlink\" title=\"想知道自己网站的PR值和百度权重，但是不知道怎么看？\"></a>想知道自己网站的PR值和百度权重，但是不知道怎么看？</h4><p>　　这个问题可以说是完全不会seo的人文的，怎么看，直接在百度搜索百度权重或PR查询，你就会了。要说的是pr值是谷歌官方的，但现在谷歌有意慢慢淡出pr值，并且很久都没更新，站长也开始不再非常关注这个。至于百度权重，只是工具上的一种说法，不是百度官方的，所以特别在查询别人权重的时候要注意结合网站其他指标。</p>\n<h4 id=\"网站标题多长最好？\"><a href=\"#网站标题多长最好？\" class=\"headerlink\" title=\"网站标题多长最好？\"></a>网站标题多长最好？</h4><p>　　百度搜索结果标题最多显示30个中文字符，谷歌是32个中文字符，所以标题标签最好不要超过30个中文字，但是为了提高用户体验和突出目标关键词，我们建议长度最好在20个左右。为什么这么说，因为当标题过长的时候，标题头尾很可能被切断，不利于用户深入查看；其次标题过长，无关字必然会多，这样不利于突出目标关键词，降低相关性；还有就是标题过长会分散关键词权重。</p>\n"},{"title":"网站SEO优化常见问题汇总3","date":"2015-01-18T07:07:35.000Z","_content":"#### 41、一个网站的导出链接多少合适?\n　　一个网站导出链接的多少合适，不能只能从数量来判断，那些知名导航站导出的链接的数量很多吧，但是自己的权重受影响了吗?首先要根据自己网站来，网站的定位、类型、权重值等都会影响导出链接的多少。其次就算是单向的导出链接，所链接的网站质量也要高，搜索引擎有它的关联判断，对方网站有问题很可能影响到你，还有就是导出链接要联系实际情况和用户需求，要提供对访问者有价值的链接。如果硬要说导出链接多少合适，我觉得可以去查看PR输出值，最好不要低于0.2，这个可以在站长工具查到。\n#### 42、经常看到人说软文推广，是不是文章里加了链接就是软文推广啊?\n　　答：软文从实质上来说就是软广告，是一种收而不漏的广告。软文推广通常借助文字表达与舆论传播使消费者认同某种概念、观点和分析思路，从而达到企业品牌宣传、产品销售的目的。但是，它跟直接的广告又有不同，它是把广告隐藏在，带有愉悦性，或知识性的文章当中，它是潜移默化的将广告植入。加不加链接它都在推广，而对于传统意义上的SEO而言，加一个链接可以多个外链，助力网站。这样可能对于网站来说更好，但是在如今的互联网，SEO工作人员需要与营销结合，外链时代早已过去，内容营销正在崛起，我们要与时俱进。\n#### 43、购买弹窗流量对搜索引擎到底是利还是弊?会不会被认为是作弊，而被K呢?\n　　答：弹窗这个东西可能会为你带来一点点流量，但是对搜索引擎优化是完全没用的。不仅如此，过分的弹窗，搜索引擎可能予以惩罚，之前百度的石榴算法已经讲过。适当的弹窗可以，但是太多不仅不利于优化，用户也很反感这种形式的广告。\n#### 44、请问百度竞价是怎么计费的呢?\n　　主要是按点击付费的，按照实际点击价格计算收入。不同的关键字价格不同，搜索业务的点击收入也不同，不同的主题文字链价格不同，主题推广业务的点击收入也不同，可以直接注册百度推广账户进入后台有详细介绍的。\n#### 45、yx链接(隐藏链接)效果好吗\n　　隐藏链接也叫黑链指的是正常的链接通过一些方法，如：把链接放入js代码中，使用display:none等等，从而使用户在正常浏览网页的时候无法看到这个链接。目的就是获得对方网站的权重值，效果好不好?当然好，但是相当不稳定，世上没有白吃的午餐，并且隐藏链接是被搜索引擎严令禁止的，建议没事就不要用这个，就算用黑帽也要用高级点的。\n#### 46、我的网站被别人复制了，而且内容是一样的，该怎么删除?\n　　复制这个事情很不容易解决，人家网站里的东西，你不可能有权限删除的。像这种被复制问题，基本上是没有办法的。理论上是可以通过法律途径的，但是过程是很麻烦的。一般情况下可以把你的网站在做一些更新和修改，在程序上做些水印和防盗页面，新闻内容和图片内容设置防盗程序，别人就不容易复制了，这些也都需要和程序员协同完成，不过现在的采集软件都相当牛，未必能见效。当然了，你还可以联系对方谈一谈，怎么谈就看你了。\n　　我觉得你的网站被镜像完全是一种成就，不要怕，继续做好优化，别人是复制站，你的网页是原创，同时搜索引擎也是在打击镜像站的，优势都在你这。\n#### 47、关键词排名下滑怎么办?\n　　不要紧张，首先要找出原因，是否被降权?个别关键字问题还是全部?竞争对手如何?百度有无调整?友链是否出错?等等对网站问题逐一排查，进行全面SEO诊断找出问题。不管如何，坚持原创、优化好页面、做好内链、适当添加高质量链接时必须做的。\n#### 48、seo什么工具好用?比如平时查看关键字、近期热门关键字之类的的工具，那个比较好用?\n　　seo工具非常多，平时查看网站关键词用用站长工具查询就行了，关键词挖掘之类的可以下载金花、追词等工具。百度关键词分析工具和谷歌关键词分析工具功能也很全面，至于近期热门也可以看百度搜索风云榜。\n#### 49、我的原创文章没有被收录，为什么啊?\n　　一、新站审核期。假若因为这点你大可不必担心，一般新站处在搜索的审核期间，是需要时间来考量的，这时你需要操作的是继续更新的网站，带来更多原创独特的内容。\n　　二、网站过度优化。过度优化一般直接造成网站收录减少，快照停滞不进或直接不收录，你需要做的操作是把优化明显的痕迹去掉再加上正常的更新。\n　　三、内容原创性。搜索收录页面不是你说原创就是原创，你没有看别人的自己写的那不见得就是原创，你写的文章和网络的观点千篇一律，只是稍微换了个说法，可读性不强也不够稀缺，你需要做的是以伪原创为主，以适当独特的内容为辅。\n　　四、友情链接有问题。对方网站被K导致你的网站受影响。\n　　五、网站作弊。任何搜搜索引擎对这点都是严打的，收录减少只是一个比较轻的惩罚，你需要的操作是尽快把网站更正。\n　　六。硬件方面。如网站打开速度慢，主机延迟，网站被挂马等，当搜索多次来探访出现这样的情况，可想而知了搜索也会慢慢摒弃的。\n#### 50、如何保证关键词排名稳定?\n　　要关键词稳，首先人要稳，不要过多的去用SEO技术，坚持网站内容建设，如果没有内容，就没有人会被吸引，就不会有什么流量，就算来了人，跳出的机率也很大。如果站的内容质量很高，自然就会有人喜欢，流量自然能保证，关键词排名也会稳定，如何写好内容推荐提升内容吸引力十个秘诀。同时也用做好用户体验建设，用户行为同样影响着关键词排名，用户稳定关键词才能稳定。还有外链也不能落下，尽管目前外链的效用在减弱，但瘦死的骆驼比马大，那些只是说的垃圾外链，高质量外链依然是网站排名的坚实依靠。\n#### 51、为什么有的网站不用更新文章都可以排名靠前?\n　　不是不更新文章，只不过是现在没更新了而已，而有的人又会说他们的收录很少排名很多，确实有些站，总不更新东西，但是排名相当稳定。不过这些站要么本身是权重高的老牌网站、要么点击量非常高、要么外链数非常多，总之他们都不是那么的平凡。\n#### 52、原创内容的丰富程度对搜索引擎的收录影响有多大?\n　　原创内容的丰富程度对于搜索引擎收录的影响还是很大的，第一会考虑用户体验的问题，第二是搜索引擎自身对好文的一个判断。原创文章不一定都写得好，而丰富的原创内容尽管能促进收录，但好的原创内容不一定被收录，影响收录的因素很多，好原创只是其中之一而已。\n#### 53、请问蜘蛛是怎么判断网站更新的?\n　　蜘蛛爬进网站抓取内容时，根据对爬行内容的判断就可以判断网站更新\n#### 54、网站一天发多少文章合适?\n　　答：文章当然是发的越多越好，不过注意一点，不管一天发多少文章，一定要保持平均还要保证质量。如果质量跟不上不要只要量不要质，如果不能坚持更新的频率，也不要三天打鱼二天晒网。文章不在多在于精，最好坚持高质量的原创、文章发多少都可以，关键是定时定量定质，不能忽高忽低\n#### 55、收录正常，就是排名一直没有升?\n　　既然收录正常，就从其他方面着手，收录正常并不等于排名上升。影响网站排名的因素有很多。可能是外链的影响，可能是用户点击，也可能是网站结构\n#### 56、怎么才叫热帖，有没有一个判定?好多帖子有的是点击量很高，没有回复，也叫热帖吗?\n　　一般而言，关注的人多，能够引起大家的共鸣，能够长时间排在论坛的首页的话，最好还能获得大量的转载基本上就可以叫做热帖了!\n#### 57、一个地方发链接好还是多个地方发外链好?\n　　外链的广泛性本身对搜索引擎的排名本身很重要，外链的多少在于域名不同的外链数量，统一域名下的链接再多也比不上不同域名下外链的数量。外链要有自然性、广泛性，不同域名下的推荐才是最真实的。\n#### 58、首页为什么不要有FLASH动画、视频?\n　　Flash不利于搜索引擎抓取，同时FLASH会影响网页的打开速度，Flash也不利用网页聚合内容与关键词的匹配，但不是说不能有FLASH动画、视频，只是说不要首页全部是这个，这样对搜索引擎是相当不友好的，合理的加入FLASH可以为网页添加色彩。网站最多还是为了用户体验，如果你觉得你的网站需要FALSH，并且能让用户体验更好，那么就可以加。\n#### 59、快照天天更新，也没觉得能给我带来啥好处啊?\n　　百度快照正常更新只是说网站比较健康，蜘蛛更新比较勤。快照更新并不等于权重提高，也不等于关键词排名。\n#### 60、我的网站排名由第一页掉到十几页了，为什么?\n　　排名一下子掉到10页开外，如果不是搜索引擎内部问题，肯定是自己网站的问题了。很多情况是被降权，降权的主要表现方式是：收录大规模减少，排名迅速下降，时常伴随着首页被K。\n　　一般如果你没有在情况出现之前做过特别的操作，那么你需要注意：\n　　1、检查是否有不良友情链接，检查友情链接是否有问题。\n　　2、检查网站所在服务器是否因为别人的网站受到了处罚。\n　　3、检查网站的内容是不是被某些大型网站进行了转载并且未说明出处。有时候不是因为内容重复过高而降权。\n　　4、检查网站是否被攻击、木马，以及被黑帽seo入侵后进行了黑帽利用。\n　　5、百度最近是否有大规模更新。\n　　6、网站存在大量重复内容。\n　　7、网站累积性优化，导致优化过度。\n　　8、外链大幅度减少，比如外链所在平台被K，外链账号被封，贴吧贴子被删，信息平台主题过期等。","source":"_posts/siteseo3.md","raw":"---\ntitle: 网站SEO优化常见问题汇总3\ndate: 2015-01-18 15:07:35\ntags: seo\n---\n#### 41、一个网站的导出链接多少合适?\n　　一个网站导出链接的多少合适，不能只能从数量来判断，那些知名导航站导出的链接的数量很多吧，但是自己的权重受影响了吗?首先要根据自己网站来，网站的定位、类型、权重值等都会影响导出链接的多少。其次就算是单向的导出链接，所链接的网站质量也要高，搜索引擎有它的关联判断，对方网站有问题很可能影响到你，还有就是导出链接要联系实际情况和用户需求，要提供对访问者有价值的链接。如果硬要说导出链接多少合适，我觉得可以去查看PR输出值，最好不要低于0.2，这个可以在站长工具查到。\n#### 42、经常看到人说软文推广，是不是文章里加了链接就是软文推广啊?\n　　答：软文从实质上来说就是软广告，是一种收而不漏的广告。软文推广通常借助文字表达与舆论传播使消费者认同某种概念、观点和分析思路，从而达到企业品牌宣传、产品销售的目的。但是，它跟直接的广告又有不同，它是把广告隐藏在，带有愉悦性，或知识性的文章当中，它是潜移默化的将广告植入。加不加链接它都在推广，而对于传统意义上的SEO而言，加一个链接可以多个外链，助力网站。这样可能对于网站来说更好，但是在如今的互联网，SEO工作人员需要与营销结合，外链时代早已过去，内容营销正在崛起，我们要与时俱进。\n#### 43、购买弹窗流量对搜索引擎到底是利还是弊?会不会被认为是作弊，而被K呢?\n　　答：弹窗这个东西可能会为你带来一点点流量，但是对搜索引擎优化是完全没用的。不仅如此，过分的弹窗，搜索引擎可能予以惩罚，之前百度的石榴算法已经讲过。适当的弹窗可以，但是太多不仅不利于优化，用户也很反感这种形式的广告。\n#### 44、请问百度竞价是怎么计费的呢?\n　　主要是按点击付费的，按照实际点击价格计算收入。不同的关键字价格不同，搜索业务的点击收入也不同，不同的主题文字链价格不同，主题推广业务的点击收入也不同，可以直接注册百度推广账户进入后台有详细介绍的。\n#### 45、yx链接(隐藏链接)效果好吗\n　　隐藏链接也叫黑链指的是正常的链接通过一些方法，如：把链接放入js代码中，使用display:none等等，从而使用户在正常浏览网页的时候无法看到这个链接。目的就是获得对方网站的权重值，效果好不好?当然好，但是相当不稳定，世上没有白吃的午餐，并且隐藏链接是被搜索引擎严令禁止的，建议没事就不要用这个，就算用黑帽也要用高级点的。\n#### 46、我的网站被别人复制了，而且内容是一样的，该怎么删除?\n　　复制这个事情很不容易解决，人家网站里的东西，你不可能有权限删除的。像这种被复制问题，基本上是没有办法的。理论上是可以通过法律途径的，但是过程是很麻烦的。一般情况下可以把你的网站在做一些更新和修改，在程序上做些水印和防盗页面，新闻内容和图片内容设置防盗程序，别人就不容易复制了，这些也都需要和程序员协同完成，不过现在的采集软件都相当牛，未必能见效。当然了，你还可以联系对方谈一谈，怎么谈就看你了。\n　　我觉得你的网站被镜像完全是一种成就，不要怕，继续做好优化，别人是复制站，你的网页是原创，同时搜索引擎也是在打击镜像站的，优势都在你这。\n#### 47、关键词排名下滑怎么办?\n　　不要紧张，首先要找出原因，是否被降权?个别关键字问题还是全部?竞争对手如何?百度有无调整?友链是否出错?等等对网站问题逐一排查，进行全面SEO诊断找出问题。不管如何，坚持原创、优化好页面、做好内链、适当添加高质量链接时必须做的。\n#### 48、seo什么工具好用?比如平时查看关键字、近期热门关键字之类的的工具，那个比较好用?\n　　seo工具非常多，平时查看网站关键词用用站长工具查询就行了，关键词挖掘之类的可以下载金花、追词等工具。百度关键词分析工具和谷歌关键词分析工具功能也很全面，至于近期热门也可以看百度搜索风云榜。\n#### 49、我的原创文章没有被收录，为什么啊?\n　　一、新站审核期。假若因为这点你大可不必担心，一般新站处在搜索的审核期间，是需要时间来考量的，这时你需要操作的是继续更新的网站，带来更多原创独特的内容。\n　　二、网站过度优化。过度优化一般直接造成网站收录减少，快照停滞不进或直接不收录，你需要做的操作是把优化明显的痕迹去掉再加上正常的更新。\n　　三、内容原创性。搜索收录页面不是你说原创就是原创，你没有看别人的自己写的那不见得就是原创，你写的文章和网络的观点千篇一律，只是稍微换了个说法，可读性不强也不够稀缺，你需要做的是以伪原创为主，以适当独特的内容为辅。\n　　四、友情链接有问题。对方网站被K导致你的网站受影响。\n　　五、网站作弊。任何搜搜索引擎对这点都是严打的，收录减少只是一个比较轻的惩罚，你需要的操作是尽快把网站更正。\n　　六。硬件方面。如网站打开速度慢，主机延迟，网站被挂马等，当搜索多次来探访出现这样的情况，可想而知了搜索也会慢慢摒弃的。\n#### 50、如何保证关键词排名稳定?\n　　要关键词稳，首先人要稳，不要过多的去用SEO技术，坚持网站内容建设，如果没有内容，就没有人会被吸引，就不会有什么流量，就算来了人，跳出的机率也很大。如果站的内容质量很高，自然就会有人喜欢，流量自然能保证，关键词排名也会稳定，如何写好内容推荐提升内容吸引力十个秘诀。同时也用做好用户体验建设，用户行为同样影响着关键词排名，用户稳定关键词才能稳定。还有外链也不能落下，尽管目前外链的效用在减弱，但瘦死的骆驼比马大，那些只是说的垃圾外链，高质量外链依然是网站排名的坚实依靠。\n#### 51、为什么有的网站不用更新文章都可以排名靠前?\n　　不是不更新文章，只不过是现在没更新了而已，而有的人又会说他们的收录很少排名很多，确实有些站，总不更新东西，但是排名相当稳定。不过这些站要么本身是权重高的老牌网站、要么点击量非常高、要么外链数非常多，总之他们都不是那么的平凡。\n#### 52、原创内容的丰富程度对搜索引擎的收录影响有多大?\n　　原创内容的丰富程度对于搜索引擎收录的影响还是很大的，第一会考虑用户体验的问题，第二是搜索引擎自身对好文的一个判断。原创文章不一定都写得好，而丰富的原创内容尽管能促进收录，但好的原创内容不一定被收录，影响收录的因素很多，好原创只是其中之一而已。\n#### 53、请问蜘蛛是怎么判断网站更新的?\n　　蜘蛛爬进网站抓取内容时，根据对爬行内容的判断就可以判断网站更新\n#### 54、网站一天发多少文章合适?\n　　答：文章当然是发的越多越好，不过注意一点，不管一天发多少文章，一定要保持平均还要保证质量。如果质量跟不上不要只要量不要质，如果不能坚持更新的频率，也不要三天打鱼二天晒网。文章不在多在于精，最好坚持高质量的原创、文章发多少都可以，关键是定时定量定质，不能忽高忽低\n#### 55、收录正常，就是排名一直没有升?\n　　既然收录正常，就从其他方面着手，收录正常并不等于排名上升。影响网站排名的因素有很多。可能是外链的影响，可能是用户点击，也可能是网站结构\n#### 56、怎么才叫热帖，有没有一个判定?好多帖子有的是点击量很高，没有回复，也叫热帖吗?\n　　一般而言，关注的人多，能够引起大家的共鸣，能够长时间排在论坛的首页的话，最好还能获得大量的转载基本上就可以叫做热帖了!\n#### 57、一个地方发链接好还是多个地方发外链好?\n　　外链的广泛性本身对搜索引擎的排名本身很重要，外链的多少在于域名不同的外链数量，统一域名下的链接再多也比不上不同域名下外链的数量。外链要有自然性、广泛性，不同域名下的推荐才是最真实的。\n#### 58、首页为什么不要有FLASH动画、视频?\n　　Flash不利于搜索引擎抓取，同时FLASH会影响网页的打开速度，Flash也不利用网页聚合内容与关键词的匹配，但不是说不能有FLASH动画、视频，只是说不要首页全部是这个，这样对搜索引擎是相当不友好的，合理的加入FLASH可以为网页添加色彩。网站最多还是为了用户体验，如果你觉得你的网站需要FALSH，并且能让用户体验更好，那么就可以加。\n#### 59、快照天天更新，也没觉得能给我带来啥好处啊?\n　　百度快照正常更新只是说网站比较健康，蜘蛛更新比较勤。快照更新并不等于权重提高，也不等于关键词排名。\n#### 60、我的网站排名由第一页掉到十几页了，为什么?\n　　排名一下子掉到10页开外，如果不是搜索引擎内部问题，肯定是自己网站的问题了。很多情况是被降权，降权的主要表现方式是：收录大规模减少，排名迅速下降，时常伴随着首页被K。\n　　一般如果你没有在情况出现之前做过特别的操作，那么你需要注意：\n　　1、检查是否有不良友情链接，检查友情链接是否有问题。\n　　2、检查网站所在服务器是否因为别人的网站受到了处罚。\n　　3、检查网站的内容是不是被某些大型网站进行了转载并且未说明出处。有时候不是因为内容重复过高而降权。\n　　4、检查网站是否被攻击、木马，以及被黑帽seo入侵后进行了黑帽利用。\n　　5、百度最近是否有大规模更新。\n　　6、网站存在大量重复内容。\n　　7、网站累积性优化，导致优化过度。\n　　8、外链大幅度减少，比如外链所在平台被K，外链账号被封，贴吧贴子被删，信息平台主题过期等。","slug":"siteseo3","published":1,"updated":"2017-01-16T02:22:26.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixzjjbm00005mgtuwztv5gsg","content":"<h4 id=\"41、一个网站的导出链接多少合适\"><a href=\"#41、一个网站的导出链接多少合适\" class=\"headerlink\" title=\"41、一个网站的导出链接多少合适?\"></a>41、一个网站的导出链接多少合适?</h4><p>　　一个网站导出链接的多少合适，不能只能从数量来判断，那些知名导航站导出的链接的数量很多吧，但是自己的权重受影响了吗?首先要根据自己网站来，网站的定位、类型、权重值等都会影响导出链接的多少。其次就算是单向的导出链接，所链接的网站质量也要高，搜索引擎有它的关联判断，对方网站有问题很可能影响到你，还有就是导出链接要联系实际情况和用户需求，要提供对访问者有价值的链接。如果硬要说导出链接多少合适，我觉得可以去查看PR输出值，最好不要低于0.2，这个可以在站长工具查到。</p>\n<h4 id=\"42、经常看到人说软文推广，是不是文章里加了链接就是软文推广啊\"><a href=\"#42、经常看到人说软文推广，是不是文章里加了链接就是软文推广啊\" class=\"headerlink\" title=\"42、经常看到人说软文推广，是不是文章里加了链接就是软文推广啊?\"></a>42、经常看到人说软文推广，是不是文章里加了链接就是软文推广啊?</h4><p>　　答：软文从实质上来说就是软广告，是一种收而不漏的广告。软文推广通常借助文字表达与舆论传播使消费者认同某种概念、观点和分析思路，从而达到企业品牌宣传、产品销售的目的。但是，它跟直接的广告又有不同，它是把广告隐藏在，带有愉悦性，或知识性的文章当中，它是潜移默化的将广告植入。加不加链接它都在推广，而对于传统意义上的SEO而言，加一个链接可以多个外链，助力网站。这样可能对于网站来说更好，但是在如今的互联网，SEO工作人员需要与营销结合，外链时代早已过去，内容营销正在崛起，我们要与时俱进。</p>\n<h4 id=\"43、购买弹窗流量对搜索引擎到底是利还是弊-会不会被认为是作弊，而被K呢\"><a href=\"#43、购买弹窗流量对搜索引擎到底是利还是弊-会不会被认为是作弊，而被K呢\" class=\"headerlink\" title=\"43、购买弹窗流量对搜索引擎到底是利还是弊?会不会被认为是作弊，而被K呢?\"></a>43、购买弹窗流量对搜索引擎到底是利还是弊?会不会被认为是作弊，而被K呢?</h4><p>　　答：弹窗这个东西可能会为你带来一点点流量，但是对搜索引擎优化是完全没用的。不仅如此，过分的弹窗，搜索引擎可能予以惩罚，之前百度的石榴算法已经讲过。适当的弹窗可以，但是太多不仅不利于优化，用户也很反感这种形式的广告。</p>\n<h4 id=\"44、请问百度竞价是怎么计费的呢\"><a href=\"#44、请问百度竞价是怎么计费的呢\" class=\"headerlink\" title=\"44、请问百度竞价是怎么计费的呢?\"></a>44、请问百度竞价是怎么计费的呢?</h4><p>　　主要是按点击付费的，按照实际点击价格计算收入。不同的关键字价格不同，搜索业务的点击收入也不同，不同的主题文字链价格不同，主题推广业务的点击收入也不同，可以直接注册百度推广账户进入后台有详细介绍的。</p>\n<h4 id=\"45、yx链接-隐藏链接-效果好吗\"><a href=\"#45、yx链接-隐藏链接-效果好吗\" class=\"headerlink\" title=\"45、yx链接(隐藏链接)效果好吗\"></a>45、yx链接(隐藏链接)效果好吗</h4><p>　　隐藏链接也叫黑链指的是正常的链接通过一些方法，如：把链接放入js代码中，使用display:none等等，从而使用户在正常浏览网页的时候无法看到这个链接。目的就是获得对方网站的权重值，效果好不好?当然好，但是相当不稳定，世上没有白吃的午餐，并且隐藏链接是被搜索引擎严令禁止的，建议没事就不要用这个，就算用黑帽也要用高级点的。</p>\n<h4 id=\"46、我的网站被别人复制了，而且内容是一样的，该怎么删除\"><a href=\"#46、我的网站被别人复制了，而且内容是一样的，该怎么删除\" class=\"headerlink\" title=\"46、我的网站被别人复制了，而且内容是一样的，该怎么删除?\"></a>46、我的网站被别人复制了，而且内容是一样的，该怎么删除?</h4><p>　　复制这个事情很不容易解决，人家网站里的东西，你不可能有权限删除的。像这种被复制问题，基本上是没有办法的。理论上是可以通过法律途径的，但是过程是很麻烦的。一般情况下可以把你的网站在做一些更新和修改，在程序上做些水印和防盗页面，新闻内容和图片内容设置防盗程序，别人就不容易复制了，这些也都需要和程序员协同完成，不过现在的采集软件都相当牛，未必能见效。当然了，你还可以联系对方谈一谈，怎么谈就看你了。<br>　　我觉得你的网站被镜像完全是一种成就，不要怕，继续做好优化，别人是复制站，你的网页是原创，同时搜索引擎也是在打击镜像站的，优势都在你这。</p>\n<h4 id=\"47、关键词排名下滑怎么办\"><a href=\"#47、关键词排名下滑怎么办\" class=\"headerlink\" title=\"47、关键词排名下滑怎么办?\"></a>47、关键词排名下滑怎么办?</h4><p>　　不要紧张，首先要找出原因，是否被降权?个别关键字问题还是全部?竞争对手如何?百度有无调整?友链是否出错?等等对网站问题逐一排查，进行全面SEO诊断找出问题。不管如何，坚持原创、优化好页面、做好内链、适当添加高质量链接时必须做的。</p>\n<h4 id=\"48、seo什么工具好用-比如平时查看关键字、近期热门关键字之类的的工具，那个比较好用\"><a href=\"#48、seo什么工具好用-比如平时查看关键字、近期热门关键字之类的的工具，那个比较好用\" class=\"headerlink\" title=\"48、seo什么工具好用?比如平时查看关键字、近期热门关键字之类的的工具，那个比较好用?\"></a>48、seo什么工具好用?比如平时查看关键字、近期热门关键字之类的的工具，那个比较好用?</h4><p>　　seo工具非常多，平时查看网站关键词用用站长工具查询就行了，关键词挖掘之类的可以下载金花、追词等工具。百度关键词分析工具和谷歌关键词分析工具功能也很全面，至于近期热门也可以看百度搜索风云榜。</p>\n<h4 id=\"49、我的原创文章没有被收录，为什么啊\"><a href=\"#49、我的原创文章没有被收录，为什么啊\" class=\"headerlink\" title=\"49、我的原创文章没有被收录，为什么啊?\"></a>49、我的原创文章没有被收录，为什么啊?</h4><p>　　一、新站审核期。假若因为这点你大可不必担心，一般新站处在搜索的审核期间，是需要时间来考量的，这时你需要操作的是继续更新的网站，带来更多原创独特的内容。<br>　　二、网站过度优化。过度优化一般直接造成网站收录减少，快照停滞不进或直接不收录，你需要做的操作是把优化明显的痕迹去掉再加上正常的更新。<br>　　三、内容原创性。搜索收录页面不是你说原创就是原创，你没有看别人的自己写的那不见得就是原创，你写的文章和网络的观点千篇一律，只是稍微换了个说法，可读性不强也不够稀缺，你需要做的是以伪原创为主，以适当独特的内容为辅。<br>　　四、友情链接有问题。对方网站被K导致你的网站受影响。<br>　　五、网站作弊。任何搜搜索引擎对这点都是严打的，收录减少只是一个比较轻的惩罚，你需要的操作是尽快把网站更正。<br>　　六。硬件方面。如网站打开速度慢，主机延迟，网站被挂马等，当搜索多次来探访出现这样的情况，可想而知了搜索也会慢慢摒弃的。</p>\n<h4 id=\"50、如何保证关键词排名稳定\"><a href=\"#50、如何保证关键词排名稳定\" class=\"headerlink\" title=\"50、如何保证关键词排名稳定?\"></a>50、如何保证关键词排名稳定?</h4><p>　　要关键词稳，首先人要稳，不要过多的去用SEO技术，坚持网站内容建设，如果没有内容，就没有人会被吸引，就不会有什么流量，就算来了人，跳出的机率也很大。如果站的内容质量很高，自然就会有人喜欢，流量自然能保证，关键词排名也会稳定，如何写好内容推荐提升内容吸引力十个秘诀。同时也用做好用户体验建设，用户行为同样影响着关键词排名，用户稳定关键词才能稳定。还有外链也不能落下，尽管目前外链的效用在减弱，但瘦死的骆驼比马大，那些只是说的垃圾外链，高质量外链依然是网站排名的坚实依靠。</p>\n<h4 id=\"51、为什么有的网站不用更新文章都可以排名靠前\"><a href=\"#51、为什么有的网站不用更新文章都可以排名靠前\" class=\"headerlink\" title=\"51、为什么有的网站不用更新文章都可以排名靠前?\"></a>51、为什么有的网站不用更新文章都可以排名靠前?</h4><p>　　不是不更新文章，只不过是现在没更新了而已，而有的人又会说他们的收录很少排名很多，确实有些站，总不更新东西，但是排名相当稳定。不过这些站要么本身是权重高的老牌网站、要么点击量非常高、要么外链数非常多，总之他们都不是那么的平凡。</p>\n<h4 id=\"52、原创内容的丰富程度对搜索引擎的收录影响有多大\"><a href=\"#52、原创内容的丰富程度对搜索引擎的收录影响有多大\" class=\"headerlink\" title=\"52、原创内容的丰富程度对搜索引擎的收录影响有多大?\"></a>52、原创内容的丰富程度对搜索引擎的收录影响有多大?</h4><p>　　原创内容的丰富程度对于搜索引擎收录的影响还是很大的，第一会考虑用户体验的问题，第二是搜索引擎自身对好文的一个判断。原创文章不一定都写得好，而丰富的原创内容尽管能促进收录，但好的原创内容不一定被收录，影响收录的因素很多，好原创只是其中之一而已。</p>\n<h4 id=\"53、请问蜘蛛是怎么判断网站更新的\"><a href=\"#53、请问蜘蛛是怎么判断网站更新的\" class=\"headerlink\" title=\"53、请问蜘蛛是怎么判断网站更新的?\"></a>53、请问蜘蛛是怎么判断网站更新的?</h4><p>　　蜘蛛爬进网站抓取内容时，根据对爬行内容的判断就可以判断网站更新</p>\n<h4 id=\"54、网站一天发多少文章合适\"><a href=\"#54、网站一天发多少文章合适\" class=\"headerlink\" title=\"54、网站一天发多少文章合适?\"></a>54、网站一天发多少文章合适?</h4><p>　　答：文章当然是发的越多越好，不过注意一点，不管一天发多少文章，一定要保持平均还要保证质量。如果质量跟不上不要只要量不要质，如果不能坚持更新的频率，也不要三天打鱼二天晒网。文章不在多在于精，最好坚持高质量的原创、文章发多少都可以，关键是定时定量定质，不能忽高忽低</p>\n<h4 id=\"55、收录正常，就是排名一直没有升\"><a href=\"#55、收录正常，就是排名一直没有升\" class=\"headerlink\" title=\"55、收录正常，就是排名一直没有升?\"></a>55、收录正常，就是排名一直没有升?</h4><p>　　既然收录正常，就从其他方面着手，收录正常并不等于排名上升。影响网站排名的因素有很多。可能是外链的影响，可能是用户点击，也可能是网站结构</p>\n<h4 id=\"56、怎么才叫热帖，有没有一个判定-好多帖子有的是点击量很高，没有回复，也叫热帖吗\"><a href=\"#56、怎么才叫热帖，有没有一个判定-好多帖子有的是点击量很高，没有回复，也叫热帖吗\" class=\"headerlink\" title=\"56、怎么才叫热帖，有没有一个判定?好多帖子有的是点击量很高，没有回复，也叫热帖吗?\"></a>56、怎么才叫热帖，有没有一个判定?好多帖子有的是点击量很高，没有回复，也叫热帖吗?</h4><p>　　一般而言，关注的人多，能够引起大家的共鸣，能够长时间排在论坛的首页的话，最好还能获得大量的转载基本上就可以叫做热帖了!</p>\n<h4 id=\"57、一个地方发链接好还是多个地方发外链好\"><a href=\"#57、一个地方发链接好还是多个地方发外链好\" class=\"headerlink\" title=\"57、一个地方发链接好还是多个地方发外链好?\"></a>57、一个地方发链接好还是多个地方发外链好?</h4><p>　　外链的广泛性本身对搜索引擎的排名本身很重要，外链的多少在于域名不同的外链数量，统一域名下的链接再多也比不上不同域名下外链的数量。外链要有自然性、广泛性，不同域名下的推荐才是最真实的。</p>\n<h4 id=\"58、首页为什么不要有FLASH动画、视频\"><a href=\"#58、首页为什么不要有FLASH动画、视频\" class=\"headerlink\" title=\"58、首页为什么不要有FLASH动画、视频?\"></a>58、首页为什么不要有FLASH动画、视频?</h4><p>　　Flash不利于搜索引擎抓取，同时FLASH会影响网页的打开速度，Flash也不利用网页聚合内容与关键词的匹配，但不是说不能有FLASH动画、视频，只是说不要首页全部是这个，这样对搜索引擎是相当不友好的，合理的加入FLASH可以为网页添加色彩。网站最多还是为了用户体验，如果你觉得你的网站需要FALSH，并且能让用户体验更好，那么就可以加。</p>\n<h4 id=\"59、快照天天更新，也没觉得能给我带来啥好处啊\"><a href=\"#59、快照天天更新，也没觉得能给我带来啥好处啊\" class=\"headerlink\" title=\"59、快照天天更新，也没觉得能给我带来啥好处啊?\"></a>59、快照天天更新，也没觉得能给我带来啥好处啊?</h4><p>　　百度快照正常更新只是说网站比较健康，蜘蛛更新比较勤。快照更新并不等于权重提高，也不等于关键词排名。</p>\n<h4 id=\"60、我的网站排名由第一页掉到十几页了，为什么\"><a href=\"#60、我的网站排名由第一页掉到十几页了，为什么\" class=\"headerlink\" title=\"60、我的网站排名由第一页掉到十几页了，为什么?\"></a>60、我的网站排名由第一页掉到十几页了，为什么?</h4><p>　　排名一下子掉到10页开外，如果不是搜索引擎内部问题，肯定是自己网站的问题了。很多情况是被降权，降权的主要表现方式是：收录大规模减少，排名迅速下降，时常伴随着首页被K。<br>　　一般如果你没有在情况出现之前做过特别的操作，那么你需要注意：<br>　　1、检查是否有不良友情链接，检查友情链接是否有问题。<br>　　2、检查网站所在服务器是否因为别人的网站受到了处罚。<br>　　3、检查网站的内容是不是被某些大型网站进行了转载并且未说明出处。有时候不是因为内容重复过高而降权。<br>　　4、检查网站是否被攻击、木马，以及被黑帽seo入侵后进行了黑帽利用。<br>　　5、百度最近是否有大规模更新。<br>　　6、网站存在大量重复内容。<br>　　7、网站累积性优化，导致优化过度。<br>　　8、外链大幅度减少，比如外链所在平台被K，外链账号被封，贴吧贴子被删，信息平台主题过期等。</p>\n","excerpt":"","more":"<h4 id=\"41、一个网站的导出链接多少合适\"><a href=\"#41、一个网站的导出链接多少合适\" class=\"headerlink\" title=\"41、一个网站的导出链接多少合适?\"></a>41、一个网站的导出链接多少合适?</h4><p>　　一个网站导出链接的多少合适，不能只能从数量来判断，那些知名导航站导出的链接的数量很多吧，但是自己的权重受影响了吗?首先要根据自己网站来，网站的定位、类型、权重值等都会影响导出链接的多少。其次就算是单向的导出链接，所链接的网站质量也要高，搜索引擎有它的关联判断，对方网站有问题很可能影响到你，还有就是导出链接要联系实际情况和用户需求，要提供对访问者有价值的链接。如果硬要说导出链接多少合适，我觉得可以去查看PR输出值，最好不要低于0.2，这个可以在站长工具查到。</p>\n<h4 id=\"42、经常看到人说软文推广，是不是文章里加了链接就是软文推广啊\"><a href=\"#42、经常看到人说软文推广，是不是文章里加了链接就是软文推广啊\" class=\"headerlink\" title=\"42、经常看到人说软文推广，是不是文章里加了链接就是软文推广啊?\"></a>42、经常看到人说软文推广，是不是文章里加了链接就是软文推广啊?</h4><p>　　答：软文从实质上来说就是软广告，是一种收而不漏的广告。软文推广通常借助文字表达与舆论传播使消费者认同某种概念、观点和分析思路，从而达到企业品牌宣传、产品销售的目的。但是，它跟直接的广告又有不同，它是把广告隐藏在，带有愉悦性，或知识性的文章当中，它是潜移默化的将广告植入。加不加链接它都在推广，而对于传统意义上的SEO而言，加一个链接可以多个外链，助力网站。这样可能对于网站来说更好，但是在如今的互联网，SEO工作人员需要与营销结合，外链时代早已过去，内容营销正在崛起，我们要与时俱进。</p>\n<h4 id=\"43、购买弹窗流量对搜索引擎到底是利还是弊-会不会被认为是作弊，而被K呢\"><a href=\"#43、购买弹窗流量对搜索引擎到底是利还是弊-会不会被认为是作弊，而被K呢\" class=\"headerlink\" title=\"43、购买弹窗流量对搜索引擎到底是利还是弊?会不会被认为是作弊，而被K呢?\"></a>43、购买弹窗流量对搜索引擎到底是利还是弊?会不会被认为是作弊，而被K呢?</h4><p>　　答：弹窗这个东西可能会为你带来一点点流量，但是对搜索引擎优化是完全没用的。不仅如此，过分的弹窗，搜索引擎可能予以惩罚，之前百度的石榴算法已经讲过。适当的弹窗可以，但是太多不仅不利于优化，用户也很反感这种形式的广告。</p>\n<h4 id=\"44、请问百度竞价是怎么计费的呢\"><a href=\"#44、请问百度竞价是怎么计费的呢\" class=\"headerlink\" title=\"44、请问百度竞价是怎么计费的呢?\"></a>44、请问百度竞价是怎么计费的呢?</h4><p>　　主要是按点击付费的，按照实际点击价格计算收入。不同的关键字价格不同，搜索业务的点击收入也不同，不同的主题文字链价格不同，主题推广业务的点击收入也不同，可以直接注册百度推广账户进入后台有详细介绍的。</p>\n<h4 id=\"45、yx链接-隐藏链接-效果好吗\"><a href=\"#45、yx链接-隐藏链接-效果好吗\" class=\"headerlink\" title=\"45、yx链接(隐藏链接)效果好吗\"></a>45、yx链接(隐藏链接)效果好吗</h4><p>　　隐藏链接也叫黑链指的是正常的链接通过一些方法，如：把链接放入js代码中，使用display:none等等，从而使用户在正常浏览网页的时候无法看到这个链接。目的就是获得对方网站的权重值，效果好不好?当然好，但是相当不稳定，世上没有白吃的午餐，并且隐藏链接是被搜索引擎严令禁止的，建议没事就不要用这个，就算用黑帽也要用高级点的。</p>\n<h4 id=\"46、我的网站被别人复制了，而且内容是一样的，该怎么删除\"><a href=\"#46、我的网站被别人复制了，而且内容是一样的，该怎么删除\" class=\"headerlink\" title=\"46、我的网站被别人复制了，而且内容是一样的，该怎么删除?\"></a>46、我的网站被别人复制了，而且内容是一样的，该怎么删除?</h4><p>　　复制这个事情很不容易解决，人家网站里的东西，你不可能有权限删除的。像这种被复制问题，基本上是没有办法的。理论上是可以通过法律途径的，但是过程是很麻烦的。一般情况下可以把你的网站在做一些更新和修改，在程序上做些水印和防盗页面，新闻内容和图片内容设置防盗程序，别人就不容易复制了，这些也都需要和程序员协同完成，不过现在的采集软件都相当牛，未必能见效。当然了，你还可以联系对方谈一谈，怎么谈就看你了。<br>　　我觉得你的网站被镜像完全是一种成就，不要怕，继续做好优化，别人是复制站，你的网页是原创，同时搜索引擎也是在打击镜像站的，优势都在你这。</p>\n<h4 id=\"47、关键词排名下滑怎么办\"><a href=\"#47、关键词排名下滑怎么办\" class=\"headerlink\" title=\"47、关键词排名下滑怎么办?\"></a>47、关键词排名下滑怎么办?</h4><p>　　不要紧张，首先要找出原因，是否被降权?个别关键字问题还是全部?竞争对手如何?百度有无调整?友链是否出错?等等对网站问题逐一排查，进行全面SEO诊断找出问题。不管如何，坚持原创、优化好页面、做好内链、适当添加高质量链接时必须做的。</p>\n<h4 id=\"48、seo什么工具好用-比如平时查看关键字、近期热门关键字之类的的工具，那个比较好用\"><a href=\"#48、seo什么工具好用-比如平时查看关键字、近期热门关键字之类的的工具，那个比较好用\" class=\"headerlink\" title=\"48、seo什么工具好用?比如平时查看关键字、近期热门关键字之类的的工具，那个比较好用?\"></a>48、seo什么工具好用?比如平时查看关键字、近期热门关键字之类的的工具，那个比较好用?</h4><p>　　seo工具非常多，平时查看网站关键词用用站长工具查询就行了，关键词挖掘之类的可以下载金花、追词等工具。百度关键词分析工具和谷歌关键词分析工具功能也很全面，至于近期热门也可以看百度搜索风云榜。</p>\n<h4 id=\"49、我的原创文章没有被收录，为什么啊\"><a href=\"#49、我的原创文章没有被收录，为什么啊\" class=\"headerlink\" title=\"49、我的原创文章没有被收录，为什么啊?\"></a>49、我的原创文章没有被收录，为什么啊?</h4><p>　　一、新站审核期。假若因为这点你大可不必担心，一般新站处在搜索的审核期间，是需要时间来考量的，这时你需要操作的是继续更新的网站，带来更多原创独特的内容。<br>　　二、网站过度优化。过度优化一般直接造成网站收录减少，快照停滞不进或直接不收录，你需要做的操作是把优化明显的痕迹去掉再加上正常的更新。<br>　　三、内容原创性。搜索收录页面不是你说原创就是原创，你没有看别人的自己写的那不见得就是原创，你写的文章和网络的观点千篇一律，只是稍微换了个说法，可读性不强也不够稀缺，你需要做的是以伪原创为主，以适当独特的内容为辅。<br>　　四、友情链接有问题。对方网站被K导致你的网站受影响。<br>　　五、网站作弊。任何搜搜索引擎对这点都是严打的，收录减少只是一个比较轻的惩罚，你需要的操作是尽快把网站更正。<br>　　六。硬件方面。如网站打开速度慢，主机延迟，网站被挂马等，当搜索多次来探访出现这样的情况，可想而知了搜索也会慢慢摒弃的。</p>\n<h4 id=\"50、如何保证关键词排名稳定\"><a href=\"#50、如何保证关键词排名稳定\" class=\"headerlink\" title=\"50、如何保证关键词排名稳定?\"></a>50、如何保证关键词排名稳定?</h4><p>　　要关键词稳，首先人要稳，不要过多的去用SEO技术，坚持网站内容建设，如果没有内容，就没有人会被吸引，就不会有什么流量，就算来了人，跳出的机率也很大。如果站的内容质量很高，自然就会有人喜欢，流量自然能保证，关键词排名也会稳定，如何写好内容推荐提升内容吸引力十个秘诀。同时也用做好用户体验建设，用户行为同样影响着关键词排名，用户稳定关键词才能稳定。还有外链也不能落下，尽管目前外链的效用在减弱，但瘦死的骆驼比马大，那些只是说的垃圾外链，高质量外链依然是网站排名的坚实依靠。</p>\n<h4 id=\"51、为什么有的网站不用更新文章都可以排名靠前\"><a href=\"#51、为什么有的网站不用更新文章都可以排名靠前\" class=\"headerlink\" title=\"51、为什么有的网站不用更新文章都可以排名靠前?\"></a>51、为什么有的网站不用更新文章都可以排名靠前?</h4><p>　　不是不更新文章，只不过是现在没更新了而已，而有的人又会说他们的收录很少排名很多，确实有些站，总不更新东西，但是排名相当稳定。不过这些站要么本身是权重高的老牌网站、要么点击量非常高、要么外链数非常多，总之他们都不是那么的平凡。</p>\n<h4 id=\"52、原创内容的丰富程度对搜索引擎的收录影响有多大\"><a href=\"#52、原创内容的丰富程度对搜索引擎的收录影响有多大\" class=\"headerlink\" title=\"52、原创内容的丰富程度对搜索引擎的收录影响有多大?\"></a>52、原创内容的丰富程度对搜索引擎的收录影响有多大?</h4><p>　　原创内容的丰富程度对于搜索引擎收录的影响还是很大的，第一会考虑用户体验的问题，第二是搜索引擎自身对好文的一个判断。原创文章不一定都写得好，而丰富的原创内容尽管能促进收录，但好的原创内容不一定被收录，影响收录的因素很多，好原创只是其中之一而已。</p>\n<h4 id=\"53、请问蜘蛛是怎么判断网站更新的\"><a href=\"#53、请问蜘蛛是怎么判断网站更新的\" class=\"headerlink\" title=\"53、请问蜘蛛是怎么判断网站更新的?\"></a>53、请问蜘蛛是怎么判断网站更新的?</h4><p>　　蜘蛛爬进网站抓取内容时，根据对爬行内容的判断就可以判断网站更新</p>\n<h4 id=\"54、网站一天发多少文章合适\"><a href=\"#54、网站一天发多少文章合适\" class=\"headerlink\" title=\"54、网站一天发多少文章合适?\"></a>54、网站一天发多少文章合适?</h4><p>　　答：文章当然是发的越多越好，不过注意一点，不管一天发多少文章，一定要保持平均还要保证质量。如果质量跟不上不要只要量不要质，如果不能坚持更新的频率，也不要三天打鱼二天晒网。文章不在多在于精，最好坚持高质量的原创、文章发多少都可以，关键是定时定量定质，不能忽高忽低</p>\n<h4 id=\"55、收录正常，就是排名一直没有升\"><a href=\"#55、收录正常，就是排名一直没有升\" class=\"headerlink\" title=\"55、收录正常，就是排名一直没有升?\"></a>55、收录正常，就是排名一直没有升?</h4><p>　　既然收录正常，就从其他方面着手，收录正常并不等于排名上升。影响网站排名的因素有很多。可能是外链的影响，可能是用户点击，也可能是网站结构</p>\n<h4 id=\"56、怎么才叫热帖，有没有一个判定-好多帖子有的是点击量很高，没有回复，也叫热帖吗\"><a href=\"#56、怎么才叫热帖，有没有一个判定-好多帖子有的是点击量很高，没有回复，也叫热帖吗\" class=\"headerlink\" title=\"56、怎么才叫热帖，有没有一个判定?好多帖子有的是点击量很高，没有回复，也叫热帖吗?\"></a>56、怎么才叫热帖，有没有一个判定?好多帖子有的是点击量很高，没有回复，也叫热帖吗?</h4><p>　　一般而言，关注的人多，能够引起大家的共鸣，能够长时间排在论坛的首页的话，最好还能获得大量的转载基本上就可以叫做热帖了!</p>\n<h4 id=\"57、一个地方发链接好还是多个地方发外链好\"><a href=\"#57、一个地方发链接好还是多个地方发外链好\" class=\"headerlink\" title=\"57、一个地方发链接好还是多个地方发外链好?\"></a>57、一个地方发链接好还是多个地方发外链好?</h4><p>　　外链的广泛性本身对搜索引擎的排名本身很重要，外链的多少在于域名不同的外链数量，统一域名下的链接再多也比不上不同域名下外链的数量。外链要有自然性、广泛性，不同域名下的推荐才是最真实的。</p>\n<h4 id=\"58、首页为什么不要有FLASH动画、视频\"><a href=\"#58、首页为什么不要有FLASH动画、视频\" class=\"headerlink\" title=\"58、首页为什么不要有FLASH动画、视频?\"></a>58、首页为什么不要有FLASH动画、视频?</h4><p>　　Flash不利于搜索引擎抓取，同时FLASH会影响网页的打开速度，Flash也不利用网页聚合内容与关键词的匹配，但不是说不能有FLASH动画、视频，只是说不要首页全部是这个，这样对搜索引擎是相当不友好的，合理的加入FLASH可以为网页添加色彩。网站最多还是为了用户体验，如果你觉得你的网站需要FALSH，并且能让用户体验更好，那么就可以加。</p>\n<h4 id=\"59、快照天天更新，也没觉得能给我带来啥好处啊\"><a href=\"#59、快照天天更新，也没觉得能给我带来啥好处啊\" class=\"headerlink\" title=\"59、快照天天更新，也没觉得能给我带来啥好处啊?\"></a>59、快照天天更新，也没觉得能给我带来啥好处啊?</h4><p>　　百度快照正常更新只是说网站比较健康，蜘蛛更新比较勤。快照更新并不等于权重提高，也不等于关键词排名。</p>\n<h4 id=\"60、我的网站排名由第一页掉到十几页了，为什么\"><a href=\"#60、我的网站排名由第一页掉到十几页了，为什么\" class=\"headerlink\" title=\"60、我的网站排名由第一页掉到十几页了，为什么?\"></a>60、我的网站排名由第一页掉到十几页了，为什么?</h4><p>　　排名一下子掉到10页开外，如果不是搜索引擎内部问题，肯定是自己网站的问题了。很多情况是被降权，降权的主要表现方式是：收录大规模减少，排名迅速下降，时常伴随着首页被K。<br>　　一般如果你没有在情况出现之前做过特别的操作，那么你需要注意：<br>　　1、检查是否有不良友情链接，检查友情链接是否有问题。<br>　　2、检查网站所在服务器是否因为别人的网站受到了处罚。<br>　　3、检查网站的内容是不是被某些大型网站进行了转载并且未说明出处。有时候不是因为内容重复过高而降权。<br>　　4、检查网站是否被攻击、木马，以及被黑帽seo入侵后进行了黑帽利用。<br>　　5、百度最近是否有大规模更新。<br>　　6、网站存在大量重复内容。<br>　　7、网站累积性优化，导致优化过度。<br>　　8、外链大幅度减少，比如外链所在平台被K，外链账号被封，贴吧贴子被删，信息平台主题过期等。</p>\n"},{"title":"网站色彩该怎样搭配才能更吸引客户的眼球","date":"2014-12-16T01:47:20.000Z","_content":"网页的色彩是树立网站形象的关键之一，色彩搭配却是网友们感到头疼的问题。网页的背景，文字，图标，边框，超链接……，应该采用什么样的色彩，应该搭配什么色彩才能最好的表达出预想的内涵呢？在此记录一些心得，希望对你有所启发。\n#### 首先我们先来了解一些色彩的基本知识：\n　　1、颜色是因为光的折射而产生的。\n　　2、红，黄，蓝是三原色，其它的色彩都可以用这三种色彩调和而成。网页html语言中的色彩表达即是用这三种颜色的数值表示例如：红色是color （255,0,0）十六进制的表示方法为（FF0000），白色为（FFFFFF）, 我们经常看到的\"bgColor=#FFFFFF\"就是指背景色为白色。\n　　3、颜色分非彩色和彩色两类。非彩色是指黑，白，灰系统色。彩色是指除了非彩色以外的所有色彩。\n　　4、任何色彩都有饱和度和透明度的属性，属性的变化产生不同的色相，所以至少可以制作几百万种色彩。\n\n　　网页制作用彩色还是非彩色好呢？根据专业的研究机构研究表明：彩色的记忆效果是黑白的3.5倍。也就是说，在一般情况下，彩色页面较完全黑白页面更加吸引人。\n　　我们通常的做法是：主要内容文字用非彩色（黑色），边框，背景，图片用彩色。这样页面整体不单调，看主要内容也不会眼花。\n#### 非彩色的搭配\n　　黑白是最基本和最简单的搭配，白字黑底，黑底白字都非常清晰明了。灰色是万能色，可以和任何彩色搭配，也可以帮助两种对立的色彩和谐过渡。如果你实在找不出合适的色彩，那么用灰色试试，效果绝对不会太差。\n#### 彩色的搭配\n　　色彩千变万化，彩色的搭配是研究的重点。\n　　一、色环。我们将色彩按\"红-&gt;黄-&gt;绿-&gt;蓝-&gt;红\"依次过度渐变，就可以得到一个色彩环。具体知识点可自行度娘。\n　　二、色彩的心理感觉。不同的颜色会给浏览者不同的心理感受。\n　　红色——是一种激奋的色彩。刺激效果，能使人产生冲动，愤怒，热情，活力的感觉。\n　　绿色——介于冷暖两中色彩的中间，显得和睦，宁静，健康，安全的感觉。 它和金黄，淡白搭配，可以产生优雅，舒适的气氛。\n　　橙色——也是一种激奋的色彩，具有轻快，欢欣，热烈，温馨，时尚的效果。\n　　黄色——具有快乐，希望，智慧和轻快的个性，它的明度最高。\n　　蓝色——是最具凉爽，清新，专业的色彩。它和白色混合，能体现柔顺，淡雅，浪漫的气氛（象天空的色彩：）\n　　白色——具有洁白，明快，纯真，清洁的感受。\n　　黑色——具有深沉，神秘，寂静，悲哀，压抑的感受。\n　　灰色——具有中庸，平凡，温和，谦让，中立和高雅的感觉。\n\n　　每种色彩在饱和度，透明度上略微变化就会产生不同的感觉。以绿色为例，黄绿色有青春，旺盛的视觉意境，而蓝绿色则显得幽宁，阴深。\n#### 网页色彩搭配的原理\n　　1、色彩的鲜明性。网页的色彩要鲜艳，容易引人注目。\n　　2、色彩的独特性。要有与众不同的色彩，使得大家对你的印象强烈。\n　　3、色彩的合适性。就是说色彩和你表达的内容气氛相适合。如用粉色体现女性站点的柔性。\n　　4、色彩的联想性。不同色彩会产生不同的联想，蓝色想到天空，黑色想到黑夜，红色想到喜事等，选择色彩要和你网页的内涵相关联。\n\n#### 网页色彩掌握的过程\n　　随着网页制作经验的积累，我们用色有这样的一个趋势：单色-&gt;五彩缤纷-&gt;标准色-&gt;单色。一开始因为技术和知识缺乏，只能制作出简单的网页，色彩单一；在有一定基础和材料后，希望制作一个漂亮的网页，将自己收集的最好的图片，最满意色彩堆砌在页面上；但是时间一长，却发现色彩杂乱，没有个性和风格；第三次重新定位自己的网站，选择好切合自己的色彩，推出的站点往往比较成功；当最后设计理念和技术达到顶峰时，则又返朴归真，用单一色彩甚至非彩色就可以设计出简洁精美的站点。\n\n#### 网页色彩搭配的技巧\n　　1、用一种色彩。这里是指先选定一种色彩，然后调整透明度或者饱和度，（说得通俗些就是将色彩变淡或则加深），产生新的色彩，用于网页。这样的页面看起来色彩统一，有层次感。\n　　2、用两种色彩。先选定一种色彩，然后选择它的对比色（在Photoshop 里按ctrl+shift+I）。我的主页用蓝色和黄色就是这样确定的。整个页面色彩丰富但不花稍。\n　　3、用一个色系。简单的说就是用一个感觉的色彩，例如淡蓝，淡黄，淡绿；或者土黄，土灰，土蓝。确定色彩的方法各人不同，我是在Photoshop 里按前景色方框，在跳出的拾色器窗中选择\"自定义\"，然后在\"色库\"中选就可以了：）\n　　4、用黑色和一种彩色。比如大红的字体配黑色的边框感觉很“跳”。\n\n#### 在网页配色中，忌讳的是：\n　　1、不要将所有颜色都用到，尽量控制在三种色彩以内。\n　　2、背景和前文的对比尽量要大，（绝对不要用花纹繁复的图案作背景），以便突出主要文字内容。\n","source":"_posts/sitepeise.md","raw":"---\ntitle: 网站色彩该怎样搭配才能更吸引客户的眼球\ndate: 2014-12-16 09:47:20\ntags: 建站 seo\n---\n网页的色彩是树立网站形象的关键之一，色彩搭配却是网友们感到头疼的问题。网页的背景，文字，图标，边框，超链接……，应该采用什么样的色彩，应该搭配什么色彩才能最好的表达出预想的内涵呢？在此记录一些心得，希望对你有所启发。\n#### 首先我们先来了解一些色彩的基本知识：\n　　1、颜色是因为光的折射而产生的。\n　　2、红，黄，蓝是三原色，其它的色彩都可以用这三种色彩调和而成。网页html语言中的色彩表达即是用这三种颜色的数值表示例如：红色是color （255,0,0）十六进制的表示方法为（FF0000），白色为（FFFFFF）, 我们经常看到的\"bgColor=#FFFFFF\"就是指背景色为白色。\n　　3、颜色分非彩色和彩色两类。非彩色是指黑，白，灰系统色。彩色是指除了非彩色以外的所有色彩。\n　　4、任何色彩都有饱和度和透明度的属性，属性的变化产生不同的色相，所以至少可以制作几百万种色彩。\n\n　　网页制作用彩色还是非彩色好呢？根据专业的研究机构研究表明：彩色的记忆效果是黑白的3.5倍。也就是说，在一般情况下，彩色页面较完全黑白页面更加吸引人。\n　　我们通常的做法是：主要内容文字用非彩色（黑色），边框，背景，图片用彩色。这样页面整体不单调，看主要内容也不会眼花。\n#### 非彩色的搭配\n　　黑白是最基本和最简单的搭配，白字黑底，黑底白字都非常清晰明了。灰色是万能色，可以和任何彩色搭配，也可以帮助两种对立的色彩和谐过渡。如果你实在找不出合适的色彩，那么用灰色试试，效果绝对不会太差。\n#### 彩色的搭配\n　　色彩千变万化，彩色的搭配是研究的重点。\n　　一、色环。我们将色彩按\"红-&gt;黄-&gt;绿-&gt;蓝-&gt;红\"依次过度渐变，就可以得到一个色彩环。具体知识点可自行度娘。\n　　二、色彩的心理感觉。不同的颜色会给浏览者不同的心理感受。\n　　红色——是一种激奋的色彩。刺激效果，能使人产生冲动，愤怒，热情，活力的感觉。\n　　绿色——介于冷暖两中色彩的中间，显得和睦，宁静，健康，安全的感觉。 它和金黄，淡白搭配，可以产生优雅，舒适的气氛。\n　　橙色——也是一种激奋的色彩，具有轻快，欢欣，热烈，温馨，时尚的效果。\n　　黄色——具有快乐，希望，智慧和轻快的个性，它的明度最高。\n　　蓝色——是最具凉爽，清新，专业的色彩。它和白色混合，能体现柔顺，淡雅，浪漫的气氛（象天空的色彩：）\n　　白色——具有洁白，明快，纯真，清洁的感受。\n　　黑色——具有深沉，神秘，寂静，悲哀，压抑的感受。\n　　灰色——具有中庸，平凡，温和，谦让，中立和高雅的感觉。\n\n　　每种色彩在饱和度，透明度上略微变化就会产生不同的感觉。以绿色为例，黄绿色有青春，旺盛的视觉意境，而蓝绿色则显得幽宁，阴深。\n#### 网页色彩搭配的原理\n　　1、色彩的鲜明性。网页的色彩要鲜艳，容易引人注目。\n　　2、色彩的独特性。要有与众不同的色彩，使得大家对你的印象强烈。\n　　3、色彩的合适性。就是说色彩和你表达的内容气氛相适合。如用粉色体现女性站点的柔性。\n　　4、色彩的联想性。不同色彩会产生不同的联想，蓝色想到天空，黑色想到黑夜，红色想到喜事等，选择色彩要和你网页的内涵相关联。\n\n#### 网页色彩掌握的过程\n　　随着网页制作经验的积累，我们用色有这样的一个趋势：单色-&gt;五彩缤纷-&gt;标准色-&gt;单色。一开始因为技术和知识缺乏，只能制作出简单的网页，色彩单一；在有一定基础和材料后，希望制作一个漂亮的网页，将自己收集的最好的图片，最满意色彩堆砌在页面上；但是时间一长，却发现色彩杂乱，没有个性和风格；第三次重新定位自己的网站，选择好切合自己的色彩，推出的站点往往比较成功；当最后设计理念和技术达到顶峰时，则又返朴归真，用单一色彩甚至非彩色就可以设计出简洁精美的站点。\n\n#### 网页色彩搭配的技巧\n　　1、用一种色彩。这里是指先选定一种色彩，然后调整透明度或者饱和度，（说得通俗些就是将色彩变淡或则加深），产生新的色彩，用于网页。这样的页面看起来色彩统一，有层次感。\n　　2、用两种色彩。先选定一种色彩，然后选择它的对比色（在Photoshop 里按ctrl+shift+I）。我的主页用蓝色和黄色就是这样确定的。整个页面色彩丰富但不花稍。\n　　3、用一个色系。简单的说就是用一个感觉的色彩，例如淡蓝，淡黄，淡绿；或者土黄，土灰，土蓝。确定色彩的方法各人不同，我是在Photoshop 里按前景色方框，在跳出的拾色器窗中选择\"自定义\"，然后在\"色库\"中选就可以了：）\n　　4、用黑色和一种彩色。比如大红的字体配黑色的边框感觉很“跳”。\n\n#### 在网页配色中，忌讳的是：\n　　1、不要将所有颜色都用到，尽量控制在三种色彩以内。\n　　2、背景和前文的对比尽量要大，（绝对不要用花纹繁复的图案作背景），以便突出主要文字内容。\n","slug":"sitepeise","published":1,"updated":"2017-01-16T01:54:54.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixzjjbm60008mgtudd00nvn6","content":"<p>网页的色彩是树立网站形象的关键之一，色彩搭配却是网友们感到头疼的问题。网页的背景，文字，图标，边框，超链接……，应该采用什么样的色彩，应该搭配什么色彩才能最好的表达出预想的内涵呢？在此记录一些心得，希望对你有所启发。</p>\n<h4 id=\"首先我们先来了解一些色彩的基本知识：\"><a href=\"#首先我们先来了解一些色彩的基本知识：\" class=\"headerlink\" title=\"首先我们先来了解一些色彩的基本知识：\"></a>首先我们先来了解一些色彩的基本知识：</h4><p>　　1、颜色是因为光的折射而产生的。<br>　　2、红，黄，蓝是三原色，其它的色彩都可以用这三种色彩调和而成。网页html语言中的色彩表达即是用这三种颜色的数值表示例如：红色是color （255,0,0）十六进制的表示方法为（FF0000），白色为（FFFFFF）, 我们经常看到的”bgColor=#FFFFFF”就是指背景色为白色。<br>　　3、颜色分非彩色和彩色两类。非彩色是指黑，白，灰系统色。彩色是指除了非彩色以外的所有色彩。<br>　　4、任何色彩都有饱和度和透明度的属性，属性的变化产生不同的色相，所以至少可以制作几百万种色彩。</p>\n<p>　　网页制作用彩色还是非彩色好呢？根据专业的研究机构研究表明：彩色的记忆效果是黑白的3.5倍。也就是说，在一般情况下，彩色页面较完全黑白页面更加吸引人。<br>　　我们通常的做法是：主要内容文字用非彩色（黑色），边框，背景，图片用彩色。这样页面整体不单调，看主要内容也不会眼花。</p>\n<h4 id=\"非彩色的搭配\"><a href=\"#非彩色的搭配\" class=\"headerlink\" title=\"非彩色的搭配\"></a>非彩色的搭配</h4><p>　　黑白是最基本和最简单的搭配，白字黑底，黑底白字都非常清晰明了。灰色是万能色，可以和任何彩色搭配，也可以帮助两种对立的色彩和谐过渡。如果你实在找不出合适的色彩，那么用灰色试试，效果绝对不会太差。</p>\n<h4 id=\"彩色的搭配\"><a href=\"#彩色的搭配\" class=\"headerlink\" title=\"彩色的搭配\"></a>彩色的搭配</h4><p>　　色彩千变万化，彩色的搭配是研究的重点。<br>　　一、色环。我们将色彩按”红-&gt;黄-&gt;绿-&gt;蓝-&gt;红”依次过度渐变，就可以得到一个色彩环。具体知识点可自行度娘。<br>　　二、色彩的心理感觉。不同的颜色会给浏览者不同的心理感受。<br>　　红色——是一种激奋的色彩。刺激效果，能使人产生冲动，愤怒，热情，活力的感觉。<br>　　绿色——介于冷暖两中色彩的中间，显得和睦，宁静，健康，安全的感觉。 它和金黄，淡白搭配，可以产生优雅，舒适的气氛。<br>　　橙色——也是一种激奋的色彩，具有轻快，欢欣，热烈，温馨，时尚的效果。<br>　　黄色——具有快乐，希望，智慧和轻快的个性，它的明度最高。<br>　　蓝色——是最具凉爽，清新，专业的色彩。它和白色混合，能体现柔顺，淡雅，浪漫的气氛（象天空的色彩：）<br>　　白色——具有洁白，明快，纯真，清洁的感受。<br>　　黑色——具有深沉，神秘，寂静，悲哀，压抑的感受。<br>　　灰色——具有中庸，平凡，温和，谦让，中立和高雅的感觉。</p>\n<p>　　每种色彩在饱和度，透明度上略微变化就会产生不同的感觉。以绿色为例，黄绿色有青春，旺盛的视觉意境，而蓝绿色则显得幽宁，阴深。</p>\n<h4 id=\"网页色彩搭配的原理\"><a href=\"#网页色彩搭配的原理\" class=\"headerlink\" title=\"网页色彩搭配的原理\"></a>网页色彩搭配的原理</h4><p>　　1、色彩的鲜明性。网页的色彩要鲜艳，容易引人注目。<br>　　2、色彩的独特性。要有与众不同的色彩，使得大家对你的印象强烈。<br>　　3、色彩的合适性。就是说色彩和你表达的内容气氛相适合。如用粉色体现女性站点的柔性。<br>　　4、色彩的联想性。不同色彩会产生不同的联想，蓝色想到天空，黑色想到黑夜，红色想到喜事等，选择色彩要和你网页的内涵相关联。</p>\n<h4 id=\"网页色彩掌握的过程\"><a href=\"#网页色彩掌握的过程\" class=\"headerlink\" title=\"网页色彩掌握的过程\"></a>网页色彩掌握的过程</h4><p>　　随着网页制作经验的积累，我们用色有这样的一个趋势：单色-&gt;五彩缤纷-&gt;标准色-&gt;单色。一开始因为技术和知识缺乏，只能制作出简单的网页，色彩单一；在有一定基础和材料后，希望制作一个漂亮的网页，将自己收集的最好的图片，最满意色彩堆砌在页面上；但是时间一长，却发现色彩杂乱，没有个性和风格；第三次重新定位自己的网站，选择好切合自己的色彩，推出的站点往往比较成功；当最后设计理念和技术达到顶峰时，则又返朴归真，用单一色彩甚至非彩色就可以设计出简洁精美的站点。</p>\n<h4 id=\"网页色彩搭配的技巧\"><a href=\"#网页色彩搭配的技巧\" class=\"headerlink\" title=\"网页色彩搭配的技巧\"></a>网页色彩搭配的技巧</h4><p>　　1、用一种色彩。这里是指先选定一种色彩，然后调整透明度或者饱和度，（说得通俗些就是将色彩变淡或则加深），产生新的色彩，用于网页。这样的页面看起来色彩统一，有层次感。<br>　　2、用两种色彩。先选定一种色彩，然后选择它的对比色（在Photoshop 里按ctrl+shift+I）。我的主页用蓝色和黄色就是这样确定的。整个页面色彩丰富但不花稍。<br>　　3、用一个色系。简单的说就是用一个感觉的色彩，例如淡蓝，淡黄，淡绿；或者土黄，土灰，土蓝。确定色彩的方法各人不同，我是在Photoshop 里按前景色方框，在跳出的拾色器窗中选择”自定义”，然后在”色库”中选就可以了：）<br>　　4、用黑色和一种彩色。比如大红的字体配黑色的边框感觉很“跳”。</p>\n<h4 id=\"在网页配色中，忌讳的是：\"><a href=\"#在网页配色中，忌讳的是：\" class=\"headerlink\" title=\"在网页配色中，忌讳的是：\"></a>在网页配色中，忌讳的是：</h4><p>　　1、不要将所有颜色都用到，尽量控制在三种色彩以内。<br>　　2、背景和前文的对比尽量要大，（绝对不要用花纹繁复的图案作背景），以便突出主要文字内容。</p>\n","excerpt":"","more":"<p>网页的色彩是树立网站形象的关键之一，色彩搭配却是网友们感到头疼的问题。网页的背景，文字，图标，边框，超链接……，应该采用什么样的色彩，应该搭配什么色彩才能最好的表达出预想的内涵呢？在此记录一些心得，希望对你有所启发。</p>\n<h4 id=\"首先我们先来了解一些色彩的基本知识：\"><a href=\"#首先我们先来了解一些色彩的基本知识：\" class=\"headerlink\" title=\"首先我们先来了解一些色彩的基本知识：\"></a>首先我们先来了解一些色彩的基本知识：</h4><p>　　1、颜色是因为光的折射而产生的。<br>　　2、红，黄，蓝是三原色，其它的色彩都可以用这三种色彩调和而成。网页html语言中的色彩表达即是用这三种颜色的数值表示例如：红色是color （255,0,0）十六进制的表示方法为（FF0000），白色为（FFFFFF）, 我们经常看到的”bgColor=#FFFFFF”就是指背景色为白色。<br>　　3、颜色分非彩色和彩色两类。非彩色是指黑，白，灰系统色。彩色是指除了非彩色以外的所有色彩。<br>　　4、任何色彩都有饱和度和透明度的属性，属性的变化产生不同的色相，所以至少可以制作几百万种色彩。</p>\n<p>　　网页制作用彩色还是非彩色好呢？根据专业的研究机构研究表明：彩色的记忆效果是黑白的3.5倍。也就是说，在一般情况下，彩色页面较完全黑白页面更加吸引人。<br>　　我们通常的做法是：主要内容文字用非彩色（黑色），边框，背景，图片用彩色。这样页面整体不单调，看主要内容也不会眼花。</p>\n<h4 id=\"非彩色的搭配\"><a href=\"#非彩色的搭配\" class=\"headerlink\" title=\"非彩色的搭配\"></a>非彩色的搭配</h4><p>　　黑白是最基本和最简单的搭配，白字黑底，黑底白字都非常清晰明了。灰色是万能色，可以和任何彩色搭配，也可以帮助两种对立的色彩和谐过渡。如果你实在找不出合适的色彩，那么用灰色试试，效果绝对不会太差。</p>\n<h4 id=\"彩色的搭配\"><a href=\"#彩色的搭配\" class=\"headerlink\" title=\"彩色的搭配\"></a>彩色的搭配</h4><p>　　色彩千变万化，彩色的搭配是研究的重点。<br>　　一、色环。我们将色彩按”红-&gt;黄-&gt;绿-&gt;蓝-&gt;红”依次过度渐变，就可以得到一个色彩环。具体知识点可自行度娘。<br>　　二、色彩的心理感觉。不同的颜色会给浏览者不同的心理感受。<br>　　红色——是一种激奋的色彩。刺激效果，能使人产生冲动，愤怒，热情，活力的感觉。<br>　　绿色——介于冷暖两中色彩的中间，显得和睦，宁静，健康，安全的感觉。 它和金黄，淡白搭配，可以产生优雅，舒适的气氛。<br>　　橙色——也是一种激奋的色彩，具有轻快，欢欣，热烈，温馨，时尚的效果。<br>　　黄色——具有快乐，希望，智慧和轻快的个性，它的明度最高。<br>　　蓝色——是最具凉爽，清新，专业的色彩。它和白色混合，能体现柔顺，淡雅，浪漫的气氛（象天空的色彩：）<br>　　白色——具有洁白，明快，纯真，清洁的感受。<br>　　黑色——具有深沉，神秘，寂静，悲哀，压抑的感受。<br>　　灰色——具有中庸，平凡，温和，谦让，中立和高雅的感觉。</p>\n<p>　　每种色彩在饱和度，透明度上略微变化就会产生不同的感觉。以绿色为例，黄绿色有青春，旺盛的视觉意境，而蓝绿色则显得幽宁，阴深。</p>\n<h4 id=\"网页色彩搭配的原理\"><a href=\"#网页色彩搭配的原理\" class=\"headerlink\" title=\"网页色彩搭配的原理\"></a>网页色彩搭配的原理</h4><p>　　1、色彩的鲜明性。网页的色彩要鲜艳，容易引人注目。<br>　　2、色彩的独特性。要有与众不同的色彩，使得大家对你的印象强烈。<br>　　3、色彩的合适性。就是说色彩和你表达的内容气氛相适合。如用粉色体现女性站点的柔性。<br>　　4、色彩的联想性。不同色彩会产生不同的联想，蓝色想到天空，黑色想到黑夜，红色想到喜事等，选择色彩要和你网页的内涵相关联。</p>\n<h4 id=\"网页色彩掌握的过程\"><a href=\"#网页色彩掌握的过程\" class=\"headerlink\" title=\"网页色彩掌握的过程\"></a>网页色彩掌握的过程</h4><p>　　随着网页制作经验的积累，我们用色有这样的一个趋势：单色-&gt;五彩缤纷-&gt;标准色-&gt;单色。一开始因为技术和知识缺乏，只能制作出简单的网页，色彩单一；在有一定基础和材料后，希望制作一个漂亮的网页，将自己收集的最好的图片，最满意色彩堆砌在页面上；但是时间一长，却发现色彩杂乱，没有个性和风格；第三次重新定位自己的网站，选择好切合自己的色彩，推出的站点往往比较成功；当最后设计理念和技术达到顶峰时，则又返朴归真，用单一色彩甚至非彩色就可以设计出简洁精美的站点。</p>\n<h4 id=\"网页色彩搭配的技巧\"><a href=\"#网页色彩搭配的技巧\" class=\"headerlink\" title=\"网页色彩搭配的技巧\"></a>网页色彩搭配的技巧</h4><p>　　1、用一种色彩。这里是指先选定一种色彩，然后调整透明度或者饱和度，（说得通俗些就是将色彩变淡或则加深），产生新的色彩，用于网页。这样的页面看起来色彩统一，有层次感。<br>　　2、用两种色彩。先选定一种色彩，然后选择它的对比色（在Photoshop 里按ctrl+shift+I）。我的主页用蓝色和黄色就是这样确定的。整个页面色彩丰富但不花稍。<br>　　3、用一个色系。简单的说就是用一个感觉的色彩，例如淡蓝，淡黄，淡绿；或者土黄，土灰，土蓝。确定色彩的方法各人不同，我是在Photoshop 里按前景色方框，在跳出的拾色器窗中选择”自定义”，然后在”色库”中选就可以了：）<br>　　4、用黑色和一种彩色。比如大红的字体配黑色的边框感觉很“跳”。</p>\n<h4 id=\"在网页配色中，忌讳的是：\"><a href=\"#在网页配色中，忌讳的是：\" class=\"headerlink\" title=\"在网页配色中，忌讳的是：\"></a>在网页配色中，忌讳的是：</h4><p>　　1、不要将所有颜色都用到，尽量控制在三种色彩以内。<br>　　2、背景和前文的对比尽量要大，（绝对不要用花纹繁复的图案作背景），以便突出主要文字内容。</p>\n"},{"title":"网站SEO优化常见问题汇总2","date":"2015-01-17T02:04:06.000Z","_content":"#### 做网站推广转载优秀文章和做原创哪个更好?\n　　从用户体验的角度说，当然是转优质的文章好，有时效性、热门的文章是用户喜爱的，自己的原创不一定能写得很好。但是从SEO的角度说，当然是原创文章好，不过没有那么多的原创可写，所以很多时候优秀的转载文章也是不错的选择。其实不矛盾，转载精品+原创本就是内容的手段，高质量内容才是最好的，部分原创还是转载。\n#### 查询网站的时候，为什么有时候反链数查询不到?\n　　有时候是会出现这样的情况，工具嘛本身就会有一些问题，查不到时多换几个工具试试。用工具查询本身就是一个参考，以官方为准。\n#### 新站要不要向搜索引擎提交?\n　　搜索引擎提交是为了更快的让搜索引擎派蜘蛛来网站抓取收录，按理来说，提交了不会让你的网站收录。只是增加了收录的可能。一般新站提交一个域名就行，因为新站上线还是存在很多问题的，过多的提交会让蜘蛛爬行的更加深入，可能让网站的缺势暴露无遗。\n#### 什么样的网页内容是违规的?\n　　一、总在正常版块发软文、广告的。二、总在回贴里加外链的，特别是刷广告的。三、网站内容本身涉及到违法、违规内容的。也有可能是一些不良关键词的拼音做域名的。具体看《百度关于新闻源建议》和百度绿萝算法2.0。\n#### 网站改版是否对权重有所影响?\n　　肯定会有的，多大的问题，所以万不得已不要改版，打算好了改版就要做好改版的规划，不要盲目的去改版，改版的目的是用户体验高于搜索优化。改版完后要及时排查遗留下来的问题，并继续网站的更新。\n#### 群发太多会影响网站声誉，严重的话可能会被封杀?\n　　在博客或论坛上写很多关于公司网站的话题，叫博客营销或是论坛营销。用软件群发，那不叫营销，那叫灌水，会造成用户反感、影响网站声誉，甚至可能会引起搜索引擎或发布平台的惩罚。当然你如果利用的好，那也是可以取得不错的效果的，就像脑白金广告一年一个，一放一年，消费者早就烦了，结果呢?\n#### 如何看一个网站有没有被K?\n　　网站被K的表现不外乎流量减少、收录外链减少、权重降低、快照异常、关键词排名降低等\n#### 修改网站描述会被降权吗?\n　　修改描述信息一般是不会造成降权的，当然你要是非常频繁的修改就不一定了。\n#### 软文一般发布到哪些地方效果比较好呢?\n　　答：大型平台的蜘蛛去得多也爬得多，加上这些网站自身权重较高，软文收录较快。不过这些网站帖子更新快，可能你的软文没过几分钟就石层大海了，除非写得非常好，否侧就直接下去了。相反一些中小型平台尽管人流量小，帖子少，收录慢，但访问到你软文的用户可能相对更多一点，软文转化率要高点，所以说各有所长，主要看你的文章质量和目的。\n#### 30、在大论坛里发软文带链接会被删帖吗?\n　　问题不是删不删贴，是你能不能发上去，现在的大论坛都设定好了能不能带链接，如果不能的话，有链接的软文是根本发不上去的，何谈删帖?当前可以带超链接的大论坛已经很少，有很多是收费的，还有很多是允许带链接，不过都是纯文本链接。要多说一句的是，发软文的目的不仅仅是为了一个链接而已，抓取用户获得流量才是我们写软文的目的，并且如今内容营销已独成一脉，越来越受到重视。\n#### 31、如何修改网站的标题才能不被降权或惩罚?\n　　网页的标题是网站优化中特别重要的元素，是不可以随便更改的，更不能频繁更换的。但是由于优化要求或市场需要必须得改的时候，那也是要毫不犹豫的改。那么怎么样的去改才能不至于对网站造成负面影响呢?首先要设置好标题，保证一次性改好，然后就是要在网站稳定、搜索引擎无重要更新时更改，最后就是修改后及时向搜索引擎提交。\n#### 32、频繁提交网站地图会对网站有什么影响吗?会导致网站排名下降吗?什么样的提交频率最好呢?\n　　网站地图只是方便搜索引擎爬行收录，本身是没有必要频繁提交的，只要网站收录正常就可以了。至于网站地图的提交频率，关键是根据网站的更新数量和更新频率决定，一般情况下设置成一周一更新就行了。\n#### 33、友情链接的网站首页不在第一页可以吗?有什么影响?\n　　site首页不在第一位已经不能作为单纯的判断降权的方法了，首页不在第一可能是内页权重过高，也可能是其他原因，网站是否被惩罚还要根据关键词排名、收录外链量、快照情况....等情况决定。所以首页不是第一位没问题，别是被惩罚就行。但是交换友情链接后，要定期检查对方网站情况。\n#### 34、不知道是什么原因网站流量下降一大半?\n　　结合流量统计后台查看网站流量来源，同时判断网站是不是被搜索引擎惩罚了，导致关键词排名降低。不过这仅是判断搜索引擎的。我们还需要看看网上其他网站来源页面，比如贴吧、博客、论坛帖子等被惩罚或被删除，最后需要查看网站付费广告是否出现问题。\n#### 35、对于商城类网站来说，侧重点又有几方面呢?流量、转化率、注册量、回头率、品牌?\n　　商城类网站你例举的几个都是重点，首先要提高流量，打造品牌提高信誉度，同时网站注册量和回头率的提高也对于网站今后的发展和成交量有着直接的影响，但是总而言之，这些都是为了网站转化率考虑。\n#### 36、如何评估网络推广的效果?\n　　一般情况下是去查看：注册用户数、销售量、传播数、关键字排名、网站收录数、网站流量(独立IP和PV)、推广展现量、推广带来的流量占总流量的百分比、推广成交量等。目前主要还是看关键字排名以及相应的推广带来的流量。\n#### 37、我想问下外链数是怎么计算的比如说在同一天,用同一个马甲同一个IP在同一论坛发了5份贴,那么这算几个外链,用2个马甲同一个IP在同一论坛各发了5份贴,那么这算几个外链?\n　　从搜索引擎这个角度来说，网页B上面有网站A的一个链接，如果网页B是被百度收录的，那么对于百度搜索而言，B就是A的有效外链，如果B没有被百度收录，那么B就是无效外链。所以不管是不是同一个马甲同一个IP，只要是高质量帖子，都是好的外链。只不过外链追求广泛度，总是同一个马甲同一个IP大量进行外链发布，效果可能减弱甚至造成负面影响，所以号少链多还不如号多链广。但是不要发同样的帖子或者是垃圾帖子，这样可能被论坛管理员惩罚。\n#### 38、baidu和google对一级域名和二级域名的权重?\n　　搜索引擎当然给予一级域名权重高，但是不是说二级域名一定做不过一级域名，只是相对来说一级域名更容易优化，看你的重心是做哪个。\n#### 39、怎么看才能看得出百度谷歌的蜘蛛来爬过我的网站呢?\n　　这个就是我们常说的观察网站日志\n#### 40、新网站如何起步?\n　　新站初期，网站问题还是非常多的，结构和布局就不多说了。首先我们要检查新站的基本情况，有没有404页面?网址是否规范化?网页URL设置是否正确?robots文件是合理....等等。其次要定位网站的目标关键词、挖掘长尾关键词，设置好标题、描述等信息，做好网站的内容建设，布置好内链，这一点至关重要，最后网站内容建设好后，就逐步加入高质量链接，增加友链，并适当利用一些优化工具。","source":"_posts/siteseo2.md","raw":"---\ntitle: 网站SEO优化常见问题汇总2\ndate: 2015-01-17 10:04:06\ntags: seo\n---\n#### 做网站推广转载优秀文章和做原创哪个更好?\n　　从用户体验的角度说，当然是转优质的文章好，有时效性、热门的文章是用户喜爱的，自己的原创不一定能写得很好。但是从SEO的角度说，当然是原创文章好，不过没有那么多的原创可写，所以很多时候优秀的转载文章也是不错的选择。其实不矛盾，转载精品+原创本就是内容的手段，高质量内容才是最好的，部分原创还是转载。\n#### 查询网站的时候，为什么有时候反链数查询不到?\n　　有时候是会出现这样的情况，工具嘛本身就会有一些问题，查不到时多换几个工具试试。用工具查询本身就是一个参考，以官方为准。\n#### 新站要不要向搜索引擎提交?\n　　搜索引擎提交是为了更快的让搜索引擎派蜘蛛来网站抓取收录，按理来说，提交了不会让你的网站收录。只是增加了收录的可能。一般新站提交一个域名就行，因为新站上线还是存在很多问题的，过多的提交会让蜘蛛爬行的更加深入，可能让网站的缺势暴露无遗。\n#### 什么样的网页内容是违规的?\n　　一、总在正常版块发软文、广告的。二、总在回贴里加外链的，特别是刷广告的。三、网站内容本身涉及到违法、违规内容的。也有可能是一些不良关键词的拼音做域名的。具体看《百度关于新闻源建议》和百度绿萝算法2.0。\n#### 网站改版是否对权重有所影响?\n　　肯定会有的，多大的问题，所以万不得已不要改版，打算好了改版就要做好改版的规划，不要盲目的去改版，改版的目的是用户体验高于搜索优化。改版完后要及时排查遗留下来的问题，并继续网站的更新。\n#### 群发太多会影响网站声誉，严重的话可能会被封杀?\n　　在博客或论坛上写很多关于公司网站的话题，叫博客营销或是论坛营销。用软件群发，那不叫营销，那叫灌水，会造成用户反感、影响网站声誉，甚至可能会引起搜索引擎或发布平台的惩罚。当然你如果利用的好，那也是可以取得不错的效果的，就像脑白金广告一年一个，一放一年，消费者早就烦了，结果呢?\n#### 如何看一个网站有没有被K?\n　　网站被K的表现不外乎流量减少、收录外链减少、权重降低、快照异常、关键词排名降低等\n#### 修改网站描述会被降权吗?\n　　修改描述信息一般是不会造成降权的，当然你要是非常频繁的修改就不一定了。\n#### 软文一般发布到哪些地方效果比较好呢?\n　　答：大型平台的蜘蛛去得多也爬得多，加上这些网站自身权重较高，软文收录较快。不过这些网站帖子更新快，可能你的软文没过几分钟就石层大海了，除非写得非常好，否侧就直接下去了。相反一些中小型平台尽管人流量小，帖子少，收录慢，但访问到你软文的用户可能相对更多一点，软文转化率要高点，所以说各有所长，主要看你的文章质量和目的。\n#### 30、在大论坛里发软文带链接会被删帖吗?\n　　问题不是删不删贴，是你能不能发上去，现在的大论坛都设定好了能不能带链接，如果不能的话，有链接的软文是根本发不上去的，何谈删帖?当前可以带超链接的大论坛已经很少，有很多是收费的，还有很多是允许带链接，不过都是纯文本链接。要多说一句的是，发软文的目的不仅仅是为了一个链接而已，抓取用户获得流量才是我们写软文的目的，并且如今内容营销已独成一脉，越来越受到重视。\n#### 31、如何修改网站的标题才能不被降权或惩罚?\n　　网页的标题是网站优化中特别重要的元素，是不可以随便更改的，更不能频繁更换的。但是由于优化要求或市场需要必须得改的时候，那也是要毫不犹豫的改。那么怎么样的去改才能不至于对网站造成负面影响呢?首先要设置好标题，保证一次性改好，然后就是要在网站稳定、搜索引擎无重要更新时更改，最后就是修改后及时向搜索引擎提交。\n#### 32、频繁提交网站地图会对网站有什么影响吗?会导致网站排名下降吗?什么样的提交频率最好呢?\n　　网站地图只是方便搜索引擎爬行收录，本身是没有必要频繁提交的，只要网站收录正常就可以了。至于网站地图的提交频率，关键是根据网站的更新数量和更新频率决定，一般情况下设置成一周一更新就行了。\n#### 33、友情链接的网站首页不在第一页可以吗?有什么影响?\n　　site首页不在第一位已经不能作为单纯的判断降权的方法了，首页不在第一可能是内页权重过高，也可能是其他原因，网站是否被惩罚还要根据关键词排名、收录外链量、快照情况....等情况决定。所以首页不是第一位没问题，别是被惩罚就行。但是交换友情链接后，要定期检查对方网站情况。\n#### 34、不知道是什么原因网站流量下降一大半?\n　　结合流量统计后台查看网站流量来源，同时判断网站是不是被搜索引擎惩罚了，导致关键词排名降低。不过这仅是判断搜索引擎的。我们还需要看看网上其他网站来源页面，比如贴吧、博客、论坛帖子等被惩罚或被删除，最后需要查看网站付费广告是否出现问题。\n#### 35、对于商城类网站来说，侧重点又有几方面呢?流量、转化率、注册量、回头率、品牌?\n　　商城类网站你例举的几个都是重点，首先要提高流量，打造品牌提高信誉度，同时网站注册量和回头率的提高也对于网站今后的发展和成交量有着直接的影响，但是总而言之，这些都是为了网站转化率考虑。\n#### 36、如何评估网络推广的效果?\n　　一般情况下是去查看：注册用户数、销售量、传播数、关键字排名、网站收录数、网站流量(独立IP和PV)、推广展现量、推广带来的流量占总流量的百分比、推广成交量等。目前主要还是看关键字排名以及相应的推广带来的流量。\n#### 37、我想问下外链数是怎么计算的比如说在同一天,用同一个马甲同一个IP在同一论坛发了5份贴,那么这算几个外链,用2个马甲同一个IP在同一论坛各发了5份贴,那么这算几个外链?\n　　从搜索引擎这个角度来说，网页B上面有网站A的一个链接，如果网页B是被百度收录的，那么对于百度搜索而言，B就是A的有效外链，如果B没有被百度收录，那么B就是无效外链。所以不管是不是同一个马甲同一个IP，只要是高质量帖子，都是好的外链。只不过外链追求广泛度，总是同一个马甲同一个IP大量进行外链发布，效果可能减弱甚至造成负面影响，所以号少链多还不如号多链广。但是不要发同样的帖子或者是垃圾帖子，这样可能被论坛管理员惩罚。\n#### 38、baidu和google对一级域名和二级域名的权重?\n　　搜索引擎当然给予一级域名权重高，但是不是说二级域名一定做不过一级域名，只是相对来说一级域名更容易优化，看你的重心是做哪个。\n#### 39、怎么看才能看得出百度谷歌的蜘蛛来爬过我的网站呢?\n　　这个就是我们常说的观察网站日志\n#### 40、新网站如何起步?\n　　新站初期，网站问题还是非常多的，结构和布局就不多说了。首先我们要检查新站的基本情况，有没有404页面?网址是否规范化?网页URL设置是否正确?robots文件是合理....等等。其次要定位网站的目标关键词、挖掘长尾关键词，设置好标题、描述等信息，做好网站的内容建设，布置好内链，这一点至关重要，最后网站内容建设好后，就逐步加入高质量链接，增加友链，并适当利用一些优化工具。","slug":"siteseo2","published":1,"updated":"2017-01-16T02:07:28.961Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixzjjbm90009mgtu25lcypq6","content":"<h4 id=\"做网站推广转载优秀文章和做原创哪个更好\"><a href=\"#做网站推广转载优秀文章和做原创哪个更好\" class=\"headerlink\" title=\"做网站推广转载优秀文章和做原创哪个更好?\"></a>做网站推广转载优秀文章和做原创哪个更好?</h4><p>　　从用户体验的角度说，当然是转优质的文章好，有时效性、热门的文章是用户喜爱的，自己的原创不一定能写得很好。但是从SEO的角度说，当然是原创文章好，不过没有那么多的原创可写，所以很多时候优秀的转载文章也是不错的选择。其实不矛盾，转载精品+原创本就是内容的手段，高质量内容才是最好的，部分原创还是转载。</p>\n<h4 id=\"查询网站的时候，为什么有时候反链数查询不到\"><a href=\"#查询网站的时候，为什么有时候反链数查询不到\" class=\"headerlink\" title=\"查询网站的时候，为什么有时候反链数查询不到?\"></a>查询网站的时候，为什么有时候反链数查询不到?</h4><p>　　有时候是会出现这样的情况，工具嘛本身就会有一些问题，查不到时多换几个工具试试。用工具查询本身就是一个参考，以官方为准。</p>\n<h4 id=\"新站要不要向搜索引擎提交\"><a href=\"#新站要不要向搜索引擎提交\" class=\"headerlink\" title=\"新站要不要向搜索引擎提交?\"></a>新站要不要向搜索引擎提交?</h4><p>　　搜索引擎提交是为了更快的让搜索引擎派蜘蛛来网站抓取收录，按理来说，提交了不会让你的网站收录。只是增加了收录的可能。一般新站提交一个域名就行，因为新站上线还是存在很多问题的，过多的提交会让蜘蛛爬行的更加深入，可能让网站的缺势暴露无遗。</p>\n<h4 id=\"什么样的网页内容是违规的\"><a href=\"#什么样的网页内容是违规的\" class=\"headerlink\" title=\"什么样的网页内容是违规的?\"></a>什么样的网页内容是违规的?</h4><p>　　一、总在正常版块发软文、广告的。二、总在回贴里加外链的，特别是刷广告的。三、网站内容本身涉及到违法、违规内容的。也有可能是一些不良关键词的拼音做域名的。具体看《百度关于新闻源建议》和百度绿萝算法2.0。</p>\n<h4 id=\"网站改版是否对权重有所影响\"><a href=\"#网站改版是否对权重有所影响\" class=\"headerlink\" title=\"网站改版是否对权重有所影响?\"></a>网站改版是否对权重有所影响?</h4><p>　　肯定会有的，多大的问题，所以万不得已不要改版，打算好了改版就要做好改版的规划，不要盲目的去改版，改版的目的是用户体验高于搜索优化。改版完后要及时排查遗留下来的问题，并继续网站的更新。</p>\n<h4 id=\"群发太多会影响网站声誉，严重的话可能会被封杀\"><a href=\"#群发太多会影响网站声誉，严重的话可能会被封杀\" class=\"headerlink\" title=\"群发太多会影响网站声誉，严重的话可能会被封杀?\"></a>群发太多会影响网站声誉，严重的话可能会被封杀?</h4><p>　　在博客或论坛上写很多关于公司网站的话题，叫博客营销或是论坛营销。用软件群发，那不叫营销，那叫灌水，会造成用户反感、影响网站声誉，甚至可能会引起搜索引擎或发布平台的惩罚。当然你如果利用的好，那也是可以取得不错的效果的，就像脑白金广告一年一个，一放一年，消费者早就烦了，结果呢?</p>\n<h4 id=\"如何看一个网站有没有被K\"><a href=\"#如何看一个网站有没有被K\" class=\"headerlink\" title=\"如何看一个网站有没有被K?\"></a>如何看一个网站有没有被K?</h4><p>　　网站被K的表现不外乎流量减少、收录外链减少、权重降低、快照异常、关键词排名降低等</p>\n<h4 id=\"修改网站描述会被降权吗\"><a href=\"#修改网站描述会被降权吗\" class=\"headerlink\" title=\"修改网站描述会被降权吗?\"></a>修改网站描述会被降权吗?</h4><p>　　修改描述信息一般是不会造成降权的，当然你要是非常频繁的修改就不一定了。</p>\n<h4 id=\"软文一般发布到哪些地方效果比较好呢\"><a href=\"#软文一般发布到哪些地方效果比较好呢\" class=\"headerlink\" title=\"软文一般发布到哪些地方效果比较好呢?\"></a>软文一般发布到哪些地方效果比较好呢?</h4><p>　　答：大型平台的蜘蛛去得多也爬得多，加上这些网站自身权重较高，软文收录较快。不过这些网站帖子更新快，可能你的软文没过几分钟就石层大海了，除非写得非常好，否侧就直接下去了。相反一些中小型平台尽管人流量小，帖子少，收录慢，但访问到你软文的用户可能相对更多一点，软文转化率要高点，所以说各有所长，主要看你的文章质量和目的。</p>\n<h4 id=\"30、在大论坛里发软文带链接会被删帖吗\"><a href=\"#30、在大论坛里发软文带链接会被删帖吗\" class=\"headerlink\" title=\"30、在大论坛里发软文带链接会被删帖吗?\"></a>30、在大论坛里发软文带链接会被删帖吗?</h4><p>　　问题不是删不删贴，是你能不能发上去，现在的大论坛都设定好了能不能带链接，如果不能的话，有链接的软文是根本发不上去的，何谈删帖?当前可以带超链接的大论坛已经很少，有很多是收费的，还有很多是允许带链接，不过都是纯文本链接。要多说一句的是，发软文的目的不仅仅是为了一个链接而已，抓取用户获得流量才是我们写软文的目的，并且如今内容营销已独成一脉，越来越受到重视。</p>\n<h4 id=\"31、如何修改网站的标题才能不被降权或惩罚\"><a href=\"#31、如何修改网站的标题才能不被降权或惩罚\" class=\"headerlink\" title=\"31、如何修改网站的标题才能不被降权或惩罚?\"></a>31、如何修改网站的标题才能不被降权或惩罚?</h4><p>　　网页的标题是网站优化中特别重要的元素，是不可以随便更改的，更不能频繁更换的。但是由于优化要求或市场需要必须得改的时候，那也是要毫不犹豫的改。那么怎么样的去改才能不至于对网站造成负面影响呢?首先要设置好标题，保证一次性改好，然后就是要在网站稳定、搜索引擎无重要更新时更改，最后就是修改后及时向搜索引擎提交。</p>\n<h4 id=\"32、频繁提交网站地图会对网站有什么影响吗-会导致网站排名下降吗-什么样的提交频率最好呢\"><a href=\"#32、频繁提交网站地图会对网站有什么影响吗-会导致网站排名下降吗-什么样的提交频率最好呢\" class=\"headerlink\" title=\"32、频繁提交网站地图会对网站有什么影响吗?会导致网站排名下降吗?什么样的提交频率最好呢?\"></a>32、频繁提交网站地图会对网站有什么影响吗?会导致网站排名下降吗?什么样的提交频率最好呢?</h4><p>　　网站地图只是方便搜索引擎爬行收录，本身是没有必要频繁提交的，只要网站收录正常就可以了。至于网站地图的提交频率，关键是根据网站的更新数量和更新频率决定，一般情况下设置成一周一更新就行了。</p>\n<h4 id=\"33、友情链接的网站首页不在第一页可以吗-有什么影响\"><a href=\"#33、友情链接的网站首页不在第一页可以吗-有什么影响\" class=\"headerlink\" title=\"33、友情链接的网站首页不在第一页可以吗?有什么影响?\"></a>33、友情链接的网站首页不在第一页可以吗?有什么影响?</h4><p>　　site首页不在第一位已经不能作为单纯的判断降权的方法了，首页不在第一可能是内页权重过高，也可能是其他原因，网站是否被惩罚还要根据关键词排名、收录外链量、快照情况….等情况决定。所以首页不是第一位没问题，别是被惩罚就行。但是交换友情链接后，要定期检查对方网站情况。</p>\n<h4 id=\"34、不知道是什么原因网站流量下降一大半\"><a href=\"#34、不知道是什么原因网站流量下降一大半\" class=\"headerlink\" title=\"34、不知道是什么原因网站流量下降一大半?\"></a>34、不知道是什么原因网站流量下降一大半?</h4><p>　　结合流量统计后台查看网站流量来源，同时判断网站是不是被搜索引擎惩罚了，导致关键词排名降低。不过这仅是判断搜索引擎的。我们还需要看看网上其他网站来源页面，比如贴吧、博客、论坛帖子等被惩罚或被删除，最后需要查看网站付费广告是否出现问题。</p>\n<h4 id=\"35、对于商城类网站来说，侧重点又有几方面呢-流量、转化率、注册量、回头率、品牌\"><a href=\"#35、对于商城类网站来说，侧重点又有几方面呢-流量、转化率、注册量、回头率、品牌\" class=\"headerlink\" title=\"35、对于商城类网站来说，侧重点又有几方面呢?流量、转化率、注册量、回头率、品牌?\"></a>35、对于商城类网站来说，侧重点又有几方面呢?流量、转化率、注册量、回头率、品牌?</h4><p>　　商城类网站你例举的几个都是重点，首先要提高流量，打造品牌提高信誉度，同时网站注册量和回头率的提高也对于网站今后的发展和成交量有着直接的影响，但是总而言之，这些都是为了网站转化率考虑。</p>\n<h4 id=\"36、如何评估网络推广的效果\"><a href=\"#36、如何评估网络推广的效果\" class=\"headerlink\" title=\"36、如何评估网络推广的效果?\"></a>36、如何评估网络推广的效果?</h4><p>　　一般情况下是去查看：注册用户数、销售量、传播数、关键字排名、网站收录数、网站流量(独立IP和PV)、推广展现量、推广带来的流量占总流量的百分比、推广成交量等。目前主要还是看关键字排名以及相应的推广带来的流量。</p>\n<h4 id=\"37、我想问下外链数是怎么计算的比如说在同一天-用同一个马甲同一个IP在同一论坛发了5份贴-那么这算几个外链-用2个马甲同一个IP在同一论坛各发了5份贴-那么这算几个外链\"><a href=\"#37、我想问下外链数是怎么计算的比如说在同一天-用同一个马甲同一个IP在同一论坛发了5份贴-那么这算几个外链-用2个马甲同一个IP在同一论坛各发了5份贴-那么这算几个外链\" class=\"headerlink\" title=\"37、我想问下外链数是怎么计算的比如说在同一天,用同一个马甲同一个IP在同一论坛发了5份贴,那么这算几个外链,用2个马甲同一个IP在同一论坛各发了5份贴,那么这算几个外链?\"></a>37、我想问下外链数是怎么计算的比如说在同一天,用同一个马甲同一个IP在同一论坛发了5份贴,那么这算几个外链,用2个马甲同一个IP在同一论坛各发了5份贴,那么这算几个外链?</h4><p>　　从搜索引擎这个角度来说，网页B上面有网站A的一个链接，如果网页B是被百度收录的，那么对于百度搜索而言，B就是A的有效外链，如果B没有被百度收录，那么B就是无效外链。所以不管是不是同一个马甲同一个IP，只要是高质量帖子，都是好的外链。只不过外链追求广泛度，总是同一个马甲同一个IP大量进行外链发布，效果可能减弱甚至造成负面影响，所以号少链多还不如号多链广。但是不要发同样的帖子或者是垃圾帖子，这样可能被论坛管理员惩罚。</p>\n<h4 id=\"38、baidu和google对一级域名和二级域名的权重\"><a href=\"#38、baidu和google对一级域名和二级域名的权重\" class=\"headerlink\" title=\"38、baidu和google对一级域名和二级域名的权重?\"></a>38、baidu和google对一级域名和二级域名的权重?</h4><p>　　搜索引擎当然给予一级域名权重高，但是不是说二级域名一定做不过一级域名，只是相对来说一级域名更容易优化，看你的重心是做哪个。</p>\n<h4 id=\"39、怎么看才能看得出百度谷歌的蜘蛛来爬过我的网站呢\"><a href=\"#39、怎么看才能看得出百度谷歌的蜘蛛来爬过我的网站呢\" class=\"headerlink\" title=\"39、怎么看才能看得出百度谷歌的蜘蛛来爬过我的网站呢?\"></a>39、怎么看才能看得出百度谷歌的蜘蛛来爬过我的网站呢?</h4><p>　　这个就是我们常说的观察网站日志</p>\n<h4 id=\"40、新网站如何起步\"><a href=\"#40、新网站如何起步\" class=\"headerlink\" title=\"40、新网站如何起步?\"></a>40、新网站如何起步?</h4><p>　　新站初期，网站问题还是非常多的，结构和布局就不多说了。首先我们要检查新站的基本情况，有没有404页面?网址是否规范化?网页URL设置是否正确?robots文件是合理….等等。其次要定位网站的目标关键词、挖掘长尾关键词，设置好标题、描述等信息，做好网站的内容建设，布置好内链，这一点至关重要，最后网站内容建设好后，就逐步加入高质量链接，增加友链，并适当利用一些优化工具。</p>\n","excerpt":"","more":"<h4 id=\"做网站推广转载优秀文章和做原创哪个更好\"><a href=\"#做网站推广转载优秀文章和做原创哪个更好\" class=\"headerlink\" title=\"做网站推广转载优秀文章和做原创哪个更好?\"></a>做网站推广转载优秀文章和做原创哪个更好?</h4><p>　　从用户体验的角度说，当然是转优质的文章好，有时效性、热门的文章是用户喜爱的，自己的原创不一定能写得很好。但是从SEO的角度说，当然是原创文章好，不过没有那么多的原创可写，所以很多时候优秀的转载文章也是不错的选择。其实不矛盾，转载精品+原创本就是内容的手段，高质量内容才是最好的，部分原创还是转载。</p>\n<h4 id=\"查询网站的时候，为什么有时候反链数查询不到\"><a href=\"#查询网站的时候，为什么有时候反链数查询不到\" class=\"headerlink\" title=\"查询网站的时候，为什么有时候反链数查询不到?\"></a>查询网站的时候，为什么有时候反链数查询不到?</h4><p>　　有时候是会出现这样的情况，工具嘛本身就会有一些问题，查不到时多换几个工具试试。用工具查询本身就是一个参考，以官方为准。</p>\n<h4 id=\"新站要不要向搜索引擎提交\"><a href=\"#新站要不要向搜索引擎提交\" class=\"headerlink\" title=\"新站要不要向搜索引擎提交?\"></a>新站要不要向搜索引擎提交?</h4><p>　　搜索引擎提交是为了更快的让搜索引擎派蜘蛛来网站抓取收录，按理来说，提交了不会让你的网站收录。只是增加了收录的可能。一般新站提交一个域名就行，因为新站上线还是存在很多问题的，过多的提交会让蜘蛛爬行的更加深入，可能让网站的缺势暴露无遗。</p>\n<h4 id=\"什么样的网页内容是违规的\"><a href=\"#什么样的网页内容是违规的\" class=\"headerlink\" title=\"什么样的网页内容是违规的?\"></a>什么样的网页内容是违规的?</h4><p>　　一、总在正常版块发软文、广告的。二、总在回贴里加外链的，特别是刷广告的。三、网站内容本身涉及到违法、违规内容的。也有可能是一些不良关键词的拼音做域名的。具体看《百度关于新闻源建议》和百度绿萝算法2.0。</p>\n<h4 id=\"网站改版是否对权重有所影响\"><a href=\"#网站改版是否对权重有所影响\" class=\"headerlink\" title=\"网站改版是否对权重有所影响?\"></a>网站改版是否对权重有所影响?</h4><p>　　肯定会有的，多大的问题，所以万不得已不要改版，打算好了改版就要做好改版的规划，不要盲目的去改版，改版的目的是用户体验高于搜索优化。改版完后要及时排查遗留下来的问题，并继续网站的更新。</p>\n<h4 id=\"群发太多会影响网站声誉，严重的话可能会被封杀\"><a href=\"#群发太多会影响网站声誉，严重的话可能会被封杀\" class=\"headerlink\" title=\"群发太多会影响网站声誉，严重的话可能会被封杀?\"></a>群发太多会影响网站声誉，严重的话可能会被封杀?</h4><p>　　在博客或论坛上写很多关于公司网站的话题，叫博客营销或是论坛营销。用软件群发，那不叫营销，那叫灌水，会造成用户反感、影响网站声誉，甚至可能会引起搜索引擎或发布平台的惩罚。当然你如果利用的好，那也是可以取得不错的效果的，就像脑白金广告一年一个，一放一年，消费者早就烦了，结果呢?</p>\n<h4 id=\"如何看一个网站有没有被K\"><a href=\"#如何看一个网站有没有被K\" class=\"headerlink\" title=\"如何看一个网站有没有被K?\"></a>如何看一个网站有没有被K?</h4><p>　　网站被K的表现不外乎流量减少、收录外链减少、权重降低、快照异常、关键词排名降低等</p>\n<h4 id=\"修改网站描述会被降权吗\"><a href=\"#修改网站描述会被降权吗\" class=\"headerlink\" title=\"修改网站描述会被降权吗?\"></a>修改网站描述会被降权吗?</h4><p>　　修改描述信息一般是不会造成降权的，当然你要是非常频繁的修改就不一定了。</p>\n<h4 id=\"软文一般发布到哪些地方效果比较好呢\"><a href=\"#软文一般发布到哪些地方效果比较好呢\" class=\"headerlink\" title=\"软文一般发布到哪些地方效果比较好呢?\"></a>软文一般发布到哪些地方效果比较好呢?</h4><p>　　答：大型平台的蜘蛛去得多也爬得多，加上这些网站自身权重较高，软文收录较快。不过这些网站帖子更新快，可能你的软文没过几分钟就石层大海了，除非写得非常好，否侧就直接下去了。相反一些中小型平台尽管人流量小，帖子少，收录慢，但访问到你软文的用户可能相对更多一点，软文转化率要高点，所以说各有所长，主要看你的文章质量和目的。</p>\n<h4 id=\"30、在大论坛里发软文带链接会被删帖吗\"><a href=\"#30、在大论坛里发软文带链接会被删帖吗\" class=\"headerlink\" title=\"30、在大论坛里发软文带链接会被删帖吗?\"></a>30、在大论坛里发软文带链接会被删帖吗?</h4><p>　　问题不是删不删贴，是你能不能发上去，现在的大论坛都设定好了能不能带链接，如果不能的话，有链接的软文是根本发不上去的，何谈删帖?当前可以带超链接的大论坛已经很少，有很多是收费的，还有很多是允许带链接，不过都是纯文本链接。要多说一句的是，发软文的目的不仅仅是为了一个链接而已，抓取用户获得流量才是我们写软文的目的，并且如今内容营销已独成一脉，越来越受到重视。</p>\n<h4 id=\"31、如何修改网站的标题才能不被降权或惩罚\"><a href=\"#31、如何修改网站的标题才能不被降权或惩罚\" class=\"headerlink\" title=\"31、如何修改网站的标题才能不被降权或惩罚?\"></a>31、如何修改网站的标题才能不被降权或惩罚?</h4><p>　　网页的标题是网站优化中特别重要的元素，是不可以随便更改的，更不能频繁更换的。但是由于优化要求或市场需要必须得改的时候，那也是要毫不犹豫的改。那么怎么样的去改才能不至于对网站造成负面影响呢?首先要设置好标题，保证一次性改好，然后就是要在网站稳定、搜索引擎无重要更新时更改，最后就是修改后及时向搜索引擎提交。</p>\n<h4 id=\"32、频繁提交网站地图会对网站有什么影响吗-会导致网站排名下降吗-什么样的提交频率最好呢\"><a href=\"#32、频繁提交网站地图会对网站有什么影响吗-会导致网站排名下降吗-什么样的提交频率最好呢\" class=\"headerlink\" title=\"32、频繁提交网站地图会对网站有什么影响吗?会导致网站排名下降吗?什么样的提交频率最好呢?\"></a>32、频繁提交网站地图会对网站有什么影响吗?会导致网站排名下降吗?什么样的提交频率最好呢?</h4><p>　　网站地图只是方便搜索引擎爬行收录，本身是没有必要频繁提交的，只要网站收录正常就可以了。至于网站地图的提交频率，关键是根据网站的更新数量和更新频率决定，一般情况下设置成一周一更新就行了。</p>\n<h4 id=\"33、友情链接的网站首页不在第一页可以吗-有什么影响\"><a href=\"#33、友情链接的网站首页不在第一页可以吗-有什么影响\" class=\"headerlink\" title=\"33、友情链接的网站首页不在第一页可以吗?有什么影响?\"></a>33、友情链接的网站首页不在第一页可以吗?有什么影响?</h4><p>　　site首页不在第一位已经不能作为单纯的判断降权的方法了，首页不在第一可能是内页权重过高，也可能是其他原因，网站是否被惩罚还要根据关键词排名、收录外链量、快照情况….等情况决定。所以首页不是第一位没问题，别是被惩罚就行。但是交换友情链接后，要定期检查对方网站情况。</p>\n<h4 id=\"34、不知道是什么原因网站流量下降一大半\"><a href=\"#34、不知道是什么原因网站流量下降一大半\" class=\"headerlink\" title=\"34、不知道是什么原因网站流量下降一大半?\"></a>34、不知道是什么原因网站流量下降一大半?</h4><p>　　结合流量统计后台查看网站流量来源，同时判断网站是不是被搜索引擎惩罚了，导致关键词排名降低。不过这仅是判断搜索引擎的。我们还需要看看网上其他网站来源页面，比如贴吧、博客、论坛帖子等被惩罚或被删除，最后需要查看网站付费广告是否出现问题。</p>\n<h4 id=\"35、对于商城类网站来说，侧重点又有几方面呢-流量、转化率、注册量、回头率、品牌\"><a href=\"#35、对于商城类网站来说，侧重点又有几方面呢-流量、转化率、注册量、回头率、品牌\" class=\"headerlink\" title=\"35、对于商城类网站来说，侧重点又有几方面呢?流量、转化率、注册量、回头率、品牌?\"></a>35、对于商城类网站来说，侧重点又有几方面呢?流量、转化率、注册量、回头率、品牌?</h4><p>　　商城类网站你例举的几个都是重点，首先要提高流量，打造品牌提高信誉度，同时网站注册量和回头率的提高也对于网站今后的发展和成交量有着直接的影响，但是总而言之，这些都是为了网站转化率考虑。</p>\n<h4 id=\"36、如何评估网络推广的效果\"><a href=\"#36、如何评估网络推广的效果\" class=\"headerlink\" title=\"36、如何评估网络推广的效果?\"></a>36、如何评估网络推广的效果?</h4><p>　　一般情况下是去查看：注册用户数、销售量、传播数、关键字排名、网站收录数、网站流量(独立IP和PV)、推广展现量、推广带来的流量占总流量的百分比、推广成交量等。目前主要还是看关键字排名以及相应的推广带来的流量。</p>\n<h4 id=\"37、我想问下外链数是怎么计算的比如说在同一天-用同一个马甲同一个IP在同一论坛发了5份贴-那么这算几个外链-用2个马甲同一个IP在同一论坛各发了5份贴-那么这算几个外链\"><a href=\"#37、我想问下外链数是怎么计算的比如说在同一天-用同一个马甲同一个IP在同一论坛发了5份贴-那么这算几个外链-用2个马甲同一个IP在同一论坛各发了5份贴-那么这算几个外链\" class=\"headerlink\" title=\"37、我想问下外链数是怎么计算的比如说在同一天,用同一个马甲同一个IP在同一论坛发了5份贴,那么这算几个外链,用2个马甲同一个IP在同一论坛各发了5份贴,那么这算几个外链?\"></a>37、我想问下外链数是怎么计算的比如说在同一天,用同一个马甲同一个IP在同一论坛发了5份贴,那么这算几个外链,用2个马甲同一个IP在同一论坛各发了5份贴,那么这算几个外链?</h4><p>　　从搜索引擎这个角度来说，网页B上面有网站A的一个链接，如果网页B是被百度收录的，那么对于百度搜索而言，B就是A的有效外链，如果B没有被百度收录，那么B就是无效外链。所以不管是不是同一个马甲同一个IP，只要是高质量帖子，都是好的外链。只不过外链追求广泛度，总是同一个马甲同一个IP大量进行外链发布，效果可能减弱甚至造成负面影响，所以号少链多还不如号多链广。但是不要发同样的帖子或者是垃圾帖子，这样可能被论坛管理员惩罚。</p>\n<h4 id=\"38、baidu和google对一级域名和二级域名的权重\"><a href=\"#38、baidu和google对一级域名和二级域名的权重\" class=\"headerlink\" title=\"38、baidu和google对一级域名和二级域名的权重?\"></a>38、baidu和google对一级域名和二级域名的权重?</h4><p>　　搜索引擎当然给予一级域名权重高，但是不是说二级域名一定做不过一级域名，只是相对来说一级域名更容易优化，看你的重心是做哪个。</p>\n<h4 id=\"39、怎么看才能看得出百度谷歌的蜘蛛来爬过我的网站呢\"><a href=\"#39、怎么看才能看得出百度谷歌的蜘蛛来爬过我的网站呢\" class=\"headerlink\" title=\"39、怎么看才能看得出百度谷歌的蜘蛛来爬过我的网站呢?\"></a>39、怎么看才能看得出百度谷歌的蜘蛛来爬过我的网站呢?</h4><p>　　这个就是我们常说的观察网站日志</p>\n<h4 id=\"40、新网站如何起步\"><a href=\"#40、新网站如何起步\" class=\"headerlink\" title=\"40、新网站如何起步?\"></a>40、新网站如何起步?</h4><p>　　新站初期，网站问题还是非常多的，结构和布局就不多说了。首先我们要检查新站的基本情况，有没有404页面?网址是否规范化?网页URL设置是否正确?robots文件是合理….等等。其次要定位网站的目标关键词、挖掘长尾关键词，设置好标题、描述等信息，做好网站的内容建设，布置好内链，这一点至关重要，最后网站内容建设好后，就逐步加入高质量链接，增加友链，并适当利用一些优化工具。</p>\n"},{"title":"网站SEO优化常见问题汇总4","date":"2015-01-18T15:34:55.000Z","_content":"#### 61、哪有比较好点的SEO论坛啊?\n　　ChinaZ站长之家，推18，落伍者，A5站长网，seowhy，28推，Baidu SEO Guide。\n#### 62、PR值对一个网站有什么用啊?\n　　PR值是Google用于评测一个网页“重要性”的一种方法，PR是衡量一个网站外链质量的重要因素，不过PR的价值如今已一落千丈，谷歌退出中国，PR作用慢慢淡化，另外谷歌也很就没有更新这个PR值了，Matt Cutts也称谷歌将慢慢淡出PR值。\n#### 63、友情链接多少合适?\n　　友情链接多少一般来说是要看网站的情况。SEO建议不要超过40个，如果超过40个，你在做链接，友链带来的链接就不那么明显了，但是有高质量的友链当然除外，还有就是链接太多首页分享给网站内页的就会变少，并且友链过多会带来管理友链的不方便，特别是一些医疗站很多都不怎么做友链，就是因为医疗网站的不稳定导致友链网站多变。\n#### 64、怎么样保护我的原创文章呢?\n　　首先在原创里合理的多你自己的信息，别人在转载时，也会帮你在打广告，其次就是用程序不让别人复制文章甚至直接屏蔽采集软件，当然这个就比较复杂了，最后就是通过百度站长工具的PING功能，PING用于网站把内容更新快速通知给百度，以便百度及时进行抓取和更新。\n#### 65、网站被抄袭怎么办?\n　　网站被抄袭这个事情很不容易解决，人家网站里的东西，你不可能有权限删除的。像这种被复制问题，基本上是没有办法的。理论上是可以通过法律途径的，但是过程是很麻烦的。一般情况下可以把你的网站在做一些更新和修改，在程序上做些水印和防盗页面，新闻内容和图片内容设置防盗程序，别人就不容易复制了，这些也都需要和程序员协同完成，不过现在的采集软件都相当牛，未必能见效。当然了，你还可以联系对方谈一谈，怎么谈就看你了。\n　　我觉得你的网站被镜像完全是一种成就，不要怕，继续做好优化，别人是复制站，你的网页是原创，同时搜索引擎也是在打击镜像站的，优势都在你这。\n#### 66、网站优化主要考核哪几项?\n　　网页的收录数、快照日期、关键字的渗透、关键字排名、网站链接、权重、外链数、转化率等等，如果需要更详细的考核，那就需要全面分析网站。\n#### 67、做seo每天更新多少文章合适?\n　　网站每天更新多少文章没有一个具体的标准，要看是什么站,一般企业站每天2-3篇原创就可以了，但是一定要注重质量，要原创的。如果是大型的新闻门户等就需要很多了，有多大的容量，有多大的需求量就要更新多少的文章，不要打肿脸撑胖子，但也不要故意偷懒，你一个新闻站，你每天更新2篇文章，你觉得合适吗?所以对文章的更新首先要根据网站需求，然后更新文章要保证质量，坚持不懈，不要三天打鱼二天晒网的，你不坚持，搜索引擎也不会坚持的。\n#### 68、外链发布，一般一天多少比较合适?\n　　这个和网站内容更新是一个意思，每天要有计划，有规律的增加，不要在短时间内暴增，要保证质和量并存，天天发多少不是关键，关键是要保持规律的发，有质量的发，同样的有多大碗就放多少饭。外链可不是闹得玩的，现在是各种打击、各种难做，千万不要为追求量而被惩罚。\n#### 69、关键词一般优化几个为好呢?\n　　这得看关键词分类了，品牌词最少，首页目标关键词一般也在2-4个，而对于长尾关键词是挖掘越多越好。特别是大型网站主要流量都是来自于长尾关键词，而品牌词对于企业品牌的建立功劳最大，一旦成形那就是坚固的长城。而对于每个页面来说，首页一般就是2-4个主目标关键词，目录页就是主要的对应产品词，内容页一般每一个对应一个长尾词就可以了。\n#### 70、为什么我的网站有高流量，却不赚钱?\n　　SEO最终的目的不过是流量的增加，排名上去了，流量充足之后，SEO的工作似乎已经达到目标了，但网站最后的出路却是转化率的提升，只有流量客户转化成有效客户，才能给网站带来实实在在的收益。\n　　不是说网站优化好了流量高了，钱就会自己来，网站优化只是互联网的一小部分，懂网站优化也不一定就懂网赚。如果网站流量确实高，SEO建议可以：\n　　1、广告联盟赚钱：流量上来了第一个可以赚钱的方式就是靠广告赚钱，像点击广告、弹窗广告、按效果提成的广告，广告联盟多的是，现在用这种方式赚钱的也挺多的。\n　　2、卖网站产品赚钱：如果你有足够的资源，如果你有足够的信誉，如果来你网站的都是高质量IP，那你就可以选择出售网络产品赚钱，做这块最好把网站做的越细越好，这里就靠自己的网站宣传后引入的高质量IP赚钱了。不过产品的选择和策略很重要。\n　　3、收取会员费：这大致也属于网站产品吧，但这是不用资本的，需要的是技术。\n　　4、收取中介费用赚钱：像威客一样，这得需要买家卖家都来你的站，并且你的站有一定的转换，这个难度有点大，只是提下，可以不考虑了。\n#### 71、一般做百度优化都有哪些好的方法?\n　　这个就多了，主要从三方面来：\n　　(1)站内优化，基本的优化页面的布局、标签优化、内部关键字的插入、内容建设、站内链接、404页面、robots文件等等。\n　　(2)站外优化，站外优化主要是外链建设和友情链接，然后加上做百科、贴吧、知道等。\n　　(3)用户体验优化，用户体验是当前做优化和推广谈得最多的一个问题，用户体验优化要做的事很多，比如：网站排版、网站配色、网站功能、社会化插件、用户群体分析等。\n#### 72、在论坛回帖留下签名可做外链吗?\n　　可以明确的说现在的论坛签名这样的外链是没什么作用的，甚至还会被搜索引擎当成垃圾链接扣分，不过在大型可信的论坛，如果你已经和大家混的很熟的话，或者是已经成为了该坛子里的名人那么签名里的这个链接就有价值了。这里的签名就起到一个推广企业网站、建立品牌和引导流量的作用。还是那句话，不要为了做SEO而做SEO,什么事物包括搜索引擎的规则都是有逻辑可循的，各大论坛都设置了论坛签名，自然是有它的好处了，不要说对于网站排名没用而不去做。\n#### 73、做网站的权重主要要做哪几点啊?\n　　关于提升网站权重的侧重点也是分阶段的，SEO主要把它们分为SEO优化前期、中期和后期，前期是关键词在20名外，主要第三方平台的外链推荐;中期目标关键词排名进入20，主要靠吸引点击流量，获得用户推荐，后期关键词排名稳定在前3，主要就是网站内部微调和长尾词引流。\n#### 74、如何做长尾关键词排名?\n　　优化长尾关键词主要是先要挖掘大量优质的长尾关键词，然后根据长尾关键词编辑优质的文章，做好长尾词和对应链接的统计，方便站内内链的建设，同时加入外链。其他和做首页目标关键词是一样的。一定要做好长尾关键词文章统计，防止站内出现多个内容页做同一个长尾词分散权重。\n#### 75、刷流量和买流量有什么区别?\n　　这两个是差不多的，刷的流量不真实。而买的流量分两种，一种真实流量，一种假流量(就是刷的流量)。网站后期给网站适当的买真实流量对于网站的排名有一定的推荐作用。\n#### 76、博客给K有几种原因?\n　　一、网站内容作弊,不少站长为了更好的提高排名,常常在网站上加些无关主题欺骗搜索引擎来牵引流量,短期取得的流量是不错,但长久下去就是自食其果啊。\n　　二、服务器原因,服务器对于SEO也很重要,切勿贪图小利,而选择便宜的,服务器不稳定,搜索引擎蜘蛛在进行抓取和更新,网站如果不能正常访问,影响搜索排名,严重时网站会被K。\n　　三、网站源码,不要经常修改网站标题与标签,搜索引擎抓取后,可能造成网站排名下降,甚至搜索降级,拔毛。\n　　四、网站构造,改变一个网站结构,就等于让搜索蜘蛛重新来过,不要随便对网站改版，一般都是被K站没法了才改版。\n　　五、搜索引擎算法,搜索引擎本身算法的更新,导致排名下降。\n　　六、网站作弊，使用黑帽子被K站是经常发生的事情。\n　　七、人工干预,搜索引擎的人工管理可是相当强,一些热门关键词与竞价比较多的的词,都是有搜索引擎的人工干预的。\n　　八、网站采集内容,网站存在大量采集文章或低质量文章。\n　　九、友情链接和外链,友情链接交换是站长常用的推广方式之一，友情站被K自己站可能受影响。另外网站充斥大量垃圾外链也会被惩罚，现在可是严打。\n　　十、ip锁定,你的网站正好与一些作弊的网站在一个服务器,这些网站被k,由于在一个IP，你的站很可能也被打入冷宫。\n　　十一、网站被攻击,如果你的网站被攻击或中毒，那K站也很正常。\n#### 77、有的网站首页是：www.xxx.com;有的首页是www.xxx.com/index.html 是路径设置的问题吗?可以和第二种网站交换友链吗?\n　　出现这种情况主要是对方网址没有进行网址规范化，如果没有进行链接的统一化，搜索引擎可能会认为这是2个页面，那么权重就肯定是不一样了，所以你要看对方是否重点优化的是带index的网址。一般情况下还是建议交换不带index的。\n#### 78、什么样的外链算是垃圾外链\n　　简单的说就是内容与网站相关性差、大量的推广信息、垃圾弹窗、外链承载平台垃圾、纯粹一个链接等等，反正你自己看着都不爽的肯定就是了，来看看lee关于外链判断。\n#### 79、外链有哪些形式?\n　　第一种，纯文本链接，这种外链对于排名影响不大，这种情况下一般是为了增加网站的品牌和名气的，一般应用在整个网站营销的这个期间，但是前期比较明显，因为网站建设初期网站权重不高，需要引蜘蛛的。\n　　第二种，超级链接，这种链接对于排名有效果，也可以增加企业网站的曝光度引入推荐流量\n　　第三种，锚文本链接，这种链接对于关键词排名最佳，不过现在这种链接越来越难做，很多时候都是来自友情链接和博客。\n#### 80、工作中如何去学习seo呀?\n　　多听，多看，多问，多学，多思考，多总结等等，既然是菜鸟，你就得该有个菜鸟样，什么都要多做，可以多到一些大型站长网比如：搜外、A5、站长之家等看好的seo文章、也可以进一些QQ群与其他人交流，不要不敢说不敢问，同时可以把学到的东西写下来，这样可以加深记忆，便于思考，最后就是需要去公司实战了，理论再好一旦实践你才能真正认识SEO.","source":"_posts/siteseo4.md","raw":"---\ntitle: 网站SEO优化常见问题汇总4\ndate: 2015-01-18 23:34:55\ntags: seo\n---\n#### 61、哪有比较好点的SEO论坛啊?\n　　ChinaZ站长之家，推18，落伍者，A5站长网，seowhy，28推，Baidu SEO Guide。\n#### 62、PR值对一个网站有什么用啊?\n　　PR值是Google用于评测一个网页“重要性”的一种方法，PR是衡量一个网站外链质量的重要因素，不过PR的价值如今已一落千丈，谷歌退出中国，PR作用慢慢淡化，另外谷歌也很就没有更新这个PR值了，Matt Cutts也称谷歌将慢慢淡出PR值。\n#### 63、友情链接多少合适?\n　　友情链接多少一般来说是要看网站的情况。SEO建议不要超过40个，如果超过40个，你在做链接，友链带来的链接就不那么明显了，但是有高质量的友链当然除外，还有就是链接太多首页分享给网站内页的就会变少，并且友链过多会带来管理友链的不方便，特别是一些医疗站很多都不怎么做友链，就是因为医疗网站的不稳定导致友链网站多变。\n#### 64、怎么样保护我的原创文章呢?\n　　首先在原创里合理的多你自己的信息，别人在转载时，也会帮你在打广告，其次就是用程序不让别人复制文章甚至直接屏蔽采集软件，当然这个就比较复杂了，最后就是通过百度站长工具的PING功能，PING用于网站把内容更新快速通知给百度，以便百度及时进行抓取和更新。\n#### 65、网站被抄袭怎么办?\n　　网站被抄袭这个事情很不容易解决，人家网站里的东西，你不可能有权限删除的。像这种被复制问题，基本上是没有办法的。理论上是可以通过法律途径的，但是过程是很麻烦的。一般情况下可以把你的网站在做一些更新和修改，在程序上做些水印和防盗页面，新闻内容和图片内容设置防盗程序，别人就不容易复制了，这些也都需要和程序员协同完成，不过现在的采集软件都相当牛，未必能见效。当然了，你还可以联系对方谈一谈，怎么谈就看你了。\n　　我觉得你的网站被镜像完全是一种成就，不要怕，继续做好优化，别人是复制站，你的网页是原创，同时搜索引擎也是在打击镜像站的，优势都在你这。\n#### 66、网站优化主要考核哪几项?\n　　网页的收录数、快照日期、关键字的渗透、关键字排名、网站链接、权重、外链数、转化率等等，如果需要更详细的考核，那就需要全面分析网站。\n#### 67、做seo每天更新多少文章合适?\n　　网站每天更新多少文章没有一个具体的标准，要看是什么站,一般企业站每天2-3篇原创就可以了，但是一定要注重质量，要原创的。如果是大型的新闻门户等就需要很多了，有多大的容量，有多大的需求量就要更新多少的文章，不要打肿脸撑胖子，但也不要故意偷懒，你一个新闻站，你每天更新2篇文章，你觉得合适吗?所以对文章的更新首先要根据网站需求，然后更新文章要保证质量，坚持不懈，不要三天打鱼二天晒网的，你不坚持，搜索引擎也不会坚持的。\n#### 68、外链发布，一般一天多少比较合适?\n　　这个和网站内容更新是一个意思，每天要有计划，有规律的增加，不要在短时间内暴增，要保证质和量并存，天天发多少不是关键，关键是要保持规律的发，有质量的发，同样的有多大碗就放多少饭。外链可不是闹得玩的，现在是各种打击、各种难做，千万不要为追求量而被惩罚。\n#### 69、关键词一般优化几个为好呢?\n　　这得看关键词分类了，品牌词最少，首页目标关键词一般也在2-4个，而对于长尾关键词是挖掘越多越好。特别是大型网站主要流量都是来自于长尾关键词，而品牌词对于企业品牌的建立功劳最大，一旦成形那就是坚固的长城。而对于每个页面来说，首页一般就是2-4个主目标关键词，目录页就是主要的对应产品词，内容页一般每一个对应一个长尾词就可以了。\n#### 70、为什么我的网站有高流量，却不赚钱?\n　　SEO最终的目的不过是流量的增加，排名上去了，流量充足之后，SEO的工作似乎已经达到目标了，但网站最后的出路却是转化率的提升，只有流量客户转化成有效客户，才能给网站带来实实在在的收益。\n　　不是说网站优化好了流量高了，钱就会自己来，网站优化只是互联网的一小部分，懂网站优化也不一定就懂网赚。如果网站流量确实高，SEO建议可以：\n　　1、广告联盟赚钱：流量上来了第一个可以赚钱的方式就是靠广告赚钱，像点击广告、弹窗广告、按效果提成的广告，广告联盟多的是，现在用这种方式赚钱的也挺多的。\n　　2、卖网站产品赚钱：如果你有足够的资源，如果你有足够的信誉，如果来你网站的都是高质量IP，那你就可以选择出售网络产品赚钱，做这块最好把网站做的越细越好，这里就靠自己的网站宣传后引入的高质量IP赚钱了。不过产品的选择和策略很重要。\n　　3、收取会员费：这大致也属于网站产品吧，但这是不用资本的，需要的是技术。\n　　4、收取中介费用赚钱：像威客一样，这得需要买家卖家都来你的站，并且你的站有一定的转换，这个难度有点大，只是提下，可以不考虑了。\n#### 71、一般做百度优化都有哪些好的方法?\n　　这个就多了，主要从三方面来：\n　　(1)站内优化，基本的优化页面的布局、标签优化、内部关键字的插入、内容建设、站内链接、404页面、robots文件等等。\n　　(2)站外优化，站外优化主要是外链建设和友情链接，然后加上做百科、贴吧、知道等。\n　　(3)用户体验优化，用户体验是当前做优化和推广谈得最多的一个问题，用户体验优化要做的事很多，比如：网站排版、网站配色、网站功能、社会化插件、用户群体分析等。\n#### 72、在论坛回帖留下签名可做外链吗?\n　　可以明确的说现在的论坛签名这样的外链是没什么作用的，甚至还会被搜索引擎当成垃圾链接扣分，不过在大型可信的论坛，如果你已经和大家混的很熟的话，或者是已经成为了该坛子里的名人那么签名里的这个链接就有价值了。这里的签名就起到一个推广企业网站、建立品牌和引导流量的作用。还是那句话，不要为了做SEO而做SEO,什么事物包括搜索引擎的规则都是有逻辑可循的，各大论坛都设置了论坛签名，自然是有它的好处了，不要说对于网站排名没用而不去做。\n#### 73、做网站的权重主要要做哪几点啊?\n　　关于提升网站权重的侧重点也是分阶段的，SEO主要把它们分为SEO优化前期、中期和后期，前期是关键词在20名外，主要第三方平台的外链推荐;中期目标关键词排名进入20，主要靠吸引点击流量，获得用户推荐，后期关键词排名稳定在前3，主要就是网站内部微调和长尾词引流。\n#### 74、如何做长尾关键词排名?\n　　优化长尾关键词主要是先要挖掘大量优质的长尾关键词，然后根据长尾关键词编辑优质的文章，做好长尾词和对应链接的统计，方便站内内链的建设，同时加入外链。其他和做首页目标关键词是一样的。一定要做好长尾关键词文章统计，防止站内出现多个内容页做同一个长尾词分散权重。\n#### 75、刷流量和买流量有什么区别?\n　　这两个是差不多的，刷的流量不真实。而买的流量分两种，一种真实流量，一种假流量(就是刷的流量)。网站后期给网站适当的买真实流量对于网站的排名有一定的推荐作用。\n#### 76、博客给K有几种原因?\n　　一、网站内容作弊,不少站长为了更好的提高排名,常常在网站上加些无关主题欺骗搜索引擎来牵引流量,短期取得的流量是不错,但长久下去就是自食其果啊。\n　　二、服务器原因,服务器对于SEO也很重要,切勿贪图小利,而选择便宜的,服务器不稳定,搜索引擎蜘蛛在进行抓取和更新,网站如果不能正常访问,影响搜索排名,严重时网站会被K。\n　　三、网站源码,不要经常修改网站标题与标签,搜索引擎抓取后,可能造成网站排名下降,甚至搜索降级,拔毛。\n　　四、网站构造,改变一个网站结构,就等于让搜索蜘蛛重新来过,不要随便对网站改版，一般都是被K站没法了才改版。\n　　五、搜索引擎算法,搜索引擎本身算法的更新,导致排名下降。\n　　六、网站作弊，使用黑帽子被K站是经常发生的事情。\n　　七、人工干预,搜索引擎的人工管理可是相当强,一些热门关键词与竞价比较多的的词,都是有搜索引擎的人工干预的。\n　　八、网站采集内容,网站存在大量采集文章或低质量文章。\n　　九、友情链接和外链,友情链接交换是站长常用的推广方式之一，友情站被K自己站可能受影响。另外网站充斥大量垃圾外链也会被惩罚，现在可是严打。\n　　十、ip锁定,你的网站正好与一些作弊的网站在一个服务器,这些网站被k,由于在一个IP，你的站很可能也被打入冷宫。\n　　十一、网站被攻击,如果你的网站被攻击或中毒，那K站也很正常。\n#### 77、有的网站首页是：www.xxx.com;有的首页是www.xxx.com/index.html 是路径设置的问题吗?可以和第二种网站交换友链吗?\n　　出现这种情况主要是对方网址没有进行网址规范化，如果没有进行链接的统一化，搜索引擎可能会认为这是2个页面，那么权重就肯定是不一样了，所以你要看对方是否重点优化的是带index的网址。一般情况下还是建议交换不带index的。\n#### 78、什么样的外链算是垃圾外链\n　　简单的说就是内容与网站相关性差、大量的推广信息、垃圾弹窗、外链承载平台垃圾、纯粹一个链接等等，反正你自己看着都不爽的肯定就是了，来看看lee关于外链判断。\n#### 79、外链有哪些形式?\n　　第一种，纯文本链接，这种外链对于排名影响不大，这种情况下一般是为了增加网站的品牌和名气的，一般应用在整个网站营销的这个期间，但是前期比较明显，因为网站建设初期网站权重不高，需要引蜘蛛的。\n　　第二种，超级链接，这种链接对于排名有效果，也可以增加企业网站的曝光度引入推荐流量\n　　第三种，锚文本链接，这种链接对于关键词排名最佳，不过现在这种链接越来越难做，很多时候都是来自友情链接和博客。\n#### 80、工作中如何去学习seo呀?\n　　多听，多看，多问，多学，多思考，多总结等等，既然是菜鸟，你就得该有个菜鸟样，什么都要多做，可以多到一些大型站长网比如：搜外、A5、站长之家等看好的seo文章、也可以进一些QQ群与其他人交流，不要不敢说不敢问，同时可以把学到的东西写下来，这样可以加深记忆，便于思考，最后就是需要去公司实战了，理论再好一旦实践你才能真正认识SEO.","slug":"siteseo4","published":1,"updated":"2017-01-16T02:22:27.004Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixzjjbme000bmgtuwytvfcpv","content":"<h4 id=\"61、哪有比较好点的SEO论坛啊\"><a href=\"#61、哪有比较好点的SEO论坛啊\" class=\"headerlink\" title=\"61、哪有比较好点的SEO论坛啊?\"></a>61、哪有比较好点的SEO论坛啊?</h4><p>　　ChinaZ站长之家，推18，落伍者，A5站长网，seowhy，28推，Baidu SEO Guide。</p>\n<h4 id=\"62、PR值对一个网站有什么用啊\"><a href=\"#62、PR值对一个网站有什么用啊\" class=\"headerlink\" title=\"62、PR值对一个网站有什么用啊?\"></a>62、PR值对一个网站有什么用啊?</h4><p>　　PR值是Google用于评测一个网页“重要性”的一种方法，PR是衡量一个网站外链质量的重要因素，不过PR的价值如今已一落千丈，谷歌退出中国，PR作用慢慢淡化，另外谷歌也很就没有更新这个PR值了，Matt Cutts也称谷歌将慢慢淡出PR值。</p>\n<h4 id=\"63、友情链接多少合适\"><a href=\"#63、友情链接多少合适\" class=\"headerlink\" title=\"63、友情链接多少合适?\"></a>63、友情链接多少合适?</h4><p>　　友情链接多少一般来说是要看网站的情况。SEO建议不要超过40个，如果超过40个，你在做链接，友链带来的链接就不那么明显了，但是有高质量的友链当然除外，还有就是链接太多首页分享给网站内页的就会变少，并且友链过多会带来管理友链的不方便，特别是一些医疗站很多都不怎么做友链，就是因为医疗网站的不稳定导致友链网站多变。</p>\n<h4 id=\"64、怎么样保护我的原创文章呢\"><a href=\"#64、怎么样保护我的原创文章呢\" class=\"headerlink\" title=\"64、怎么样保护我的原创文章呢?\"></a>64、怎么样保护我的原创文章呢?</h4><p>　　首先在原创里合理的多你自己的信息，别人在转载时，也会帮你在打广告，其次就是用程序不让别人复制文章甚至直接屏蔽采集软件，当然这个就比较复杂了，最后就是通过百度站长工具的PING功能，PING用于网站把内容更新快速通知给百度，以便百度及时进行抓取和更新。</p>\n<h4 id=\"65、网站被抄袭怎么办\"><a href=\"#65、网站被抄袭怎么办\" class=\"headerlink\" title=\"65、网站被抄袭怎么办?\"></a>65、网站被抄袭怎么办?</h4><p>　　网站被抄袭这个事情很不容易解决，人家网站里的东西，你不可能有权限删除的。像这种被复制问题，基本上是没有办法的。理论上是可以通过法律途径的，但是过程是很麻烦的。一般情况下可以把你的网站在做一些更新和修改，在程序上做些水印和防盗页面，新闻内容和图片内容设置防盗程序，别人就不容易复制了，这些也都需要和程序员协同完成，不过现在的采集软件都相当牛，未必能见效。当然了，你还可以联系对方谈一谈，怎么谈就看你了。<br>　　我觉得你的网站被镜像完全是一种成就，不要怕，继续做好优化，别人是复制站，你的网页是原创，同时搜索引擎也是在打击镜像站的，优势都在你这。</p>\n<h4 id=\"66、网站优化主要考核哪几项\"><a href=\"#66、网站优化主要考核哪几项\" class=\"headerlink\" title=\"66、网站优化主要考核哪几项?\"></a>66、网站优化主要考核哪几项?</h4><p>　　网页的收录数、快照日期、关键字的渗透、关键字排名、网站链接、权重、外链数、转化率等等，如果需要更详细的考核，那就需要全面分析网站。</p>\n<h4 id=\"67、做seo每天更新多少文章合适\"><a href=\"#67、做seo每天更新多少文章合适\" class=\"headerlink\" title=\"67、做seo每天更新多少文章合适?\"></a>67、做seo每天更新多少文章合适?</h4><p>　　网站每天更新多少文章没有一个具体的标准，要看是什么站,一般企业站每天2-3篇原创就可以了，但是一定要注重质量，要原创的。如果是大型的新闻门户等就需要很多了，有多大的容量，有多大的需求量就要更新多少的文章，不要打肿脸撑胖子，但也不要故意偷懒，你一个新闻站，你每天更新2篇文章，你觉得合适吗?所以对文章的更新首先要根据网站需求，然后更新文章要保证质量，坚持不懈，不要三天打鱼二天晒网的，你不坚持，搜索引擎也不会坚持的。</p>\n<h4 id=\"68、外链发布，一般一天多少比较合适\"><a href=\"#68、外链发布，一般一天多少比较合适\" class=\"headerlink\" title=\"68、外链发布，一般一天多少比较合适?\"></a>68、外链发布，一般一天多少比较合适?</h4><p>　　这个和网站内容更新是一个意思，每天要有计划，有规律的增加，不要在短时间内暴增，要保证质和量并存，天天发多少不是关键，关键是要保持规律的发，有质量的发，同样的有多大碗就放多少饭。外链可不是闹得玩的，现在是各种打击、各种难做，千万不要为追求量而被惩罚。</p>\n<h4 id=\"69、关键词一般优化几个为好呢\"><a href=\"#69、关键词一般优化几个为好呢\" class=\"headerlink\" title=\"69、关键词一般优化几个为好呢?\"></a>69、关键词一般优化几个为好呢?</h4><p>　　这得看关键词分类了，品牌词最少，首页目标关键词一般也在2-4个，而对于长尾关键词是挖掘越多越好。特别是大型网站主要流量都是来自于长尾关键词，而品牌词对于企业品牌的建立功劳最大，一旦成形那就是坚固的长城。而对于每个页面来说，首页一般就是2-4个主目标关键词，目录页就是主要的对应产品词，内容页一般每一个对应一个长尾词就可以了。</p>\n<h4 id=\"70、为什么我的网站有高流量，却不赚钱\"><a href=\"#70、为什么我的网站有高流量，却不赚钱\" class=\"headerlink\" title=\"70、为什么我的网站有高流量，却不赚钱?\"></a>70、为什么我的网站有高流量，却不赚钱?</h4><p>　　SEO最终的目的不过是流量的增加，排名上去了，流量充足之后，SEO的工作似乎已经达到目标了，但网站最后的出路却是转化率的提升，只有流量客户转化成有效客户，才能给网站带来实实在在的收益。<br>　　不是说网站优化好了流量高了，钱就会自己来，网站优化只是互联网的一小部分，懂网站优化也不一定就懂网赚。如果网站流量确实高，SEO建议可以：<br>　　1、广告联盟赚钱：流量上来了第一个可以赚钱的方式就是靠广告赚钱，像点击广告、弹窗广告、按效果提成的广告，广告联盟多的是，现在用这种方式赚钱的也挺多的。<br>　　2、卖网站产品赚钱：如果你有足够的资源，如果你有足够的信誉，如果来你网站的都是高质量IP，那你就可以选择出售网络产品赚钱，做这块最好把网站做的越细越好，这里就靠自己的网站宣传后引入的高质量IP赚钱了。不过产品的选择和策略很重要。<br>　　3、收取会员费：这大致也属于网站产品吧，但这是不用资本的，需要的是技术。<br>　　4、收取中介费用赚钱：像威客一样，这得需要买家卖家都来你的站，并且你的站有一定的转换，这个难度有点大，只是提下，可以不考虑了。</p>\n<h4 id=\"71、一般做百度优化都有哪些好的方法\"><a href=\"#71、一般做百度优化都有哪些好的方法\" class=\"headerlink\" title=\"71、一般做百度优化都有哪些好的方法?\"></a>71、一般做百度优化都有哪些好的方法?</h4><p>　　这个就多了，主要从三方面来：<br>　　(1)站内优化，基本的优化页面的布局、标签优化、内部关键字的插入、内容建设、站内链接、404页面、robots文件等等。<br>　　(2)站外优化，站外优化主要是外链建设和友情链接，然后加上做百科、贴吧、知道等。<br>　　(3)用户体验优化，用户体验是当前做优化和推广谈得最多的一个问题，用户体验优化要做的事很多，比如：网站排版、网站配色、网站功能、社会化插件、用户群体分析等。</p>\n<h4 id=\"72、在论坛回帖留下签名可做外链吗\"><a href=\"#72、在论坛回帖留下签名可做外链吗\" class=\"headerlink\" title=\"72、在论坛回帖留下签名可做外链吗?\"></a>72、在论坛回帖留下签名可做外链吗?</h4><p>　　可以明确的说现在的论坛签名这样的外链是没什么作用的，甚至还会被搜索引擎当成垃圾链接扣分，不过在大型可信的论坛，如果你已经和大家混的很熟的话，或者是已经成为了该坛子里的名人那么签名里的这个链接就有价值了。这里的签名就起到一个推广企业网站、建立品牌和引导流量的作用。还是那句话，不要为了做SEO而做SEO,什么事物包括搜索引擎的规则都是有逻辑可循的，各大论坛都设置了论坛签名，自然是有它的好处了，不要说对于网站排名没用而不去做。</p>\n<h4 id=\"73、做网站的权重主要要做哪几点啊\"><a href=\"#73、做网站的权重主要要做哪几点啊\" class=\"headerlink\" title=\"73、做网站的权重主要要做哪几点啊?\"></a>73、做网站的权重主要要做哪几点啊?</h4><p>　　关于提升网站权重的侧重点也是分阶段的，SEO主要把它们分为SEO优化前期、中期和后期，前期是关键词在20名外，主要第三方平台的外链推荐;中期目标关键词排名进入20，主要靠吸引点击流量，获得用户推荐，后期关键词排名稳定在前3，主要就是网站内部微调和长尾词引流。</p>\n<h4 id=\"74、如何做长尾关键词排名\"><a href=\"#74、如何做长尾关键词排名\" class=\"headerlink\" title=\"74、如何做长尾关键词排名?\"></a>74、如何做长尾关键词排名?</h4><p>　　优化长尾关键词主要是先要挖掘大量优质的长尾关键词，然后根据长尾关键词编辑优质的文章，做好长尾词和对应链接的统计，方便站内内链的建设，同时加入外链。其他和做首页目标关键词是一样的。一定要做好长尾关键词文章统计，防止站内出现多个内容页做同一个长尾词分散权重。</p>\n<h4 id=\"75、刷流量和买流量有什么区别\"><a href=\"#75、刷流量和买流量有什么区别\" class=\"headerlink\" title=\"75、刷流量和买流量有什么区别?\"></a>75、刷流量和买流量有什么区别?</h4><p>　　这两个是差不多的，刷的流量不真实。而买的流量分两种，一种真实流量，一种假流量(就是刷的流量)。网站后期给网站适当的买真实流量对于网站的排名有一定的推荐作用。</p>\n<h4 id=\"76、博客给K有几种原因\"><a href=\"#76、博客给K有几种原因\" class=\"headerlink\" title=\"76、博客给K有几种原因?\"></a>76、博客给K有几种原因?</h4><p>　　一、网站内容作弊,不少站长为了更好的提高排名,常常在网站上加些无关主题欺骗搜索引擎来牵引流量,短期取得的流量是不错,但长久下去就是自食其果啊。<br>　　二、服务器原因,服务器对于SEO也很重要,切勿贪图小利,而选择便宜的,服务器不稳定,搜索引擎蜘蛛在进行抓取和更新,网站如果不能正常访问,影响搜索排名,严重时网站会被K。<br>　　三、网站源码,不要经常修改网站标题与标签,搜索引擎抓取后,可能造成网站排名下降,甚至搜索降级,拔毛。<br>　　四、网站构造,改变一个网站结构,就等于让搜索蜘蛛重新来过,不要随便对网站改版，一般都是被K站没法了才改版。<br>　　五、搜索引擎算法,搜索引擎本身算法的更新,导致排名下降。<br>　　六、网站作弊，使用黑帽子被K站是经常发生的事情。<br>　　七、人工干预,搜索引擎的人工管理可是相当强,一些热门关键词与竞价比较多的的词,都是有搜索引擎的人工干预的。<br>　　八、网站采集内容,网站存在大量采集文章或低质量文章。<br>　　九、友情链接和外链,友情链接交换是站长常用的推广方式之一，友情站被K自己站可能受影响。另外网站充斥大量垃圾外链也会被惩罚，现在可是严打。<br>　　十、ip锁定,你的网站正好与一些作弊的网站在一个服务器,这些网站被k,由于在一个IP，你的站很可能也被打入冷宫。<br>　　十一、网站被攻击,如果你的网站被攻击或中毒，那K站也很正常。</p>\n<h4 id=\"77、有的网站首页是：www-xxx-com-有的首页是www-xxx-com-index-html-是路径设置的问题吗-可以和第二种网站交换友链吗\"><a href=\"#77、有的网站首页是：www-xxx-com-有的首页是www-xxx-com-index-html-是路径设置的问题吗-可以和第二种网站交换友链吗\" class=\"headerlink\" title=\"77、有的网站首页是：www.xxx.com;有的首页是www.xxx.com/index.html 是路径设置的问题吗?可以和第二种网站交换友链吗?\"></a>77、有的网站首页是：www.xxx.com;有的首页是www.xxx.com/index.html 是路径设置的问题吗?可以和第二种网站交换友链吗?</h4><p>　　出现这种情况主要是对方网址没有进行网址规范化，如果没有进行链接的统一化，搜索引擎可能会认为这是2个页面，那么权重就肯定是不一样了，所以你要看对方是否重点优化的是带index的网址。一般情况下还是建议交换不带index的。</p>\n<h4 id=\"78、什么样的外链算是垃圾外链\"><a href=\"#78、什么样的外链算是垃圾外链\" class=\"headerlink\" title=\"78、什么样的外链算是垃圾外链\"></a>78、什么样的外链算是垃圾外链</h4><p>　　简单的说就是内容与网站相关性差、大量的推广信息、垃圾弹窗、外链承载平台垃圾、纯粹一个链接等等，反正你自己看着都不爽的肯定就是了，来看看lee关于外链判断。</p>\n<h4 id=\"79、外链有哪些形式\"><a href=\"#79、外链有哪些形式\" class=\"headerlink\" title=\"79、外链有哪些形式?\"></a>79、外链有哪些形式?</h4><p>　　第一种，纯文本链接，这种外链对于排名影响不大，这种情况下一般是为了增加网站的品牌和名气的，一般应用在整个网站营销的这个期间，但是前期比较明显，因为网站建设初期网站权重不高，需要引蜘蛛的。<br>　　第二种，超级链接，这种链接对于排名有效果，也可以增加企业网站的曝光度引入推荐流量<br>　　第三种，锚文本链接，这种链接对于关键词排名最佳，不过现在这种链接越来越难做，很多时候都是来自友情链接和博客。</p>\n<h4 id=\"80、工作中如何去学习seo呀\"><a href=\"#80、工作中如何去学习seo呀\" class=\"headerlink\" title=\"80、工作中如何去学习seo呀?\"></a>80、工作中如何去学习seo呀?</h4><p>　　多听，多看，多问，多学，多思考，多总结等等，既然是菜鸟，你就得该有个菜鸟样，什么都要多做，可以多到一些大型站长网比如：搜外、A5、站长之家等看好的seo文章、也可以进一些QQ群与其他人交流，不要不敢说不敢问，同时可以把学到的东西写下来，这样可以加深记忆，便于思考，最后就是需要去公司实战了，理论再好一旦实践你才能真正认识SEO.</p>\n","excerpt":"","more":"<h4 id=\"61、哪有比较好点的SEO论坛啊\"><a href=\"#61、哪有比较好点的SEO论坛啊\" class=\"headerlink\" title=\"61、哪有比较好点的SEO论坛啊?\"></a>61、哪有比较好点的SEO论坛啊?</h4><p>　　ChinaZ站长之家，推18，落伍者，A5站长网，seowhy，28推，Baidu SEO Guide。</p>\n<h4 id=\"62、PR值对一个网站有什么用啊\"><a href=\"#62、PR值对一个网站有什么用啊\" class=\"headerlink\" title=\"62、PR值对一个网站有什么用啊?\"></a>62、PR值对一个网站有什么用啊?</h4><p>　　PR值是Google用于评测一个网页“重要性”的一种方法，PR是衡量一个网站外链质量的重要因素，不过PR的价值如今已一落千丈，谷歌退出中国，PR作用慢慢淡化，另外谷歌也很就没有更新这个PR值了，Matt Cutts也称谷歌将慢慢淡出PR值。</p>\n<h4 id=\"63、友情链接多少合适\"><a href=\"#63、友情链接多少合适\" class=\"headerlink\" title=\"63、友情链接多少合适?\"></a>63、友情链接多少合适?</h4><p>　　友情链接多少一般来说是要看网站的情况。SEO建议不要超过40个，如果超过40个，你在做链接，友链带来的链接就不那么明显了，但是有高质量的友链当然除外，还有就是链接太多首页分享给网站内页的就会变少，并且友链过多会带来管理友链的不方便，特别是一些医疗站很多都不怎么做友链，就是因为医疗网站的不稳定导致友链网站多变。</p>\n<h4 id=\"64、怎么样保护我的原创文章呢\"><a href=\"#64、怎么样保护我的原创文章呢\" class=\"headerlink\" title=\"64、怎么样保护我的原创文章呢?\"></a>64、怎么样保护我的原创文章呢?</h4><p>　　首先在原创里合理的多你自己的信息，别人在转载时，也会帮你在打广告，其次就是用程序不让别人复制文章甚至直接屏蔽采集软件，当然这个就比较复杂了，最后就是通过百度站长工具的PING功能，PING用于网站把内容更新快速通知给百度，以便百度及时进行抓取和更新。</p>\n<h4 id=\"65、网站被抄袭怎么办\"><a href=\"#65、网站被抄袭怎么办\" class=\"headerlink\" title=\"65、网站被抄袭怎么办?\"></a>65、网站被抄袭怎么办?</h4><p>　　网站被抄袭这个事情很不容易解决，人家网站里的东西，你不可能有权限删除的。像这种被复制问题，基本上是没有办法的。理论上是可以通过法律途径的，但是过程是很麻烦的。一般情况下可以把你的网站在做一些更新和修改，在程序上做些水印和防盗页面，新闻内容和图片内容设置防盗程序，别人就不容易复制了，这些也都需要和程序员协同完成，不过现在的采集软件都相当牛，未必能见效。当然了，你还可以联系对方谈一谈，怎么谈就看你了。<br>　　我觉得你的网站被镜像完全是一种成就，不要怕，继续做好优化，别人是复制站，你的网页是原创，同时搜索引擎也是在打击镜像站的，优势都在你这。</p>\n<h4 id=\"66、网站优化主要考核哪几项\"><a href=\"#66、网站优化主要考核哪几项\" class=\"headerlink\" title=\"66、网站优化主要考核哪几项?\"></a>66、网站优化主要考核哪几项?</h4><p>　　网页的收录数、快照日期、关键字的渗透、关键字排名、网站链接、权重、外链数、转化率等等，如果需要更详细的考核，那就需要全面分析网站。</p>\n<h4 id=\"67、做seo每天更新多少文章合适\"><a href=\"#67、做seo每天更新多少文章合适\" class=\"headerlink\" title=\"67、做seo每天更新多少文章合适?\"></a>67、做seo每天更新多少文章合适?</h4><p>　　网站每天更新多少文章没有一个具体的标准，要看是什么站,一般企业站每天2-3篇原创就可以了，但是一定要注重质量，要原创的。如果是大型的新闻门户等就需要很多了，有多大的容量，有多大的需求量就要更新多少的文章，不要打肿脸撑胖子，但也不要故意偷懒，你一个新闻站，你每天更新2篇文章，你觉得合适吗?所以对文章的更新首先要根据网站需求，然后更新文章要保证质量，坚持不懈，不要三天打鱼二天晒网的，你不坚持，搜索引擎也不会坚持的。</p>\n<h4 id=\"68、外链发布，一般一天多少比较合适\"><a href=\"#68、外链发布，一般一天多少比较合适\" class=\"headerlink\" title=\"68、外链发布，一般一天多少比较合适?\"></a>68、外链发布，一般一天多少比较合适?</h4><p>　　这个和网站内容更新是一个意思，每天要有计划，有规律的增加，不要在短时间内暴增，要保证质和量并存，天天发多少不是关键，关键是要保持规律的发，有质量的发，同样的有多大碗就放多少饭。外链可不是闹得玩的，现在是各种打击、各种难做，千万不要为追求量而被惩罚。</p>\n<h4 id=\"69、关键词一般优化几个为好呢\"><a href=\"#69、关键词一般优化几个为好呢\" class=\"headerlink\" title=\"69、关键词一般优化几个为好呢?\"></a>69、关键词一般优化几个为好呢?</h4><p>　　这得看关键词分类了，品牌词最少，首页目标关键词一般也在2-4个，而对于长尾关键词是挖掘越多越好。特别是大型网站主要流量都是来自于长尾关键词，而品牌词对于企业品牌的建立功劳最大，一旦成形那就是坚固的长城。而对于每个页面来说，首页一般就是2-4个主目标关键词，目录页就是主要的对应产品词，内容页一般每一个对应一个长尾词就可以了。</p>\n<h4 id=\"70、为什么我的网站有高流量，却不赚钱\"><a href=\"#70、为什么我的网站有高流量，却不赚钱\" class=\"headerlink\" title=\"70、为什么我的网站有高流量，却不赚钱?\"></a>70、为什么我的网站有高流量，却不赚钱?</h4><p>　　SEO最终的目的不过是流量的增加，排名上去了，流量充足之后，SEO的工作似乎已经达到目标了，但网站最后的出路却是转化率的提升，只有流量客户转化成有效客户，才能给网站带来实实在在的收益。<br>　　不是说网站优化好了流量高了，钱就会自己来，网站优化只是互联网的一小部分，懂网站优化也不一定就懂网赚。如果网站流量确实高，SEO建议可以：<br>　　1、广告联盟赚钱：流量上来了第一个可以赚钱的方式就是靠广告赚钱，像点击广告、弹窗广告、按效果提成的广告，广告联盟多的是，现在用这种方式赚钱的也挺多的。<br>　　2、卖网站产品赚钱：如果你有足够的资源，如果你有足够的信誉，如果来你网站的都是高质量IP，那你就可以选择出售网络产品赚钱，做这块最好把网站做的越细越好，这里就靠自己的网站宣传后引入的高质量IP赚钱了。不过产品的选择和策略很重要。<br>　　3、收取会员费：这大致也属于网站产品吧，但这是不用资本的，需要的是技术。<br>　　4、收取中介费用赚钱：像威客一样，这得需要买家卖家都来你的站，并且你的站有一定的转换，这个难度有点大，只是提下，可以不考虑了。</p>\n<h4 id=\"71、一般做百度优化都有哪些好的方法\"><a href=\"#71、一般做百度优化都有哪些好的方法\" class=\"headerlink\" title=\"71、一般做百度优化都有哪些好的方法?\"></a>71、一般做百度优化都有哪些好的方法?</h4><p>　　这个就多了，主要从三方面来：<br>　　(1)站内优化，基本的优化页面的布局、标签优化、内部关键字的插入、内容建设、站内链接、404页面、robots文件等等。<br>　　(2)站外优化，站外优化主要是外链建设和友情链接，然后加上做百科、贴吧、知道等。<br>　　(3)用户体验优化，用户体验是当前做优化和推广谈得最多的一个问题，用户体验优化要做的事很多，比如：网站排版、网站配色、网站功能、社会化插件、用户群体分析等。</p>\n<h4 id=\"72、在论坛回帖留下签名可做外链吗\"><a href=\"#72、在论坛回帖留下签名可做外链吗\" class=\"headerlink\" title=\"72、在论坛回帖留下签名可做外链吗?\"></a>72、在论坛回帖留下签名可做外链吗?</h4><p>　　可以明确的说现在的论坛签名这样的外链是没什么作用的，甚至还会被搜索引擎当成垃圾链接扣分，不过在大型可信的论坛，如果你已经和大家混的很熟的话，或者是已经成为了该坛子里的名人那么签名里的这个链接就有价值了。这里的签名就起到一个推广企业网站、建立品牌和引导流量的作用。还是那句话，不要为了做SEO而做SEO,什么事物包括搜索引擎的规则都是有逻辑可循的，各大论坛都设置了论坛签名，自然是有它的好处了，不要说对于网站排名没用而不去做。</p>\n<h4 id=\"73、做网站的权重主要要做哪几点啊\"><a href=\"#73、做网站的权重主要要做哪几点啊\" class=\"headerlink\" title=\"73、做网站的权重主要要做哪几点啊?\"></a>73、做网站的权重主要要做哪几点啊?</h4><p>　　关于提升网站权重的侧重点也是分阶段的，SEO主要把它们分为SEO优化前期、中期和后期，前期是关键词在20名外，主要第三方平台的外链推荐;中期目标关键词排名进入20，主要靠吸引点击流量，获得用户推荐，后期关键词排名稳定在前3，主要就是网站内部微调和长尾词引流。</p>\n<h4 id=\"74、如何做长尾关键词排名\"><a href=\"#74、如何做长尾关键词排名\" class=\"headerlink\" title=\"74、如何做长尾关键词排名?\"></a>74、如何做长尾关键词排名?</h4><p>　　优化长尾关键词主要是先要挖掘大量优质的长尾关键词，然后根据长尾关键词编辑优质的文章，做好长尾词和对应链接的统计，方便站内内链的建设，同时加入外链。其他和做首页目标关键词是一样的。一定要做好长尾关键词文章统计，防止站内出现多个内容页做同一个长尾词分散权重。</p>\n<h4 id=\"75、刷流量和买流量有什么区别\"><a href=\"#75、刷流量和买流量有什么区别\" class=\"headerlink\" title=\"75、刷流量和买流量有什么区别?\"></a>75、刷流量和买流量有什么区别?</h4><p>　　这两个是差不多的，刷的流量不真实。而买的流量分两种，一种真实流量，一种假流量(就是刷的流量)。网站后期给网站适当的买真实流量对于网站的排名有一定的推荐作用。</p>\n<h4 id=\"76、博客给K有几种原因\"><a href=\"#76、博客给K有几种原因\" class=\"headerlink\" title=\"76、博客给K有几种原因?\"></a>76、博客给K有几种原因?</h4><p>　　一、网站内容作弊,不少站长为了更好的提高排名,常常在网站上加些无关主题欺骗搜索引擎来牵引流量,短期取得的流量是不错,但长久下去就是自食其果啊。<br>　　二、服务器原因,服务器对于SEO也很重要,切勿贪图小利,而选择便宜的,服务器不稳定,搜索引擎蜘蛛在进行抓取和更新,网站如果不能正常访问,影响搜索排名,严重时网站会被K。<br>　　三、网站源码,不要经常修改网站标题与标签,搜索引擎抓取后,可能造成网站排名下降,甚至搜索降级,拔毛。<br>　　四、网站构造,改变一个网站结构,就等于让搜索蜘蛛重新来过,不要随便对网站改版，一般都是被K站没法了才改版。<br>　　五、搜索引擎算法,搜索引擎本身算法的更新,导致排名下降。<br>　　六、网站作弊，使用黑帽子被K站是经常发生的事情。<br>　　七、人工干预,搜索引擎的人工管理可是相当强,一些热门关键词与竞价比较多的的词,都是有搜索引擎的人工干预的。<br>　　八、网站采集内容,网站存在大量采集文章或低质量文章。<br>　　九、友情链接和外链,友情链接交换是站长常用的推广方式之一，友情站被K自己站可能受影响。另外网站充斥大量垃圾外链也会被惩罚，现在可是严打。<br>　　十、ip锁定,你的网站正好与一些作弊的网站在一个服务器,这些网站被k,由于在一个IP，你的站很可能也被打入冷宫。<br>　　十一、网站被攻击,如果你的网站被攻击或中毒，那K站也很正常。</p>\n<h4 id=\"77、有的网站首页是：www-xxx-com-有的首页是www-xxx-com-index-html-是路径设置的问题吗-可以和第二种网站交换友链吗\"><a href=\"#77、有的网站首页是：www-xxx-com-有的首页是www-xxx-com-index-html-是路径设置的问题吗-可以和第二种网站交换友链吗\" class=\"headerlink\" title=\"77、有的网站首页是：www.xxx.com;有的首页是www.xxx.com/index.html 是路径设置的问题吗?可以和第二种网站交换友链吗?\"></a>77、有的网站首页是：www.xxx.com;有的首页是www.xxx.com/index.html 是路径设置的问题吗?可以和第二种网站交换友链吗?</h4><p>　　出现这种情况主要是对方网址没有进行网址规范化，如果没有进行链接的统一化，搜索引擎可能会认为这是2个页面，那么权重就肯定是不一样了，所以你要看对方是否重点优化的是带index的网址。一般情况下还是建议交换不带index的。</p>\n<h4 id=\"78、什么样的外链算是垃圾外链\"><a href=\"#78、什么样的外链算是垃圾外链\" class=\"headerlink\" title=\"78、什么样的外链算是垃圾外链\"></a>78、什么样的外链算是垃圾外链</h4><p>　　简单的说就是内容与网站相关性差、大量的推广信息、垃圾弹窗、外链承载平台垃圾、纯粹一个链接等等，反正你自己看着都不爽的肯定就是了，来看看lee关于外链判断。</p>\n<h4 id=\"79、外链有哪些形式\"><a href=\"#79、外链有哪些形式\" class=\"headerlink\" title=\"79、外链有哪些形式?\"></a>79、外链有哪些形式?</h4><p>　　第一种，纯文本链接，这种外链对于排名影响不大，这种情况下一般是为了增加网站的品牌和名气的，一般应用在整个网站营销的这个期间，但是前期比较明显，因为网站建设初期网站权重不高，需要引蜘蛛的。<br>　　第二种，超级链接，这种链接对于排名有效果，也可以增加企业网站的曝光度引入推荐流量<br>　　第三种，锚文本链接，这种链接对于关键词排名最佳，不过现在这种链接越来越难做，很多时候都是来自友情链接和博客。</p>\n<h4 id=\"80、工作中如何去学习seo呀\"><a href=\"#80、工作中如何去学习seo呀\" class=\"headerlink\" title=\"80、工作中如何去学习seo呀?\"></a>80、工作中如何去学习seo呀?</h4><p>　　多听，多看，多问，多学，多思考，多总结等等，既然是菜鸟，你就得该有个菜鸟样，什么都要多做，可以多到一些大型站长网比如：搜外、A5、站长之家等看好的seo文章、也可以进一些QQ群与其他人交流，不要不敢说不敢问，同时可以把学到的东西写下来，这样可以加深记忆，便于思考，最后就是需要去公司实战了，理论再好一旦实践你才能真正认识SEO.</p>\n"},{"title":"网站SEO优化常见问题汇总5","date":"2015-01-20T03:15:07.000Z","_content":"#### 81、只有论坛做外链效果好吗?\n　　外链讲究广泛性和自然性，如果只是一个地方给你投票，那么投着投着带来的效果肯定是越来越小，同时论坛代替性强，要是哪一天论坛关了或帖子被删岂不是什么都没了?所以做外链的过程中外链平台一定要自然广泛，可以交换友情链接、投稿、做博客、问答平台、收藏夹、分类信息/B2B/B2C等等，要善于去挖掘可用的外链资源。\n#### 82、为什么网站有很多个快照?\n　　百度快照是对某个时间网站数据的一个缓存，不同的页面缓存的时间都是不一样的，搜索引擎具有一个缓存机制，在搜索网站不同的关键词时对应的快照时间也会是不一样的，因为搜索引擎根据不同的关键词索引建立了不同的缓存，所以有多个快照是很正常的。\n#### 83、为什么蜘蛛天天来，而不更新呢?\n　　蜘蛛天天来，你需要看蜘蛛是否只爬不抓，如果只爬不抓说明内容还是存在问题的，要加大原创力度。另外蜘蛛抓取了也不会很快就更新，这之间是有一个过程的，想缩短这个过程首先要积累网站的权重，其次定时定量的更新高质量文章获得搜索引擎的信任。最后说一点，蜘蛛天天来，那来的到底是些什么蜘蛛呢?不是所有的蜘蛛来网站都会更新的，降权也说不定，所以我们需要分析网站日志，了解搜索引擎蜘蛛。\n#### 84、如何判断购买的链接的好坏?\n　　1、百度权重是第三方站长工具模拟百度算法给出的网站评级，虽然说算法不够准确，但是还是能模拟出一些网站的评级的。但是为了防止别人的权重是刷上来的，购买时要查看该网站主要关键词的排名情况。\n　　2、网站快照更新频率，快照更新尽管不等于网站好，但网站快照更新是否及时，也是一个网站是否健康的考虑因素，当然你不要在百度发疯期间去看别人快照。\n　　3、网站的整体收录、外链量和当日收录、外链增加量，不过只看总的。\n　　4、目标网站导出链接数量，一个网站权重很高，但如果导出链接太多，那你分到的就是凤毛菱角。\n　　5、相关性：尽量选择行业对口的或者相近行业的网站交换链接，这样有助于搜索引擎判断网站在所属行业的权重。\n　　6、目标网站的友情链接是否有非法站点链接或者黑链。\n　　7、目标网站是否存在作弊行为，是否是短时间内通过作弊手段获得的高权重。\n　　................\n#### 85、友情链接必须是同行业的吗?\n　　我们说友情链接要有相关性并不是说一定得同行的，没有那么多同行和你换友情链接。这个相关包含的含义很多，比如用户需求相关。卖锅的能和卖碗的换吗?当然能!能带来流量就是好链接。\n#### 86、交换友情链接都有哪些途径?\n　　可以在QQ上多加一些相关的网站交流群，或是专门换友情链接的群。也可以到相关行业论坛、贴吧的版块，比如推一把、站长之家就有友情链接交换版。当然也有专门换友情链接的网站。不过在网站前期，也没多少人愿意和你换，与其到处找不如首先好好做好自己网站的排名。\n#### 87、关键字排名下降有哪些原因?\n　　一、网站内容作弊,网站文不对题，导致网站得分降低，排名下降。\n　　二、服务器不稳定\n　　三、最近网站是否有改版?\n　　四、搜索引擎算法,搜索引擎本身算法的更新,导致排名下降。\n　　五、网站使用作弊手法被K站。\n　　六、网站采集内容,网站存在大量采集文章或低质量文章。\n　　七、友情站被K自己站自己的站连坐导致排名下降。\n　　八、网站外链不稳定带来关键词排名也不稳定。\n　　九、网站被攻击或中毒。\n　　十、本身行业的竞争，你的关键词不稳定，这是正常的。\n#### 88、一般进入考核期多长时间才能出来啊?\n　　百度考核期平均在3个月左右，12个周, 不同的网站、不同的行业、不同的网站建设和不同的优化手法等都会影响这个周期的时长，这个周期是百度考虑网站作弊时间成本和热门关键词的排名周期确定的。在考核期内要坚持网站的内容建设和外部投票建设，尽量讨好用户和搜索引擎，不要给网站很大波动。\n#### 89、全站链接是什么?怎么做全站链接?\n　　全站链接是整个网站的每个页面都做上你站点的链接，全站链接是相对与首页链接来说的，一般大型网站的链接会区分，而一般小型的网站很少会去区分。站点上权重最高的是首页，内页分配的权重比较少，但是大型网站的内页权重也是很高的，所以一些很重要的页面在每个页面都做上链接那就可以获得不错的效果，既然全站链接是在每个页面上都加上某个链接，那么怎么加就不用多说吧。\n#### 90、大家感觉锚文本加在文章的哪个位置更好?\n　　对于收索引擎而言，SEO认为锚文本在文章开头和结尾处最好，因为搜索引擎给予文章开头和结尾的权重相对高一点，锚文本在这2处获得的权值自然高一些，但是对于用户体验而言，SEO则认为没有哪个位置最好，只需要在用户需求的时候给予用户最好的推荐即可，重点不在位置，而在锚文本和所对应内容对用户需求的满足。\n#### 91、网站的百度快照倒退了，怎么办?\n　　首先要大概分析网站快照倒退的原因：网站服务器是否稳定?近期做过网站改版?友情链接网站被K?使用作弊优化手段?网站被挂马?内容采集或重复度过高?垃圾外链?百度调整误伤?等等。针对具体原因予以改正，一般情况下进行改正的过程中减少不必要的优化手法，主要增加网站内容质量、外链质量和用户的访问量，减少网站过大的波动。要注意的是快照与网站权重、排名没有必然的关系，但是是一面镜子，如果出现异常需要予以关注。\n#### 92、为什么我们的原创信息被别人转载后，别人的信息排在前面?\n　　前面说了网站的排序综合得分，主要包括页面基础得分、站内得分、站外得分和用户得分，你自己的原创信息只占了基础得分里内容质量这小小的一块，如果转载你文章的其他得分都超过你，排名在你前面在自然不过。\n#### 93、文章质量高体现在那些方面?\n　　按百度搜索研发部的说法，从四个方面说：\n　　1. 受众\n　　受众群体的大小，即代表了用户检索需求的大小。评价受众的大小主要依据信息发布源的受众和信息内容本身受众两大方面。\n　　2. 稀缺\n　　稀缺主要是描述页面在互联网中的独特性。说到稀缺往往会想到重复，稀缺是否等同于无重复，我们应该怎样解读这一概念呢?可以看一个例子：\n　　某人发表了一篇针对某新闻事件的原创博客，随后被新浪转载到了新闻频道。从描述的内容上讲，这是一种重复。但这种重复仅仅是主体内容上的重复，一方面它的转载带来了访问速度、稳定性等方面的增益，并且之后的检索用户还有可能用“新闻事件+新浪”来检索此新闻。这可以被称之为站点增益。因此即使主题内容没有任何变化，新浪的这次转载也是有价值的，其稀缺度也是较高的。\n　　所以对于主体内容重复的页面，我们应该评价其是否存在站点增益和内容增益，只有对于大量完全无增益的重复页面，我们才应该认为其稀缺度较低。这就是为什么你的原创为什么在别人那却排名比你好的原因。\n　　3. 质量\n　　页面的质量是它对需求的满足程度的一种体现。判断页面质量的高低，应该是从最基础的需求依次递进的。\n　　首先，不能是死链、网站要有一定的稳定性、访问速度要令人满意。\n　　其次，主体内容是否完整、版式和字体是否易读、各类广告会不会太多。\n　　最后，信息是否丰富、延伸出的次级需求是否满足。\n　　4. 时效性\n　　“时效性”是页面价值的一个属性，它一般体现在两个方面：一是页面所描述的事物本身有着较强的公众话题性，容易被传播。这其实是受众的一个体现。二是页面所描述的事物仅在第一时间有较高热度，随着时间推移热度显着下降。这是一种“新闻”性。对于具有上述两种属性的页面，如果搜索引擎spider发现页面的时间正处于该事物的“爆发期”或“爆发期”之前，我们认为该页面具有时效性。\n#### 94、外链大幅度下降怎么办?\n　　链不稳定，时多时少。如果在外链建设一直保持在稳定状态，突然在某个时间段成数倍数十倍增加外链，这样搜索引擎可能判定网站有作弊嫌疑，就把网站外链收入沙盒，如果判定期过了发现外链合法，没有使用作弊手法，搜索引擎就会把外链放出来重新恢复。这段时间恢复到以前外链发布数量并保证质量，原创更新稳定。\n　　也有很多时候是因为网站已经被K了，这个时候就和前面讲的网站被K时的操作一样。\n　　不排除搜索引擎自身问题，就像这段时间，百度每天的更新幅度都很大，也会出现网站外链起伏不定的情况，这属于正常情况，这是搜索引擎在整理自身数据库导致的。\n#### 95、多个域名对网站有什么影响?\n　　同一个站点多个域名短时间内会获得不少流量，但是这种多个域名会分散权重，同时搜索引擎会认为是作弊行为而处理，一般多个域名可以301重定向到主域名。\n#### 96、seo群发软件有效果吗?应该注意什么?\n　　这个时期，群发的效果越来越差，现在很少看到大规模的群发了，如果你还在执着于群发软件，那么SEO的建议是应该注意不要在用了，当然有时候在有一定资源的情况下，针对各个平台进行少量的群发还是可以了，减少了手动发送的时间。\n#### 97、如何进行DOC、PDF等文档的搜索引擎优化呢?\n　　目前常用的文档格式有DOC、PDF等，对这些文档的搜索引擎优化方法比较简单，只要在文件标题和文档首页前面的一些文字信息中包含关键词即可，与网页优化的思路一致。这些工作只需要我们在写作文档时顺便做一下就OK了，在大家对这些问题还都不够重视的时候，只需稍加注意，就会获得较好的检索排名效果。随着同类文档的逐渐增加，也许还需要更加复杂的优化手段，但是目前这方面好像还没有更多有效的方法可以借鉴的。\n　　PDF文档在搜索引擎的权重是很高，PDF文档可以在其内容中添加链接，相比普通的HTML文件，PDF文档具有先天优势，原创PDF文件BR=3的高权重，原因主要有三点：1、一般大家会把相对重要的文件、文本做成PDF格式，这样就导致了搜索引擎对PDF文件的高度认可。2、PDF文件的打开方式是html，网络客户端读取方便。3、PDF文件的易下载，易传播，而且在传播过程中不会失真，也不易被修改。\n#### 98、网站加入百度统计有好处吗?\n　　根据官方声明，并没有什么影响，但是可以确定的是，会加快引擎对站点的索引更新。加入百度统计后搜索引擎会对网站进行更深入的抓取，同时可以在百度统计后台查看网站的IP来路，受访页面、跳出率等用户行为，可以说百度统计是间接助力SEO优化。\n#### 99、优化网站导航的目的是什么呢?\n　　1. 决定用户在网站中穿梭浏览的体验，这一点是最基本的。\n　　2、网站导航设计合理，可以将网站的内容和服务最大面积的展现在用户面前。\n　　3、合理的导航设计可以增加用户粘性，提高网站的浏览深度。\n　　4、清晰的网站导航，方便搜索引擎更好的抓取网站，从而增加网站的收录量。\n#### 100、做前端和seo有关系吗？\n   说有也有，说没有也没有，毕竟艺多不加人，多学点东西还是很有好处的，骚年！","source":"_posts/siteseo5.md","raw":"---\ntitle: 网站SEO优化常见问题汇总5\ndate: 2015-01-20 11:15:07\ntags: seo\n---\n#### 81、只有论坛做外链效果好吗?\n　　外链讲究广泛性和自然性，如果只是一个地方给你投票，那么投着投着带来的效果肯定是越来越小，同时论坛代替性强，要是哪一天论坛关了或帖子被删岂不是什么都没了?所以做外链的过程中外链平台一定要自然广泛，可以交换友情链接、投稿、做博客、问答平台、收藏夹、分类信息/B2B/B2C等等，要善于去挖掘可用的外链资源。\n#### 82、为什么网站有很多个快照?\n　　百度快照是对某个时间网站数据的一个缓存，不同的页面缓存的时间都是不一样的，搜索引擎具有一个缓存机制，在搜索网站不同的关键词时对应的快照时间也会是不一样的，因为搜索引擎根据不同的关键词索引建立了不同的缓存，所以有多个快照是很正常的。\n#### 83、为什么蜘蛛天天来，而不更新呢?\n　　蜘蛛天天来，你需要看蜘蛛是否只爬不抓，如果只爬不抓说明内容还是存在问题的，要加大原创力度。另外蜘蛛抓取了也不会很快就更新，这之间是有一个过程的，想缩短这个过程首先要积累网站的权重，其次定时定量的更新高质量文章获得搜索引擎的信任。最后说一点，蜘蛛天天来，那来的到底是些什么蜘蛛呢?不是所有的蜘蛛来网站都会更新的，降权也说不定，所以我们需要分析网站日志，了解搜索引擎蜘蛛。\n#### 84、如何判断购买的链接的好坏?\n　　1、百度权重是第三方站长工具模拟百度算法给出的网站评级，虽然说算法不够准确，但是还是能模拟出一些网站的评级的。但是为了防止别人的权重是刷上来的，购买时要查看该网站主要关键词的排名情况。\n　　2、网站快照更新频率，快照更新尽管不等于网站好，但网站快照更新是否及时，也是一个网站是否健康的考虑因素，当然你不要在百度发疯期间去看别人快照。\n　　3、网站的整体收录、外链量和当日收录、外链增加量，不过只看总的。\n　　4、目标网站导出链接数量，一个网站权重很高，但如果导出链接太多，那你分到的就是凤毛菱角。\n　　5、相关性：尽量选择行业对口的或者相近行业的网站交换链接，这样有助于搜索引擎判断网站在所属行业的权重。\n　　6、目标网站的友情链接是否有非法站点链接或者黑链。\n　　7、目标网站是否存在作弊行为，是否是短时间内通过作弊手段获得的高权重。\n　　................\n#### 85、友情链接必须是同行业的吗?\n　　我们说友情链接要有相关性并不是说一定得同行的，没有那么多同行和你换友情链接。这个相关包含的含义很多，比如用户需求相关。卖锅的能和卖碗的换吗?当然能!能带来流量就是好链接。\n#### 86、交换友情链接都有哪些途径?\n　　可以在QQ上多加一些相关的网站交流群，或是专门换友情链接的群。也可以到相关行业论坛、贴吧的版块，比如推一把、站长之家就有友情链接交换版。当然也有专门换友情链接的网站。不过在网站前期，也没多少人愿意和你换，与其到处找不如首先好好做好自己网站的排名。\n#### 87、关键字排名下降有哪些原因?\n　　一、网站内容作弊,网站文不对题，导致网站得分降低，排名下降。\n　　二、服务器不稳定\n　　三、最近网站是否有改版?\n　　四、搜索引擎算法,搜索引擎本身算法的更新,导致排名下降。\n　　五、网站使用作弊手法被K站。\n　　六、网站采集内容,网站存在大量采集文章或低质量文章。\n　　七、友情站被K自己站自己的站连坐导致排名下降。\n　　八、网站外链不稳定带来关键词排名也不稳定。\n　　九、网站被攻击或中毒。\n　　十、本身行业的竞争，你的关键词不稳定，这是正常的。\n#### 88、一般进入考核期多长时间才能出来啊?\n　　百度考核期平均在3个月左右，12个周, 不同的网站、不同的行业、不同的网站建设和不同的优化手法等都会影响这个周期的时长，这个周期是百度考虑网站作弊时间成本和热门关键词的排名周期确定的。在考核期内要坚持网站的内容建设和外部投票建设，尽量讨好用户和搜索引擎，不要给网站很大波动。\n#### 89、全站链接是什么?怎么做全站链接?\n　　全站链接是整个网站的每个页面都做上你站点的链接，全站链接是相对与首页链接来说的，一般大型网站的链接会区分，而一般小型的网站很少会去区分。站点上权重最高的是首页，内页分配的权重比较少，但是大型网站的内页权重也是很高的，所以一些很重要的页面在每个页面都做上链接那就可以获得不错的效果，既然全站链接是在每个页面上都加上某个链接，那么怎么加就不用多说吧。\n#### 90、大家感觉锚文本加在文章的哪个位置更好?\n　　对于收索引擎而言，SEO认为锚文本在文章开头和结尾处最好，因为搜索引擎给予文章开头和结尾的权重相对高一点，锚文本在这2处获得的权值自然高一些，但是对于用户体验而言，SEO则认为没有哪个位置最好，只需要在用户需求的时候给予用户最好的推荐即可，重点不在位置，而在锚文本和所对应内容对用户需求的满足。\n#### 91、网站的百度快照倒退了，怎么办?\n　　首先要大概分析网站快照倒退的原因：网站服务器是否稳定?近期做过网站改版?友情链接网站被K?使用作弊优化手段?网站被挂马?内容采集或重复度过高?垃圾外链?百度调整误伤?等等。针对具体原因予以改正，一般情况下进行改正的过程中减少不必要的优化手法，主要增加网站内容质量、外链质量和用户的访问量，减少网站过大的波动。要注意的是快照与网站权重、排名没有必然的关系，但是是一面镜子，如果出现异常需要予以关注。\n#### 92、为什么我们的原创信息被别人转载后，别人的信息排在前面?\n　　前面说了网站的排序综合得分，主要包括页面基础得分、站内得分、站外得分和用户得分，你自己的原创信息只占了基础得分里内容质量这小小的一块，如果转载你文章的其他得分都超过你，排名在你前面在自然不过。\n#### 93、文章质量高体现在那些方面?\n　　按百度搜索研发部的说法，从四个方面说：\n　　1. 受众\n　　受众群体的大小，即代表了用户检索需求的大小。评价受众的大小主要依据信息发布源的受众和信息内容本身受众两大方面。\n　　2. 稀缺\n　　稀缺主要是描述页面在互联网中的独特性。说到稀缺往往会想到重复，稀缺是否等同于无重复，我们应该怎样解读这一概念呢?可以看一个例子：\n　　某人发表了一篇针对某新闻事件的原创博客，随后被新浪转载到了新闻频道。从描述的内容上讲，这是一种重复。但这种重复仅仅是主体内容上的重复，一方面它的转载带来了访问速度、稳定性等方面的增益，并且之后的检索用户还有可能用“新闻事件+新浪”来检索此新闻。这可以被称之为站点增益。因此即使主题内容没有任何变化，新浪的这次转载也是有价值的，其稀缺度也是较高的。\n　　所以对于主体内容重复的页面，我们应该评价其是否存在站点增益和内容增益，只有对于大量完全无增益的重复页面，我们才应该认为其稀缺度较低。这就是为什么你的原创为什么在别人那却排名比你好的原因。\n　　3. 质量\n　　页面的质量是它对需求的满足程度的一种体现。判断页面质量的高低，应该是从最基础的需求依次递进的。\n　　首先，不能是死链、网站要有一定的稳定性、访问速度要令人满意。\n　　其次，主体内容是否完整、版式和字体是否易读、各类广告会不会太多。\n　　最后，信息是否丰富、延伸出的次级需求是否满足。\n　　4. 时效性\n　　“时效性”是页面价值的一个属性，它一般体现在两个方面：一是页面所描述的事物本身有着较强的公众话题性，容易被传播。这其实是受众的一个体现。二是页面所描述的事物仅在第一时间有较高热度，随着时间推移热度显着下降。这是一种“新闻”性。对于具有上述两种属性的页面，如果搜索引擎spider发现页面的时间正处于该事物的“爆发期”或“爆发期”之前，我们认为该页面具有时效性。\n#### 94、外链大幅度下降怎么办?\n　　链不稳定，时多时少。如果在外链建设一直保持在稳定状态，突然在某个时间段成数倍数十倍增加外链，这样搜索引擎可能判定网站有作弊嫌疑，就把网站外链收入沙盒，如果判定期过了发现外链合法，没有使用作弊手法，搜索引擎就会把外链放出来重新恢复。这段时间恢复到以前外链发布数量并保证质量，原创更新稳定。\n　　也有很多时候是因为网站已经被K了，这个时候就和前面讲的网站被K时的操作一样。\n　　不排除搜索引擎自身问题，就像这段时间，百度每天的更新幅度都很大，也会出现网站外链起伏不定的情况，这属于正常情况，这是搜索引擎在整理自身数据库导致的。\n#### 95、多个域名对网站有什么影响?\n　　同一个站点多个域名短时间内会获得不少流量，但是这种多个域名会分散权重，同时搜索引擎会认为是作弊行为而处理，一般多个域名可以301重定向到主域名。\n#### 96、seo群发软件有效果吗?应该注意什么?\n　　这个时期，群发的效果越来越差，现在很少看到大规模的群发了，如果你还在执着于群发软件，那么SEO的建议是应该注意不要在用了，当然有时候在有一定资源的情况下，针对各个平台进行少量的群发还是可以了，减少了手动发送的时间。\n#### 97、如何进行DOC、PDF等文档的搜索引擎优化呢?\n　　目前常用的文档格式有DOC、PDF等，对这些文档的搜索引擎优化方法比较简单，只要在文件标题和文档首页前面的一些文字信息中包含关键词即可，与网页优化的思路一致。这些工作只需要我们在写作文档时顺便做一下就OK了，在大家对这些问题还都不够重视的时候，只需稍加注意，就会获得较好的检索排名效果。随着同类文档的逐渐增加，也许还需要更加复杂的优化手段，但是目前这方面好像还没有更多有效的方法可以借鉴的。\n　　PDF文档在搜索引擎的权重是很高，PDF文档可以在其内容中添加链接，相比普通的HTML文件，PDF文档具有先天优势，原创PDF文件BR=3的高权重，原因主要有三点：1、一般大家会把相对重要的文件、文本做成PDF格式，这样就导致了搜索引擎对PDF文件的高度认可。2、PDF文件的打开方式是html，网络客户端读取方便。3、PDF文件的易下载，易传播，而且在传播过程中不会失真，也不易被修改。\n#### 98、网站加入百度统计有好处吗?\n　　根据官方声明，并没有什么影响，但是可以确定的是，会加快引擎对站点的索引更新。加入百度统计后搜索引擎会对网站进行更深入的抓取，同时可以在百度统计后台查看网站的IP来路，受访页面、跳出率等用户行为，可以说百度统计是间接助力SEO优化。\n#### 99、优化网站导航的目的是什么呢?\n　　1. 决定用户在网站中穿梭浏览的体验，这一点是最基本的。\n　　2、网站导航设计合理，可以将网站的内容和服务最大面积的展现在用户面前。\n　　3、合理的导航设计可以增加用户粘性，提高网站的浏览深度。\n　　4、清晰的网站导航，方便搜索引擎更好的抓取网站，从而增加网站的收录量。\n#### 100、做前端和seo有关系吗？\n   说有也有，说没有也没有，毕竟艺多不加人，多学点东西还是很有好处的，骚年！","slug":"siteseo5","published":1,"updated":"2017-01-16T02:22:26.983Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixzjjbmg000dmgtumj3yflg3","content":"<h4 id=\"81、只有论坛做外链效果好吗\"><a href=\"#81、只有论坛做外链效果好吗\" class=\"headerlink\" title=\"81、只有论坛做外链效果好吗?\"></a>81、只有论坛做外链效果好吗?</h4><p>　　外链讲究广泛性和自然性，如果只是一个地方给你投票，那么投着投着带来的效果肯定是越来越小，同时论坛代替性强，要是哪一天论坛关了或帖子被删岂不是什么都没了?所以做外链的过程中外链平台一定要自然广泛，可以交换友情链接、投稿、做博客、问答平台、收藏夹、分类信息/B2B/B2C等等，要善于去挖掘可用的外链资源。</p>\n<h4 id=\"82、为什么网站有很多个快照\"><a href=\"#82、为什么网站有很多个快照\" class=\"headerlink\" title=\"82、为什么网站有很多个快照?\"></a>82、为什么网站有很多个快照?</h4><p>　　百度快照是对某个时间网站数据的一个缓存，不同的页面缓存的时间都是不一样的，搜索引擎具有一个缓存机制，在搜索网站不同的关键词时对应的快照时间也会是不一样的，因为搜索引擎根据不同的关键词索引建立了不同的缓存，所以有多个快照是很正常的。</p>\n<h4 id=\"83、为什么蜘蛛天天来，而不更新呢\"><a href=\"#83、为什么蜘蛛天天来，而不更新呢\" class=\"headerlink\" title=\"83、为什么蜘蛛天天来，而不更新呢?\"></a>83、为什么蜘蛛天天来，而不更新呢?</h4><p>　　蜘蛛天天来，你需要看蜘蛛是否只爬不抓，如果只爬不抓说明内容还是存在问题的，要加大原创力度。另外蜘蛛抓取了也不会很快就更新，这之间是有一个过程的，想缩短这个过程首先要积累网站的权重，其次定时定量的更新高质量文章获得搜索引擎的信任。最后说一点，蜘蛛天天来，那来的到底是些什么蜘蛛呢?不是所有的蜘蛛来网站都会更新的，降权也说不定，所以我们需要分析网站日志，了解搜索引擎蜘蛛。</p>\n<h4 id=\"84、如何判断购买的链接的好坏\"><a href=\"#84、如何判断购买的链接的好坏\" class=\"headerlink\" title=\"84、如何判断购买的链接的好坏?\"></a>84、如何判断购买的链接的好坏?</h4><p>　　1、百度权重是第三方站长工具模拟百度算法给出的网站评级，虽然说算法不够准确，但是还是能模拟出一些网站的评级的。但是为了防止别人的权重是刷上来的，购买时要查看该网站主要关键词的排名情况。<br>　　2、网站快照更新频率，快照更新尽管不等于网站好，但网站快照更新是否及时，也是一个网站是否健康的考虑因素，当然你不要在百度发疯期间去看别人快照。<br>　　3、网站的整体收录、外链量和当日收录、外链增加量，不过只看总的。<br>　　4、目标网站导出链接数量，一个网站权重很高，但如果导出链接太多，那你分到的就是凤毛菱角。<br>　　5、相关性：尽量选择行业对口的或者相近行业的网站交换链接，这样有助于搜索引擎判断网站在所属行业的权重。<br>　　6、目标网站的友情链接是否有非法站点链接或者黑链。<br>　　7、目标网站是否存在作弊行为，是否是短时间内通过作弊手段获得的高权重。<br>　　…………….</p>\n<h4 id=\"85、友情链接必须是同行业的吗\"><a href=\"#85、友情链接必须是同行业的吗\" class=\"headerlink\" title=\"85、友情链接必须是同行业的吗?\"></a>85、友情链接必须是同行业的吗?</h4><p>　　我们说友情链接要有相关性并不是说一定得同行的，没有那么多同行和你换友情链接。这个相关包含的含义很多，比如用户需求相关。卖锅的能和卖碗的换吗?当然能!能带来流量就是好链接。</p>\n<h4 id=\"86、交换友情链接都有哪些途径\"><a href=\"#86、交换友情链接都有哪些途径\" class=\"headerlink\" title=\"86、交换友情链接都有哪些途径?\"></a>86、交换友情链接都有哪些途径?</h4><p>　　可以在QQ上多加一些相关的网站交流群，或是专门换友情链接的群。也可以到相关行业论坛、贴吧的版块，比如推一把、站长之家就有友情链接交换版。当然也有专门换友情链接的网站。不过在网站前期，也没多少人愿意和你换，与其到处找不如首先好好做好自己网站的排名。</p>\n<h4 id=\"87、关键字排名下降有哪些原因\"><a href=\"#87、关键字排名下降有哪些原因\" class=\"headerlink\" title=\"87、关键字排名下降有哪些原因?\"></a>87、关键字排名下降有哪些原因?</h4><p>　　一、网站内容作弊,网站文不对题，导致网站得分降低，排名下降。<br>　　二、服务器不稳定<br>　　三、最近网站是否有改版?<br>　　四、搜索引擎算法,搜索引擎本身算法的更新,导致排名下降。<br>　　五、网站使用作弊手法被K站。<br>　　六、网站采集内容,网站存在大量采集文章或低质量文章。<br>　　七、友情站被K自己站自己的站连坐导致排名下降。<br>　　八、网站外链不稳定带来关键词排名也不稳定。<br>　　九、网站被攻击或中毒。<br>　　十、本身行业的竞争，你的关键词不稳定，这是正常的。</p>\n<h4 id=\"88、一般进入考核期多长时间才能出来啊\"><a href=\"#88、一般进入考核期多长时间才能出来啊\" class=\"headerlink\" title=\"88、一般进入考核期多长时间才能出来啊?\"></a>88、一般进入考核期多长时间才能出来啊?</h4><p>　　百度考核期平均在3个月左右，12个周, 不同的网站、不同的行业、不同的网站建设和不同的优化手法等都会影响这个周期的时长，这个周期是百度考虑网站作弊时间成本和热门关键词的排名周期确定的。在考核期内要坚持网站的内容建设和外部投票建设，尽量讨好用户和搜索引擎，不要给网站很大波动。</p>\n<h4 id=\"89、全站链接是什么-怎么做全站链接\"><a href=\"#89、全站链接是什么-怎么做全站链接\" class=\"headerlink\" title=\"89、全站链接是什么?怎么做全站链接?\"></a>89、全站链接是什么?怎么做全站链接?</h4><p>　　全站链接是整个网站的每个页面都做上你站点的链接，全站链接是相对与首页链接来说的，一般大型网站的链接会区分，而一般小型的网站很少会去区分。站点上权重最高的是首页，内页分配的权重比较少，但是大型网站的内页权重也是很高的，所以一些很重要的页面在每个页面都做上链接那就可以获得不错的效果，既然全站链接是在每个页面上都加上某个链接，那么怎么加就不用多说吧。</p>\n<h4 id=\"90、大家感觉锚文本加在文章的哪个位置更好\"><a href=\"#90、大家感觉锚文本加在文章的哪个位置更好\" class=\"headerlink\" title=\"90、大家感觉锚文本加在文章的哪个位置更好?\"></a>90、大家感觉锚文本加在文章的哪个位置更好?</h4><p>　　对于收索引擎而言，SEO认为锚文本在文章开头和结尾处最好，因为搜索引擎给予文章开头和结尾的权重相对高一点，锚文本在这2处获得的权值自然高一些，但是对于用户体验而言，SEO则认为没有哪个位置最好，只需要在用户需求的时候给予用户最好的推荐即可，重点不在位置，而在锚文本和所对应内容对用户需求的满足。</p>\n<h4 id=\"91、网站的百度快照倒退了，怎么办\"><a href=\"#91、网站的百度快照倒退了，怎么办\" class=\"headerlink\" title=\"91、网站的百度快照倒退了，怎么办?\"></a>91、网站的百度快照倒退了，怎么办?</h4><p>　　首先要大概分析网站快照倒退的原因：网站服务器是否稳定?近期做过网站改版?友情链接网站被K?使用作弊优化手段?网站被挂马?内容采集或重复度过高?垃圾外链?百度调整误伤?等等。针对具体原因予以改正，一般情况下进行改正的过程中减少不必要的优化手法，主要增加网站内容质量、外链质量和用户的访问量，减少网站过大的波动。要注意的是快照与网站权重、排名没有必然的关系，但是是一面镜子，如果出现异常需要予以关注。</p>\n<h4 id=\"92、为什么我们的原创信息被别人转载后，别人的信息排在前面\"><a href=\"#92、为什么我们的原创信息被别人转载后，别人的信息排在前面\" class=\"headerlink\" title=\"92、为什么我们的原创信息被别人转载后，别人的信息排在前面?\"></a>92、为什么我们的原创信息被别人转载后，别人的信息排在前面?</h4><p>　　前面说了网站的排序综合得分，主要包括页面基础得分、站内得分、站外得分和用户得分，你自己的原创信息只占了基础得分里内容质量这小小的一块，如果转载你文章的其他得分都超过你，排名在你前面在自然不过。</p>\n<h4 id=\"93、文章质量高体现在那些方面\"><a href=\"#93、文章质量高体现在那些方面\" class=\"headerlink\" title=\"93、文章质量高体现在那些方面?\"></a>93、文章质量高体现在那些方面?</h4><p>　　按百度搜索研发部的说法，从四个方面说：<br>　　1. 受众<br>　　受众群体的大小，即代表了用户检索需求的大小。评价受众的大小主要依据信息发布源的受众和信息内容本身受众两大方面。<br>　　2. 稀缺<br>　　稀缺主要是描述页面在互联网中的独特性。说到稀缺往往会想到重复，稀缺是否等同于无重复，我们应该怎样解读这一概念呢?可以看一个例子：<br>　　某人发表了一篇针对某新闻事件的原创博客，随后被新浪转载到了新闻频道。从描述的内容上讲，这是一种重复。但这种重复仅仅是主体内容上的重复，一方面它的转载带来了访问速度、稳定性等方面的增益，并且之后的检索用户还有可能用“新闻事件+新浪”来检索此新闻。这可以被称之为站点增益。因此即使主题内容没有任何变化，新浪的这次转载也是有价值的，其稀缺度也是较高的。<br>　　所以对于主体内容重复的页面，我们应该评价其是否存在站点增益和内容增益，只有对于大量完全无增益的重复页面，我们才应该认为其稀缺度较低。这就是为什么你的原创为什么在别人那却排名比你好的原因。<br>　　3. 质量<br>　　页面的质量是它对需求的满足程度的一种体现。判断页面质量的高低，应该是从最基础的需求依次递进的。<br>　　首先，不能是死链、网站要有一定的稳定性、访问速度要令人满意。<br>　　其次，主体内容是否完整、版式和字体是否易读、各类广告会不会太多。<br>　　最后，信息是否丰富、延伸出的次级需求是否满足。<br>　　4. 时效性<br>　　“时效性”是页面价值的一个属性，它一般体现在两个方面：一是页面所描述的事物本身有着较强的公众话题性，容易被传播。这其实是受众的一个体现。二是页面所描述的事物仅在第一时间有较高热度，随着时间推移热度显着下降。这是一种“新闻”性。对于具有上述两种属性的页面，如果搜索引擎spider发现页面的时间正处于该事物的“爆发期”或“爆发期”之前，我们认为该页面具有时效性。</p>\n<h4 id=\"94、外链大幅度下降怎么办\"><a href=\"#94、外链大幅度下降怎么办\" class=\"headerlink\" title=\"94、外链大幅度下降怎么办?\"></a>94、外链大幅度下降怎么办?</h4><p>　　链不稳定，时多时少。如果在外链建设一直保持在稳定状态，突然在某个时间段成数倍数十倍增加外链，这样搜索引擎可能判定网站有作弊嫌疑，就把网站外链收入沙盒，如果判定期过了发现外链合法，没有使用作弊手法，搜索引擎就会把外链放出来重新恢复。这段时间恢复到以前外链发布数量并保证质量，原创更新稳定。<br>　　也有很多时候是因为网站已经被K了，这个时候就和前面讲的网站被K时的操作一样。<br>　　不排除搜索引擎自身问题，就像这段时间，百度每天的更新幅度都很大，也会出现网站外链起伏不定的情况，这属于正常情况，这是搜索引擎在整理自身数据库导致的。</p>\n<h4 id=\"95、多个域名对网站有什么影响\"><a href=\"#95、多个域名对网站有什么影响\" class=\"headerlink\" title=\"95、多个域名对网站有什么影响?\"></a>95、多个域名对网站有什么影响?</h4><p>　　同一个站点多个域名短时间内会获得不少流量，但是这种多个域名会分散权重，同时搜索引擎会认为是作弊行为而处理，一般多个域名可以301重定向到主域名。</p>\n<h4 id=\"96、seo群发软件有效果吗-应该注意什么\"><a href=\"#96、seo群发软件有效果吗-应该注意什么\" class=\"headerlink\" title=\"96、seo群发软件有效果吗?应该注意什么?\"></a>96、seo群发软件有效果吗?应该注意什么?</h4><p>　　这个时期，群发的效果越来越差，现在很少看到大规模的群发了，如果你还在执着于群发软件，那么SEO的建议是应该注意不要在用了，当然有时候在有一定资源的情况下，针对各个平台进行少量的群发还是可以了，减少了手动发送的时间。</p>\n<h4 id=\"97、如何进行DOC、PDF等文档的搜索引擎优化呢\"><a href=\"#97、如何进行DOC、PDF等文档的搜索引擎优化呢\" class=\"headerlink\" title=\"97、如何进行DOC、PDF等文档的搜索引擎优化呢?\"></a>97、如何进行DOC、PDF等文档的搜索引擎优化呢?</h4><p>　　目前常用的文档格式有DOC、PDF等，对这些文档的搜索引擎优化方法比较简单，只要在文件标题和文档首页前面的一些文字信息中包含关键词即可，与网页优化的思路一致。这些工作只需要我们在写作文档时顺便做一下就OK了，在大家对这些问题还都不够重视的时候，只需稍加注意，就会获得较好的检索排名效果。随着同类文档的逐渐增加，也许还需要更加复杂的优化手段，但是目前这方面好像还没有更多有效的方法可以借鉴的。<br>　　PDF文档在搜索引擎的权重是很高，PDF文档可以在其内容中添加链接，相比普通的HTML文件，PDF文档具有先天优势，原创PDF文件BR=3的高权重，原因主要有三点：1、一般大家会把相对重要的文件、文本做成PDF格式，这样就导致了搜索引擎对PDF文件的高度认可。2、PDF文件的打开方式是html，网络客户端读取方便。3、PDF文件的易下载，易传播，而且在传播过程中不会失真，也不易被修改。</p>\n<h4 id=\"98、网站加入百度统计有好处吗\"><a href=\"#98、网站加入百度统计有好处吗\" class=\"headerlink\" title=\"98、网站加入百度统计有好处吗?\"></a>98、网站加入百度统计有好处吗?</h4><p>　　根据官方声明，并没有什么影响，但是可以确定的是，会加快引擎对站点的索引更新。加入百度统计后搜索引擎会对网站进行更深入的抓取，同时可以在百度统计后台查看网站的IP来路，受访页面、跳出率等用户行为，可以说百度统计是间接助力SEO优化。</p>\n<h4 id=\"99、优化网站导航的目的是什么呢\"><a href=\"#99、优化网站导航的目的是什么呢\" class=\"headerlink\" title=\"99、优化网站导航的目的是什么呢?\"></a>99、优化网站导航的目的是什么呢?</h4><p>　　1. 决定用户在网站中穿梭浏览的体验，这一点是最基本的。<br>　　2、网站导航设计合理，可以将网站的内容和服务最大面积的展现在用户面前。<br>　　3、合理的导航设计可以增加用户粘性，提高网站的浏览深度。<br>　　4、清晰的网站导航，方便搜索引擎更好的抓取网站，从而增加网站的收录量。</p>\n<h4 id=\"100、做前端和seo有关系吗？\"><a href=\"#100、做前端和seo有关系吗？\" class=\"headerlink\" title=\"100、做前端和seo有关系吗？\"></a>100、做前端和seo有关系吗？</h4><p>   说有也有，说没有也没有，毕竟艺多不加人，多学点东西还是很有好处的，骚年！</p>\n","excerpt":"","more":"<h4 id=\"81、只有论坛做外链效果好吗\"><a href=\"#81、只有论坛做外链效果好吗\" class=\"headerlink\" title=\"81、只有论坛做外链效果好吗?\"></a>81、只有论坛做外链效果好吗?</h4><p>　　外链讲究广泛性和自然性，如果只是一个地方给你投票，那么投着投着带来的效果肯定是越来越小，同时论坛代替性强，要是哪一天论坛关了或帖子被删岂不是什么都没了?所以做外链的过程中外链平台一定要自然广泛，可以交换友情链接、投稿、做博客、问答平台、收藏夹、分类信息/B2B/B2C等等，要善于去挖掘可用的外链资源。</p>\n<h4 id=\"82、为什么网站有很多个快照\"><a href=\"#82、为什么网站有很多个快照\" class=\"headerlink\" title=\"82、为什么网站有很多个快照?\"></a>82、为什么网站有很多个快照?</h4><p>　　百度快照是对某个时间网站数据的一个缓存，不同的页面缓存的时间都是不一样的，搜索引擎具有一个缓存机制，在搜索网站不同的关键词时对应的快照时间也会是不一样的，因为搜索引擎根据不同的关键词索引建立了不同的缓存，所以有多个快照是很正常的。</p>\n<h4 id=\"83、为什么蜘蛛天天来，而不更新呢\"><a href=\"#83、为什么蜘蛛天天来，而不更新呢\" class=\"headerlink\" title=\"83、为什么蜘蛛天天来，而不更新呢?\"></a>83、为什么蜘蛛天天来，而不更新呢?</h4><p>　　蜘蛛天天来，你需要看蜘蛛是否只爬不抓，如果只爬不抓说明内容还是存在问题的，要加大原创力度。另外蜘蛛抓取了也不会很快就更新，这之间是有一个过程的，想缩短这个过程首先要积累网站的权重，其次定时定量的更新高质量文章获得搜索引擎的信任。最后说一点，蜘蛛天天来，那来的到底是些什么蜘蛛呢?不是所有的蜘蛛来网站都会更新的，降权也说不定，所以我们需要分析网站日志，了解搜索引擎蜘蛛。</p>\n<h4 id=\"84、如何判断购买的链接的好坏\"><a href=\"#84、如何判断购买的链接的好坏\" class=\"headerlink\" title=\"84、如何判断购买的链接的好坏?\"></a>84、如何判断购买的链接的好坏?</h4><p>　　1、百度权重是第三方站长工具模拟百度算法给出的网站评级，虽然说算法不够准确，但是还是能模拟出一些网站的评级的。但是为了防止别人的权重是刷上来的，购买时要查看该网站主要关键词的排名情况。<br>　　2、网站快照更新频率，快照更新尽管不等于网站好，但网站快照更新是否及时，也是一个网站是否健康的考虑因素，当然你不要在百度发疯期间去看别人快照。<br>　　3、网站的整体收录、外链量和当日收录、外链增加量，不过只看总的。<br>　　4、目标网站导出链接数量，一个网站权重很高，但如果导出链接太多，那你分到的就是凤毛菱角。<br>　　5、相关性：尽量选择行业对口的或者相近行业的网站交换链接，这样有助于搜索引擎判断网站在所属行业的权重。<br>　　6、目标网站的友情链接是否有非法站点链接或者黑链。<br>　　7、目标网站是否存在作弊行为，是否是短时间内通过作弊手段获得的高权重。<br>　　…………….</p>\n<h4 id=\"85、友情链接必须是同行业的吗\"><a href=\"#85、友情链接必须是同行业的吗\" class=\"headerlink\" title=\"85、友情链接必须是同行业的吗?\"></a>85、友情链接必须是同行业的吗?</h4><p>　　我们说友情链接要有相关性并不是说一定得同行的，没有那么多同行和你换友情链接。这个相关包含的含义很多，比如用户需求相关。卖锅的能和卖碗的换吗?当然能!能带来流量就是好链接。</p>\n<h4 id=\"86、交换友情链接都有哪些途径\"><a href=\"#86、交换友情链接都有哪些途径\" class=\"headerlink\" title=\"86、交换友情链接都有哪些途径?\"></a>86、交换友情链接都有哪些途径?</h4><p>　　可以在QQ上多加一些相关的网站交流群，或是专门换友情链接的群。也可以到相关行业论坛、贴吧的版块，比如推一把、站长之家就有友情链接交换版。当然也有专门换友情链接的网站。不过在网站前期，也没多少人愿意和你换，与其到处找不如首先好好做好自己网站的排名。</p>\n<h4 id=\"87、关键字排名下降有哪些原因\"><a href=\"#87、关键字排名下降有哪些原因\" class=\"headerlink\" title=\"87、关键字排名下降有哪些原因?\"></a>87、关键字排名下降有哪些原因?</h4><p>　　一、网站内容作弊,网站文不对题，导致网站得分降低，排名下降。<br>　　二、服务器不稳定<br>　　三、最近网站是否有改版?<br>　　四、搜索引擎算法,搜索引擎本身算法的更新,导致排名下降。<br>　　五、网站使用作弊手法被K站。<br>　　六、网站采集内容,网站存在大量采集文章或低质量文章。<br>　　七、友情站被K自己站自己的站连坐导致排名下降。<br>　　八、网站外链不稳定带来关键词排名也不稳定。<br>　　九、网站被攻击或中毒。<br>　　十、本身行业的竞争，你的关键词不稳定，这是正常的。</p>\n<h4 id=\"88、一般进入考核期多长时间才能出来啊\"><a href=\"#88、一般进入考核期多长时间才能出来啊\" class=\"headerlink\" title=\"88、一般进入考核期多长时间才能出来啊?\"></a>88、一般进入考核期多长时间才能出来啊?</h4><p>　　百度考核期平均在3个月左右，12个周, 不同的网站、不同的行业、不同的网站建设和不同的优化手法等都会影响这个周期的时长，这个周期是百度考虑网站作弊时间成本和热门关键词的排名周期确定的。在考核期内要坚持网站的内容建设和外部投票建设，尽量讨好用户和搜索引擎，不要给网站很大波动。</p>\n<h4 id=\"89、全站链接是什么-怎么做全站链接\"><a href=\"#89、全站链接是什么-怎么做全站链接\" class=\"headerlink\" title=\"89、全站链接是什么?怎么做全站链接?\"></a>89、全站链接是什么?怎么做全站链接?</h4><p>　　全站链接是整个网站的每个页面都做上你站点的链接，全站链接是相对与首页链接来说的，一般大型网站的链接会区分，而一般小型的网站很少会去区分。站点上权重最高的是首页，内页分配的权重比较少，但是大型网站的内页权重也是很高的，所以一些很重要的页面在每个页面都做上链接那就可以获得不错的效果，既然全站链接是在每个页面上都加上某个链接，那么怎么加就不用多说吧。</p>\n<h4 id=\"90、大家感觉锚文本加在文章的哪个位置更好\"><a href=\"#90、大家感觉锚文本加在文章的哪个位置更好\" class=\"headerlink\" title=\"90、大家感觉锚文本加在文章的哪个位置更好?\"></a>90、大家感觉锚文本加在文章的哪个位置更好?</h4><p>　　对于收索引擎而言，SEO认为锚文本在文章开头和结尾处最好，因为搜索引擎给予文章开头和结尾的权重相对高一点，锚文本在这2处获得的权值自然高一些，但是对于用户体验而言，SEO则认为没有哪个位置最好，只需要在用户需求的时候给予用户最好的推荐即可，重点不在位置，而在锚文本和所对应内容对用户需求的满足。</p>\n<h4 id=\"91、网站的百度快照倒退了，怎么办\"><a href=\"#91、网站的百度快照倒退了，怎么办\" class=\"headerlink\" title=\"91、网站的百度快照倒退了，怎么办?\"></a>91、网站的百度快照倒退了，怎么办?</h4><p>　　首先要大概分析网站快照倒退的原因：网站服务器是否稳定?近期做过网站改版?友情链接网站被K?使用作弊优化手段?网站被挂马?内容采集或重复度过高?垃圾外链?百度调整误伤?等等。针对具体原因予以改正，一般情况下进行改正的过程中减少不必要的优化手法，主要增加网站内容质量、外链质量和用户的访问量，减少网站过大的波动。要注意的是快照与网站权重、排名没有必然的关系，但是是一面镜子，如果出现异常需要予以关注。</p>\n<h4 id=\"92、为什么我们的原创信息被别人转载后，别人的信息排在前面\"><a href=\"#92、为什么我们的原创信息被别人转载后，别人的信息排在前面\" class=\"headerlink\" title=\"92、为什么我们的原创信息被别人转载后，别人的信息排在前面?\"></a>92、为什么我们的原创信息被别人转载后，别人的信息排在前面?</h4><p>　　前面说了网站的排序综合得分，主要包括页面基础得分、站内得分、站外得分和用户得分，你自己的原创信息只占了基础得分里内容质量这小小的一块，如果转载你文章的其他得分都超过你，排名在你前面在自然不过。</p>\n<h4 id=\"93、文章质量高体现在那些方面\"><a href=\"#93、文章质量高体现在那些方面\" class=\"headerlink\" title=\"93、文章质量高体现在那些方面?\"></a>93、文章质量高体现在那些方面?</h4><p>　　按百度搜索研发部的说法，从四个方面说：<br>　　1. 受众<br>　　受众群体的大小，即代表了用户检索需求的大小。评价受众的大小主要依据信息发布源的受众和信息内容本身受众两大方面。<br>　　2. 稀缺<br>　　稀缺主要是描述页面在互联网中的独特性。说到稀缺往往会想到重复，稀缺是否等同于无重复，我们应该怎样解读这一概念呢?可以看一个例子：<br>　　某人发表了一篇针对某新闻事件的原创博客，随后被新浪转载到了新闻频道。从描述的内容上讲，这是一种重复。但这种重复仅仅是主体内容上的重复，一方面它的转载带来了访问速度、稳定性等方面的增益，并且之后的检索用户还有可能用“新闻事件+新浪”来检索此新闻。这可以被称之为站点增益。因此即使主题内容没有任何变化，新浪的这次转载也是有价值的，其稀缺度也是较高的。<br>　　所以对于主体内容重复的页面，我们应该评价其是否存在站点增益和内容增益，只有对于大量完全无增益的重复页面，我们才应该认为其稀缺度较低。这就是为什么你的原创为什么在别人那却排名比你好的原因。<br>　　3. 质量<br>　　页面的质量是它对需求的满足程度的一种体现。判断页面质量的高低，应该是从最基础的需求依次递进的。<br>　　首先，不能是死链、网站要有一定的稳定性、访问速度要令人满意。<br>　　其次，主体内容是否完整、版式和字体是否易读、各类广告会不会太多。<br>　　最后，信息是否丰富、延伸出的次级需求是否满足。<br>　　4. 时效性<br>　　“时效性”是页面价值的一个属性，它一般体现在两个方面：一是页面所描述的事物本身有着较强的公众话题性，容易被传播。这其实是受众的一个体现。二是页面所描述的事物仅在第一时间有较高热度，随着时间推移热度显着下降。这是一种“新闻”性。对于具有上述两种属性的页面，如果搜索引擎spider发现页面的时间正处于该事物的“爆发期”或“爆发期”之前，我们认为该页面具有时效性。</p>\n<h4 id=\"94、外链大幅度下降怎么办\"><a href=\"#94、外链大幅度下降怎么办\" class=\"headerlink\" title=\"94、外链大幅度下降怎么办?\"></a>94、外链大幅度下降怎么办?</h4><p>　　链不稳定，时多时少。如果在外链建设一直保持在稳定状态，突然在某个时间段成数倍数十倍增加外链，这样搜索引擎可能判定网站有作弊嫌疑，就把网站外链收入沙盒，如果判定期过了发现外链合法，没有使用作弊手法，搜索引擎就会把外链放出来重新恢复。这段时间恢复到以前外链发布数量并保证质量，原创更新稳定。<br>　　也有很多时候是因为网站已经被K了，这个时候就和前面讲的网站被K时的操作一样。<br>　　不排除搜索引擎自身问题，就像这段时间，百度每天的更新幅度都很大，也会出现网站外链起伏不定的情况，这属于正常情况，这是搜索引擎在整理自身数据库导致的。</p>\n<h4 id=\"95、多个域名对网站有什么影响\"><a href=\"#95、多个域名对网站有什么影响\" class=\"headerlink\" title=\"95、多个域名对网站有什么影响?\"></a>95、多个域名对网站有什么影响?</h4><p>　　同一个站点多个域名短时间内会获得不少流量，但是这种多个域名会分散权重，同时搜索引擎会认为是作弊行为而处理，一般多个域名可以301重定向到主域名。</p>\n<h4 id=\"96、seo群发软件有效果吗-应该注意什么\"><a href=\"#96、seo群发软件有效果吗-应该注意什么\" class=\"headerlink\" title=\"96、seo群发软件有效果吗?应该注意什么?\"></a>96、seo群发软件有效果吗?应该注意什么?</h4><p>　　这个时期，群发的效果越来越差，现在很少看到大规模的群发了，如果你还在执着于群发软件，那么SEO的建议是应该注意不要在用了，当然有时候在有一定资源的情况下，针对各个平台进行少量的群发还是可以了，减少了手动发送的时间。</p>\n<h4 id=\"97、如何进行DOC、PDF等文档的搜索引擎优化呢\"><a href=\"#97、如何进行DOC、PDF等文档的搜索引擎优化呢\" class=\"headerlink\" title=\"97、如何进行DOC、PDF等文档的搜索引擎优化呢?\"></a>97、如何进行DOC、PDF等文档的搜索引擎优化呢?</h4><p>　　目前常用的文档格式有DOC、PDF等，对这些文档的搜索引擎优化方法比较简单，只要在文件标题和文档首页前面的一些文字信息中包含关键词即可，与网页优化的思路一致。这些工作只需要我们在写作文档时顺便做一下就OK了，在大家对这些问题还都不够重视的时候，只需稍加注意，就会获得较好的检索排名效果。随着同类文档的逐渐增加，也许还需要更加复杂的优化手段，但是目前这方面好像还没有更多有效的方法可以借鉴的。<br>　　PDF文档在搜索引擎的权重是很高，PDF文档可以在其内容中添加链接，相比普通的HTML文件，PDF文档具有先天优势，原创PDF文件BR=3的高权重，原因主要有三点：1、一般大家会把相对重要的文件、文本做成PDF格式，这样就导致了搜索引擎对PDF文件的高度认可。2、PDF文件的打开方式是html，网络客户端读取方便。3、PDF文件的易下载，易传播，而且在传播过程中不会失真，也不易被修改。</p>\n<h4 id=\"98、网站加入百度统计有好处吗\"><a href=\"#98、网站加入百度统计有好处吗\" class=\"headerlink\" title=\"98、网站加入百度统计有好处吗?\"></a>98、网站加入百度统计有好处吗?</h4><p>　　根据官方声明，并没有什么影响，但是可以确定的是，会加快引擎对站点的索引更新。加入百度统计后搜索引擎会对网站进行更深入的抓取，同时可以在百度统计后台查看网站的IP来路，受访页面、跳出率等用户行为，可以说百度统计是间接助力SEO优化。</p>\n<h4 id=\"99、优化网站导航的目的是什么呢\"><a href=\"#99、优化网站导航的目的是什么呢\" class=\"headerlink\" title=\"99、优化网站导航的目的是什么呢?\"></a>99、优化网站导航的目的是什么呢?</h4><p>　　1. 决定用户在网站中穿梭浏览的体验，这一点是最基本的。<br>　　2、网站导航设计合理，可以将网站的内容和服务最大面积的展现在用户面前。<br>　　3、合理的导航设计可以增加用户粘性，提高网站的浏览深度。<br>　　4、清晰的网站导航，方便搜索引擎更好的抓取网站，从而增加网站的收录量。</p>\n<h4 id=\"100、做前端和seo有关系吗？\"><a href=\"#100、做前端和seo有关系吗？\" class=\"headerlink\" title=\"100、做前端和seo有关系吗？\"></a>100、做前端和seo有关系吗？</h4><p>   说有也有，说没有也没有，毕竟艺多不加人，多学点东西还是很有好处的，骚年！</p>\n"},{"title":"前端中交互设计应注意的细节","date":"2015-12-16T03:05:37.000Z","_content":"当交互设计师完成一份自以为详尽的交互输出物，前端的开发结果总是不那么另人满意。交互会抱怨：为什么会做成这样呢，很多常识性的东西也会做错。显然因为领域不同，对“常识”的理解不尽相同，我们不能把希望寄托在前端工程师的可用性觉悟上。所以交互设计师必须站在对方的角度，在提交输出物前补充交互细节，以免日后不必要的迭代。\n\n　　1.列表项目为空时的显示效果。比如“购物车”里没有东西时，该如何显示。否则开发会让屏幕空白。\n\n　　2.当页面或应用会向后台下载数据较慢时，载入过程的提示。如果我们不说，技术不会考虑载入时的信息反馈，会让页面呈现假死的状态。\n\n　　3.当按钮、图标、链接等不可用时，怎样呈现给用户(a.消失 b.disable+文案改变c.disable+tip d.非模态或嵌入式提示 e.点击后出现模态对话框)。如果我们不说，技术会采用最简单且一般来说体验最差的方式—模态对话框，甚至什么提示都没有。\n\n　　4.应用或者一些偏操作的网络产品，对话框内的按钮，如“确定”“取消”。需要有一个默认选中，支持键盘enter操作。\n\n　　5.每个图标都要加上tip，尤其是用户可能不明白的拖动操作。\n\n　　6.在文档中规定系统出错的提示该如何呈现，提示的文案中不能带有技术性描述(如错误类型：XXX)。如果我们不规定，技术会自己添加一些出错的模态浮层，使用技术性的语言。\n\n　　7.文本长度超过标准被截断时，该如何显示。\n\n　　8.鼠标的响应范围，如列表项目，radioBtn ，checkbox等。一般来说，响应范围大点好。如果我们不说，技术只会使用默认设置，如radioBtn的响应范围就只是前面那个点。\n\n　　9.修改文本框内容，在获取焦点时，是全选还是将插入点放在文本末尾。\n\n　　如果用户很可能会重新输入整个值，则应在获取输入焦点时选择全部文本。如果用户更有可能进行编辑，则应将插入点放在文本末尾。\n\n　　10.下拉框，列表框的默认定位，比如生日。如果我们不说，技术会默认在“1900”年。\n\n　　11.如果是客户端，或是流式网页布局，要提供多种分辨率下的展示。\n\n　　12.在移动客户端，多点触摸，手势的操作和动画过程，显得尤其重要。\n\n　　13.用户操作成功或失败的反馈，超时的反馈，系统崩溃的反馈等等。\n\n　　14.移动客客户端横竖屏的不同显示方式，网络状况差时的交互反馈。\n","source":"_posts/webjiaohuxijie.md","raw":"---\ntitle: 前端中交互设计应注意的细节\ndate: 2015-12-16 11:05:37\ntags: web 交互\n---\n当交互设计师完成一份自以为详尽的交互输出物，前端的开发结果总是不那么另人满意。交互会抱怨：为什么会做成这样呢，很多常识性的东西也会做错。显然因为领域不同，对“常识”的理解不尽相同，我们不能把希望寄托在前端工程师的可用性觉悟上。所以交互设计师必须站在对方的角度，在提交输出物前补充交互细节，以免日后不必要的迭代。\n\n　　1.列表项目为空时的显示效果。比如“购物车”里没有东西时，该如何显示。否则开发会让屏幕空白。\n\n　　2.当页面或应用会向后台下载数据较慢时，载入过程的提示。如果我们不说，技术不会考虑载入时的信息反馈，会让页面呈现假死的状态。\n\n　　3.当按钮、图标、链接等不可用时，怎样呈现给用户(a.消失 b.disable+文案改变c.disable+tip d.非模态或嵌入式提示 e.点击后出现模态对话框)。如果我们不说，技术会采用最简单且一般来说体验最差的方式—模态对话框，甚至什么提示都没有。\n\n　　4.应用或者一些偏操作的网络产品，对话框内的按钮，如“确定”“取消”。需要有一个默认选中，支持键盘enter操作。\n\n　　5.每个图标都要加上tip，尤其是用户可能不明白的拖动操作。\n\n　　6.在文档中规定系统出错的提示该如何呈现，提示的文案中不能带有技术性描述(如错误类型：XXX)。如果我们不规定，技术会自己添加一些出错的模态浮层，使用技术性的语言。\n\n　　7.文本长度超过标准被截断时，该如何显示。\n\n　　8.鼠标的响应范围，如列表项目，radioBtn ，checkbox等。一般来说，响应范围大点好。如果我们不说，技术只会使用默认设置，如radioBtn的响应范围就只是前面那个点。\n\n　　9.修改文本框内容，在获取焦点时，是全选还是将插入点放在文本末尾。\n\n　　如果用户很可能会重新输入整个值，则应在获取输入焦点时选择全部文本。如果用户更有可能进行编辑，则应将插入点放在文本末尾。\n\n　　10.下拉框，列表框的默认定位，比如生日。如果我们不说，技术会默认在“1900”年。\n\n　　11.如果是客户端，或是流式网页布局，要提供多种分辨率下的展示。\n\n　　12.在移动客户端，多点触摸，手势的操作和动画过程，显得尤其重要。\n\n　　13.用户操作成功或失败的反馈，超时的反馈，系统崩溃的反馈等等。\n\n　　14.移动客客户端横竖屏的不同显示方式，网络状况差时的交互反馈。\n","slug":"webjiaohuxijie","published":1,"updated":"2017-01-16T03:07:19.771Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixzjjbnh000rmgtuoxf3zzdw","content":"<p>当交互设计师完成一份自以为详尽的交互输出物，前端的开发结果总是不那么另人满意。交互会抱怨：为什么会做成这样呢，很多常识性的东西也会做错。显然因为领域不同，对“常识”的理解不尽相同，我们不能把希望寄托在前端工程师的可用性觉悟上。所以交互设计师必须站在对方的角度，在提交输出物前补充交互细节，以免日后不必要的迭代。</p>\n<p>　　1.列表项目为空时的显示效果。比如“购物车”里没有东西时，该如何显示。否则开发会让屏幕空白。</p>\n<p>　　2.当页面或应用会向后台下载数据较慢时，载入过程的提示。如果我们不说，技术不会考虑载入时的信息反馈，会让页面呈现假死的状态。</p>\n<p>　　3.当按钮、图标、链接等不可用时，怎样呈现给用户(a.消失 b.disable+文案改变c.disable+tip d.非模态或嵌入式提示 e.点击后出现模态对话框)。如果我们不说，技术会采用最简单且一般来说体验最差的方式—模态对话框，甚至什么提示都没有。</p>\n<p>　　4.应用或者一些偏操作的网络产品，对话框内的按钮，如“确定”“取消”。需要有一个默认选中，支持键盘enter操作。</p>\n<p>　　5.每个图标都要加上tip，尤其是用户可能不明白的拖动操作。</p>\n<p>　　6.在文档中规定系统出错的提示该如何呈现，提示的文案中不能带有技术性描述(如错误类型：XXX)。如果我们不规定，技术会自己添加一些出错的模态浮层，使用技术性的语言。</p>\n<p>　　7.文本长度超过标准被截断时，该如何显示。</p>\n<p>　　8.鼠标的响应范围，如列表项目，radioBtn ，checkbox等。一般来说，响应范围大点好。如果我们不说，技术只会使用默认设置，如radioBtn的响应范围就只是前面那个点。</p>\n<p>　　9.修改文本框内容，在获取焦点时，是全选还是将插入点放在文本末尾。</p>\n<p>　　如果用户很可能会重新输入整个值，则应在获取输入焦点时选择全部文本。如果用户更有可能进行编辑，则应将插入点放在文本末尾。</p>\n<p>　　10.下拉框，列表框的默认定位，比如生日。如果我们不说，技术会默认在“1900”年。</p>\n<p>　　11.如果是客户端，或是流式网页布局，要提供多种分辨率下的展示。</p>\n<p>　　12.在移动客户端，多点触摸，手势的操作和动画过程，显得尤其重要。</p>\n<p>　　13.用户操作成功或失败的反馈，超时的反馈，系统崩溃的反馈等等。</p>\n<p>　　14.移动客客户端横竖屏的不同显示方式，网络状况差时的交互反馈。</p>\n","excerpt":"","more":"<p>当交互设计师完成一份自以为详尽的交互输出物，前端的开发结果总是不那么另人满意。交互会抱怨：为什么会做成这样呢，很多常识性的东西也会做错。显然因为领域不同，对“常识”的理解不尽相同，我们不能把希望寄托在前端工程师的可用性觉悟上。所以交互设计师必须站在对方的角度，在提交输出物前补充交互细节，以免日后不必要的迭代。</p>\n<p>　　1.列表项目为空时的显示效果。比如“购物车”里没有东西时，该如何显示。否则开发会让屏幕空白。</p>\n<p>　　2.当页面或应用会向后台下载数据较慢时，载入过程的提示。如果我们不说，技术不会考虑载入时的信息反馈，会让页面呈现假死的状态。</p>\n<p>　　3.当按钮、图标、链接等不可用时，怎样呈现给用户(a.消失 b.disable+文案改变c.disable+tip d.非模态或嵌入式提示 e.点击后出现模态对话框)。如果我们不说，技术会采用最简单且一般来说体验最差的方式—模态对话框，甚至什么提示都没有。</p>\n<p>　　4.应用或者一些偏操作的网络产品，对话框内的按钮，如“确定”“取消”。需要有一个默认选中，支持键盘enter操作。</p>\n<p>　　5.每个图标都要加上tip，尤其是用户可能不明白的拖动操作。</p>\n<p>　　6.在文档中规定系统出错的提示该如何呈现，提示的文案中不能带有技术性描述(如错误类型：XXX)。如果我们不规定，技术会自己添加一些出错的模态浮层，使用技术性的语言。</p>\n<p>　　7.文本长度超过标准被截断时，该如何显示。</p>\n<p>　　8.鼠标的响应范围，如列表项目，radioBtn ，checkbox等。一般来说，响应范围大点好。如果我们不说，技术只会使用默认设置，如radioBtn的响应范围就只是前面那个点。</p>\n<p>　　9.修改文本框内容，在获取焦点时，是全选还是将插入点放在文本末尾。</p>\n<p>　　如果用户很可能会重新输入整个值，则应在获取输入焦点时选择全部文本。如果用户更有可能进行编辑，则应将插入点放在文本末尾。</p>\n<p>　　10.下拉框，列表框的默认定位，比如生日。如果我们不说，技术会默认在“1900”年。</p>\n<p>　　11.如果是客户端，或是流式网页布局，要提供多种分辨率下的展示。</p>\n<p>　　12.在移动客户端，多点触摸，手势的操作和动画过程，显得尤其重要。</p>\n<p>　　13.用户操作成功或失败的反馈，超时的反馈，系统崩溃的反馈等等。</p>\n<p>　　14.移动客客户端横竖屏的不同显示方式，网络状况差时的交互反馈。</p>\n"},{"title":"chrome 控制台调试angularjs代码逻辑","date":"2016-01-25T06:02:46.000Z","_content":"##### chrome浏览器开发者工具中sources中的VM+数字是怎么一回事\nChrome控制台中的VM，一般是自己在控制台写的JS代码片段（或者网页Ajax获取的代码片段）运行后的提示。\n这是为了表示代码来源，与JS文件中的代码进行区分。\nVM是 Virtual Machine的缩写，其实代指Chrome的V8引擎。\n后面加数字，是编号，不同的代码片段，Chrome会自动按顺序分配一个id编号。\n\n#### 善用控制台搜索功能\n\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/console.png-public)\n</div>\n调试时，想要找源文件中的某个函数或者变量，都可以用在源文件中按ctrl+f搜索。\n想在控制台中查看自己定义的变量时，也可以用search功能。debugger://VM3189就是指的上面说的VM+数字;\n\n#### angular中怎么在控制台调试controller中的数据以及修改后台接口返回来的数据。\n1.controller中加上var vm= this;（指明控制台的vm指的是页面中的this,此处的vm可以换成其他变量，此处的vm和上面说的VM没有半毛线关系，只是controller里习惯了这么写而已。） 在对应的调试的位置打上断点debugger;\n2.然后在chrorme 的控制台中输入window.aa=vm.xxx;假设vm.xxx为ajax请求回来的数据。\n3.此时在控制台中输入aa按回车即可看到ajax请求回来的数据，此时用aa变量就可以查看和更改ajax请求回来的数据了。\n4.利用更改aa的值很容易就能调试页面了，想让此时的页面渲染什么样的数据都可以，这样的好处是页面能渲染aa的值，当页面刷新时，他还是渲染ajax请求回来的数据。实现了更改后端返回来的数据的目的了，极大地方便了自己调试。想让页面渲染啥值就渲染啥值。\n5.利用的原理：对象是引用数据类型的，存储的时候是以地址存储的，不是以值存储。例：window.aa=vm.xxx，本来页面渲染的是vm.xxx这个对象的数据，此时你让window.aa等于vm.xxx这个对象，你更改了aa的值就相当于更改了vm.xxx的值，就这么简单的原理。\n\n#### 断点调试问题\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/debug.png)\n</div>\n注意调试时，可以打多个断点方便调试，在源码中打一个断点即可，当控制台停到debugger处，可以在控制台的源文件中行号前根据逻辑打断点，该一步步走时就一步步地调， 可以查看函数的执行过程，也可以略过。调试异步时，可以在成功的回调函数处打断点，直接就能查看请求回来的数据了。不要一步步地走，得点好多好多次。注意代码的执行顺序。配合着在控制台想看某些变量的值，看看是否与逻辑相符即可。\n\n#### 通过ng-click传参来实现同一个controller中获取不同的数据列表，进而页面显示不同的内容\nng-click的时候可以进行传参，如：ng-click=\"controller.aaa=1;controller.getList()\" 此时执行点击操作时控制器中能收到aaa=1这个参数并且会执行getList这个函数。可以根据传过去aaa值的不同来执行不同的接口获取列表，写一个getList方法，在getList方法里根据传过来的值不同做判断，不同的值走不同接口，此时达到了都执行getList这个函数，但是会请求不同的端口。\n\n#### ng-model=\"controller.param.time\" 注意绑定的是date对象类型才会显示时间\nvar vm.param.time=new Date();此时页面会显示时间，因为time是日期对象类型的。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/date.png-public)\n</div>\n项目中，利用日期查询订单时，一般把date类型格式化成字符串形式比如：“2016-01-01”，如果此时vm.param.time直接等于这个字符串“2016-01-01”，此时页面将不能正常显示时间。\n解决办法：var obj={time:''};obj.time= moment(vm.param.time).format('YYYY-MM-DD');请求查询订单时把格式化后的日期obj当请求参数传进去即可，注：要一直保证vm.param.time是一个date类型。否则页面就不能正常显示。\n\n#### 调试总比苦思冥想要好\n当页面展现的内容不是自己想要的时候，在控制台network里调试，看看该操作走的是哪个接口，是不是自己想让它走的那个接口。还可以看看该操作都走了哪几个接口，与逻辑是否相符。\n\n自己想要的结果没出来用debugger调试，控制台看看值传过去了没有，如果没有就传，把自己的想法通过debugger的形式来调试然后把想法通过代码加进去。遇到问题静心想逻辑，逻辑，逻辑。有问题了一个一个解决，不要同时想好几个问题，把一个问题解决了再说另一个问题，一块想好几个问题容易乱套。问题都是一个一个解决的。想一个问题时要想为什么没有达到自己的预期，是哪里的问题，如何通过debugger来解决。\n\n#### 总结\n遇到与自己想的结果不一样时，莫捉急，要多打debugger调试，不要空想，调试真的能解决很多问题。","source":"_posts/chrome-debugger.md","raw":"---\ntitle: chrome 控制台调试angularjs代码逻辑\ndate: 2016-01-25 14:02:46\ntags: debugger\n---\n##### chrome浏览器开发者工具中sources中的VM+数字是怎么一回事\nChrome控制台中的VM，一般是自己在控制台写的JS代码片段（或者网页Ajax获取的代码片段）运行后的提示。\n这是为了表示代码来源，与JS文件中的代码进行区分。\nVM是 Virtual Machine的缩写，其实代指Chrome的V8引擎。\n后面加数字，是编号，不同的代码片段，Chrome会自动按顺序分配一个id编号。\n\n#### 善用控制台搜索功能\n\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/console.png-public)\n</div>\n调试时，想要找源文件中的某个函数或者变量，都可以用在源文件中按ctrl+f搜索。\n想在控制台中查看自己定义的变量时，也可以用search功能。debugger://VM3189就是指的上面说的VM+数字;\n\n#### angular中怎么在控制台调试controller中的数据以及修改后台接口返回来的数据。\n1.controller中加上var vm= this;（指明控制台的vm指的是页面中的this,此处的vm可以换成其他变量，此处的vm和上面说的VM没有半毛线关系，只是controller里习惯了这么写而已。） 在对应的调试的位置打上断点debugger;\n2.然后在chrorme 的控制台中输入window.aa=vm.xxx;假设vm.xxx为ajax请求回来的数据。\n3.此时在控制台中输入aa按回车即可看到ajax请求回来的数据，此时用aa变量就可以查看和更改ajax请求回来的数据了。\n4.利用更改aa的值很容易就能调试页面了，想让此时的页面渲染什么样的数据都可以，这样的好处是页面能渲染aa的值，当页面刷新时，他还是渲染ajax请求回来的数据。实现了更改后端返回来的数据的目的了，极大地方便了自己调试。想让页面渲染啥值就渲染啥值。\n5.利用的原理：对象是引用数据类型的，存储的时候是以地址存储的，不是以值存储。例：window.aa=vm.xxx，本来页面渲染的是vm.xxx这个对象的数据，此时你让window.aa等于vm.xxx这个对象，你更改了aa的值就相当于更改了vm.xxx的值，就这么简单的原理。\n\n#### 断点调试问题\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/debug.png)\n</div>\n注意调试时，可以打多个断点方便调试，在源码中打一个断点即可，当控制台停到debugger处，可以在控制台的源文件中行号前根据逻辑打断点，该一步步走时就一步步地调， 可以查看函数的执行过程，也可以略过。调试异步时，可以在成功的回调函数处打断点，直接就能查看请求回来的数据了。不要一步步地走，得点好多好多次。注意代码的执行顺序。配合着在控制台想看某些变量的值，看看是否与逻辑相符即可。\n\n#### 通过ng-click传参来实现同一个controller中获取不同的数据列表，进而页面显示不同的内容\nng-click的时候可以进行传参，如：ng-click=\"controller.aaa=1;controller.getList()\" 此时执行点击操作时控制器中能收到aaa=1这个参数并且会执行getList这个函数。可以根据传过去aaa值的不同来执行不同的接口获取列表，写一个getList方法，在getList方法里根据传过来的值不同做判断，不同的值走不同接口，此时达到了都执行getList这个函数，但是会请求不同的端口。\n\n#### ng-model=\"controller.param.time\" 注意绑定的是date对象类型才会显示时间\nvar vm.param.time=new Date();此时页面会显示时间，因为time是日期对象类型的。\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/date.png-public)\n</div>\n项目中，利用日期查询订单时，一般把date类型格式化成字符串形式比如：“2016-01-01”，如果此时vm.param.time直接等于这个字符串“2016-01-01”，此时页面将不能正常显示时间。\n解决办法：var obj={time:''};obj.time= moment(vm.param.time).format('YYYY-MM-DD');请求查询订单时把格式化后的日期obj当请求参数传进去即可，注：要一直保证vm.param.time是一个date类型。否则页面就不能正常显示。\n\n#### 调试总比苦思冥想要好\n当页面展现的内容不是自己想要的时候，在控制台network里调试，看看该操作走的是哪个接口，是不是自己想让它走的那个接口。还可以看看该操作都走了哪几个接口，与逻辑是否相符。\n\n自己想要的结果没出来用debugger调试，控制台看看值传过去了没有，如果没有就传，把自己的想法通过debugger的形式来调试然后把想法通过代码加进去。遇到问题静心想逻辑，逻辑，逻辑。有问题了一个一个解决，不要同时想好几个问题，把一个问题解决了再说另一个问题，一块想好几个问题容易乱套。问题都是一个一个解决的。想一个问题时要想为什么没有达到自己的预期，是哪里的问题，如何通过debugger来解决。\n\n#### 总结\n遇到与自己想的结果不一样时，莫捉急，要多打debugger调试，不要空想，调试真的能解决很多问题。","slug":"chrome-debugger","published":1,"updated":"2017-01-25T08:39:27.991Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciyr1umvi00005gtu91sderd8","content":"<h5 id=\"chrome浏览器开发者工具中sources中的VM-数字是怎么一回事\"><a href=\"#chrome浏览器开发者工具中sources中的VM-数字是怎么一回事\" class=\"headerlink\" title=\"chrome浏览器开发者工具中sources中的VM+数字是怎么一回事\"></a>chrome浏览器开发者工具中sources中的VM+数字是怎么一回事</h5><p>Chrome控制台中的VM，一般是自己在控制台写的JS代码片段（或者网页Ajax获取的代码片段）运行后的提示。<br>这是为了表示代码来源，与JS文件中的代码进行区分。<br>VM是 Virtual Machine的缩写，其实代指Chrome的V8引擎。<br>后面加数字，是编号，不同的代码片段，Chrome会自动按顺序分配一个id编号。</p>\n<h4 id=\"善用控制台搜索功能\"><a href=\"#善用控制台搜索功能\" class=\"headerlink\" title=\"善用控制台搜索功能\"></a>善用控制台搜索功能</h4><p><div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/console.png-public\" alt=\"\"><br></div><br>调试时，想要找源文件中的某个函数或者变量，都可以用在源文件中按ctrl+f搜索。<br>想在控制台中查看自己定义的变量时，也可以用search功能。debugger://VM3189就是指的上面说的VM+数字;</p>\n<h4 id=\"angular中怎么在控制台调试controller中的数据以及修改后台接口返回来的数据。\"><a href=\"#angular中怎么在控制台调试controller中的数据以及修改后台接口返回来的数据。\" class=\"headerlink\" title=\"angular中怎么在控制台调试controller中的数据以及修改后台接口返回来的数据。\"></a>angular中怎么在控制台调试controller中的数据以及修改后台接口返回来的数据。</h4><p>1.controller中加上var vm= this;（指明控制台的vm指的是页面中的this,此处的vm可以换成其他变量，此处的vm和上面说的VM没有半毛线关系，只是controller里习惯了这么写而已。） 在对应的调试的位置打上断点debugger;<br>2.然后在chrorme 的控制台中输入window.aa=vm.xxx;假设vm.xxx为ajax请求回来的数据。<br>3.此时在控制台中输入aa按回车即可看到ajax请求回来的数据，此时用aa变量就可以查看和更改ajax请求回来的数据了。<br>4.利用更改aa的值很容易就能调试页面了，想让此时的页面渲染什么样的数据都可以，这样的好处是页面能渲染aa的值，当页面刷新时，他还是渲染ajax请求回来的数据。实现了更改后端返回来的数据的目的了，极大地方便了自己调试。想让页面渲染啥值就渲染啥值。<br>5.利用的原理：对象是引用数据类型的，存储的时候是以地址存储的，不是以值存储。例：window.aa=vm.xxx，本来页面渲染的是vm.xxx这个对象的数据，此时你让window.aa等于vm.xxx这个对象，你更改了aa的值就相当于更改了vm.xxx的值，就这么简单的原理。</p>\n<h4 id=\"断点调试问题\"><a href=\"#断点调试问题\" class=\"headerlink\" title=\"断点调试问题\"></a>断点调试问题</h4><p><div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/debug.png\" alt=\"\"><br></div><br>注意调试时，可以打多个断点方便调试，在源码中打一个断点即可，当控制台停到debugger处，可以在控制台的源文件中行号前根据逻辑打断点，该一步步走时就一步步地调， 可以查看函数的执行过程，也可以略过。调试异步时，可以在成功的回调函数处打断点，直接就能查看请求回来的数据了。不要一步步地走，得点好多好多次。注意代码的执行顺序。配合着在控制台想看某些变量的值，看看是否与逻辑相符即可。</p>\n<h4 id=\"通过ng-click传参来实现同一个controller中获取不同的数据列表，进而页面显示不同的内容\"><a href=\"#通过ng-click传参来实现同一个controller中获取不同的数据列表，进而页面显示不同的内容\" class=\"headerlink\" title=\"通过ng-click传参来实现同一个controller中获取不同的数据列表，进而页面显示不同的内容\"></a>通过ng-click传参来实现同一个controller中获取不同的数据列表，进而页面显示不同的内容</h4><p>ng-click的时候可以进行传参，如：ng-click=”controller.aaa=1;controller.getList()” 此时执行点击操作时控制器中能收到aaa=1这个参数并且会执行getList这个函数。可以根据传过去aaa值的不同来执行不同的接口获取列表，写一个getList方法，在getList方法里根据传过来的值不同做判断，不同的值走不同接口，此时达到了都执行getList这个函数，但是会请求不同的端口。</p>\n<h4 id=\"ng-model-”controller-param-time”-注意绑定的是date对象类型才会显示时间\"><a href=\"#ng-model-”controller-param-time”-注意绑定的是date对象类型才会显示时间\" class=\"headerlink\" title=\"ng-model=”controller.param.time” 注意绑定的是date对象类型才会显示时间\"></a>ng-model=”controller.param.time” 注意绑定的是date对象类型才会显示时间</h4><p>var vm.param.time=new Date();此时页面会显示时间，因为time是日期对象类型的。</p>\n<p><div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/date.png-public\" alt=\"\"><br></div><br>项目中，利用日期查询订单时，一般把date类型格式化成字符串形式比如：“2016-01-01”，如果此时vm.param.time直接等于这个字符串“2016-01-01”，此时页面将不能正常显示时间。<br>解决办法：var obj={time:’’};obj.time= moment(vm.param.time).format(‘YYYY-MM-DD’);请求查询订单时把格式化后的日期obj当请求参数传进去即可，注：要一直保证vm.param.time是一个date类型。否则页面就不能正常显示。</p>\n<h4 id=\"调试总比苦思冥想要好\"><a href=\"#调试总比苦思冥想要好\" class=\"headerlink\" title=\"调试总比苦思冥想要好\"></a>调试总比苦思冥想要好</h4><p>当页面展现的内容不是自己想要的时候，在控制台network里调试，看看该操作走的是哪个接口，是不是自己想让它走的那个接口。还可以看看该操作都走了哪几个接口，与逻辑是否相符。</p>\n<p>自己想要的结果没出来用debugger调试，控制台看看值传过去了没有，如果没有就传，把自己的想法通过debugger的形式来调试然后把想法通过代码加进去。遇到问题静心想逻辑，逻辑，逻辑。有问题了一个一个解决，不要同时想好几个问题，把一个问题解决了再说另一个问题，一块想好几个问题容易乱套。问题都是一个一个解决的。想一个问题时要想为什么没有达到自己的预期，是哪里的问题，如何通过debugger来解决。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>遇到与自己想的结果不一样时，莫捉急，要多打debugger调试，不要空想，调试真的能解决很多问题。</p>\n","excerpt":"","more":"<h5 id=\"chrome浏览器开发者工具中sources中的VM-数字是怎么一回事\"><a href=\"#chrome浏览器开发者工具中sources中的VM-数字是怎么一回事\" class=\"headerlink\" title=\"chrome浏览器开发者工具中sources中的VM+数字是怎么一回事\"></a>chrome浏览器开发者工具中sources中的VM+数字是怎么一回事</h5><p>Chrome控制台中的VM，一般是自己在控制台写的JS代码片段（或者网页Ajax获取的代码片段）运行后的提示。<br>这是为了表示代码来源，与JS文件中的代码进行区分。<br>VM是 Virtual Machine的缩写，其实代指Chrome的V8引擎。<br>后面加数字，是编号，不同的代码片段，Chrome会自动按顺序分配一个id编号。</p>\n<h4 id=\"善用控制台搜索功能\"><a href=\"#善用控制台搜索功能\" class=\"headerlink\" title=\"善用控制台搜索功能\"></a>善用控制台搜索功能</h4><p><div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/console.png-public\" alt=\"\"><br></div><br>调试时，想要找源文件中的某个函数或者变量，都可以用在源文件中按ctrl+f搜索。<br>想在控制台中查看自己定义的变量时，也可以用search功能。debugger://VM3189就是指的上面说的VM+数字;</p>\n<h4 id=\"angular中怎么在控制台调试controller中的数据以及修改后台接口返回来的数据。\"><a href=\"#angular中怎么在控制台调试controller中的数据以及修改后台接口返回来的数据。\" class=\"headerlink\" title=\"angular中怎么在控制台调试controller中的数据以及修改后台接口返回来的数据。\"></a>angular中怎么在控制台调试controller中的数据以及修改后台接口返回来的数据。</h4><p>1.controller中加上var vm= this;（指明控制台的vm指的是页面中的this,此处的vm可以换成其他变量，此处的vm和上面说的VM没有半毛线关系，只是controller里习惯了这么写而已。） 在对应的调试的位置打上断点debugger;<br>2.然后在chrorme 的控制台中输入window.aa=vm.xxx;假设vm.xxx为ajax请求回来的数据。<br>3.此时在控制台中输入aa按回车即可看到ajax请求回来的数据，此时用aa变量就可以查看和更改ajax请求回来的数据了。<br>4.利用更改aa的值很容易就能调试页面了，想让此时的页面渲染什么样的数据都可以，这样的好处是页面能渲染aa的值，当页面刷新时，他还是渲染ajax请求回来的数据。实现了更改后端返回来的数据的目的了，极大地方便了自己调试。想让页面渲染啥值就渲染啥值。<br>5.利用的原理：对象是引用数据类型的，存储的时候是以地址存储的，不是以值存储。例：window.aa=vm.xxx，本来页面渲染的是vm.xxx这个对象的数据，此时你让window.aa等于vm.xxx这个对象，你更改了aa的值就相当于更改了vm.xxx的值，就这么简单的原理。</p>\n<h4 id=\"断点调试问题\"><a href=\"#断点调试问题\" class=\"headerlink\" title=\"断点调试问题\"></a>断点调试问题</h4><p><div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/debug.png\" alt=\"\"><br></div><br>注意调试时，可以打多个断点方便调试，在源码中打一个断点即可，当控制台停到debugger处，可以在控制台的源文件中行号前根据逻辑打断点，该一步步走时就一步步地调， 可以查看函数的执行过程，也可以略过。调试异步时，可以在成功的回调函数处打断点，直接就能查看请求回来的数据了。不要一步步地走，得点好多好多次。注意代码的执行顺序。配合着在控制台想看某些变量的值，看看是否与逻辑相符即可。</p>\n<h4 id=\"通过ng-click传参来实现同一个controller中获取不同的数据列表，进而页面显示不同的内容\"><a href=\"#通过ng-click传参来实现同一个controller中获取不同的数据列表，进而页面显示不同的内容\" class=\"headerlink\" title=\"通过ng-click传参来实现同一个controller中获取不同的数据列表，进而页面显示不同的内容\"></a>通过ng-click传参来实现同一个controller中获取不同的数据列表，进而页面显示不同的内容</h4><p>ng-click的时候可以进行传参，如：ng-click=”controller.aaa=1;controller.getList()” 此时执行点击操作时控制器中能收到aaa=1这个参数并且会执行getList这个函数。可以根据传过去aaa值的不同来执行不同的接口获取列表，写一个getList方法，在getList方法里根据传过来的值不同做判断，不同的值走不同接口，此时达到了都执行getList这个函数，但是会请求不同的端口。</p>\n<h4 id=\"ng-model-”controller-param-time”-注意绑定的是date对象类型才会显示时间\"><a href=\"#ng-model-”controller-param-time”-注意绑定的是date对象类型才会显示时间\" class=\"headerlink\" title=\"ng-model=”controller.param.time” 注意绑定的是date对象类型才会显示时间\"></a>ng-model=”controller.param.time” 注意绑定的是date对象类型才会显示时间</h4><p>var vm.param.time=new Date();此时页面会显示时间，因为time是日期对象类型的。</p>\n<p><div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/date.png-public\" alt=\"\"><br></div><br>项目中，利用日期查询订单时，一般把date类型格式化成字符串形式比如：“2016-01-01”，如果此时vm.param.time直接等于这个字符串“2016-01-01”，此时页面将不能正常显示时间。<br>解决办法：var obj={time:’’};obj.time= moment(vm.param.time).format(‘YYYY-MM-DD’);请求查询订单时把格式化后的日期obj当请求参数传进去即可，注：要一直保证vm.param.time是一个date类型。否则页面就不能正常显示。</p>\n<h4 id=\"调试总比苦思冥想要好\"><a href=\"#调试总比苦思冥想要好\" class=\"headerlink\" title=\"调试总比苦思冥想要好\"></a>调试总比苦思冥想要好</h4><p>当页面展现的内容不是自己想要的时候，在控制台network里调试，看看该操作走的是哪个接口，是不是自己想让它走的那个接口。还可以看看该操作都走了哪几个接口，与逻辑是否相符。</p>\n<p>自己想要的结果没出来用debugger调试，控制台看看值传过去了没有，如果没有就传，把自己的想法通过debugger的形式来调试然后把想法通过代码加进去。遇到问题静心想逻辑，逻辑，逻辑。有问题了一个一个解决，不要同时想好几个问题，把一个问题解决了再说另一个问题，一块想好几个问题容易乱套。问题都是一个一个解决的。想一个问题时要想为什么没有达到自己的预期，是哪里的问题，如何通过debugger来解决。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>遇到与自己想的结果不一样时，莫捉急，要多打debugger调试，不要空想，调试真的能解决很多问题。</p>\n"},{"title":"21天减肥攻略","date":"2016-01-24T09:15:33.000Z","_content":"\n## Q1：减肥有哪些严重错误观点？\n#### 错误观点1：体重减少就是“瘦了”。\n健身者都喜欢运动完称一称，惊喜发现自己“变轻了”，结果第二天怎么又“反弹了”？有个非常普遍的错误观点就是“减肥=减体重”。NO！减肥是“减少脂肪”，运动完后减掉的很多都是水分。所以说，不要称体重！要测量体脂率！(可以买个体脂仪来测)\n\n#### 错误观点2：不吃早饭。\n不吃早饭会得胆结石胆囊炎，不信你可以试试昂！\n\n#### 错误观点3：只喝果汁或者吃水果减肥。\n噗！水果含糖量你知道多高吗？别傻了。\n\n#### 错误观点4：不吃肉减肥。\n“减肥不吃肉”是个严重的错误观点！鸡肉每100的脂肪含量才只有1克多。所以，你不吃肉也减不下来多少肥，除非你平时一直在吃肥肉。一定需要吃肉，鸡肉牛肉鱼肉都行，只要不吃肥肉，不吃炸鸡什么的绝对没问题。\n\n#### 错误观点5：局部减脂。\n减脂只能减全身！从来没有什么局部减脂一说，如果有人告诉你某种产品可以局部减脂，他一定是在耍流氓。局部确实可以瘦，怎么瘦？无氧运动练肌肉！肌肉变得紧致了，肌间脂肪肌内脂肪减少了，不仅线条优美，血液循环和体制都会变好！\n\n## Q2：什么减肥方法最好？\n有氧运动+无氧运动+低卡饮食=最好的减肥方法。没有之一!减不下来的原因只有两个：不是猪一样的吃就是猪一样的练。你看看你是哪个？\n\n## Q3：减肥不能吃什么？\n1.低糖！什么糖都不许碰（这是最重要的一条！）\n2.主食减少，吃精白米饭。\n3.严禁零食、油炸、火锅、肥肉等。\n4.自己做菜的时候少盐少油。\n5.早饭吃好吃饱（非常重要！），中饭吃饱，晚饭吃少。\n6.21天后给自己1天Cheat Day可以放开吃，然后进入第二个周期。（cheat day  放松日）\n7.3个周期之后恢复正常饮食，但依然不可以高糖高油，少吃零食。\n\n## Q4：减肥吃什么？\n1.主食：玉米、燕麦、豆类、山药等。\n2.肉肉：鸡胸肉、瘦牛肉、鱼肉等。\n3.蔬菜：芹菜、黄瓜、大白菜、豆芽、竹笋、西红柿等。\n4.水果：苹果，香蕉，葡萄柚，菠萝。不用吃太多。\n5.可以平时少吃米饭，换成玉米，自己搞点即时燕麦片什么的。\n\n## Q5：减肥怎么练？\n1.21天为一个周期，每周7天练3天，每次1小时。\n2.每次的时间安排：热身10分钟+无氧10分钟+有氧40分钟\n3.热身：慢跑／热身操／跳绳 （三选一）\n4.无氧：静蹲，平板支撑，臀桥，器械训练，力量训练，短跑\n5.有氧: 椭圆机／跑步／游泳／球类／健身操\n\n## Q6：运动有哪些注意事项？\n1.热身+无氧+有氧三者缺一不可。\n2.不要运动时间过长，心急吃不了热豆腐。\n3.不要睡觉前练，不要饭后练。\n4.一定要注意保护膝盖，防止损伤！长期不运动的一定从静蹲开始练习，把自己的膝关节的保护肌肉练好才能保护住你的膝关节，否则会出现膑骨软化，以后想练啥都白搭。健身房能跑椭圆机就跑椭圆机，不要跑跑步机，最伤膝盖的一是登山机二是跑步机，要跑步到室外地上跑。刚开始幅度不要太大.\n\n## Q7：懒怎么办？\n1.按周进行，每次1小时。开始不要太热情，你会半途而废（你懂的）。 中途断了一天千万不要有负罪感，不要变更你的时间计划想着“我今天不做明天做”之类的（你明天又会推后天的），解决方案就是“忽略”，然后还是按照你的时间表。\n2.给自己点激励，用纸做个表格贴墙上.\n\n## Q8：减肥怎么称体重？\n1.忘记“体重”，关注“体脂率”。所谓“体脂率”就是“体内脂肪的比率”.\n2.用体脂仪代替体重秤.\n3.每天称一下，看看是否有效，体脂率下降对自己的激励效果特别明显，看着可开心啦！\n\n## Q9：一些网传减肥法靠谱吗？\n不！靠！谱！\n1.主食减肥法：国外非常流行的一种减肥法，不吃碳水化合物，主食改为鸡肉或者精瘦牛肉。你的皮肤和头发都会迅速变差，很多人反映记忆力变差，反应迟缓，容易疲劳。反弹迅速。\n2.水果减肥法：全日只吃水果代替正常饭菜。这比主食减肥法更不靠谱.\n3.各种减肥饼干和减肥代餐：额...求求你好好吃饭行么？谁信谁sb\n\n## Q10：可以快速一个月内减肥吗？\n可以个毛线，no zuo no die，找到方法，贵在坚持，你就会有一个好身材！！！我要好好学习，好好实践，此文献给我自己！！！哈哈，有本事你来打我啊\n\n\n","source":"_posts/jianfei21.md","raw":"---\ntitle: 21天减肥攻略\ndate: 2016-01-24 17:15:33\ntags: fit\n---\n\n## Q1：减肥有哪些严重错误观点？\n#### 错误观点1：体重减少就是“瘦了”。\n健身者都喜欢运动完称一称，惊喜发现自己“变轻了”，结果第二天怎么又“反弹了”？有个非常普遍的错误观点就是“减肥=减体重”。NO！减肥是“减少脂肪”，运动完后减掉的很多都是水分。所以说，不要称体重！要测量体脂率！(可以买个体脂仪来测)\n\n#### 错误观点2：不吃早饭。\n不吃早饭会得胆结石胆囊炎，不信你可以试试昂！\n\n#### 错误观点3：只喝果汁或者吃水果减肥。\n噗！水果含糖量你知道多高吗？别傻了。\n\n#### 错误观点4：不吃肉减肥。\n“减肥不吃肉”是个严重的错误观点！鸡肉每100的脂肪含量才只有1克多。所以，你不吃肉也减不下来多少肥，除非你平时一直在吃肥肉。一定需要吃肉，鸡肉牛肉鱼肉都行，只要不吃肥肉，不吃炸鸡什么的绝对没问题。\n\n#### 错误观点5：局部减脂。\n减脂只能减全身！从来没有什么局部减脂一说，如果有人告诉你某种产品可以局部减脂，他一定是在耍流氓。局部确实可以瘦，怎么瘦？无氧运动练肌肉！肌肉变得紧致了，肌间脂肪肌内脂肪减少了，不仅线条优美，血液循环和体制都会变好！\n\n## Q2：什么减肥方法最好？\n有氧运动+无氧运动+低卡饮食=最好的减肥方法。没有之一!减不下来的原因只有两个：不是猪一样的吃就是猪一样的练。你看看你是哪个？\n\n## Q3：减肥不能吃什么？\n1.低糖！什么糖都不许碰（这是最重要的一条！）\n2.主食减少，吃精白米饭。\n3.严禁零食、油炸、火锅、肥肉等。\n4.自己做菜的时候少盐少油。\n5.早饭吃好吃饱（非常重要！），中饭吃饱，晚饭吃少。\n6.21天后给自己1天Cheat Day可以放开吃，然后进入第二个周期。（cheat day  放松日）\n7.3个周期之后恢复正常饮食，但依然不可以高糖高油，少吃零食。\n\n## Q4：减肥吃什么？\n1.主食：玉米、燕麦、豆类、山药等。\n2.肉肉：鸡胸肉、瘦牛肉、鱼肉等。\n3.蔬菜：芹菜、黄瓜、大白菜、豆芽、竹笋、西红柿等。\n4.水果：苹果，香蕉，葡萄柚，菠萝。不用吃太多。\n5.可以平时少吃米饭，换成玉米，自己搞点即时燕麦片什么的。\n\n## Q5：减肥怎么练？\n1.21天为一个周期，每周7天练3天，每次1小时。\n2.每次的时间安排：热身10分钟+无氧10分钟+有氧40分钟\n3.热身：慢跑／热身操／跳绳 （三选一）\n4.无氧：静蹲，平板支撑，臀桥，器械训练，力量训练，短跑\n5.有氧: 椭圆机／跑步／游泳／球类／健身操\n\n## Q6：运动有哪些注意事项？\n1.热身+无氧+有氧三者缺一不可。\n2.不要运动时间过长，心急吃不了热豆腐。\n3.不要睡觉前练，不要饭后练。\n4.一定要注意保护膝盖，防止损伤！长期不运动的一定从静蹲开始练习，把自己的膝关节的保护肌肉练好才能保护住你的膝关节，否则会出现膑骨软化，以后想练啥都白搭。健身房能跑椭圆机就跑椭圆机，不要跑跑步机，最伤膝盖的一是登山机二是跑步机，要跑步到室外地上跑。刚开始幅度不要太大.\n\n## Q7：懒怎么办？\n1.按周进行，每次1小时。开始不要太热情，你会半途而废（你懂的）。 中途断了一天千万不要有负罪感，不要变更你的时间计划想着“我今天不做明天做”之类的（你明天又会推后天的），解决方案就是“忽略”，然后还是按照你的时间表。\n2.给自己点激励，用纸做个表格贴墙上.\n\n## Q8：减肥怎么称体重？\n1.忘记“体重”，关注“体脂率”。所谓“体脂率”就是“体内脂肪的比率”.\n2.用体脂仪代替体重秤.\n3.每天称一下，看看是否有效，体脂率下降对自己的激励效果特别明显，看着可开心啦！\n\n## Q9：一些网传减肥法靠谱吗？\n不！靠！谱！\n1.主食减肥法：国外非常流行的一种减肥法，不吃碳水化合物，主食改为鸡肉或者精瘦牛肉。你的皮肤和头发都会迅速变差，很多人反映记忆力变差，反应迟缓，容易疲劳。反弹迅速。\n2.水果减肥法：全日只吃水果代替正常饭菜。这比主食减肥法更不靠谱.\n3.各种减肥饼干和减肥代餐：额...求求你好好吃饭行么？谁信谁sb\n\n## Q10：可以快速一个月内减肥吗？\n可以个毛线，no zuo no die，找到方法，贵在坚持，你就会有一个好身材！！！我要好好学习，好好实践，此文献给我自己！！！哈哈，有本事你来打我啊\n\n\n","slug":"jianfei21","published":1,"updated":"2017-01-24T09:40:59.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciyr1umw100015gtun2vjcwpz","content":"<h2 id=\"Q1：减肥有哪些严重错误观点？\"><a href=\"#Q1：减肥有哪些严重错误观点？\" class=\"headerlink\" title=\"Q1：减肥有哪些严重错误观点？\"></a>Q1：减肥有哪些严重错误观点？</h2><h4 id=\"错误观点1：体重减少就是“瘦了”。\"><a href=\"#错误观点1：体重减少就是“瘦了”。\" class=\"headerlink\" title=\"错误观点1：体重减少就是“瘦了”。\"></a>错误观点1：体重减少就是“瘦了”。</h4><p>健身者都喜欢运动完称一称，惊喜发现自己“变轻了”，结果第二天怎么又“反弹了”？有个非常普遍的错误观点就是“减肥=减体重”。NO！减肥是“减少脂肪”，运动完后减掉的很多都是水分。所以说，不要称体重！要测量体脂率！(可以买个体脂仪来测)</p>\n<h4 id=\"错误观点2：不吃早饭。\"><a href=\"#错误观点2：不吃早饭。\" class=\"headerlink\" title=\"错误观点2：不吃早饭。\"></a>错误观点2：不吃早饭。</h4><p>不吃早饭会得胆结石胆囊炎，不信你可以试试昂！</p>\n<h4 id=\"错误观点3：只喝果汁或者吃水果减肥。\"><a href=\"#错误观点3：只喝果汁或者吃水果减肥。\" class=\"headerlink\" title=\"错误观点3：只喝果汁或者吃水果减肥。\"></a>错误观点3：只喝果汁或者吃水果减肥。</h4><p>噗！水果含糖量你知道多高吗？别傻了。</p>\n<h4 id=\"错误观点4：不吃肉减肥。\"><a href=\"#错误观点4：不吃肉减肥。\" class=\"headerlink\" title=\"错误观点4：不吃肉减肥。\"></a>错误观点4：不吃肉减肥。</h4><p>“减肥不吃肉”是个严重的错误观点！鸡肉每100的脂肪含量才只有1克多。所以，你不吃肉也减不下来多少肥，除非你平时一直在吃肥肉。一定需要吃肉，鸡肉牛肉鱼肉都行，只要不吃肥肉，不吃炸鸡什么的绝对没问题。</p>\n<h4 id=\"错误观点5：局部减脂。\"><a href=\"#错误观点5：局部减脂。\" class=\"headerlink\" title=\"错误观点5：局部减脂。\"></a>错误观点5：局部减脂。</h4><p>减脂只能减全身！从来没有什么局部减脂一说，如果有人告诉你某种产品可以局部减脂，他一定是在耍流氓。局部确实可以瘦，怎么瘦？无氧运动练肌肉！肌肉变得紧致了，肌间脂肪肌内脂肪减少了，不仅线条优美，血液循环和体制都会变好！</p>\n<h2 id=\"Q2：什么减肥方法最好？\"><a href=\"#Q2：什么减肥方法最好？\" class=\"headerlink\" title=\"Q2：什么减肥方法最好？\"></a>Q2：什么减肥方法最好？</h2><p>有氧运动+无氧运动+低卡饮食=最好的减肥方法。没有之一!减不下来的原因只有两个：不是猪一样的吃就是猪一样的练。你看看你是哪个？</p>\n<h2 id=\"Q3：减肥不能吃什么？\"><a href=\"#Q3：减肥不能吃什么？\" class=\"headerlink\" title=\"Q3：减肥不能吃什么？\"></a>Q3：减肥不能吃什么？</h2><p>1.低糖！什么糖都不许碰（这是最重要的一条！）<br>2.主食减少，吃精白米饭。<br>3.严禁零食、油炸、火锅、肥肉等。<br>4.自己做菜的时候少盐少油。<br>5.早饭吃好吃饱（非常重要！），中饭吃饱，晚饭吃少。<br>6.21天后给自己1天Cheat Day可以放开吃，然后进入第二个周期。（cheat day  放松日）<br>7.3个周期之后恢复正常饮食，但依然不可以高糖高油，少吃零食。</p>\n<h2 id=\"Q4：减肥吃什么？\"><a href=\"#Q4：减肥吃什么？\" class=\"headerlink\" title=\"Q4：减肥吃什么？\"></a>Q4：减肥吃什么？</h2><p>1.主食：玉米、燕麦、豆类、山药等。<br>2.肉肉：鸡胸肉、瘦牛肉、鱼肉等。<br>3.蔬菜：芹菜、黄瓜、大白菜、豆芽、竹笋、西红柿等。<br>4.水果：苹果，香蕉，葡萄柚，菠萝。不用吃太多。<br>5.可以平时少吃米饭，换成玉米，自己搞点即时燕麦片什么的。</p>\n<h2 id=\"Q5：减肥怎么练？\"><a href=\"#Q5：减肥怎么练？\" class=\"headerlink\" title=\"Q5：减肥怎么练？\"></a>Q5：减肥怎么练？</h2><p>1.21天为一个周期，每周7天练3天，每次1小时。<br>2.每次的时间安排：热身10分钟+无氧10分钟+有氧40分钟<br>3.热身：慢跑／热身操／跳绳 （三选一）<br>4.无氧：静蹲，平板支撑，臀桥，器械训练，力量训练，短跑<br>5.有氧: 椭圆机／跑步／游泳／球类／健身操</p>\n<h2 id=\"Q6：运动有哪些注意事项？\"><a href=\"#Q6：运动有哪些注意事项？\" class=\"headerlink\" title=\"Q6：运动有哪些注意事项？\"></a>Q6：运动有哪些注意事项？</h2><p>1.热身+无氧+有氧三者缺一不可。<br>2.不要运动时间过长，心急吃不了热豆腐。<br>3.不要睡觉前练，不要饭后练。<br>4.一定要注意保护膝盖，防止损伤！长期不运动的一定从静蹲开始练习，把自己的膝关节的保护肌肉练好才能保护住你的膝关节，否则会出现膑骨软化，以后想练啥都白搭。健身房能跑椭圆机就跑椭圆机，不要跑跑步机，最伤膝盖的一是登山机二是跑步机，要跑步到室外地上跑。刚开始幅度不要太大.</p>\n<h2 id=\"Q7：懒怎么办？\"><a href=\"#Q7：懒怎么办？\" class=\"headerlink\" title=\"Q7：懒怎么办？\"></a>Q7：懒怎么办？</h2><p>1.按周进行，每次1小时。开始不要太热情，你会半途而废（你懂的）。 中途断了一天千万不要有负罪感，不要变更你的时间计划想着“我今天不做明天做”之类的（你明天又会推后天的），解决方案就是“忽略”，然后还是按照你的时间表。<br>2.给自己点激励，用纸做个表格贴墙上.</p>\n<h2 id=\"Q8：减肥怎么称体重？\"><a href=\"#Q8：减肥怎么称体重？\" class=\"headerlink\" title=\"Q8：减肥怎么称体重？\"></a>Q8：减肥怎么称体重？</h2><p>1.忘记“体重”，关注“体脂率”。所谓“体脂率”就是“体内脂肪的比率”.<br>2.用体脂仪代替体重秤.<br>3.每天称一下，看看是否有效，体脂率下降对自己的激励效果特别明显，看着可开心啦！</p>\n<h2 id=\"Q9：一些网传减肥法靠谱吗？\"><a href=\"#Q9：一些网传减肥法靠谱吗？\" class=\"headerlink\" title=\"Q9：一些网传减肥法靠谱吗？\"></a>Q9：一些网传减肥法靠谱吗？</h2><p>不！靠！谱！<br>1.主食减肥法：国外非常流行的一种减肥法，不吃碳水化合物，主食改为鸡肉或者精瘦牛肉。你的皮肤和头发都会迅速变差，很多人反映记忆力变差，反应迟缓，容易疲劳。反弹迅速。<br>2.水果减肥法：全日只吃水果代替正常饭菜。这比主食减肥法更不靠谱.<br>3.各种减肥饼干和减肥代餐：额…求求你好好吃饭行么？谁信谁sb</p>\n<h2 id=\"Q10：可以快速一个月内减肥吗？\"><a href=\"#Q10：可以快速一个月内减肥吗？\" class=\"headerlink\" title=\"Q10：可以快速一个月内减肥吗？\"></a>Q10：可以快速一个月内减肥吗？</h2><p>可以个毛线，no zuo no die，找到方法，贵在坚持，你就会有一个好身材！！！我要好好学习，好好实践，此文献给我自己！！！哈哈，有本事你来打我啊</p>\n","excerpt":"","more":"<h2 id=\"Q1：减肥有哪些严重错误观点？\"><a href=\"#Q1：减肥有哪些严重错误观点？\" class=\"headerlink\" title=\"Q1：减肥有哪些严重错误观点？\"></a>Q1：减肥有哪些严重错误观点？</h2><h4 id=\"错误观点1：体重减少就是“瘦了”。\"><a href=\"#错误观点1：体重减少就是“瘦了”。\" class=\"headerlink\" title=\"错误观点1：体重减少就是“瘦了”。\"></a>错误观点1：体重减少就是“瘦了”。</h4><p>健身者都喜欢运动完称一称，惊喜发现自己“变轻了”，结果第二天怎么又“反弹了”？有个非常普遍的错误观点就是“减肥=减体重”。NO！减肥是“减少脂肪”，运动完后减掉的很多都是水分。所以说，不要称体重！要测量体脂率！(可以买个体脂仪来测)</p>\n<h4 id=\"错误观点2：不吃早饭。\"><a href=\"#错误观点2：不吃早饭。\" class=\"headerlink\" title=\"错误观点2：不吃早饭。\"></a>错误观点2：不吃早饭。</h4><p>不吃早饭会得胆结石胆囊炎，不信你可以试试昂！</p>\n<h4 id=\"错误观点3：只喝果汁或者吃水果减肥。\"><a href=\"#错误观点3：只喝果汁或者吃水果减肥。\" class=\"headerlink\" title=\"错误观点3：只喝果汁或者吃水果减肥。\"></a>错误观点3：只喝果汁或者吃水果减肥。</h4><p>噗！水果含糖量你知道多高吗？别傻了。</p>\n<h4 id=\"错误观点4：不吃肉减肥。\"><a href=\"#错误观点4：不吃肉减肥。\" class=\"headerlink\" title=\"错误观点4：不吃肉减肥。\"></a>错误观点4：不吃肉减肥。</h4><p>“减肥不吃肉”是个严重的错误观点！鸡肉每100的脂肪含量才只有1克多。所以，你不吃肉也减不下来多少肥，除非你平时一直在吃肥肉。一定需要吃肉，鸡肉牛肉鱼肉都行，只要不吃肥肉，不吃炸鸡什么的绝对没问题。</p>\n<h4 id=\"错误观点5：局部减脂。\"><a href=\"#错误观点5：局部减脂。\" class=\"headerlink\" title=\"错误观点5：局部减脂。\"></a>错误观点5：局部减脂。</h4><p>减脂只能减全身！从来没有什么局部减脂一说，如果有人告诉你某种产品可以局部减脂，他一定是在耍流氓。局部确实可以瘦，怎么瘦？无氧运动练肌肉！肌肉变得紧致了，肌间脂肪肌内脂肪减少了，不仅线条优美，血液循环和体制都会变好！</p>\n<h2 id=\"Q2：什么减肥方法最好？\"><a href=\"#Q2：什么减肥方法最好？\" class=\"headerlink\" title=\"Q2：什么减肥方法最好？\"></a>Q2：什么减肥方法最好？</h2><p>有氧运动+无氧运动+低卡饮食=最好的减肥方法。没有之一!减不下来的原因只有两个：不是猪一样的吃就是猪一样的练。你看看你是哪个？</p>\n<h2 id=\"Q3：减肥不能吃什么？\"><a href=\"#Q3：减肥不能吃什么？\" class=\"headerlink\" title=\"Q3：减肥不能吃什么？\"></a>Q3：减肥不能吃什么？</h2><p>1.低糖！什么糖都不许碰（这是最重要的一条！）<br>2.主食减少，吃精白米饭。<br>3.严禁零食、油炸、火锅、肥肉等。<br>4.自己做菜的时候少盐少油。<br>5.早饭吃好吃饱（非常重要！），中饭吃饱，晚饭吃少。<br>6.21天后给自己1天Cheat Day可以放开吃，然后进入第二个周期。（cheat day  放松日）<br>7.3个周期之后恢复正常饮食，但依然不可以高糖高油，少吃零食。</p>\n<h2 id=\"Q4：减肥吃什么？\"><a href=\"#Q4：减肥吃什么？\" class=\"headerlink\" title=\"Q4：减肥吃什么？\"></a>Q4：减肥吃什么？</h2><p>1.主食：玉米、燕麦、豆类、山药等。<br>2.肉肉：鸡胸肉、瘦牛肉、鱼肉等。<br>3.蔬菜：芹菜、黄瓜、大白菜、豆芽、竹笋、西红柿等。<br>4.水果：苹果，香蕉，葡萄柚，菠萝。不用吃太多。<br>5.可以平时少吃米饭，换成玉米，自己搞点即时燕麦片什么的。</p>\n<h2 id=\"Q5：减肥怎么练？\"><a href=\"#Q5：减肥怎么练？\" class=\"headerlink\" title=\"Q5：减肥怎么练？\"></a>Q5：减肥怎么练？</h2><p>1.21天为一个周期，每周7天练3天，每次1小时。<br>2.每次的时间安排：热身10分钟+无氧10分钟+有氧40分钟<br>3.热身：慢跑／热身操／跳绳 （三选一）<br>4.无氧：静蹲，平板支撑，臀桥，器械训练，力量训练，短跑<br>5.有氧: 椭圆机／跑步／游泳／球类／健身操</p>\n<h2 id=\"Q6：运动有哪些注意事项？\"><a href=\"#Q6：运动有哪些注意事项？\" class=\"headerlink\" title=\"Q6：运动有哪些注意事项？\"></a>Q6：运动有哪些注意事项？</h2><p>1.热身+无氧+有氧三者缺一不可。<br>2.不要运动时间过长，心急吃不了热豆腐。<br>3.不要睡觉前练，不要饭后练。<br>4.一定要注意保护膝盖，防止损伤！长期不运动的一定从静蹲开始练习，把自己的膝关节的保护肌肉练好才能保护住你的膝关节，否则会出现膑骨软化，以后想练啥都白搭。健身房能跑椭圆机就跑椭圆机，不要跑跑步机，最伤膝盖的一是登山机二是跑步机，要跑步到室外地上跑。刚开始幅度不要太大.</p>\n<h2 id=\"Q7：懒怎么办？\"><a href=\"#Q7：懒怎么办？\" class=\"headerlink\" title=\"Q7：懒怎么办？\"></a>Q7：懒怎么办？</h2><p>1.按周进行，每次1小时。开始不要太热情，你会半途而废（你懂的）。 中途断了一天千万不要有负罪感，不要变更你的时间计划想着“我今天不做明天做”之类的（你明天又会推后天的），解决方案就是“忽略”，然后还是按照你的时间表。<br>2.给自己点激励，用纸做个表格贴墙上.</p>\n<h2 id=\"Q8：减肥怎么称体重？\"><a href=\"#Q8：减肥怎么称体重？\" class=\"headerlink\" title=\"Q8：减肥怎么称体重？\"></a>Q8：减肥怎么称体重？</h2><p>1.忘记“体重”，关注“体脂率”。所谓“体脂率”就是“体内脂肪的比率”.<br>2.用体脂仪代替体重秤.<br>3.每天称一下，看看是否有效，体脂率下降对自己的激励效果特别明显，看着可开心啦！</p>\n<h2 id=\"Q9：一些网传减肥法靠谱吗？\"><a href=\"#Q9：一些网传减肥法靠谱吗？\" class=\"headerlink\" title=\"Q9：一些网传减肥法靠谱吗？\"></a>Q9：一些网传减肥法靠谱吗？</h2><p>不！靠！谱！<br>1.主食减肥法：国外非常流行的一种减肥法，不吃碳水化合物，主食改为鸡肉或者精瘦牛肉。你的皮肤和头发都会迅速变差，很多人反映记忆力变差，反应迟缓，容易疲劳。反弹迅速。<br>2.水果减肥法：全日只吃水果代替正常饭菜。这比主食减肥法更不靠谱.<br>3.各种减肥饼干和减肥代餐：额…求求你好好吃饭行么？谁信谁sb</p>\n<h2 id=\"Q10：可以快速一个月内减肥吗？\"><a href=\"#Q10：可以快速一个月内减肥吗？\" class=\"headerlink\" title=\"Q10：可以快速一个月内减肥吗？\"></a>Q10：可以快速一个月内减肥吗？</h2><p>可以个毛线，no zuo no die，找到方法，贵在坚持，你就会有一个好身材！！！我要好好学习，好好实践，此文献给我自己！！！哈哈，有本事你来打我啊</p>\n"},{"title":"移动H5前端性能优化指南","date":"2016-12-29T07:31:49.000Z","_content":"<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/h5optimization.png)\n</div>\n\n#### 概述\n1. PC优化手段在Mobile侧同样适用\n2. 在Mobile侧我们提出三秒种渲染完成首屏指标\n3. 基于第二点，首屏加载3秒完成或使用Loading\n4. 基于联通3G网络平均338KB/s(2.71Mb/s)，所以首屏资源不应超过1014KB\n5. Mobile侧因手机配置原因，除加载外渲染速度也是优化重点\n6. 基于第五点，要合理处理代码减少渲染损耗\n7. 基于第二、第五点，所有影响首屏加载和渲染的代码应在处理逻辑中后置\n8. 加载完成后用户交互使用时也需注意性能\n\n#### 优化指南\n\n<font color=red face=“黑体”>[加载优化]</font>\n\n加载过程是最为耗时的过程，可能会占到总耗时的80%时间，因此是优化的重点\n\n一、 减少HTTP请求\n因为手机浏览器同时响应请求为4个请求（Android支持4个，iOS 5后可支持6个），所以要尽量减少页面的请求数，首次加载同时请求数不能超过4个\na) 合并CSS、JavaScript\nb) 合并小图片，使用雪碧图\n\n二、 缓存\n使用缓存可以减少向服务器的请求数，节省加载时间，所以所有静态资源都要在服务器端设置缓存，并且尽量使用长Cache（长Cache资源的更新可使用时间戳）\na) 缓存一切可缓存的资源\nb) 使用长Cache（使用时间戳更新Cache）\nc) 使用外联式引用CSS、JavaScript\n\n三、 压缩HTML、CSS、JavaScript\n减少资源大小可以加快网页显示速度，所以要对HTML、CSS、JavaScript等进行代码压缩，并在服务器端设置GZip\na) 压缩（例如，多余的空格、换行符和缩进）\nb) 启用GZip\n\n四、 无阻塞\n写在HTML头部的JavaScript（无异步），和写在HTML标签中的Style会阻塞页面的渲染，因此CSS放在页面头部并使用Link方式引入，避免在HTML标签中写Style，JavaScript放在页面尾部或使用异步方式加载\n\n五、 使用首屏加载\n首屏的快速显示，可以大大提升用户对页面速度的感知，因此应尽量针对首屏的快速显示做优化\n\n- 按需加载\n将不影响首屏的资源和当前屏幕资源不用的资源放到用户需要时才加载，可以大大提升重要资源的显示速度和降低总体流量\nPS：按需加载会导致大量重绘，影响渲染性能\na) LazyLoad\nb) 滚屏加载\nc) 通过Media Query加载\n\n- 预加载\n大型重资源页面（如游戏）可使用增加Loading的方法，资源加载完成后再显示页面。但Loading时间过长，会造成用户流失\n对用户行为分析，可以在当前页加载下一页资源，提升速度\na) 可感知Loading(如进入空间游戏的Loading)\nb) 不可感知的Loading（如提前加载下一页）\n\n- 压缩图片\n图片是最占流量的资源，因此尽量避免使用他，使用时选择最合适的格式（实现需求的前提下，以大小判断），合适的大小，然后使用智图压缩，同时在代码中用Srcset来按需显示\nPS：过度压缩图片大小影响图片显示效果\na) 使用智图（ http://zhitu.isux.us/ ）\nb) 使用其它方式代替图片(1. 使用CSS3 2. 使用SVG 3. 使用IconFont)\nc) 使用Srcset\nd) 选择合适的图片(1. webP优于JPG 2. PNG8优于GIF)\ne) 选择合适的大小（1. 首次加载不大于1014KB 2. 不宽于640（基于手机屏幕一般宽度））\n\n- 减少Cookie\nCookie会影响加载速度，所以静态资源域名不使用Cookie\n\n- 避免重定向\n重定向会影响加载速度，所以在服务器正确设置避免重定向\n\n- 异步加载第三方资源\n第三方资源不可控会影响页面的加载和显示，因此要异步加载第三方资源\n\n<font color=red face=“黑体”>[脚本执行优化]</font>\n\n脚本处理不当会阻塞页面加载、渲染，因此在使用时需当注意\n\n一、 CSS写在头部，JavaScript写在尾部或异步\n\n二、 避免图片和iFrame等的空Src\n空Src会重新加载当前页面，影响速度和效率\n\n三、 尽量避免重设图片大小\n重设图片大小是指在页面、CSS、JavaScript等中多次重置图片大小，多次重设图片大小会引发图片的多次重绘，影响性能\n\n四、 图片尽量避免使用DataURL\nDataURL图片没有使用图片的压缩算法文件会变大，并且要解码后再渲染，加载慢耗时长\n\n<font color=red face=“黑体”>[CSS优化]</font>\n\n一、 尽量避免写在HTML标签中写Style属性\n\n二、 避免CSS表达式\nCSS表达式的执行需跳出CSS树的渲染，因此请避免CSS表达式\n\n三、 移除空的CSS规则\n空的CSS规则增加了CSS文件的大小，且影响CSS树的执行，所以需移除空的CSS规则\n\n四、 正确使用Display的属性\nDisplay属性会影响页面的渲染，因此请合理使用\na) display:inline后不应该再使用width、height、margin、padding以及float\nb) display:inline-block后不应该再使用float\nc) display:block后不应该再使用vertical-align\nd) display:table-*后不应该再使用margin或者float\n\n五、 不滥用Float\nFloat在渲染时计算量比较大，尽量减少使用\n\n六、 不滥用Web字体\nWeb字体需要下载，解析，重绘当前页面，尽量减少使用\n\n七、 不声明过多的Font-size\n过多的Font-size引发CSS树的效率\n\n八、 值为0时不需要任何单位\n为了浏览器的兼容性和性能，值为0时不要带单位\n\n九、 标准化各种浏览器前缀\na) 无前缀应放在最后\nb) CSS动画只用 （-webkit- 无前缀）两种即可\nc) 其它前缀为 -webkit- -moz- -ms- 无前缀 四种，（-o-Opera浏览器改用blink内核，所以淘汰）\n\n十、 避免让选择符看起来像正则表达式\n高级选择器执行耗时长且不易读懂，避免使用\n\n<font color=red face=“黑体”>[JavaScript执行优化]</font>\n\n一、 减少重绘和回流\na) 避免不必要的Dom操作\nb) 尽量改变Class而不是Style，使用classList代替className\nc) 避免使用document.write\nd) 减少drawImage\n\n二、 缓存Dom选择与计算\n每次Dom选择都要计算，缓存他\n\n三、 缓存列表.length\n每次.length都要计算，用一个变量保存这个值\n\n四、 尽量使用事件代理，避免批量绑定事件\n\n五、 尽量使用ID选择器\nID选择器是最快的\n\n六、 TOUCH事件优化\n使用touchstart、touchend代替click，因快影响速度快。但应注意Touch响应过快，易引发误操作\n\n<font color=red face=“黑体”>[渲染优化]</font>\n\n一、 HTML使用Viewport\nViewport可以加速页面的渲染，请使用以下代码\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n二、 减少Dom节点\nDom节点太多影响页面的渲染，应尽量减少Dom节点\n\n三、 动画优化\na) 尽量使用CSS3动画\nb) 合理使用requestAnimationFrame动画代替setTimeout\nc) 适当使用Canvas动画 5个元素以内使用css动画，5个以上使用Canvas动画（iOS8可使用webGL）\n\n四、 高频事件优化\nTouchmove、Scroll 事件可导致多次渲染\na) 使用requestAnimationFrame监听帧变化，使得在正确的时间进行渲染\nb) 增加响应变化的时间间隔，减少重绘次数\n\n五、 GPU加速\nCSS中以下属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）来触发GPU渲染，请合理使用\nPS：过渡使用会引发手机过耗电增加\n\n补充:移动端用Zepto.js来代替jq，移动端不用考虑太多浏览器版本的兼容，所以用zepto比较轻量级，比较好。\n\n声明：文章参考来源于网络，在此记录参考学习。","source":"_posts/h5optimization.md","raw":"---\ntitle: 移动H5前端性能优化指南\ndate: 2016-12-29 15:31:49\ntags: H5 移动端优化\n---\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/h5optimization.png)\n</div>\n\n#### 概述\n1. PC优化手段在Mobile侧同样适用\n2. 在Mobile侧我们提出三秒种渲染完成首屏指标\n3. 基于第二点，首屏加载3秒完成或使用Loading\n4. 基于联通3G网络平均338KB/s(2.71Mb/s)，所以首屏资源不应超过1014KB\n5. Mobile侧因手机配置原因，除加载外渲染速度也是优化重点\n6. 基于第五点，要合理处理代码减少渲染损耗\n7. 基于第二、第五点，所有影响首屏加载和渲染的代码应在处理逻辑中后置\n8. 加载完成后用户交互使用时也需注意性能\n\n#### 优化指南\n\n<font color=red face=“黑体”>[加载优化]</font>\n\n加载过程是最为耗时的过程，可能会占到总耗时的80%时间，因此是优化的重点\n\n一、 减少HTTP请求\n因为手机浏览器同时响应请求为4个请求（Android支持4个，iOS 5后可支持6个），所以要尽量减少页面的请求数，首次加载同时请求数不能超过4个\na) 合并CSS、JavaScript\nb) 合并小图片，使用雪碧图\n\n二、 缓存\n使用缓存可以减少向服务器的请求数，节省加载时间，所以所有静态资源都要在服务器端设置缓存，并且尽量使用长Cache（长Cache资源的更新可使用时间戳）\na) 缓存一切可缓存的资源\nb) 使用长Cache（使用时间戳更新Cache）\nc) 使用外联式引用CSS、JavaScript\n\n三、 压缩HTML、CSS、JavaScript\n减少资源大小可以加快网页显示速度，所以要对HTML、CSS、JavaScript等进行代码压缩，并在服务器端设置GZip\na) 压缩（例如，多余的空格、换行符和缩进）\nb) 启用GZip\n\n四、 无阻塞\n写在HTML头部的JavaScript（无异步），和写在HTML标签中的Style会阻塞页面的渲染，因此CSS放在页面头部并使用Link方式引入，避免在HTML标签中写Style，JavaScript放在页面尾部或使用异步方式加载\n\n五、 使用首屏加载\n首屏的快速显示，可以大大提升用户对页面速度的感知，因此应尽量针对首屏的快速显示做优化\n\n- 按需加载\n将不影响首屏的资源和当前屏幕资源不用的资源放到用户需要时才加载，可以大大提升重要资源的显示速度和降低总体流量\nPS：按需加载会导致大量重绘，影响渲染性能\na) LazyLoad\nb) 滚屏加载\nc) 通过Media Query加载\n\n- 预加载\n大型重资源页面（如游戏）可使用增加Loading的方法，资源加载完成后再显示页面。但Loading时间过长，会造成用户流失\n对用户行为分析，可以在当前页加载下一页资源，提升速度\na) 可感知Loading(如进入空间游戏的Loading)\nb) 不可感知的Loading（如提前加载下一页）\n\n- 压缩图片\n图片是最占流量的资源，因此尽量避免使用他，使用时选择最合适的格式（实现需求的前提下，以大小判断），合适的大小，然后使用智图压缩，同时在代码中用Srcset来按需显示\nPS：过度压缩图片大小影响图片显示效果\na) 使用智图（ http://zhitu.isux.us/ ）\nb) 使用其它方式代替图片(1. 使用CSS3 2. 使用SVG 3. 使用IconFont)\nc) 使用Srcset\nd) 选择合适的图片(1. webP优于JPG 2. PNG8优于GIF)\ne) 选择合适的大小（1. 首次加载不大于1014KB 2. 不宽于640（基于手机屏幕一般宽度））\n\n- 减少Cookie\nCookie会影响加载速度，所以静态资源域名不使用Cookie\n\n- 避免重定向\n重定向会影响加载速度，所以在服务器正确设置避免重定向\n\n- 异步加载第三方资源\n第三方资源不可控会影响页面的加载和显示，因此要异步加载第三方资源\n\n<font color=red face=“黑体”>[脚本执行优化]</font>\n\n脚本处理不当会阻塞页面加载、渲染，因此在使用时需当注意\n\n一、 CSS写在头部，JavaScript写在尾部或异步\n\n二、 避免图片和iFrame等的空Src\n空Src会重新加载当前页面，影响速度和效率\n\n三、 尽量避免重设图片大小\n重设图片大小是指在页面、CSS、JavaScript等中多次重置图片大小，多次重设图片大小会引发图片的多次重绘，影响性能\n\n四、 图片尽量避免使用DataURL\nDataURL图片没有使用图片的压缩算法文件会变大，并且要解码后再渲染，加载慢耗时长\n\n<font color=red face=“黑体”>[CSS优化]</font>\n\n一、 尽量避免写在HTML标签中写Style属性\n\n二、 避免CSS表达式\nCSS表达式的执行需跳出CSS树的渲染，因此请避免CSS表达式\n\n三、 移除空的CSS规则\n空的CSS规则增加了CSS文件的大小，且影响CSS树的执行，所以需移除空的CSS规则\n\n四、 正确使用Display的属性\nDisplay属性会影响页面的渲染，因此请合理使用\na) display:inline后不应该再使用width、height、margin、padding以及float\nb) display:inline-block后不应该再使用float\nc) display:block后不应该再使用vertical-align\nd) display:table-*后不应该再使用margin或者float\n\n五、 不滥用Float\nFloat在渲染时计算量比较大，尽量减少使用\n\n六、 不滥用Web字体\nWeb字体需要下载，解析，重绘当前页面，尽量减少使用\n\n七、 不声明过多的Font-size\n过多的Font-size引发CSS树的效率\n\n八、 值为0时不需要任何单位\n为了浏览器的兼容性和性能，值为0时不要带单位\n\n九、 标准化各种浏览器前缀\na) 无前缀应放在最后\nb) CSS动画只用 （-webkit- 无前缀）两种即可\nc) 其它前缀为 -webkit- -moz- -ms- 无前缀 四种，（-o-Opera浏览器改用blink内核，所以淘汰）\n\n十、 避免让选择符看起来像正则表达式\n高级选择器执行耗时长且不易读懂，避免使用\n\n<font color=red face=“黑体”>[JavaScript执行优化]</font>\n\n一、 减少重绘和回流\na) 避免不必要的Dom操作\nb) 尽量改变Class而不是Style，使用classList代替className\nc) 避免使用document.write\nd) 减少drawImage\n\n二、 缓存Dom选择与计算\n每次Dom选择都要计算，缓存他\n\n三、 缓存列表.length\n每次.length都要计算，用一个变量保存这个值\n\n四、 尽量使用事件代理，避免批量绑定事件\n\n五、 尽量使用ID选择器\nID选择器是最快的\n\n六、 TOUCH事件优化\n使用touchstart、touchend代替click，因快影响速度快。但应注意Touch响应过快，易引发误操作\n\n<font color=red face=“黑体”>[渲染优化]</font>\n\n一、 HTML使用Viewport\nViewport可以加速页面的渲染，请使用以下代码\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n二、 减少Dom节点\nDom节点太多影响页面的渲染，应尽量减少Dom节点\n\n三、 动画优化\na) 尽量使用CSS3动画\nb) 合理使用requestAnimationFrame动画代替setTimeout\nc) 适当使用Canvas动画 5个元素以内使用css动画，5个以上使用Canvas动画（iOS8可使用webGL）\n\n四、 高频事件优化\nTouchmove、Scroll 事件可导致多次渲染\na) 使用requestAnimationFrame监听帧变化，使得在正确的时间进行渲染\nb) 增加响应变化的时间间隔，减少重绘次数\n\n五、 GPU加速\nCSS中以下属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）来触发GPU渲染，请合理使用\nPS：过渡使用会引发手机过耗电增加\n\n补充:移动端用Zepto.js来代替jq，移动端不用考虑太多浏览器版本的兼容，所以用zepto比较轻量级，比较好。\n\n声明：文章参考来源于网络，在此记录参考学习。","slug":"h5optimization","published":1,"updated":"2017-02-04T08:11:18.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciyr1umxm00035gtu4kwzdtl1","content":"<div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/h5optimization.png\" alt=\"\"><br></div>\n\n<h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><ol>\n<li>PC优化手段在Mobile侧同样适用</li>\n<li>在Mobile侧我们提出三秒种渲染完成首屏指标</li>\n<li>基于第二点，首屏加载3秒完成或使用Loading</li>\n<li>基于联通3G网络平均338KB/s(2.71Mb/s)，所以首屏资源不应超过1014KB</li>\n<li>Mobile侧因手机配置原因，除加载外渲染速度也是优化重点</li>\n<li>基于第五点，要合理处理代码减少渲染损耗</li>\n<li>基于第二、第五点，所有影响首屏加载和渲染的代码应在处理逻辑中后置</li>\n<li>加载完成后用户交互使用时也需注意性能</li>\n</ol>\n<h4 id=\"优化指南\"><a href=\"#优化指南\" class=\"headerlink\" title=\"优化指南\"></a>优化指南</h4><font color=\"red\" face=\"“黑体”\">[加载优化]</font>\n\n<p>加载过程是最为耗时的过程，可能会占到总耗时的80%时间，因此是优化的重点</p>\n<p>一、 减少HTTP请求<br>因为手机浏览器同时响应请求为4个请求（Android支持4个，iOS 5后可支持6个），所以要尽量减少页面的请求数，首次加载同时请求数不能超过4个<br>a) 合并CSS、JavaScript<br>b) 合并小图片，使用雪碧图</p>\n<p>二、 缓存<br>使用缓存可以减少向服务器的请求数，节省加载时间，所以所有静态资源都要在服务器端设置缓存，并且尽量使用长Cache（长Cache资源的更新可使用时间戳）<br>a) 缓存一切可缓存的资源<br>b) 使用长Cache（使用时间戳更新Cache）<br>c) 使用外联式引用CSS、JavaScript</p>\n<p>三、 压缩HTML、CSS、JavaScript<br>减少资源大小可以加快网页显示速度，所以要对HTML、CSS、JavaScript等进行代码压缩，并在服务器端设置GZip<br>a) 压缩（例如，多余的空格、换行符和缩进）<br>b) 启用GZip</p>\n<p>四、 无阻塞<br>写在HTML头部的JavaScript（无异步），和写在HTML标签中的Style会阻塞页面的渲染，因此CSS放在页面头部并使用Link方式引入，避免在HTML标签中写Style，JavaScript放在页面尾部或使用异步方式加载</p>\n<p>五、 使用首屏加载<br>首屏的快速显示，可以大大提升用户对页面速度的感知，因此应尽量针对首屏的快速显示做优化</p>\n<ul>\n<li><p>按需加载<br>将不影响首屏的资源和当前屏幕资源不用的资源放到用户需要时才加载，可以大大提升重要资源的显示速度和降低总体流量<br>PS：按需加载会导致大量重绘，影响渲染性能<br>a) LazyLoad<br>b) 滚屏加载<br>c) 通过Media Query加载</p>\n</li>\n<li><p>预加载<br>大型重资源页面（如游戏）可使用增加Loading的方法，资源加载完成后再显示页面。但Loading时间过长，会造成用户流失<br>对用户行为分析，可以在当前页加载下一页资源，提升速度<br>a) 可感知Loading(如进入空间游戏的Loading)<br>b) 不可感知的Loading（如提前加载下一页）</p>\n</li>\n<li><p>压缩图片<br>图片是最占流量的资源，因此尽量避免使用他，使用时选择最合适的格式（实现需求的前提下，以大小判断），合适的大小，然后使用智图压缩，同时在代码中用Srcset来按需显示<br>PS：过度压缩图片大小影响图片显示效果<br>a) 使用智图（ <a href=\"http://zhitu.isux.us/\" target=\"_blank\" rel=\"external\">http://zhitu.isux.us/</a> ）<br>b) 使用其它方式代替图片(1. 使用CSS3 2. 使用SVG 3. 使用IconFont)<br>c) 使用Srcset<br>d) 选择合适的图片(1. webP优于JPG 2. PNG8优于GIF)<br>e) 选择合适的大小（1. 首次加载不大于1014KB 2. 不宽于640（基于手机屏幕一般宽度））</p>\n</li>\n<li><p>减少Cookie<br>Cookie会影响加载速度，所以静态资源域名不使用Cookie</p>\n</li>\n<li><p>避免重定向<br>重定向会影响加载速度，所以在服务器正确设置避免重定向</p>\n</li>\n<li><p>异步加载第三方资源<br>第三方资源不可控会影响页面的加载和显示，因此要异步加载第三方资源</p>\n</li>\n</ul>\n<font color=\"red\" face=\"“黑体”\">[脚本执行优化]</font>\n\n<p>脚本处理不当会阻塞页面加载、渲染，因此在使用时需当注意</p>\n<p>一、 CSS写在头部，JavaScript写在尾部或异步</p>\n<p>二、 避免图片和iFrame等的空Src<br>空Src会重新加载当前页面，影响速度和效率</p>\n<p>三、 尽量避免重设图片大小<br>重设图片大小是指在页面、CSS、JavaScript等中多次重置图片大小，多次重设图片大小会引发图片的多次重绘，影响性能</p>\n<p>四、 图片尽量避免使用DataURL<br>DataURL图片没有使用图片的压缩算法文件会变大，并且要解码后再渲染，加载慢耗时长</p>\n<font color=\"red\" face=\"“黑体”\">[CSS优化]</font>\n\n<p>一、 尽量避免写在HTML标签中写Style属性</p>\n<p>二、 避免CSS表达式<br>CSS表达式的执行需跳出CSS树的渲染，因此请避免CSS表达式</p>\n<p>三、 移除空的CSS规则<br>空的CSS规则增加了CSS文件的大小，且影响CSS树的执行，所以需移除空的CSS规则</p>\n<p>四、 正确使用Display的属性<br>Display属性会影响页面的渲染，因此请合理使用<br>a) display:inline后不应该再使用width、height、margin、padding以及float<br>b) display:inline-block后不应该再使用float<br>c) display:block后不应该再使用vertical-align<br>d) display:table-*后不应该再使用margin或者float</p>\n<p>五、 不滥用Float<br>Float在渲染时计算量比较大，尽量减少使用</p>\n<p>六、 不滥用Web字体<br>Web字体需要下载，解析，重绘当前页面，尽量减少使用</p>\n<p>七、 不声明过多的Font-size<br>过多的Font-size引发CSS树的效率</p>\n<p>八、 值为0时不需要任何单位<br>为了浏览器的兼容性和性能，值为0时不要带单位</p>\n<p>九、 标准化各种浏览器前缀<br>a) 无前缀应放在最后<br>b) CSS动画只用 （-webkit- 无前缀）两种即可<br>c) 其它前缀为 -webkit- -moz- -ms- 无前缀 四种，（-o-Opera浏览器改用blink内核，所以淘汰）</p>\n<p>十、 避免让选择符看起来像正则表达式<br>高级选择器执行耗时长且不易读懂，避免使用</p>\n<font color=\"red\" face=\"“黑体”\">[JavaScript执行优化]</font>\n\n<p>一、 减少重绘和回流<br>a) 避免不必要的Dom操作<br>b) 尽量改变Class而不是Style，使用classList代替className<br>c) 避免使用document.write<br>d) 减少drawImage</p>\n<p>二、 缓存Dom选择与计算<br>每次Dom选择都要计算，缓存他</p>\n<p>三、 缓存列表.length<br>每次.length都要计算，用一个变量保存这个值</p>\n<p>四、 尽量使用事件代理，避免批量绑定事件</p>\n<p>五、 尽量使用ID选择器<br>ID选择器是最快的</p>\n<p>六、 TOUCH事件优化<br>使用touchstart、touchend代替click，因快影响速度快。但应注意Touch响应过快，易引发误操作</p>\n<font color=\"red\" face=\"“黑体”\">[渲染优化]</font>\n\n<p>一、 HTML使用Viewport<br>Viewport可以加速页面的渲染，请使用以下代码</p>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n<p>二、 减少Dom节点<br>Dom节点太多影响页面的渲染，应尽量减少Dom节点</p>\n<p>三、 动画优化<br>a) 尽量使用CSS3动画<br>b) 合理使用requestAnimationFrame动画代替setTimeout<br>c) 适当使用Canvas动画 5个元素以内使用css动画，5个以上使用Canvas动画（iOS8可使用webGL）</p>\n<p>四、 高频事件优化<br>Touchmove、Scroll 事件可导致多次渲染<br>a) 使用requestAnimationFrame监听帧变化，使得在正确的时间进行渲染<br>b) 增加响应变化的时间间隔，减少重绘次数</p>\n<p>五、 GPU加速<br>CSS中以下属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）来触发GPU渲染，请合理使用<br>PS：过渡使用会引发手机过耗电增加</p>\n<p>补充:移动端用Zepto.js来代替jq，移动端不用考虑太多浏览器版本的兼容，所以用zepto比较轻量级，比较好。</p>\n<p>声明：文章参考来源于网络，在此记录参考学习。</p>\n","excerpt":"","more":"<div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/h5optimization.png\" alt=\"\"><br></div>\n\n<h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><ol>\n<li>PC优化手段在Mobile侧同样适用</li>\n<li>在Mobile侧我们提出三秒种渲染完成首屏指标</li>\n<li>基于第二点，首屏加载3秒完成或使用Loading</li>\n<li>基于联通3G网络平均338KB/s(2.71Mb/s)，所以首屏资源不应超过1014KB</li>\n<li>Mobile侧因手机配置原因，除加载外渲染速度也是优化重点</li>\n<li>基于第五点，要合理处理代码减少渲染损耗</li>\n<li>基于第二、第五点，所有影响首屏加载和渲染的代码应在处理逻辑中后置</li>\n<li>加载完成后用户交互使用时也需注意性能</li>\n</ol>\n<h4 id=\"优化指南\"><a href=\"#优化指南\" class=\"headerlink\" title=\"优化指南\"></a>优化指南</h4><font color=red face=“黑体”>[加载优化]</font>\n\n<p>加载过程是最为耗时的过程，可能会占到总耗时的80%时间，因此是优化的重点</p>\n<p>一、 减少HTTP请求<br>因为手机浏览器同时响应请求为4个请求（Android支持4个，iOS 5后可支持6个），所以要尽量减少页面的请求数，首次加载同时请求数不能超过4个<br>a) 合并CSS、JavaScript<br>b) 合并小图片，使用雪碧图</p>\n<p>二、 缓存<br>使用缓存可以减少向服务器的请求数，节省加载时间，所以所有静态资源都要在服务器端设置缓存，并且尽量使用长Cache（长Cache资源的更新可使用时间戳）<br>a) 缓存一切可缓存的资源<br>b) 使用长Cache（使用时间戳更新Cache）<br>c) 使用外联式引用CSS、JavaScript</p>\n<p>三、 压缩HTML、CSS、JavaScript<br>减少资源大小可以加快网页显示速度，所以要对HTML、CSS、JavaScript等进行代码压缩，并在服务器端设置GZip<br>a) 压缩（例如，多余的空格、换行符和缩进）<br>b) 启用GZip</p>\n<p>四、 无阻塞<br>写在HTML头部的JavaScript（无异步），和写在HTML标签中的Style会阻塞页面的渲染，因此CSS放在页面头部并使用Link方式引入，避免在HTML标签中写Style，JavaScript放在页面尾部或使用异步方式加载</p>\n<p>五、 使用首屏加载<br>首屏的快速显示，可以大大提升用户对页面速度的感知，因此应尽量针对首屏的快速显示做优化</p>\n<ul>\n<li><p>按需加载<br>将不影响首屏的资源和当前屏幕资源不用的资源放到用户需要时才加载，可以大大提升重要资源的显示速度和降低总体流量<br>PS：按需加载会导致大量重绘，影响渲染性能<br>a) LazyLoad<br>b) 滚屏加载<br>c) 通过Media Query加载</p>\n</li>\n<li><p>预加载<br>大型重资源页面（如游戏）可使用增加Loading的方法，资源加载完成后再显示页面。但Loading时间过长，会造成用户流失<br>对用户行为分析，可以在当前页加载下一页资源，提升速度<br>a) 可感知Loading(如进入空间游戏的Loading)<br>b) 不可感知的Loading（如提前加载下一页）</p>\n</li>\n<li><p>压缩图片<br>图片是最占流量的资源，因此尽量避免使用他，使用时选择最合适的格式（实现需求的前提下，以大小判断），合适的大小，然后使用智图压缩，同时在代码中用Srcset来按需显示<br>PS：过度压缩图片大小影响图片显示效果<br>a) 使用智图（ <a href=\"http://zhitu.isux.us/\">http://zhitu.isux.us/</a> ）<br>b) 使用其它方式代替图片(1. 使用CSS3 2. 使用SVG 3. 使用IconFont)<br>c) 使用Srcset<br>d) 选择合适的图片(1. webP优于JPG 2. PNG8优于GIF)<br>e) 选择合适的大小（1. 首次加载不大于1014KB 2. 不宽于640（基于手机屏幕一般宽度））</p>\n</li>\n<li><p>减少Cookie<br>Cookie会影响加载速度，所以静态资源域名不使用Cookie</p>\n</li>\n<li><p>避免重定向<br>重定向会影响加载速度，所以在服务器正确设置避免重定向</p>\n</li>\n<li><p>异步加载第三方资源<br>第三方资源不可控会影响页面的加载和显示，因此要异步加载第三方资源</p>\n</li>\n</ul>\n<font color=red face=“黑体”>[脚本执行优化]</font>\n\n<p>脚本处理不当会阻塞页面加载、渲染，因此在使用时需当注意</p>\n<p>一、 CSS写在头部，JavaScript写在尾部或异步</p>\n<p>二、 避免图片和iFrame等的空Src<br>空Src会重新加载当前页面，影响速度和效率</p>\n<p>三、 尽量避免重设图片大小<br>重设图片大小是指在页面、CSS、JavaScript等中多次重置图片大小，多次重设图片大小会引发图片的多次重绘，影响性能</p>\n<p>四、 图片尽量避免使用DataURL<br>DataURL图片没有使用图片的压缩算法文件会变大，并且要解码后再渲染，加载慢耗时长</p>\n<font color=red face=“黑体”>[CSS优化]</font>\n\n<p>一、 尽量避免写在HTML标签中写Style属性</p>\n<p>二、 避免CSS表达式<br>CSS表达式的执行需跳出CSS树的渲染，因此请避免CSS表达式</p>\n<p>三、 移除空的CSS规则<br>空的CSS规则增加了CSS文件的大小，且影响CSS树的执行，所以需移除空的CSS规则</p>\n<p>四、 正确使用Display的属性<br>Display属性会影响页面的渲染，因此请合理使用<br>a) display:inline后不应该再使用width、height、margin、padding以及float<br>b) display:inline-block后不应该再使用float<br>c) display:block后不应该再使用vertical-align<br>d) display:table-*后不应该再使用margin或者float</p>\n<p>五、 不滥用Float<br>Float在渲染时计算量比较大，尽量减少使用</p>\n<p>六、 不滥用Web字体<br>Web字体需要下载，解析，重绘当前页面，尽量减少使用</p>\n<p>七、 不声明过多的Font-size<br>过多的Font-size引发CSS树的效率</p>\n<p>八、 值为0时不需要任何单位<br>为了浏览器的兼容性和性能，值为0时不要带单位</p>\n<p>九、 标准化各种浏览器前缀<br>a) 无前缀应放在最后<br>b) CSS动画只用 （-webkit- 无前缀）两种即可<br>c) 其它前缀为 -webkit- -moz- -ms- 无前缀 四种，（-o-Opera浏览器改用blink内核，所以淘汰）</p>\n<p>十、 避免让选择符看起来像正则表达式<br>高级选择器执行耗时长且不易读懂，避免使用</p>\n<font color=red face=“黑体”>[JavaScript执行优化]</font>\n\n<p>一、 减少重绘和回流<br>a) 避免不必要的Dom操作<br>b) 尽量改变Class而不是Style，使用classList代替className<br>c) 避免使用document.write<br>d) 减少drawImage</p>\n<p>二、 缓存Dom选择与计算<br>每次Dom选择都要计算，缓存他</p>\n<p>三、 缓存列表.length<br>每次.length都要计算，用一个变量保存这个值</p>\n<p>四、 尽量使用事件代理，避免批量绑定事件</p>\n<p>五、 尽量使用ID选择器<br>ID选择器是最快的</p>\n<p>六、 TOUCH事件优化<br>使用touchstart、touchend代替click，因快影响速度快。但应注意Touch响应过快，易引发误操作</p>\n<font color=red face=“黑体”>[渲染优化]</font>\n\n<p>一、 HTML使用Viewport<br>Viewport可以加速页面的渲染，请使用以下代码</p>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n<p>二、 减少Dom节点<br>Dom节点太多影响页面的渲染，应尽量减少Dom节点</p>\n<p>三、 动画优化<br>a) 尽量使用CSS3动画<br>b) 合理使用requestAnimationFrame动画代替setTimeout<br>c) 适当使用Canvas动画 5个元素以内使用css动画，5个以上使用Canvas动画（iOS8可使用webGL）</p>\n<p>四、 高频事件优化<br>Touchmove、Scroll 事件可导致多次渲染<br>a) 使用requestAnimationFrame监听帧变化，使得在正确的时间进行渲染<br>b) 增加响应变化的时间间隔，减少重绘次数</p>\n<p>五、 GPU加速<br>CSS中以下属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）来触发GPU渲染，请合理使用<br>PS：过渡使用会引发手机过耗电增加</p>\n<p>补充:移动端用Zepto.js来代替jq，移动端不用考虑太多浏览器版本的兼容，所以用zepto比较轻量级，比较好。</p>\n<p>声明：文章参考来源于网络，在此记录参考学习。</p>\n"},{"title":"webstorm开发微信小程序代码提醒","date":"2017-02-04T09:20:57.000Z","_content":"使用了微信提供的开发工具是真心难用，卡顿厉害、中英文切写注释换相当不爽、还没办法多开窗口，相信大家也遇到过这种现象。\n\n下边我们介绍下webstorm来开发微信小程序的一些配置：\n\n一、 首先File下找到settings,再找到FileType下Cascading Style Sheet 添加*.wxss\n\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/ws1.jpg-public)\n</div>\n\n二、 FileType下HTML 添加*.wxml\n\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/ws2.jpg-public)\n</div>\n\n三、 将wecharCode.jar下载下来，然后在webStorm 的 File -> import settings 中导入即可\n[wecharCode.jar下载地址-点击即可](https://github.com/qbright/wechatCode-complete)\n\n四、 配置已经完成，接下来你的代码就能出现微信小程序的代码提醒了。\n\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/ws3.jpg-public)\n</div>","source":"_posts/wsdevwechat.md","raw":"---\ntitle: webstorm开发微信小程序代码提醒\ndate: 2017-02-04 17:20:57\ntags: wechat webstorm\n---\n使用了微信提供的开发工具是真心难用，卡顿厉害、中英文切写注释换相当不爽、还没办法多开窗口，相信大家也遇到过这种现象。\n\n下边我们介绍下webstorm来开发微信小程序的一些配置：\n\n一、 首先File下找到settings,再找到FileType下Cascading Style Sheet 添加*.wxss\n\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/ws1.jpg-public)\n</div>\n\n二、 FileType下HTML 添加*.wxml\n\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/ws2.jpg-public)\n</div>\n\n三、 将wecharCode.jar下载下来，然后在webStorm 的 File -> import settings 中导入即可\n[wecharCode.jar下载地址-点击即可](https://github.com/qbright/wechatCode-complete)\n\n四、 配置已经完成，接下来你的代码就能出现微信小程序的代码提醒了。\n\n<div align=center>\n    ![](http://oi28tswuq.bkt.clouddn.com/images/ws3.jpg-public)\n</div>","slug":"wsdevwechat","published":1,"updated":"2017-02-04T09:36:19.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciyr1umxr00045gtujgll01lk","content":"<p>使用了微信提供的开发工具是真心难用，卡顿厉害、中英文切写注释换相当不爽、还没办法多开窗口，相信大家也遇到过这种现象。</p>\n<p>下边我们介绍下webstorm来开发微信小程序的一些配置：</p>\n<p>一、 首先File下找到settings,再找到FileType下Cascading Style Sheet 添加*.wxss</p>\n<div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/ws1.jpg-public\" alt=\"\"><br></div>\n\n<p>二、 FileType下HTML 添加*.wxml</p>\n<div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/ws2.jpg-public\" alt=\"\"><br></div>\n\n<p>三、 将wecharCode.jar下载下来，然后在webStorm 的 File -&gt; import settings 中导入即可<br><a href=\"https://github.com/qbright/wechatCode-complete\" target=\"_blank\" rel=\"external\">wecharCode.jar下载地址-点击即可</a></p>\n<p>四、 配置已经完成，接下来你的代码就能出现微信小程序的代码提醒了。</p>\n<div align=\"center\"><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/ws3.jpg-public\" alt=\"\"><br></div>","excerpt":"","more":"<p>使用了微信提供的开发工具是真心难用，卡顿厉害、中英文切写注释换相当不爽、还没办法多开窗口，相信大家也遇到过这种现象。</p>\n<p>下边我们介绍下webstorm来开发微信小程序的一些配置：</p>\n<p>一、 首先File下找到settings,再找到FileType下Cascading Style Sheet 添加*.wxss</p>\n<div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/ws1.jpg-public\" alt=\"\"><br></div>\n\n<p>二、 FileType下HTML 添加*.wxml</p>\n<div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/ws2.jpg-public\" alt=\"\"><br></div>\n\n<p>三、 将wecharCode.jar下载下来，然后在webStorm 的 File -&gt; import settings 中导入即可<br><a href=\"https://github.com/qbright/wechatCode-complete\">wecharCode.jar下载地址-点击即可</a></p>\n<p>四、 配置已经完成，接下来你的代码就能出现微信小程序的代码提醒了。</p>\n<div align=center><br>    <img src=\"http://oi28tswuq.bkt.clouddn.com/images/ws3.jpg-public\" alt=\"\"><br></div>"},{"title":"雅虎网站性能优化的 14 条规则","date":"2016-07-04T06:52:55.000Z","_content":"1. 尽可能减少 HTTP 请求数\n2. 使用 CDN（内容分发网络）\n3. 为文件头指定 Expires 或 Cache-Control，使内容具有缓存性\n4. 使用 Gzip 压缩内容\n5. 把 CSS 放到顶部\n6. 把 JavaScript 放在底部\n7. 避免在 CSS 中使用 Expressions\n8. 把 JavaScript 和 CSS 都放到外部文件中\n9. 减少 DNS 查找次数\n10. 压缩 JavaScript 和 CSS\n11. 避免重定向\n12. 剔除重复的 JavaScript 和 CSS\n13. 配置 Etags\n14. 使 AJAX 缓存\n\n#### 对上述规则的分析\n\n一、 代码编写方面的规则\n- 把 CSS 放到顶部\n- 把 JavaScript 放在底部\n- 把 JavaScript 和 CSS 都放到外部文件中\n- 避免在 CSS 中使用 Expressions（css表达式）\n- 使 AJAX 缓存\n\n二、 打包方面的规则：\n- 尽可能减少 HTTP 请求数\n- 压缩 JavaScript 和 CSS\n- 剔除重复的 JavaScript 和 CSS\n \n三、 部署方面的规则：\n- 使用 CDN（内容分发网络）\n- 为文件头指定 Expires 或 Cache-Control，使内容具有缓存性\n- 使用 Gzip 压缩内容\n- 减少 DNS 查找次数\n- 避免重定向\n- 配置 Etags\n \n#### 对规则的实践\n\n- 部署方面的规则，应用 Nginx 为静态文件添加 Expires 跟 Cache-Control 头， 配置 Etags，并启用 Gzip 压缩。并且避免在 Nginx 中做重定向，有条件的话可以 启用 CDN，并优化网络配置以减少 DNS 查找次数。\n- 代码编写方面的规则，需要在编写代码种形成规范。默认使用类似 jQuery 这样的库 便可以对 AJAX 进行缓存。\n- 打包方面 webpack 可以合并压缩 JavaScript 与 CSS 文件, 小图片的合并（css雪碧图）或者字体图标或者用base64 用以减少 HTTP 请求数。","source":"_posts/yahuyouhua.md","raw":"---\ntitle: 雅虎网站性能优化的 14 条规则\ndate: 2016-07-04 14:52:55\ntags: 性能优化\n---\n1. 尽可能减少 HTTP 请求数\n2. 使用 CDN（内容分发网络）\n3. 为文件头指定 Expires 或 Cache-Control，使内容具有缓存性\n4. 使用 Gzip 压缩内容\n5. 把 CSS 放到顶部\n6. 把 JavaScript 放在底部\n7. 避免在 CSS 中使用 Expressions\n8. 把 JavaScript 和 CSS 都放到外部文件中\n9. 减少 DNS 查找次数\n10. 压缩 JavaScript 和 CSS\n11. 避免重定向\n12. 剔除重复的 JavaScript 和 CSS\n13. 配置 Etags\n14. 使 AJAX 缓存\n\n#### 对上述规则的分析\n\n一、 代码编写方面的规则\n- 把 CSS 放到顶部\n- 把 JavaScript 放在底部\n- 把 JavaScript 和 CSS 都放到外部文件中\n- 避免在 CSS 中使用 Expressions（css表达式）\n- 使 AJAX 缓存\n\n二、 打包方面的规则：\n- 尽可能减少 HTTP 请求数\n- 压缩 JavaScript 和 CSS\n- 剔除重复的 JavaScript 和 CSS\n \n三、 部署方面的规则：\n- 使用 CDN（内容分发网络）\n- 为文件头指定 Expires 或 Cache-Control，使内容具有缓存性\n- 使用 Gzip 压缩内容\n- 减少 DNS 查找次数\n- 避免重定向\n- 配置 Etags\n \n#### 对规则的实践\n\n- 部署方面的规则，应用 Nginx 为静态文件添加 Expires 跟 Cache-Control 头， 配置 Etags，并启用 Gzip 压缩。并且避免在 Nginx 中做重定向，有条件的话可以 启用 CDN，并优化网络配置以减少 DNS 查找次数。\n- 代码编写方面的规则，需要在编写代码种形成规范。默认使用类似 jQuery 这样的库 便可以对 AJAX 进行缓存。\n- 打包方面 webpack 可以合并压缩 JavaScript 与 CSS 文件, 小图片的合并（css雪碧图）或者字体图标或者用base64 用以减少 HTTP 请求数。","slug":"yahuyouhua","published":1,"updated":"2017-02-04T07:13:56.559Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciyr1umxu00055gtu0lfhg7if","content":"<ol>\n<li>尽可能减少 HTTP 请求数</li>\n<li>使用 CDN（内容分发网络）</li>\n<li>为文件头指定 Expires 或 Cache-Control，使内容具有缓存性</li>\n<li>使用 Gzip 压缩内容</li>\n<li>把 CSS 放到顶部</li>\n<li>把 JavaScript 放在底部</li>\n<li>避免在 CSS 中使用 Expressions</li>\n<li>把 JavaScript 和 CSS 都放到外部文件中</li>\n<li>减少 DNS 查找次数</li>\n<li>压缩 JavaScript 和 CSS</li>\n<li>避免重定向</li>\n<li>剔除重复的 JavaScript 和 CSS</li>\n<li>配置 Etags</li>\n<li>使 AJAX 缓存</li>\n</ol>\n<h4 id=\"对上述规则的分析\"><a href=\"#对上述规则的分析\" class=\"headerlink\" title=\"对上述规则的分析\"></a>对上述规则的分析</h4><p>一、 代码编写方面的规则</p>\n<ul>\n<li>把 CSS 放到顶部</li>\n<li>把 JavaScript 放在底部</li>\n<li>把 JavaScript 和 CSS 都放到外部文件中</li>\n<li>避免在 CSS 中使用 Expressions（css表达式）</li>\n<li>使 AJAX 缓存</li>\n</ul>\n<p>二、 打包方面的规则：</p>\n<ul>\n<li>尽可能减少 HTTP 请求数</li>\n<li>压缩 JavaScript 和 CSS</li>\n<li>剔除重复的 JavaScript 和 CSS</li>\n</ul>\n<p>三、 部署方面的规则：</p>\n<ul>\n<li>使用 CDN（内容分发网络）</li>\n<li>为文件头指定 Expires 或 Cache-Control，使内容具有缓存性</li>\n<li>使用 Gzip 压缩内容</li>\n<li>减少 DNS 查找次数</li>\n<li>避免重定向</li>\n<li>配置 Etags</li>\n</ul>\n<h4 id=\"对规则的实践\"><a href=\"#对规则的实践\" class=\"headerlink\" title=\"对规则的实践\"></a>对规则的实践</h4><ul>\n<li>部署方面的规则，应用 Nginx 为静态文件添加 Expires 跟 Cache-Control 头， 配置 Etags，并启用 Gzip 压缩。并且避免在 Nginx 中做重定向，有条件的话可以 启用 CDN，并优化网络配置以减少 DNS 查找次数。</li>\n<li>代码编写方面的规则，需要在编写代码种形成规范。默认使用类似 jQuery 这样的库 便可以对 AJAX 进行缓存。</li>\n<li>打包方面 webpack 可以合并压缩 JavaScript 与 CSS 文件, 小图片的合并（css雪碧图）或者字体图标或者用base64 用以减少 HTTP 请求数。</li>\n</ul>\n","excerpt":"","more":"<ol>\n<li>尽可能减少 HTTP 请求数</li>\n<li>使用 CDN（内容分发网络）</li>\n<li>为文件头指定 Expires 或 Cache-Control，使内容具有缓存性</li>\n<li>使用 Gzip 压缩内容</li>\n<li>把 CSS 放到顶部</li>\n<li>把 JavaScript 放在底部</li>\n<li>避免在 CSS 中使用 Expressions</li>\n<li>把 JavaScript 和 CSS 都放到外部文件中</li>\n<li>减少 DNS 查找次数</li>\n<li>压缩 JavaScript 和 CSS</li>\n<li>避免重定向</li>\n<li>剔除重复的 JavaScript 和 CSS</li>\n<li>配置 Etags</li>\n<li>使 AJAX 缓存</li>\n</ol>\n<h4 id=\"对上述规则的分析\"><a href=\"#对上述规则的分析\" class=\"headerlink\" title=\"对上述规则的分析\"></a>对上述规则的分析</h4><p>一、 代码编写方面的规则</p>\n<ul>\n<li>把 CSS 放到顶部</li>\n<li>把 JavaScript 放在底部</li>\n<li>把 JavaScript 和 CSS 都放到外部文件中</li>\n<li>避免在 CSS 中使用 Expressions（css表达式）</li>\n<li>使 AJAX 缓存</li>\n</ul>\n<p>二、 打包方面的规则：</p>\n<ul>\n<li>尽可能减少 HTTP 请求数</li>\n<li>压缩 JavaScript 和 CSS</li>\n<li>剔除重复的 JavaScript 和 CSS</li>\n</ul>\n<p>三、 部署方面的规则：</p>\n<ul>\n<li>使用 CDN（内容分发网络）</li>\n<li>为文件头指定 Expires 或 Cache-Control，使内容具有缓存性</li>\n<li>使用 Gzip 压缩内容</li>\n<li>减少 DNS 查找次数</li>\n<li>避免重定向</li>\n<li>配置 Etags</li>\n</ul>\n<h4 id=\"对规则的实践\"><a href=\"#对规则的实践\" class=\"headerlink\" title=\"对规则的实践\"></a>对规则的实践</h4><ul>\n<li>部署方面的规则，应用 Nginx 为静态文件添加 Expires 跟 Cache-Control 头， 配置 Etags，并启用 Gzip 压缩。并且避免在 Nginx 中做重定向，有条件的话可以 启用 CDN，并优化网络配置以减少 DNS 查找次数。</li>\n<li>代码编写方面的规则，需要在编写代码种形成规范。默认使用类似 jQuery 这样的库 便可以对 AJAX 进行缓存。</li>\n<li>打包方面 webpack 可以合并压缩 JavaScript 与 CSS 文件, 小图片的合并（css雪碧图）或者字体图标或者用base64 用以减少 HTTP 请求数。</li>\n</ul>\n"},{"title":"关于this那些事","date":"2017-02-09T02:43:40.000Z","_content":"#### this的简单理解\nthis 是在运行时进行绑定的， 并不是在编写时绑定， 它的上下文取决于函数调用时的各种条件。 this 的绑定和函数声明的位置没有任何关系， 只取决于函数的调用方式。\n```\ncall()、apply()和bind()用来改变this关键字的\nfunction.call(thisObj,参数1，参数2....)\nfunction.apply(thisObj,[参数1，参数2....])\nfunction.bind(thisObj，参数1,参数2...)\n```\ncall和apply改变this关键字时函数会被立即执行，而bind不会使函数立即执行，而是会创建一个新函数。\n```\nfunction foo() {\n this.count++;\n} \nfoo.count = 0; 函数是一个对象类型的，所以可以添加自定义属性。\nfoo.call(foo);//这样foo.count=2,因为call把foo函数里的this指向foo本身。\nfoo();//函数直接执行，函数里面的this指向window,所以foo.count还是为0;\n```\n总结：this 实际上是在函数被调用时发生的绑定， 它指向什么完全取决于函数在哪里被调用。\n#### 严格与非严格模式下的this\n```\nfunction foo() {\nconsole.log( this.a );\n}\nvar a = 2;\nfoo(); // 2，此时函数里的this默认指向全局window。\n```\n如果使用严格模式（ strict mode）， 那么全局对象将无法使用默认绑定， 因此 this 会绑定到 undefined：\n```\nfunction foo() {\n\"use strict\";\nconsole.log( this.a );\n}\nvar a = 2;\nfoo(); // TypeError: this is undefined\n```\n虽然 this 的绑定规则完全取决于调用位置， 但是只有 foo() 运行在非 strict mode 下时， 默认绑定才能绑定到全局对象； 严格模式下与 foo()的调用位置无关：\n```\nfunction foo() {\nconsole.log( this.a );\n}\nvar a = 2;\n(function(){\n\"use strict\";\nfoo(); // 2\n})();\n```\n通常来说你不应该在代码中混合使用 strict mode 和 non-strict mode。 整个程序要么严格要么非严格。 然而， 有时候你可能会用到第三方库， 其严格程度和你的代码有所不同， 因此一定要注意这类兼容性细节。\n```\nfunction foo() {\nconsole.log( this.a );\n}\nvar obj2 = {\na: 42,\nfoo: foo\n};\nvar obj1 = {\na: 2,\nobj2: obj2\n};\nobj1.obj2.foo(); // 42\n```\n函数调用时，函数中的this取决于该函数点前面是谁，点前面是谁this就代表谁，此处点前面是obj2，所以运行结果为42.\n当函数执行时前面没有点时，在非严格模式下，this指向(默认绑定)全局window;如果在严格模式下，this会指向undefined,当然会报TypeError: this is undefined。 当函数运行时前面没有点时，要注意有没有显示绑定方法如apply,call和bind，因为它们会显示改变函数中的this。\n\n注意： 对于默认绑定来说， 决定 this 绑定对象的并不是调用位置是否处于严格模式， 而是函数体是否处于严格模式。 如果函数体处于严格模式， this 会被绑定到 undefined， 否则\nthis 会被绑定到全局对象。\n\n#### 判断this的规则\n现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。 可以按照下面的顺序来进行判断：\n- 1.函数是否在 new 中调用（ new 绑定） ？ 如果是的话 this 绑定的是新创建的对象。var bar = new foo()，构造函数中的this指向当前创建的实例。\n- 2.函数是否通过 call、 apply（ 显式绑定） 或者硬绑定调用？ 如果是的话， this 绑定的是指定的对象。var bar = foo.call(obj2)\n- 3.函数是否在某个上下文对象中调用（ 隐式绑定） ？ 如果是的话， this 绑定的是那个上下文对象。var bar = obj1.foo()\n- 4.如果都不是的话， 使用默认绑定。 如果在严格模式下， 就绑定到 undefined， 否则绑定到全局对象。var bar = foo()\n- 5.定时器中的this一直指向window.\n\n#### 被忽略的this\n如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、 apply 或者 bind， 这些值在调用时会被忽略， 实际应用的是默认绑定规则：\n```\nfunction foo() {\nconsole.log( this.a );\n} v\nar a = 2;\nfoo.call( null ); // 2\n```\n那么什么情况下会传入 null 呢？\n一种非常常见的做法是使用 apply(..) 来“ 展开” 一个数组， 并当作参数传入一个函数。类似地， bind(..) 可以对参数进行柯里化（ 预先设置一些参数）， 这种方法有时非常有用：\n```\nfunction foo(a,b) {\nconsole.log( \"a:\" + a + \", b:\" + b );\n} \n// 把数组“ 展开” 成参数\nfoo.apply( null, [2, 3] ); // a:2, b:3\n// 使用 bind(..) 进行柯里化\nvar bar = foo.bind( null, 2 );\nbar( 3 ); // a:2, b:3\n```\n这两种方法都需要传入一个参数当作 this 的绑定对象。 如果函数并不关心 this 的话， 你仍然需要传入一个占位值， 这时 null 可能是一个不错的选择， 就像代码所示的那样。\n小提示：在 ES6 中， 可以用 ... 操作符代替 apply(..) 来“ 展开” 数组， foo(...[1,2]) 和 foo(1,2) 是一样的， 这样可以避免不必要的this 绑定。 可惜， 在 ES6中没有柯里化的相关语法， 因此还是需要使用bind(..)。\n\n然而， 总是使用 null 来忽略 this 绑定可能产生一些副作用。 如果某个函数确实使用了this（ 比如第三方库中的一个函数）， 那默认绑定规则会把 this 绑定到全局对象（ 在浏览\n器中这个对象是 window）， 这将导致不可预计的后果（ 比如修改全局对象）。（假设要使用bind方法的函数（称为fun1）中使用了第三方库的函数，恰好这个第三库的函数中也有this，此时代码fun1.bind(null，参数1)很有可以会影响到第三库函数中的this）显而易见， 这种方式可能会导致许多难以分析和追踪的 bug。\n\n#### 更安全的this\n一种“ 更安全” 的做法是传入一个特殊的对象， 把 this 绑定到这个对象不会对程序产生任何副作用。可以创建一个“ DMZ”（ demilitarizedzone， 非军事区） 对象——它就是一个空的非委托的对象.如果我们在忽略 this 绑定时总是传入一个 DMZ 对象， 那就什么都不用担心了， 因为任何对于 this 的使用都会被限制在这个空对象中， 不会对全局对象产生任何影响。\n在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null)，Object.create(null) 和 {} 很 像， 但 是 并 不 会 创 建 Object.prototype 这个委托， 所以它比 {}“ 更空” ：\n```\nfunction foo(a,b) {\nconsole.log( \"a:\" + a + \", b:\" + b );\n} \n// 定义的 DMZ 空对象\nvar ø = Object.create( null );//ø为变量名，可以随便起。\n// 把数组展开成参数\nfoo.apply( ø, [2, 3] ); // a:2, b:3\n// 使用 bind(..) 进行柯里化\nvar bar = foo.bind( ø, 2 );\nbar( 3 ); // a:2, b:3\n```\n使用变量名 ø 不仅让函数变得更加“ 安全”， 而且可以提高代码的可读性， 因为 ø 表示“ 我希望 this 是空”， 这比 null 的含义更清楚。 当然你可以用任何喜欢的名字来命名 DMZ 对象。\n\n#### 箭头函数中的this\n箭头函数并不是使用 function 关键字定义的， 而是使用被称为“ 胖箭头” 的操作符 => 定义的。 箭头函数不使用 this 的标准规则， 而是根据外层（ 函数或者全局） 作用域来决定 this。\n```\nfunction foo() {\n// 返回一个箭头函数\nreturn (a) => {\n//this 继承自 foo()\nconsole.log( this.a );\n};\n}\nvar obj1 = {\na:2\n};\nvar obj2 = {\na:3\n};\nvar bar = foo.call( obj1 );\nbar.call( obj2 ); // 2, 不是 3 ！\n```\nfoo() 内部创建的箭头函数会捕获调用时 foo() 的 this。 由于 foo() 的 this 绑定到 obj1，bar（ 引用箭头函数） 的 this 也会绑定到 obj1， 箭头函数的绑定无法被修改。（ new 也不\n行！ ）\n箭头函数最常用于回调函数中， 例如事件处理器或者定时器：\n```\nfunction foo() {\nsetTimeout(() => {\n// 这里的 this 在此法上继承自 foo()\nconsole.log( this.a );\n},100);\n}\nvar obj = {\na:2\n};\nfoo.call( obj ); // 2\n```\n","source":"_posts/deepthis.md","raw":"---\ntitle: 关于this那些事\ndate: 2017-02-09 10:43:40\ntags: js this\n---\n#### this的简单理解\nthis 是在运行时进行绑定的， 并不是在编写时绑定， 它的上下文取决于函数调用时的各种条件。 this 的绑定和函数声明的位置没有任何关系， 只取决于函数的调用方式。\n```\ncall()、apply()和bind()用来改变this关键字的\nfunction.call(thisObj,参数1，参数2....)\nfunction.apply(thisObj,[参数1，参数2....])\nfunction.bind(thisObj，参数1,参数2...)\n```\ncall和apply改变this关键字时函数会被立即执行，而bind不会使函数立即执行，而是会创建一个新函数。\n```\nfunction foo() {\n this.count++;\n} \nfoo.count = 0; 函数是一个对象类型的，所以可以添加自定义属性。\nfoo.call(foo);//这样foo.count=2,因为call把foo函数里的this指向foo本身。\nfoo();//函数直接执行，函数里面的this指向window,所以foo.count还是为0;\n```\n总结：this 实际上是在函数被调用时发生的绑定， 它指向什么完全取决于函数在哪里被调用。\n#### 严格与非严格模式下的this\n```\nfunction foo() {\nconsole.log( this.a );\n}\nvar a = 2;\nfoo(); // 2，此时函数里的this默认指向全局window。\n```\n如果使用严格模式（ strict mode）， 那么全局对象将无法使用默认绑定， 因此 this 会绑定到 undefined：\n```\nfunction foo() {\n\"use strict\";\nconsole.log( this.a );\n}\nvar a = 2;\nfoo(); // TypeError: this is undefined\n```\n虽然 this 的绑定规则完全取决于调用位置， 但是只有 foo() 运行在非 strict mode 下时， 默认绑定才能绑定到全局对象； 严格模式下与 foo()的调用位置无关：\n```\nfunction foo() {\nconsole.log( this.a );\n}\nvar a = 2;\n(function(){\n\"use strict\";\nfoo(); // 2\n})();\n```\n通常来说你不应该在代码中混合使用 strict mode 和 non-strict mode。 整个程序要么严格要么非严格。 然而， 有时候你可能会用到第三方库， 其严格程度和你的代码有所不同， 因此一定要注意这类兼容性细节。\n```\nfunction foo() {\nconsole.log( this.a );\n}\nvar obj2 = {\na: 42,\nfoo: foo\n};\nvar obj1 = {\na: 2,\nobj2: obj2\n};\nobj1.obj2.foo(); // 42\n```\n函数调用时，函数中的this取决于该函数点前面是谁，点前面是谁this就代表谁，此处点前面是obj2，所以运行结果为42.\n当函数执行时前面没有点时，在非严格模式下，this指向(默认绑定)全局window;如果在严格模式下，this会指向undefined,当然会报TypeError: this is undefined。 当函数运行时前面没有点时，要注意有没有显示绑定方法如apply,call和bind，因为它们会显示改变函数中的this。\n\n注意： 对于默认绑定来说， 决定 this 绑定对象的并不是调用位置是否处于严格模式， 而是函数体是否处于严格模式。 如果函数体处于严格模式， this 会被绑定到 undefined， 否则\nthis 会被绑定到全局对象。\n\n#### 判断this的规则\n现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。 可以按照下面的顺序来进行判断：\n- 1.函数是否在 new 中调用（ new 绑定） ？ 如果是的话 this 绑定的是新创建的对象。var bar = new foo()，构造函数中的this指向当前创建的实例。\n- 2.函数是否通过 call、 apply（ 显式绑定） 或者硬绑定调用？ 如果是的话， this 绑定的是指定的对象。var bar = foo.call(obj2)\n- 3.函数是否在某个上下文对象中调用（ 隐式绑定） ？ 如果是的话， this 绑定的是那个上下文对象。var bar = obj1.foo()\n- 4.如果都不是的话， 使用默认绑定。 如果在严格模式下， 就绑定到 undefined， 否则绑定到全局对象。var bar = foo()\n- 5.定时器中的this一直指向window.\n\n#### 被忽略的this\n如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、 apply 或者 bind， 这些值在调用时会被忽略， 实际应用的是默认绑定规则：\n```\nfunction foo() {\nconsole.log( this.a );\n} v\nar a = 2;\nfoo.call( null ); // 2\n```\n那么什么情况下会传入 null 呢？\n一种非常常见的做法是使用 apply(..) 来“ 展开” 一个数组， 并当作参数传入一个函数。类似地， bind(..) 可以对参数进行柯里化（ 预先设置一些参数）， 这种方法有时非常有用：\n```\nfunction foo(a,b) {\nconsole.log( \"a:\" + a + \", b:\" + b );\n} \n// 把数组“ 展开” 成参数\nfoo.apply( null, [2, 3] ); // a:2, b:3\n// 使用 bind(..) 进行柯里化\nvar bar = foo.bind( null, 2 );\nbar( 3 ); // a:2, b:3\n```\n这两种方法都需要传入一个参数当作 this 的绑定对象。 如果函数并不关心 this 的话， 你仍然需要传入一个占位值， 这时 null 可能是一个不错的选择， 就像代码所示的那样。\n小提示：在 ES6 中， 可以用 ... 操作符代替 apply(..) 来“ 展开” 数组， foo(...[1,2]) 和 foo(1,2) 是一样的， 这样可以避免不必要的this 绑定。 可惜， 在 ES6中没有柯里化的相关语法， 因此还是需要使用bind(..)。\n\n然而， 总是使用 null 来忽略 this 绑定可能产生一些副作用。 如果某个函数确实使用了this（ 比如第三方库中的一个函数）， 那默认绑定规则会把 this 绑定到全局对象（ 在浏览\n器中这个对象是 window）， 这将导致不可预计的后果（ 比如修改全局对象）。（假设要使用bind方法的函数（称为fun1）中使用了第三方库的函数，恰好这个第三库的函数中也有this，此时代码fun1.bind(null，参数1)很有可以会影响到第三库函数中的this）显而易见， 这种方式可能会导致许多难以分析和追踪的 bug。\n\n#### 更安全的this\n一种“ 更安全” 的做法是传入一个特殊的对象， 把 this 绑定到这个对象不会对程序产生任何副作用。可以创建一个“ DMZ”（ demilitarizedzone， 非军事区） 对象——它就是一个空的非委托的对象.如果我们在忽略 this 绑定时总是传入一个 DMZ 对象， 那就什么都不用担心了， 因为任何对于 this 的使用都会被限制在这个空对象中， 不会对全局对象产生任何影响。\n在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null)，Object.create(null) 和 {} 很 像， 但 是 并 不 会 创 建 Object.prototype 这个委托， 所以它比 {}“ 更空” ：\n```\nfunction foo(a,b) {\nconsole.log( \"a:\" + a + \", b:\" + b );\n} \n// 定义的 DMZ 空对象\nvar ø = Object.create( null );//ø为变量名，可以随便起。\n// 把数组展开成参数\nfoo.apply( ø, [2, 3] ); // a:2, b:3\n// 使用 bind(..) 进行柯里化\nvar bar = foo.bind( ø, 2 );\nbar( 3 ); // a:2, b:3\n```\n使用变量名 ø 不仅让函数变得更加“ 安全”， 而且可以提高代码的可读性， 因为 ø 表示“ 我希望 this 是空”， 这比 null 的含义更清楚。 当然你可以用任何喜欢的名字来命名 DMZ 对象。\n\n#### 箭头函数中的this\n箭头函数并不是使用 function 关键字定义的， 而是使用被称为“ 胖箭头” 的操作符 => 定义的。 箭头函数不使用 this 的标准规则， 而是根据外层（ 函数或者全局） 作用域来决定 this。\n```\nfunction foo() {\n// 返回一个箭头函数\nreturn (a) => {\n//this 继承自 foo()\nconsole.log( this.a );\n};\n}\nvar obj1 = {\na:2\n};\nvar obj2 = {\na:3\n};\nvar bar = foo.call( obj1 );\nbar.call( obj2 ); // 2, 不是 3 ！\n```\nfoo() 内部创建的箭头函数会捕获调用时 foo() 的 this。 由于 foo() 的 this 绑定到 obj1，bar（ 引用箭头函数） 的 this 也会绑定到 obj1， 箭头函数的绑定无法被修改。（ new 也不\n行！ ）\n箭头函数最常用于回调函数中， 例如事件处理器或者定时器：\n```\nfunction foo() {\nsetTimeout(() => {\n// 这里的 this 在此法上继承自 foo()\nconsole.log( this.a );\n},100);\n}\nvar obj = {\na:2\n};\nfoo.call( obj ); // 2\n```\n","slug":"deepthis","published":1,"updated":"2017-02-09T03:27:44.627Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciyxtqwuf0000istu10i1mcd9","content":"<h4 id=\"this的简单理解\"><a href=\"#this的简单理解\" class=\"headerlink\" title=\"this的简单理解\"></a>this的简单理解</h4><p>this 是在运行时进行绑定的， 并不是在编写时绑定， 它的上下文取决于函数调用时的各种条件。 this 的绑定和函数声明的位置没有任何关系， 只取决于函数的调用方式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">call()、apply()和bind()用来改变this关键字的</div><div class=\"line\">function.call(thisObj,参数1，参数2....)</div><div class=\"line\">function.apply(thisObj,[参数1，参数2....])</div><div class=\"line\">function.bind(thisObj，参数1,参数2...)</div></pre></td></tr></table></figure></p>\n<p>call和apply改变this关键字时函数会被立即执行，而bind不会使函数立即执行，而是会创建一个新函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\"> this.count++;</div><div class=\"line\">&#125; </div><div class=\"line\">foo.count = 0; 函数是一个对象类型的，所以可以添加自定义属性。</div><div class=\"line\">foo.call(foo);//这样foo.count=2,因为call把foo函数里的this指向foo本身。</div><div class=\"line\">foo();//函数直接执行，函数里面的this指向window,所以foo.count还是为0;</div></pre></td></tr></table></figure></p>\n<p>总结：this 实际上是在函数被调用时发生的绑定， 它指向什么完全取决于函数在哪里被调用。</p>\n<h4 id=\"严格与非严格模式下的this\"><a href=\"#严格与非严格模式下的this\" class=\"headerlink\" title=\"严格与非严格模式下的this\"></a>严格与非严格模式下的this</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\">var a = 2;</div><div class=\"line\">foo(); // 2，此时函数里的this默认指向全局window。</div></pre></td></tr></table></figure>\n<p>如果使用严格模式（ strict mode）， 那么全局对象将无法使用默认绑定， 因此 this 会绑定到 undefined：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">&quot;use strict&quot;;</div><div class=\"line\">console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\">var a = 2;</div><div class=\"line\">foo(); // TypeError: this is undefined</div></pre></td></tr></table></figure></p>\n<p>虽然 this 的绑定规则完全取决于调用位置， 但是只有 foo() 运行在非 strict mode 下时， 默认绑定才能绑定到全局对象； 严格模式下与 foo()的调用位置无关：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\">var a = 2;</div><div class=\"line\">(function()&#123;</div><div class=\"line\">&quot;use strict&quot;;</div><div class=\"line\">foo(); // 2</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure></p>\n<p>通常来说你不应该在代码中混合使用 strict mode 和 non-strict mode。 整个程序要么严格要么非严格。 然而， 有时候你可能会用到第三方库， 其严格程度和你的代码有所不同， 因此一定要注意这类兼容性细节。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\">var obj2 = &#123;</div><div class=\"line\">a: 42,</div><div class=\"line\">foo: foo</div><div class=\"line\">&#125;;</div><div class=\"line\">var obj1 = &#123;</div><div class=\"line\">a: 2,</div><div class=\"line\">obj2: obj2</div><div class=\"line\">&#125;;</div><div class=\"line\">obj1.obj2.foo(); // 42</div></pre></td></tr></table></figure></p>\n<p>函数调用时，函数中的this取决于该函数点前面是谁，点前面是谁this就代表谁，此处点前面是obj2，所以运行结果为42.<br>当函数执行时前面没有点时，在非严格模式下，this指向(默认绑定)全局window;如果在严格模式下，this会指向undefined,当然会报TypeError: this is undefined。 当函数运行时前面没有点时，要注意有没有显示绑定方法如apply,call和bind，因为它们会显示改变函数中的this。</p>\n<p>注意： 对于默认绑定来说， 决定 this 绑定对象的并不是调用位置是否处于严格模式， 而是函数体是否处于严格模式。 如果函数体处于严格模式， this 会被绑定到 undefined， 否则<br>this 会被绑定到全局对象。</p>\n<h4 id=\"判断this的规则\"><a href=\"#判断this的规则\" class=\"headerlink\" title=\"判断this的规则\"></a>判断this的规则</h4><p>现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。 可以按照下面的顺序来进行判断：</p>\n<ul>\n<li>1.函数是否在 new 中调用（ new 绑定） ？ 如果是的话 this 绑定的是新创建的对象。var bar = new foo()，构造函数中的this指向当前创建的实例。</li>\n<li>2.函数是否通过 call、 apply（ 显式绑定） 或者硬绑定调用？ 如果是的话， this 绑定的是指定的对象。var bar = foo.call(obj2)</li>\n<li>3.函数是否在某个上下文对象中调用（ 隐式绑定） ？ 如果是的话， this 绑定的是那个上下文对象。var bar = obj1.foo()</li>\n<li>4.如果都不是的话， 使用默认绑定。 如果在严格模式下， 就绑定到 undefined， 否则绑定到全局对象。var bar = foo()</li>\n<li>5.定时器中的this一直指向window.</li>\n</ul>\n<h4 id=\"被忽略的this\"><a href=\"#被忽略的this\" class=\"headerlink\" title=\"被忽略的this\"></a>被忽略的this</h4><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、 apply 或者 bind， 这些值在调用时会被忽略， 实际应用的是默认绑定规则：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">console.log( this.a );</div><div class=\"line\">&#125; v</div><div class=\"line\">ar a = 2;</div><div class=\"line\">foo.call( null ); // 2</div></pre></td></tr></table></figure></p>\n<p>那么什么情况下会传入 null 呢？<br>一种非常常见的做法是使用 apply(..) 来“ 展开” 一个数组， 并当作参数传入一个函数。类似地， bind(..) 可以对参数进行柯里化（ 预先设置一些参数）， 这种方法有时非常有用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo(a,b) &#123;</div><div class=\"line\">console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</div><div class=\"line\">&#125; </div><div class=\"line\">// 把数组“ 展开” 成参数</div><div class=\"line\">foo.apply( null, [2, 3] ); // a:2, b:3</div><div class=\"line\">// 使用 bind(..) 进行柯里化</div><div class=\"line\">var bar = foo.bind( null, 2 );</div><div class=\"line\">bar( 3 ); // a:2, b:3</div></pre></td></tr></table></figure></p>\n<p>这两种方法都需要传入一个参数当作 this 的绑定对象。 如果函数并不关心 this 的话， 你仍然需要传入一个占位值， 这时 null 可能是一个不错的选择， 就像代码所示的那样。<br>小提示：在 ES6 中， 可以用 … 操作符代替 apply(..) 来“ 展开” 数组， foo(…[1,2]) 和 foo(1,2) 是一样的， 这样可以避免不必要的this 绑定。 可惜， 在 ES6中没有柯里化的相关语法， 因此还是需要使用bind(..)。</p>\n<p>然而， 总是使用 null 来忽略 this 绑定可能产生一些副作用。 如果某个函数确实使用了this（ 比如第三方库中的一个函数）， 那默认绑定规则会把 this 绑定到全局对象（ 在浏览<br>器中这个对象是 window）， 这将导致不可预计的后果（ 比如修改全局对象）。（假设要使用bind方法的函数（称为fun1）中使用了第三方库的函数，恰好这个第三库的函数中也有this，此时代码fun1.bind(null，参数1)很有可以会影响到第三库函数中的this）显而易见， 这种方式可能会导致许多难以分析和追踪的 bug。</p>\n<h4 id=\"更安全的this\"><a href=\"#更安全的this\" class=\"headerlink\" title=\"更安全的this\"></a>更安全的this</h4><p>一种“ 更安全” 的做法是传入一个特殊的对象， 把 this 绑定到这个对象不会对程序产生任何副作用。可以创建一个“ DMZ”（ demilitarizedzone， 非军事区） 对象——它就是一个空的非委托的对象.如果我们在忽略 this 绑定时总是传入一个 DMZ 对象， 那就什么都不用担心了， 因为任何对于 this 的使用都会被限制在这个空对象中， 不会对全局对象产生任何影响。<br>在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null)，Object.create(null) 和 {} 很 像， 但 是 并 不 会 创 建 Object.prototype 这个委托， 所以它比 {}“ 更空” ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo(a,b) &#123;</div><div class=\"line\">console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</div><div class=\"line\">&#125; </div><div class=\"line\">// 定义的 DMZ 空对象</div><div class=\"line\">var ø = Object.create( null );//ø为变量名，可以随便起。</div><div class=\"line\">// 把数组展开成参数</div><div class=\"line\">foo.apply( ø, [2, 3] ); // a:2, b:3</div><div class=\"line\">// 使用 bind(..) 进行柯里化</div><div class=\"line\">var bar = foo.bind( ø, 2 );</div><div class=\"line\">bar( 3 ); // a:2, b:3</div></pre></td></tr></table></figure></p>\n<p>使用变量名 ø 不仅让函数变得更加“ 安全”， 而且可以提高代码的可读性， 因为 ø 表示“ 我希望 this 是空”， 这比 null 的含义更清楚。 当然你可以用任何喜欢的名字来命名 DMZ 对象。</p>\n<h4 id=\"箭头函数中的this\"><a href=\"#箭头函数中的this\" class=\"headerlink\" title=\"箭头函数中的this\"></a>箭头函数中的this</h4><p>箭头函数并不是使用 function 关键字定义的， 而是使用被称为“ 胖箭头” 的操作符 =&gt; 定义的。 箭头函数不使用 this 的标准规则， 而是根据外层（ 函数或者全局） 作用域来决定 this。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">// 返回一个箭头函数</div><div class=\"line\">return (a) =&gt; &#123;</div><div class=\"line\">//this 继承自 foo()</div><div class=\"line\">console.log( this.a );</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">var obj1 = &#123;</div><div class=\"line\">a:2</div><div class=\"line\">&#125;;</div><div class=\"line\">var obj2 = &#123;</div><div class=\"line\">a:3</div><div class=\"line\">&#125;;</div><div class=\"line\">var bar = foo.call( obj1 );</div><div class=\"line\">bar.call( obj2 ); // 2, 不是 3 ！</div></pre></td></tr></table></figure></p>\n<p>foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。 由于 foo() 的 this 绑定到 obj1，bar（ 引用箭头函数） 的 this 也会绑定到 obj1， 箭头函数的绑定无法被修改。（ new 也不<br>行！ ）<br>箭头函数最常用于回调函数中， 例如事件处理器或者定时器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">setTimeout(() =&gt; &#123;</div><div class=\"line\">// 这里的 this 在此法上继承自 foo()</div><div class=\"line\">console.log( this.a );</div><div class=\"line\">&#125;,100);</div><div class=\"line\">&#125;</div><div class=\"line\">var obj = &#123;</div><div class=\"line\">a:2</div><div class=\"line\">&#125;;</div><div class=\"line\">foo.call( obj ); // 2</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<h4 id=\"this的简单理解\"><a href=\"#this的简单理解\" class=\"headerlink\" title=\"this的简单理解\"></a>this的简单理解</h4><p>this 是在运行时进行绑定的， 并不是在编写时绑定， 它的上下文取决于函数调用时的各种条件。 this 的绑定和函数声明的位置没有任何关系， 只取决于函数的调用方式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">call()、apply()和bind()用来改变this关键字的</div><div class=\"line\">function.call(thisObj,参数1，参数2....)</div><div class=\"line\">function.apply(thisObj,[参数1，参数2....])</div><div class=\"line\">function.bind(thisObj，参数1,参数2...)</div></pre></td></tr></table></figure></p>\n<p>call和apply改变this关键字时函数会被立即执行，而bind不会使函数立即执行，而是会创建一个新函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\"> this.count++;</div><div class=\"line\">&#125; </div><div class=\"line\">foo.count = 0; 函数是一个对象类型的，所以可以添加自定义属性。</div><div class=\"line\">foo.call(foo);//这样foo.count=2,因为call把foo函数里的this指向foo本身。</div><div class=\"line\">foo();//函数直接执行，函数里面的this指向window,所以foo.count还是为0;</div></pre></td></tr></table></figure></p>\n<p>总结：this 实际上是在函数被调用时发生的绑定， 它指向什么完全取决于函数在哪里被调用。</p>\n<h4 id=\"严格与非严格模式下的this\"><a href=\"#严格与非严格模式下的this\" class=\"headerlink\" title=\"严格与非严格模式下的this\"></a>严格与非严格模式下的this</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\">var a = 2;</div><div class=\"line\">foo(); // 2，此时函数里的this默认指向全局window。</div></pre></td></tr></table></figure>\n<p>如果使用严格模式（ strict mode）， 那么全局对象将无法使用默认绑定， 因此 this 会绑定到 undefined：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">&quot;use strict&quot;;</div><div class=\"line\">console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\">var a = 2;</div><div class=\"line\">foo(); // TypeError: this is undefined</div></pre></td></tr></table></figure></p>\n<p>虽然 this 的绑定规则完全取决于调用位置， 但是只有 foo() 运行在非 strict mode 下时， 默认绑定才能绑定到全局对象； 严格模式下与 foo()的调用位置无关：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\">var a = 2;</div><div class=\"line\">(function()&#123;</div><div class=\"line\">&quot;use strict&quot;;</div><div class=\"line\">foo(); // 2</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure></p>\n<p>通常来说你不应该在代码中混合使用 strict mode 和 non-strict mode。 整个程序要么严格要么非严格。 然而， 有时候你可能会用到第三方库， 其严格程度和你的代码有所不同， 因此一定要注意这类兼容性细节。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\">var obj2 = &#123;</div><div class=\"line\">a: 42,</div><div class=\"line\">foo: foo</div><div class=\"line\">&#125;;</div><div class=\"line\">var obj1 = &#123;</div><div class=\"line\">a: 2,</div><div class=\"line\">obj2: obj2</div><div class=\"line\">&#125;;</div><div class=\"line\">obj1.obj2.foo(); // 42</div></pre></td></tr></table></figure></p>\n<p>函数调用时，函数中的this取决于该函数点前面是谁，点前面是谁this就代表谁，此处点前面是obj2，所以运行结果为42.<br>当函数执行时前面没有点时，在非严格模式下，this指向(默认绑定)全局window;如果在严格模式下，this会指向undefined,当然会报TypeError: this is undefined。 当函数运行时前面没有点时，要注意有没有显示绑定方法如apply,call和bind，因为它们会显示改变函数中的this。</p>\n<p>注意： 对于默认绑定来说， 决定 this 绑定对象的并不是调用位置是否处于严格模式， 而是函数体是否处于严格模式。 如果函数体处于严格模式， this 会被绑定到 undefined， 否则<br>this 会被绑定到全局对象。</p>\n<h4 id=\"判断this的规则\"><a href=\"#判断this的规则\" class=\"headerlink\" title=\"判断this的规则\"></a>判断this的规则</h4><p>现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。 可以按照下面的顺序来进行判断：</p>\n<ul>\n<li>1.函数是否在 new 中调用（ new 绑定） ？ 如果是的话 this 绑定的是新创建的对象。var bar = new foo()，构造函数中的this指向当前创建的实例。</li>\n<li>2.函数是否通过 call、 apply（ 显式绑定） 或者硬绑定调用？ 如果是的话， this 绑定的是指定的对象。var bar = foo.call(obj2)</li>\n<li>3.函数是否在某个上下文对象中调用（ 隐式绑定） ？ 如果是的话， this 绑定的是那个上下文对象。var bar = obj1.foo()</li>\n<li>4.如果都不是的话， 使用默认绑定。 如果在严格模式下， 就绑定到 undefined， 否则绑定到全局对象。var bar = foo()</li>\n<li>5.定时器中的this一直指向window.</li>\n</ul>\n<h4 id=\"被忽略的this\"><a href=\"#被忽略的this\" class=\"headerlink\" title=\"被忽略的this\"></a>被忽略的this</h4><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、 apply 或者 bind， 这些值在调用时会被忽略， 实际应用的是默认绑定规则：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">console.log( this.a );</div><div class=\"line\">&#125; v</div><div class=\"line\">ar a = 2;</div><div class=\"line\">foo.call( null ); // 2</div></pre></td></tr></table></figure></p>\n<p>那么什么情况下会传入 null 呢？<br>一种非常常见的做法是使用 apply(..) 来“ 展开” 一个数组， 并当作参数传入一个函数。类似地， bind(..) 可以对参数进行柯里化（ 预先设置一些参数）， 这种方法有时非常有用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo(a,b) &#123;</div><div class=\"line\">console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</div><div class=\"line\">&#125; </div><div class=\"line\">// 把数组“ 展开” 成参数</div><div class=\"line\">foo.apply( null, [2, 3] ); // a:2, b:3</div><div class=\"line\">// 使用 bind(..) 进行柯里化</div><div class=\"line\">var bar = foo.bind( null, 2 );</div><div class=\"line\">bar( 3 ); // a:2, b:3</div></pre></td></tr></table></figure></p>\n<p>这两种方法都需要传入一个参数当作 this 的绑定对象。 如果函数并不关心 this 的话， 你仍然需要传入一个占位值， 这时 null 可能是一个不错的选择， 就像代码所示的那样。<br>小提示：在 ES6 中， 可以用 … 操作符代替 apply(..) 来“ 展开” 数组， foo(…[1,2]) 和 foo(1,2) 是一样的， 这样可以避免不必要的this 绑定。 可惜， 在 ES6中没有柯里化的相关语法， 因此还是需要使用bind(..)。</p>\n<p>然而， 总是使用 null 来忽略 this 绑定可能产生一些副作用。 如果某个函数确实使用了this（ 比如第三方库中的一个函数）， 那默认绑定规则会把 this 绑定到全局对象（ 在浏览<br>器中这个对象是 window）， 这将导致不可预计的后果（ 比如修改全局对象）。（假设要使用bind方法的函数（称为fun1）中使用了第三方库的函数，恰好这个第三库的函数中也有this，此时代码fun1.bind(null，参数1)很有可以会影响到第三库函数中的this）显而易见， 这种方式可能会导致许多难以分析和追踪的 bug。</p>\n<h4 id=\"更安全的this\"><a href=\"#更安全的this\" class=\"headerlink\" title=\"更安全的this\"></a>更安全的this</h4><p>一种“ 更安全” 的做法是传入一个特殊的对象， 把 this 绑定到这个对象不会对程序产生任何副作用。可以创建一个“ DMZ”（ demilitarizedzone， 非军事区） 对象——它就是一个空的非委托的对象.如果我们在忽略 this 绑定时总是传入一个 DMZ 对象， 那就什么都不用担心了， 因为任何对于 this 的使用都会被限制在这个空对象中， 不会对全局对象产生任何影响。<br>在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null)，Object.create(null) 和 {} 很 像， 但 是 并 不 会 创 建 Object.prototype 这个委托， 所以它比 {}“ 更空” ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo(a,b) &#123;</div><div class=\"line\">console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</div><div class=\"line\">&#125; </div><div class=\"line\">// 定义的 DMZ 空对象</div><div class=\"line\">var ø = Object.create( null );//ø为变量名，可以随便起。</div><div class=\"line\">// 把数组展开成参数</div><div class=\"line\">foo.apply( ø, [2, 3] ); // a:2, b:3</div><div class=\"line\">// 使用 bind(..) 进行柯里化</div><div class=\"line\">var bar = foo.bind( ø, 2 );</div><div class=\"line\">bar( 3 ); // a:2, b:3</div></pre></td></tr></table></figure></p>\n<p>使用变量名 ø 不仅让函数变得更加“ 安全”， 而且可以提高代码的可读性， 因为 ø 表示“ 我希望 this 是空”， 这比 null 的含义更清楚。 当然你可以用任何喜欢的名字来命名 DMZ 对象。</p>\n<h4 id=\"箭头函数中的this\"><a href=\"#箭头函数中的this\" class=\"headerlink\" title=\"箭头函数中的this\"></a>箭头函数中的this</h4><p>箭头函数并不是使用 function 关键字定义的， 而是使用被称为“ 胖箭头” 的操作符 =&gt; 定义的。 箭头函数不使用 this 的标准规则， 而是根据外层（ 函数或者全局） 作用域来决定 this。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">// 返回一个箭头函数</div><div class=\"line\">return (a) =&gt; &#123;</div><div class=\"line\">//this 继承自 foo()</div><div class=\"line\">console.log( this.a );</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">var obj1 = &#123;</div><div class=\"line\">a:2</div><div class=\"line\">&#125;;</div><div class=\"line\">var obj2 = &#123;</div><div class=\"line\">a:3</div><div class=\"line\">&#125;;</div><div class=\"line\">var bar = foo.call( obj1 );</div><div class=\"line\">bar.call( obj2 ); // 2, 不是 3 ！</div></pre></td></tr></table></figure></p>\n<p>foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。 由于 foo() 的 this 绑定到 obj1，bar（ 引用箭头函数） 的 this 也会绑定到 obj1， 箭头函数的绑定无法被修改。（ new 也不<br>行！ ）<br>箭头函数最常用于回调函数中， 例如事件处理器或者定时器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">setTimeout(() =&gt; &#123;</div><div class=\"line\">// 这里的 this 在此法上继承自 foo()</div><div class=\"line\">console.log( this.a );</div><div class=\"line\">&#125;,100);</div><div class=\"line\">&#125;</div><div class=\"line\">var obj = &#123;</div><div class=\"line\">a:2</div><div class=\"line\">&#125;;</div><div class=\"line\">foo.call( obj ); // 2</div></pre></td></tr></table></figure></p>\n"},{"title":"深入理解闭包","date":"2017-02-06T09:32:12.000Z","_content":"闭包定义：当函数可以记住并访问所在的词法作用域时， 就产生了闭包， 即使函数是在当前词法作用域之外执行。\n```\nfunction foo() {\nvar a = 2;\nfunction bar() {\nconsole.log( a ); // 2\n}\nbar();//基于词法作用域的查找规则， 函数bar() 可以访问外部作用域中的变量 a\n} \nfoo();\n```\n这是真正意义上的闭包吗？技术上来讲，也许是。但根据前面的定义，确切地说并不是。最准确地用来解释bar() 对 a 的引用的方法是词法作用域的查找规则， 而这些规则只是闭包的一部分。（ 但却是非常重要的一部分！） 。由于看上去 foo() 的内容不会再被使用， 所以引擎很自然地会考虑对其进行回收。foo()执行完，由于浏览器引擎的垃圾回收机制，foo函数的作用域都会被销毁。\n```\nfunction foo() {\nvar a = 2;\nfunction bar() {\nconsole.log( a );\n}\nreturn bar;\n}\nvar baz = foo();\nbaz(); // 2 —— 这才是闭包\n```\n函数 bar() 的词法作用域能够访问 foo() 的内部作用域。 然后将 bar() 函数本身当作一个值类型进行传递。 在这个例子中， 我们将 bar 所引用的函数对象本身当作返回值。在 foo() 执行后， 其返回值（ 也就是内部的 bar() 函数） 赋值给变量 baz 并调用 baz()， 实际上只是通过不同的标识符引用调用了内部的函数 bar()。 但是在这个例子中，bar()在自己定义的词法作用域以外的地方执行。\n\n在 foo() 执行后， 通常会期待 foo() 的整个内部作用域都被销毁， 因为引擎有垃圾回收器用来释放不再使用的内存空间。 而闭包的“ 神奇” 之处正是可以阻止这件事情的发生。在此处事实上foo内部作用域依然存在， 因此没有被回收。 谁在使用这个内部作用域？ 原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐， 它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活， 以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用， 而这个引用就叫作闭包。\n\n 这个函数在定义时的词法作用域以外的地方被调用。 闭包使得函数可以继续访问定义时的词法作用域。\n 当然， 无论使用何种方式对函数类型的值进行传递， 当函数在别处被调用时都可以观察到闭包。      \n ```                            \nfunction foo() {\nvar a = 2;\nfunction baz() {\nconsole.log( a ); // 2\n} \nbar( baz );\n}\nfunction bar(fn) {\nfn(); // 快看呀， 这就是闭包！\n}\n```\n把内部函数 baz 传递给 bar， 当调用这个内部函数时（ 现在叫作 fn）， 它涵盖的 foo() 内部作用域的闭包就可以观察到了， 因为它能够访问 a。传递函数当然也可以是间接的。\n```\nvar fn;\nfunction foo() {\nvar a = 2;\nfunction baz() {\nconsole.log( a );\n} \nfn = baz; // 将 baz 分配给全局变量\n}\nfunction bar() {\nfn(); // 妈妈快看呀， 这就是闭包！\n} \nfoo();\nbar(); // 2\n```\n无论通过何种手段将内部函数传递到所在的词法作用域以外， 它都会持有对原始定义作用域的引用， 无论在何处执行这个函数都会使用闭包。\n\n#### 循环和闭包\n```\nfor (var i=1; i<=5; i++) {\nsetTimeout( function timer() {\nconsole.log( i );\n}, i*1000 );\n}\n```\n以上这段代码在运行时会以每秒一次的频率输出五次 6。（在定时器还没有执行完的时候，i的值已经是6了，因为定时器是异步的，for循环是同步的，执行速度可以忽略不记）\n\n正常情况下， 我们对这段代码行为的预期是分别输出数字 1~5， 每秒一次， 每次一个，那该如何做呢？可以利用闭包的特点来实现。\n```\nfor (var i=1; i<=5; i++) {\n(function() {\nvar j = i;\nsetTimeout( function timer() {\nconsole.log( j );\n}, j*1000 );\n})();\n}\n```\n可以对上面代码进行一些改进：\n```\nfor (var i=1; i<=5; i++) {\n(function(j) {\nsetTimeout( function timer() {\nconsole.log( j );\n}, j*1000 );\n})( i );\n}\n```\n在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域， 使得延迟函数的回调可以将新的作用域封闭在每个迭代内部， 每个迭代中都会含有一个具有正确值的变量供我们访问。\n\n<font color=\"red\">也可以用块作用域来实现</font>\n\n使用 IIFE 在每次迭代时都创建一个新的作用域。 换句话说， 每次迭代我们都需要一个块作用域。let 可以用来劫持块作用域， 并且在这个块作用域中声明一个变量。本质上这是将一个块转换成一个可以被关闭的作用域。 因此， 下面这些看起来很酷的代码就可以正常运行了：\n```\nfor (var i=1; i<=5; i++) {\nlet j = i; // 是的， 闭包的块作用域！\nsetTimeout( function timer() {\nconsole.log( j );\n}, j*1000 );\n}\n```\n虽然实现了，但是不是最优的，for 循环头部的 let 声明还会有一个特殊的行为。 这个行为指出变量在循环过程中不止被声明一次， 每次迭代都会声明。 随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。\n```\nfor (let i=1; i<=5; i++) {\nsetTimeout( function timer() {\nconsole.log( i );\n}, i*1000 );\n}\n```\n 块作用域和闭包联手便可天下无敌。 有了此功能你就可以成为一名快乐的 JavaScript 程序员了。\n\n","source":"_posts/deepclosure.md","raw":"---\ntitle: 深入理解闭包\ndate: 2017-02-06 17:32:12\ntags: js closure\n---\n闭包定义：当函数可以记住并访问所在的词法作用域时， 就产生了闭包， 即使函数是在当前词法作用域之外执行。\n```\nfunction foo() {\nvar a = 2;\nfunction bar() {\nconsole.log( a ); // 2\n}\nbar();//基于词法作用域的查找规则， 函数bar() 可以访问外部作用域中的变量 a\n} \nfoo();\n```\n这是真正意义上的闭包吗？技术上来讲，也许是。但根据前面的定义，确切地说并不是。最准确地用来解释bar() 对 a 的引用的方法是词法作用域的查找规则， 而这些规则只是闭包的一部分。（ 但却是非常重要的一部分！） 。由于看上去 foo() 的内容不会再被使用， 所以引擎很自然地会考虑对其进行回收。foo()执行完，由于浏览器引擎的垃圾回收机制，foo函数的作用域都会被销毁。\n```\nfunction foo() {\nvar a = 2;\nfunction bar() {\nconsole.log( a );\n}\nreturn bar;\n}\nvar baz = foo();\nbaz(); // 2 —— 这才是闭包\n```\n函数 bar() 的词法作用域能够访问 foo() 的内部作用域。 然后将 bar() 函数本身当作一个值类型进行传递。 在这个例子中， 我们将 bar 所引用的函数对象本身当作返回值。在 foo() 执行后， 其返回值（ 也就是内部的 bar() 函数） 赋值给变量 baz 并调用 baz()， 实际上只是通过不同的标识符引用调用了内部的函数 bar()。 但是在这个例子中，bar()在自己定义的词法作用域以外的地方执行。\n\n在 foo() 执行后， 通常会期待 foo() 的整个内部作用域都被销毁， 因为引擎有垃圾回收器用来释放不再使用的内存空间。 而闭包的“ 神奇” 之处正是可以阻止这件事情的发生。在此处事实上foo内部作用域依然存在， 因此没有被回收。 谁在使用这个内部作用域？ 原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐， 它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活， 以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用， 而这个引用就叫作闭包。\n\n 这个函数在定义时的词法作用域以外的地方被调用。 闭包使得函数可以继续访问定义时的词法作用域。\n 当然， 无论使用何种方式对函数类型的值进行传递， 当函数在别处被调用时都可以观察到闭包。      \n ```                            \nfunction foo() {\nvar a = 2;\nfunction baz() {\nconsole.log( a ); // 2\n} \nbar( baz );\n}\nfunction bar(fn) {\nfn(); // 快看呀， 这就是闭包！\n}\n```\n把内部函数 baz 传递给 bar， 当调用这个内部函数时（ 现在叫作 fn）， 它涵盖的 foo() 内部作用域的闭包就可以观察到了， 因为它能够访问 a。传递函数当然也可以是间接的。\n```\nvar fn;\nfunction foo() {\nvar a = 2;\nfunction baz() {\nconsole.log( a );\n} \nfn = baz; // 将 baz 分配给全局变量\n}\nfunction bar() {\nfn(); // 妈妈快看呀， 这就是闭包！\n} \nfoo();\nbar(); // 2\n```\n无论通过何种手段将内部函数传递到所在的词法作用域以外， 它都会持有对原始定义作用域的引用， 无论在何处执行这个函数都会使用闭包。\n\n#### 循环和闭包\n```\nfor (var i=1; i<=5; i++) {\nsetTimeout( function timer() {\nconsole.log( i );\n}, i*1000 );\n}\n```\n以上这段代码在运行时会以每秒一次的频率输出五次 6。（在定时器还没有执行完的时候，i的值已经是6了，因为定时器是异步的，for循环是同步的，执行速度可以忽略不记）\n\n正常情况下， 我们对这段代码行为的预期是分别输出数字 1~5， 每秒一次， 每次一个，那该如何做呢？可以利用闭包的特点来实现。\n```\nfor (var i=1; i<=5; i++) {\n(function() {\nvar j = i;\nsetTimeout( function timer() {\nconsole.log( j );\n}, j*1000 );\n})();\n}\n```\n可以对上面代码进行一些改进：\n```\nfor (var i=1; i<=5; i++) {\n(function(j) {\nsetTimeout( function timer() {\nconsole.log( j );\n}, j*1000 );\n})( i );\n}\n```\n在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域， 使得延迟函数的回调可以将新的作用域封闭在每个迭代内部， 每个迭代中都会含有一个具有正确值的变量供我们访问。\n\n<font color=\"red\">也可以用块作用域来实现</font>\n\n使用 IIFE 在每次迭代时都创建一个新的作用域。 换句话说， 每次迭代我们都需要一个块作用域。let 可以用来劫持块作用域， 并且在这个块作用域中声明一个变量。本质上这是将一个块转换成一个可以被关闭的作用域。 因此， 下面这些看起来很酷的代码就可以正常运行了：\n```\nfor (var i=1; i<=5; i++) {\nlet j = i; // 是的， 闭包的块作用域！\nsetTimeout( function timer() {\nconsole.log( j );\n}, j*1000 );\n}\n```\n虽然实现了，但是不是最优的，for 循环头部的 let 声明还会有一个特殊的行为。 这个行为指出变量在循环过程中不止被声明一次， 每次迭代都会声明。 随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。\n```\nfor (let i=1; i<=5; i++) {\nsetTimeout( function timer() {\nconsole.log( i );\n}, i*1000 );\n}\n```\n 块作用域和闭包联手便可天下无敌。 有了此功能你就可以成为一名快乐的 JavaScript 程序员了。\n\n","slug":"deepclosure","published":1,"updated":"2017-02-08T10:16:54.428Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciyxtqwus0001istujbb9erty","content":"<p>闭包定义：当函数可以记住并访问所在的词法作用域时， 就产生了闭包， 即使函数是在当前词法作用域之外执行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">var a = 2;</div><div class=\"line\">function bar() &#123;</div><div class=\"line\">console.log( a ); // 2</div><div class=\"line\">&#125;</div><div class=\"line\">bar();//基于词法作用域的查找规则， 函数bar() 可以访问外部作用域中的变量 a</div><div class=\"line\">&#125; </div><div class=\"line\">foo();</div></pre></td></tr></table></figure></p>\n<p>这是真正意义上的闭包吗？技术上来讲，也许是。但根据前面的定义，确切地说并不是。最准确地用来解释bar() 对 a 的引用的方法是词法作用域的查找规则， 而这些规则只是闭包的一部分。（ 但却是非常重要的一部分！） 。由于看上去 foo() 的内容不会再被使用， 所以引擎很自然地会考虑对其进行回收。foo()执行完，由于浏览器引擎的垃圾回收机制，foo函数的作用域都会被销毁。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">var a = 2;</div><div class=\"line\">function bar() &#123;</div><div class=\"line\">console.log( a );</div><div class=\"line\">&#125;</div><div class=\"line\">return bar;</div><div class=\"line\">&#125;</div><div class=\"line\">var baz = foo();</div><div class=\"line\">baz(); // 2 —— 这才是闭包</div></pre></td></tr></table></figure></p>\n<p>函数 bar() 的词法作用域能够访问 foo() 的内部作用域。 然后将 bar() 函数本身当作一个值类型进行传递。 在这个例子中， 我们将 bar 所引用的函数对象本身当作返回值。在 foo() 执行后， 其返回值（ 也就是内部的 bar() 函数） 赋值给变量 baz 并调用 baz()， 实际上只是通过不同的标识符引用调用了内部的函数 bar()。 但是在这个例子中，bar()在自己定义的词法作用域以外的地方执行。</p>\n<p>在 foo() 执行后， 通常会期待 foo() 的整个内部作用域都被销毁， 因为引擎有垃圾回收器用来释放不再使用的内存空间。 而闭包的“ 神奇” 之处正是可以阻止这件事情的发生。在此处事实上foo内部作用域依然存在， 因此没有被回收。 谁在使用这个内部作用域？ 原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐， 它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活， 以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用， 而这个引用就叫作闭包。</p>\n<p> 这个函数在定义时的词法作用域以外的地方被调用。 闭包使得函数可以继续访问定义时的词法作用域。<br> 当然， 无论使用何种方式对函数类型的值进行传递， 当函数在别处被调用时都可以观察到闭包。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">var a = 2;</div><div class=\"line\">function baz() &#123;</div><div class=\"line\">console.log( a ); // 2</div><div class=\"line\">&#125; </div><div class=\"line\">bar( baz );</div><div class=\"line\">&#125;</div><div class=\"line\">function bar(fn) &#123;</div><div class=\"line\">fn(); // 快看呀， 这就是闭包！</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>把内部函数 baz 传递给 bar， 当调用这个内部函数时（ 现在叫作 fn）， 它涵盖的 foo() 内部作用域的闭包就可以观察到了， 因为它能够访问 a。传递函数当然也可以是间接的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">var fn;</div><div class=\"line\">function foo() &#123;</div><div class=\"line\">var a = 2;</div><div class=\"line\">function baz() &#123;</div><div class=\"line\">console.log( a );</div><div class=\"line\">&#125; </div><div class=\"line\">fn = baz; // 将 baz 分配给全局变量</div><div class=\"line\">&#125;</div><div class=\"line\">function bar() &#123;</div><div class=\"line\">fn(); // 妈妈快看呀， 这就是闭包！</div><div class=\"line\">&#125; </div><div class=\"line\">foo();</div><div class=\"line\">bar(); // 2</div></pre></td></tr></table></figure></p>\n<p>无论通过何种手段将内部函数传递到所在的词法作用域以外， 它都会持有对原始定义作用域的引用， 无论在何处执行这个函数都会使用闭包。</p>\n<h4 id=\"循环和闭包\"><a href=\"#循环和闭包\" class=\"headerlink\" title=\"循环和闭包\"></a>循环和闭包</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i=1; i&lt;=5; i++) &#123;</div><div class=\"line\">setTimeout( function timer() &#123;</div><div class=\"line\">console.log( i );</div><div class=\"line\">&#125;, i*1000 );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上这段代码在运行时会以每秒一次的频率输出五次 6。（在定时器还没有执行完的时候，i的值已经是6了，因为定时器是异步的，for循环是同步的，执行速度可以忽略不记）</p>\n<p>正常情况下， 我们对这段代码行为的预期是分别输出数字 1~5， 每秒一次， 每次一个，那该如何做呢？可以利用闭包的特点来实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i=1; i&lt;=5; i++) &#123;</div><div class=\"line\">(function() &#123;</div><div class=\"line\">var j = i;</div><div class=\"line\">setTimeout( function timer() &#123;</div><div class=\"line\">console.log( j );</div><div class=\"line\">&#125;, j*1000 );</div><div class=\"line\">&#125;)();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以对上面代码进行一些改进：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i=1; i&lt;=5; i++) &#123;</div><div class=\"line\">(function(j) &#123;</div><div class=\"line\">setTimeout( function timer() &#123;</div><div class=\"line\">console.log( j );</div><div class=\"line\">&#125;, j*1000 );</div><div class=\"line\">&#125;)( i );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域， 使得延迟函数的回调可以将新的作用域封闭在每个迭代内部， 每个迭代中都会含有一个具有正确值的变量供我们访问。</p>\n<font color=\"red\">也可以用块作用域来实现</font>\n\n<p>使用 IIFE 在每次迭代时都创建一个新的作用域。 换句话说， 每次迭代我们都需要一个块作用域。let 可以用来劫持块作用域， 并且在这个块作用域中声明一个变量。本质上这是将一个块转换成一个可以被关闭的作用域。 因此， 下面这些看起来很酷的代码就可以正常运行了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i=1; i&lt;=5; i++) &#123;</div><div class=\"line\">let j = i; // 是的， 闭包的块作用域！</div><div class=\"line\">setTimeout( function timer() &#123;</div><div class=\"line\">console.log( j );</div><div class=\"line\">&#125;, j*1000 );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>虽然实现了，但是不是最优的，for 循环头部的 let 声明还会有一个特殊的行为。 这个行为指出变量在循环过程中不止被声明一次， 每次迭代都会声明。 随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (let i=1; i&lt;=5; i++) &#123;</div><div class=\"line\">setTimeout( function timer() &#123;</div><div class=\"line\">console.log( i );</div><div class=\"line\">&#125;, i*1000 );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p> 块作用域和闭包联手便可天下无敌。 有了此功能你就可以成为一名快乐的 JavaScript 程序员了。</p>\n","excerpt":"","more":"<p>闭包定义：当函数可以记住并访问所在的词法作用域时， 就产生了闭包， 即使函数是在当前词法作用域之外执行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">var a = 2;</div><div class=\"line\">function bar() &#123;</div><div class=\"line\">console.log( a ); // 2</div><div class=\"line\">&#125;</div><div class=\"line\">bar();//基于词法作用域的查找规则， 函数bar() 可以访问外部作用域中的变量 a</div><div class=\"line\">&#125; </div><div class=\"line\">foo();</div></pre></td></tr></table></figure></p>\n<p>这是真正意义上的闭包吗？技术上来讲，也许是。但根据前面的定义，确切地说并不是。最准确地用来解释bar() 对 a 的引用的方法是词法作用域的查找规则， 而这些规则只是闭包的一部分。（ 但却是非常重要的一部分！） 。由于看上去 foo() 的内容不会再被使用， 所以引擎很自然地会考虑对其进行回收。foo()执行完，由于浏览器引擎的垃圾回收机制，foo函数的作用域都会被销毁。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">var a = 2;</div><div class=\"line\">function bar() &#123;</div><div class=\"line\">console.log( a );</div><div class=\"line\">&#125;</div><div class=\"line\">return bar;</div><div class=\"line\">&#125;</div><div class=\"line\">var baz = foo();</div><div class=\"line\">baz(); // 2 —— 这才是闭包</div></pre></td></tr></table></figure></p>\n<p>函数 bar() 的词法作用域能够访问 foo() 的内部作用域。 然后将 bar() 函数本身当作一个值类型进行传递。 在这个例子中， 我们将 bar 所引用的函数对象本身当作返回值。在 foo() 执行后， 其返回值（ 也就是内部的 bar() 函数） 赋值给变量 baz 并调用 baz()， 实际上只是通过不同的标识符引用调用了内部的函数 bar()。 但是在这个例子中，bar()在自己定义的词法作用域以外的地方执行。</p>\n<p>在 foo() 执行后， 通常会期待 foo() 的整个内部作用域都被销毁， 因为引擎有垃圾回收器用来释放不再使用的内存空间。 而闭包的“ 神奇” 之处正是可以阻止这件事情的发生。在此处事实上foo内部作用域依然存在， 因此没有被回收。 谁在使用这个内部作用域？ 原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐， 它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活， 以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用， 而这个引用就叫作闭包。</p>\n<p> 这个函数在定义时的词法作用域以外的地方被调用。 闭包使得函数可以继续访问定义时的词法作用域。<br> 当然， 无论使用何种方式对函数类型的值进行传递， 当函数在别处被调用时都可以观察到闭包。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">var a = 2;</div><div class=\"line\">function baz() &#123;</div><div class=\"line\">console.log( a ); // 2</div><div class=\"line\">&#125; </div><div class=\"line\">bar( baz );</div><div class=\"line\">&#125;</div><div class=\"line\">function bar(fn) &#123;</div><div class=\"line\">fn(); // 快看呀， 这就是闭包！</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>把内部函数 baz 传递给 bar， 当调用这个内部函数时（ 现在叫作 fn）， 它涵盖的 foo() 内部作用域的闭包就可以观察到了， 因为它能够访问 a。传递函数当然也可以是间接的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">var fn;</div><div class=\"line\">function foo() &#123;</div><div class=\"line\">var a = 2;</div><div class=\"line\">function baz() &#123;</div><div class=\"line\">console.log( a );</div><div class=\"line\">&#125; </div><div class=\"line\">fn = baz; // 将 baz 分配给全局变量</div><div class=\"line\">&#125;</div><div class=\"line\">function bar() &#123;</div><div class=\"line\">fn(); // 妈妈快看呀， 这就是闭包！</div><div class=\"line\">&#125; </div><div class=\"line\">foo();</div><div class=\"line\">bar(); // 2</div></pre></td></tr></table></figure></p>\n<p>无论通过何种手段将内部函数传递到所在的词法作用域以外， 它都会持有对原始定义作用域的引用， 无论在何处执行这个函数都会使用闭包。</p>\n<h4 id=\"循环和闭包\"><a href=\"#循环和闭包\" class=\"headerlink\" title=\"循环和闭包\"></a>循环和闭包</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i=1; i&lt;=5; i++) &#123;</div><div class=\"line\">setTimeout( function timer() &#123;</div><div class=\"line\">console.log( i );</div><div class=\"line\">&#125;, i*1000 );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上这段代码在运行时会以每秒一次的频率输出五次 6。（在定时器还没有执行完的时候，i的值已经是6了，因为定时器是异步的，for循环是同步的，执行速度可以忽略不记）</p>\n<p>正常情况下， 我们对这段代码行为的预期是分别输出数字 1~5， 每秒一次， 每次一个，那该如何做呢？可以利用闭包的特点来实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i=1; i&lt;=5; i++) &#123;</div><div class=\"line\">(function() &#123;</div><div class=\"line\">var j = i;</div><div class=\"line\">setTimeout( function timer() &#123;</div><div class=\"line\">console.log( j );</div><div class=\"line\">&#125;, j*1000 );</div><div class=\"line\">&#125;)();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以对上面代码进行一些改进：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i=1; i&lt;=5; i++) &#123;</div><div class=\"line\">(function(j) &#123;</div><div class=\"line\">setTimeout( function timer() &#123;</div><div class=\"line\">console.log( j );</div><div class=\"line\">&#125;, j*1000 );</div><div class=\"line\">&#125;)( i );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域， 使得延迟函数的回调可以将新的作用域封闭在每个迭代内部， 每个迭代中都会含有一个具有正确值的变量供我们访问。</p>\n<font color=\"red\">也可以用块作用域来实现</font>\n\n<p>使用 IIFE 在每次迭代时都创建一个新的作用域。 换句话说， 每次迭代我们都需要一个块作用域。let 可以用来劫持块作用域， 并且在这个块作用域中声明一个变量。本质上这是将一个块转换成一个可以被关闭的作用域。 因此， 下面这些看起来很酷的代码就可以正常运行了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i=1; i&lt;=5; i++) &#123;</div><div class=\"line\">let j = i; // 是的， 闭包的块作用域！</div><div class=\"line\">setTimeout( function timer() &#123;</div><div class=\"line\">console.log( j );</div><div class=\"line\">&#125;, j*1000 );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>虽然实现了，但是不是最优的，for 循环头部的 let 声明还会有一个特殊的行为。 这个行为指出变量在循环过程中不止被声明一次， 每次迭代都会声明。 随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (let i=1; i&lt;=5; i++) &#123;</div><div class=\"line\">setTimeout( function timer() &#123;</div><div class=\"line\">console.log( i );</div><div class=\"line\">&#125;, i*1000 );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p> 块作用域和闭包联手便可天下无敌。 有了此功能你就可以成为一名快乐的 JavaScript 程序员了。</p>\n"},{"title":"学习flex布局","date":"2017-02-07T03:09:43.000Z","_content":"布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。\n2009年，W3C提出了一种新的方案----Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。\n#### 一、Flex布局是什么？\n\nFlex是Flexible Box的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。\n```\n.box{\n  display: flex;\n}\n```\n行内元素也可以使用Flex布局。\n```\n.box{\n  display: inline-flex;\n}\n```\nWebkit内核的浏览器，必须加上-webkit前缀。\n```\n.box{\n  display: -webkit-flex; /* Safari */\n  display: flex;\n}\n```\n注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。\n\n#### 二、基本概念\n采用Flex布局的元素，称为Flex容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称\"项目\"。\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。\n\n#### 三、容器的属性\n以下6个属性设置在容器上。\nflex-direction\nflex-wrap\nflex-flow\njustify-content\nalign-items\nalign-content\n\n更多学习内容参考以下链接：\n[Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool)\n[Flex 布局教程：实例篇](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html)","source":"_posts/flexintroduction.md","raw":"---\ntitle: 学习flex布局\ndate: 2017-02-07 11:09:43\ntags: flex css\n---\n布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。\n2009年，W3C提出了一种新的方案----Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。\n#### 一、Flex布局是什么？\n\nFlex是Flexible Box的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。\n```\n.box{\n  display: flex;\n}\n```\n行内元素也可以使用Flex布局。\n```\n.box{\n  display: inline-flex;\n}\n```\nWebkit内核的浏览器，必须加上-webkit前缀。\n```\n.box{\n  display: -webkit-flex; /* Safari */\n  display: flex;\n}\n```\n注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。\n\n#### 二、基本概念\n采用Flex布局的元素，称为Flex容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称\"项目\"。\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。\n\n#### 三、容器的属性\n以下6个属性设置在容器上。\nflex-direction\nflex-wrap\nflex-flow\njustify-content\nalign-items\nalign-content\n\n更多学习内容参考以下链接：\n[Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool)\n[Flex 布局教程：实例篇](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html)","slug":"flexintroduction","published":1,"updated":"2017-02-07T03:16:10.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciyxtqwvx0003istue21zooqv","content":"<p>布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。<br>2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p>\n<h4 id=\"一、Flex布局是什么？\"><a href=\"#一、Flex布局是什么？\" class=\"headerlink\" title=\"一、Flex布局是什么？\"></a>一、Flex布局是什么？</h4><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.box&#123;</div><div class=\"line\">  display: flex;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>行内元素也可以使用Flex布局。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.box&#123;</div><div class=\"line\">  display: inline-flex;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Webkit内核的浏览器，必须加上-webkit前缀。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">.box&#123;</div><div class=\"line\">  display: -webkit-flex; /* Safari */</div><div class=\"line\">  display: flex;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</p>\n<h4 id=\"二、基本概念\"><a href=\"#二、基本概念\" class=\"headerlink\" title=\"二、基本概念\"></a>二、基本概念</h4><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>\n<h4 id=\"三、容器的属性\"><a href=\"#三、容器的属性\" class=\"headerlink\" title=\"三、容器的属性\"></a>三、容器的属性</h4><p>以下6个属性设置在容器上。<br>flex-direction<br>flex-wrap<br>flex-flow<br>justify-content<br>align-items<br>align-content</p>\n<p>更多学习内容参考以下链接：<br><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool\" target=\"_blank\" rel=\"external\">Flex 布局教程：语法篇</a><br><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\" target=\"_blank\" rel=\"external\">Flex 布局教程：实例篇</a></p>\n","excerpt":"","more":"<p>布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。<br>2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p>\n<h4 id=\"一、Flex布局是什么？\"><a href=\"#一、Flex布局是什么？\" class=\"headerlink\" title=\"一、Flex布局是什么？\"></a>一、Flex布局是什么？</h4><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.box&#123;</div><div class=\"line\">  display: flex;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>行内元素也可以使用Flex布局。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.box&#123;</div><div class=\"line\">  display: inline-flex;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Webkit内核的浏览器，必须加上-webkit前缀。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">.box&#123;</div><div class=\"line\">  display: -webkit-flex; /* Safari */</div><div class=\"line\">  display: flex;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</p>\n<h4 id=\"二、基本概念\"><a href=\"#二、基本概念\" class=\"headerlink\" title=\"二、基本概念\"></a>二、基本概念</h4><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>\n<h4 id=\"三、容器的属性\"><a href=\"#三、容器的属性\" class=\"headerlink\" title=\"三、容器的属性\"></a>三、容器的属性</h4><p>以下6个属性设置在容器上。<br>flex-direction<br>flex-wrap<br>flex-flow<br>justify-content<br>align-items<br>align-content</p>\n<p>更多学习内容参考以下链接：<br><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool\">Flex 布局教程：语法篇</a><br><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\">Flex 布局教程：实例篇</a></p>\n"},{"title":"作用域预编译及引发异常问题","date":"2015-02-08T07:13:43.000Z","_content":"#### 预编译\nvar a=2;执行分为两个过程：\n代码执行前先进行预编译，此时只是声明了一个变量a，此时a的值为undefined，当代码运行到a=2时，变量a才会赋值2。\n总结： 变量的赋值操作会执行两个动作， 首先编译器会在当前作用域中声明一个变量（ 如果之前没有声明过）， 然后在运行时引擎会在作用域中查找该变量， 如果能够找到就会对\n它赋值。\n\n\n#### 类型错误\n```\nfunction foo(a) {\nconsole.log( a + b );\nb = a;\n} \nfoo( 2 );\n```\n上述代码在严格模式中 找不到变量b时（此句对应 console.log( a + b )）， 并不会创建并返回一个全局变量， 引擎会抛出一个ReferenceError 异常。在非严格模式下，如果找不到变量b（此句对应b=a，给b赋值时它会看预编译的时候有没有声明b，如果没有声明，在非严格模式下它会声明并给其赋值），在全局作用域中就会创建一个具有该名称的变量b， 并将其返还给引擎\n\n如果你对一个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用， 或着引用 null 或 undefined 类型的值中的属性， 那么引擎会抛出另外一种类型的异常， 叫作 TypeError。例：\n```\nvar a=12;\nvar b=null;\n```\n执行a(),b.property或者b.length都会抛出一个TypeError异常。\n\n总结：ReferenceError 同作用域判别失败相关（在相关作用域内及全局作用域内没有找到变量）， 而 TypeError 则代表作用域判别成功了(在作用域内找到了变量)， 但是对结果的操作是非法或不合理的。\n\n#### 小结\n作用域是一套规则， 用于确定在何处以及如何查找变量（ 标识符）。 如果查找的目的是对变量进行赋值， 那么就会使用 LHS 查询； 如果目的是获取变量的值， 就会使用 RHS 查询。\n\n赋值操作符会导致 LHS 查询。 ＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。\n\nJavaScript 引擎首先会在代码执行前对其进行编译， 在这个过程中， 像 var a = 2 这样的声明会被分解成两个独立的步骤：\n1.首先， var a 在其作用域中声明新变量。 这会在最开始的阶段， 也就是代码执行前进行。\n2.接下来， a = 2 会查询（ LHS 查询） 变量 a 并对其进行赋值\n\nLHS 和 RHS 查询都会在当前执行作用域中开始， 如果有需要（ 也就是说它们没有找到所需的标识符）， 就会向上级作用域继续查找目标标识符， 这样每次上升一级作用域， 最后抵达全局作用域（ 顶层）， 无论找到或没找到都将停止。不成功的 RHS 引用会导致抛出 ReferenceError 异常。 不成功的 LHS 引用会导致自动隐式地创建一个全局变量（ 非严格模式下）， 该变量使用 LHS 引用的目标作为标识符， 或者抛出 ReferenceError 异常（ 严格模式下）","source":"_posts/scope.md","raw":"---\ntitle: 作用域预编译及引发异常问题\ndate: 2015-02-08 15:13:43\ntags: js scope\n---\n#### 预编译\nvar a=2;执行分为两个过程：\n代码执行前先进行预编译，此时只是声明了一个变量a，此时a的值为undefined，当代码运行到a=2时，变量a才会赋值2。\n总结： 变量的赋值操作会执行两个动作， 首先编译器会在当前作用域中声明一个变量（ 如果之前没有声明过）， 然后在运行时引擎会在作用域中查找该变量， 如果能够找到就会对\n它赋值。\n\n\n#### 类型错误\n```\nfunction foo(a) {\nconsole.log( a + b );\nb = a;\n} \nfoo( 2 );\n```\n上述代码在严格模式中 找不到变量b时（此句对应 console.log( a + b )）， 并不会创建并返回一个全局变量， 引擎会抛出一个ReferenceError 异常。在非严格模式下，如果找不到变量b（此句对应b=a，给b赋值时它会看预编译的时候有没有声明b，如果没有声明，在非严格模式下它会声明并给其赋值），在全局作用域中就会创建一个具有该名称的变量b， 并将其返还给引擎\n\n如果你对一个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用， 或着引用 null 或 undefined 类型的值中的属性， 那么引擎会抛出另外一种类型的异常， 叫作 TypeError。例：\n```\nvar a=12;\nvar b=null;\n```\n执行a(),b.property或者b.length都会抛出一个TypeError异常。\n\n总结：ReferenceError 同作用域判别失败相关（在相关作用域内及全局作用域内没有找到变量）， 而 TypeError 则代表作用域判别成功了(在作用域内找到了变量)， 但是对结果的操作是非法或不合理的。\n\n#### 小结\n作用域是一套规则， 用于确定在何处以及如何查找变量（ 标识符）。 如果查找的目的是对变量进行赋值， 那么就会使用 LHS 查询； 如果目的是获取变量的值， 就会使用 RHS 查询。\n\n赋值操作符会导致 LHS 查询。 ＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。\n\nJavaScript 引擎首先会在代码执行前对其进行编译， 在这个过程中， 像 var a = 2 这样的声明会被分解成两个独立的步骤：\n1.首先， var a 在其作用域中声明新变量。 这会在最开始的阶段， 也就是代码执行前进行。\n2.接下来， a = 2 会查询（ LHS 查询） 变量 a 并对其进行赋值\n\nLHS 和 RHS 查询都会在当前执行作用域中开始， 如果有需要（ 也就是说它们没有找到所需的标识符）， 就会向上级作用域继续查找目标标识符， 这样每次上升一级作用域， 最后抵达全局作用域（ 顶层）， 无论找到或没找到都将停止。不成功的 RHS 引用会导致抛出 ReferenceError 异常。 不成功的 LHS 引用会导致自动隐式地创建一个全局变量（ 非严格模式下）， 该变量使用 LHS 引用的目标作为标识符， 或者抛出 ReferenceError 异常（ 严格模式下）","slug":"scope","published":1,"updated":"2017-02-08T07:52:07.764Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciyxtqww00004istu5723lfkq","content":"<h4 id=\"预编译\"><a href=\"#预编译\" class=\"headerlink\" title=\"预编译\"></a>预编译</h4><p>var a=2;执行分为两个过程：<br>代码执行前先进行预编译，此时只是声明了一个变量a，此时a的值为undefined，当代码运行到a=2时，变量a才会赋值2。<br>总结： 变量的赋值操作会执行两个动作， 首先编译器会在当前作用域中声明一个变量（ 如果之前没有声明过）， 然后在运行时引擎会在作用域中查找该变量， 如果能够找到就会对<br>它赋值。</p>\n<h4 id=\"类型错误\"><a href=\"#类型错误\" class=\"headerlink\" title=\"类型错误\"></a>类型错误</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo(a) &#123;</div><div class=\"line\">console.log( a + b );</div><div class=\"line\">b = a;</div><div class=\"line\">&#125; </div><div class=\"line\">foo( 2 );</div></pre></td></tr></table></figure>\n<p>上述代码在严格模式中 找不到变量b时（此句对应 console.log( a + b )）， 并不会创建并返回一个全局变量， 引擎会抛出一个ReferenceError 异常。在非严格模式下，如果找不到变量b（此句对应b=a，给b赋值时它会看预编译的时候有没有声明b，如果没有声明，在非严格模式下它会声明并给其赋值），在全局作用域中就会创建一个具有该名称的变量b， 并将其返还给引擎</p>\n<p>如果你对一个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用， 或着引用 null 或 undefined 类型的值中的属性， 那么引擎会抛出另外一种类型的异常， 叫作 TypeError。例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a=12;</div><div class=\"line\">var b=null;</div></pre></td></tr></table></figure></p>\n<p>执行a(),b.property或者b.length都会抛出一个TypeError异常。</p>\n<p>总结：ReferenceError 同作用域判别失败相关（在相关作用域内及全局作用域内没有找到变量）， 而 TypeError 则代表作用域判别成功了(在作用域内找到了变量)， 但是对结果的操作是非法或不合理的。</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>作用域是一套规则， 用于确定在何处以及如何查找变量（ 标识符）。 如果查找的目的是对变量进行赋值， 那么就会使用 LHS 查询； 如果目的是获取变量的值， 就会使用 RHS 查询。</p>\n<p>赋值操作符会导致 LHS 查询。 ＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。</p>\n<p>JavaScript 引擎首先会在代码执行前对其进行编译， 在这个过程中， 像 var a = 2 这样的声明会被分解成两个独立的步骤：<br>1.首先， var a 在其作用域中声明新变量。 这会在最开始的阶段， 也就是代码执行前进行。<br>2.接下来， a = 2 会查询（ LHS 查询） 变量 a 并对其进行赋值</p>\n<p>LHS 和 RHS 查询都会在当前执行作用域中开始， 如果有需要（ 也就是说它们没有找到所需的标识符）， 就会向上级作用域继续查找目标标识符， 这样每次上升一级作用域， 最后抵达全局作用域（ 顶层）， 无论找到或没找到都将停止。不成功的 RHS 引用会导致抛出 ReferenceError 异常。 不成功的 LHS 引用会导致自动隐式地创建一个全局变量（ 非严格模式下）， 该变量使用 LHS 引用的目标作为标识符， 或者抛出 ReferenceError 异常（ 严格模式下）</p>\n","excerpt":"","more":"<h4 id=\"预编译\"><a href=\"#预编译\" class=\"headerlink\" title=\"预编译\"></a>预编译</h4><p>var a=2;执行分为两个过程：<br>代码执行前先进行预编译，此时只是声明了一个变量a，此时a的值为undefined，当代码运行到a=2时，变量a才会赋值2。<br>总结： 变量的赋值操作会执行两个动作， 首先编译器会在当前作用域中声明一个变量（ 如果之前没有声明过）， 然后在运行时引擎会在作用域中查找该变量， 如果能够找到就会对<br>它赋值。</p>\n<h4 id=\"类型错误\"><a href=\"#类型错误\" class=\"headerlink\" title=\"类型错误\"></a>类型错误</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo(a) &#123;</div><div class=\"line\">console.log( a + b );</div><div class=\"line\">b = a;</div><div class=\"line\">&#125; </div><div class=\"line\">foo( 2 );</div></pre></td></tr></table></figure>\n<p>上述代码在严格模式中 找不到变量b时（此句对应 console.log( a + b )）， 并不会创建并返回一个全局变量， 引擎会抛出一个ReferenceError 异常。在非严格模式下，如果找不到变量b（此句对应b=a，给b赋值时它会看预编译的时候有没有声明b，如果没有声明，在非严格模式下它会声明并给其赋值），在全局作用域中就会创建一个具有该名称的变量b， 并将其返还给引擎</p>\n<p>如果你对一个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用， 或着引用 null 或 undefined 类型的值中的属性， 那么引擎会抛出另外一种类型的异常， 叫作 TypeError。例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a=12;</div><div class=\"line\">var b=null;</div></pre></td></tr></table></figure></p>\n<p>执行a(),b.property或者b.length都会抛出一个TypeError异常。</p>\n<p>总结：ReferenceError 同作用域判别失败相关（在相关作用域内及全局作用域内没有找到变量）， 而 TypeError 则代表作用域判别成功了(在作用域内找到了变量)， 但是对结果的操作是非法或不合理的。</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>作用域是一套规则， 用于确定在何处以及如何查找变量（ 标识符）。 如果查找的目的是对变量进行赋值， 那么就会使用 LHS 查询； 如果目的是获取变量的值， 就会使用 RHS 查询。</p>\n<p>赋值操作符会导致 LHS 查询。 ＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。</p>\n<p>JavaScript 引擎首先会在代码执行前对其进行编译， 在这个过程中， 像 var a = 2 这样的声明会被分解成两个独立的步骤：<br>1.首先， var a 在其作用域中声明新变量。 这会在最开始的阶段， 也就是代码执行前进行。<br>2.接下来， a = 2 会查询（ LHS 查询） 变量 a 并对其进行赋值</p>\n<p>LHS 和 RHS 查询都会在当前执行作用域中开始， 如果有需要（ 也就是说它们没有找到所需的标识符）， 就会向上级作用域继续查找目标标识符， 这样每次上升一级作用域， 最后抵达全局作用域（ 顶层）， 无论找到或没找到都将停止。不成功的 RHS 引用会导致抛出 ReferenceError 异常。 不成功的 LHS 引用会导致自动隐式地创建一个全局变量（ 非严格模式下）， 该变量使用 LHS 引用的目标作为标识符， 或者抛出 ReferenceError 异常（ 严格模式下）</p>\n"},{"title":"微信小程序之开发文档解读","date":"2017-02-06T07:43:11.000Z","_content":"## 页面构建\n#### 1. 基本逻辑\nWXML 和 WXSS 两种文件是小程序界面元素声明及样式描述文件。 WXML 最大的特点是以视图（ view）的方式串联界面元素，并通过程序逻辑（ AppService），将信息更新实时传递至视图层。\nview 类似于 HTML 中的 div 元素。在构建的时候， view 可以被多级嵌套， view 内可以放置任意视觉元素。需要注意的是，元素一旦超出屏幕之外，用户是无法再看到的，这与 HTML 有较大不同。举一个例子，将手机屏幕想像成一个舞台，在舞台之外的演员是无法被观众看到的。\n\n小程序有专门用于滚动的视图，如果希望界面是一个可以自由滚动的界面（例如列表等），可以使用 scroll-view 视图，在 WXSS中将其大小调整为整个屏幕，并设置 scroll-y（上下滚动）或\nscroll-x（左右滚动）为 true。\n```\n<scroll-view scroll-y=\"true\">\n    <view>Hello World</view>\n</scroll-view>\n```\n小程序中不能直接使用 DOM 控制 WXML 元素。如果需要进行数据更新，需要使用 WXML 提供的数据绑定及元素渲染方法。还有一点需要注意的是：小程序的栅格排版系统使用的是 Flex\n布局，它是 W3C 在 2009 年提出的一种排版标准。\n#### 2. 绑定数据\n对于单个字段，开发者可以使用数据绑定的方法进行信息更新。绑定的数据除了在加载的时候可以更新，也可以在 JS 主程序中以函数形式进行更新，更新同样可以反映到界面上被绑定的数据中。\n\n#### 3. 条件渲染与列表（循环）渲染\n条件渲染适合带有意外情况提示的页面（如无法加载列表或详情时做出提示等等）。它的渲染带有触发条件，即符合条件时渲染这个页面，否则忽略或渲染另一段代码。\n```\n<view wx:if=\"{{ boyname == 'Tom' }}\">Hello,\nTom!</view>\n<view wx:elif=\"{{ girlname == 'Anna' }}\">Hello,\nAnna!</view>\n<view wx:else>You neither Tom nor Anna.</view>\n```\n两个花括号所包含的判断条件中的变量于主程序 JS 代码中的data 中声明。\n```\nPage({\ndata: {\nboyname: 'Tom',\ngirlname: 'Anna'\n}\n})\n```\n若需要在界面中构建一个列表，可以使用 WXML 中的循环渲染，将同一元素渲染代码进行集合。循环的数据可以通过数组的方式写入data 中供 WXML 访问。\n```\n<view wx:for=\"{{array}}\">\n{{index}}: {{item.message}}\n</view>\nPage({\ndata: {\narray: [{\nmessage: 'foo',\n}, {\nmessage: 'bar'\n}]\n}\n})\n```\n渲染完毕后，渲染判断条件的变动可以影响界面变动。\n\n#### 4. 模板与引用\nWXML 支持使用模板与引用减少代码体积。模板是在 WXML 代码中对相同的代码进行复用的方式。可以将多个模板写入至同一文件，并使用 import 在其他文件中进行引用。\n```\n<template name=\"grettings\">\n<view>\n<text>Hello, {{name}}</text>\n</view>\n</template>//some other codes\n<template is=\"grettings\" data=\"{{...name}}\" />\n```\n如果需要整个页面引用，需要使用到 include。\n```\n<include src=\"header.wxml\"/>\n<view> body </view>\n<include src=\"footer.wxml\"/>\n```\n\n#### 5. 样式\n通过 WXSS 样式表，开发者可以定义 WXML 中的元素样式。WXSS 与 CSS 代码一样，可以直接使用选择器选择元素。在 WXML中也可以直接定义元素的 id 和 class 以便于在 WXSS 文件中进\n行样式定义。\n\n#### 6. 用户操作与事件响应\n由于微信使用的不是 HTML，所以也不能通过添加超链接（ a 元素）的方式来监测用户的点击事件。对于需要监听点击事件的元素，应该在 WXML 中使用 bindtap 属性或 catchtap 属性进行绑定。\n```\n<view bindtap=\"tapName\"> Click me! </view>\n```\n除了点击一次，微信也提供按住、开始触摸、松手等事件响应在 WXML 中绑定好一个事件之后，就能在主程序 JS 中使用。\n```\nPage({\ntapName: function(someThingHere){\n// 执行这部分代码\n}\n})\n```\n其他 API 中也有其他相应的事件，这些事件可以在微信小程序的官方文档中查阅到。当 需 要 在 小 程 序 的 页 面 间 进 行 跳 转 时 ， 应 该 使 用wx.navigateTo() 方式。\n```\ntapName: function() {\nwx.navigateTo({\nurl: '../logs/logs'\n})\n}\n```\n需要注意的是，有关于页面层级跳转，微信将层级跳转限制到了五层。在开发时需要注意是否超过了相应限制。\n\n## 网络访问\n小程序支持三种请求方式。一种是直接的 HTTP 连接请求，请求后直接返回结果，连接结束。另一种是 Socket 持续性连接，当一方主动关闭连接时，连接结束。除了以上两种收发纯文本的连接方式，微信还提供了一个文件收发接口。小程序中录制的语音以及选择的照片都需要这个方式来进行上传。通过小程序访问网络需要服务器端必须支持 HTTPS 安全连接，且端口号必须为 443。同时，小程序只能访问开发者在登记小程序时所设定的服务器地址。\n\n## 多媒体与存储\n若需在小程序中播放多媒体（包括音视频）或进行数据存储，不能使用 HTML 5 中所提供的标准，必须使用微信提供的小程序多媒体播放控制接口及存储接口等。\n有关于声音的接口有音频播放与音乐播放两种接口。音频播放提供了播放、暂停和停止播放三种接口，不提供跳转至某个播放时间点的功能，也不能获取目前的播放进度。音乐播放接口提供除以上的基础播放控制外的音乐状态检查和监听等功能。小程序提供照片和视频数据交换接口。通过这个接口，小程序可以访问用户选定或拍摄的照片与视频。通过音频录制和视频照片接口获得的多媒体信息是临时的，需要通过小程序存储文件接口对文件进行永久保存。对于文本数据，小程序也提供了存储这类数据的接口。从诸如Android 或其他 app 平台转向的开发者需要注意的是，小程序不提供数据库式的本地数据保存形式，而是通过 「字段 - 值」的一对一形式进行保存。\n\n## 硬件相关\n小程序依托于微信，提供许多与硬件有关的 API。以下数据，小程序可以通过 API 获取到。\n1.系统相关信息（包括网络状态、设备型号、窗口尺寸等）\n2.重力感应数据\n3.罗盘数据\n通过以上 API，应该可以轻松写出「摇一摇」等互动性页面。但需要注意：由于这些数据只能主动获取，而不能通过这些数值变化的回调实时获取。\n\n## 推送服务\n小程序提供有推送服务，可以随时向用户发送必要的通知。但请注意，推送服务只能用于通知提醒，不能用于群发。小程序中，推送服务叫做「模板消息」（之前有开发过服务号的开发者应该比较熟悉）。开发者需要在微信小程序后台登记新的模板推送消息（比如：购买成功通知等）并审核通过后，才能在小程序中使用模板消息推送服务，具体审核标准建议参考相应文档。模板消息审核通过后，开发者需要先向微信服务器获取 Access Token，随后将该值、模板编号和模板中的动态变量（比如：订单号、价格等）提交给微信，由微信向用户推送通知。\n\n## 用户信息与微信支付\n小程序可以在用户同意的前提下获取到用户的信息。小程序首先要通过微信登录的接口，让用户授权登录。之后，小程序就可以展示并使用用户信息。使用微信登录的时候需要注意，消息需要经过签名确认其完整性之后，方能保证数据未经篡改。小程序中也可以使用微信支付。需要注意的是在发送支付请求时，需要在发送的消息中添加签名，以确认消息完整性。\n\n如果开发过程中遇到问题，最好的办法还是查阅微信官方的小程序开发文档，相信在文档中，你能找到绝大部分问题的解决办法。","source":"_posts/wxapp1.md","raw":"---\ntitle: 微信小程序之开发文档解读\ndate: 2017-02-06 15:43:11\ntags: wxapp\n---\n## 页面构建\n#### 1. 基本逻辑\nWXML 和 WXSS 两种文件是小程序界面元素声明及样式描述文件。 WXML 最大的特点是以视图（ view）的方式串联界面元素，并通过程序逻辑（ AppService），将信息更新实时传递至视图层。\nview 类似于 HTML 中的 div 元素。在构建的时候， view 可以被多级嵌套， view 内可以放置任意视觉元素。需要注意的是，元素一旦超出屏幕之外，用户是无法再看到的，这与 HTML 有较大不同。举一个例子，将手机屏幕想像成一个舞台，在舞台之外的演员是无法被观众看到的。\n\n小程序有专门用于滚动的视图，如果希望界面是一个可以自由滚动的界面（例如列表等），可以使用 scroll-view 视图，在 WXSS中将其大小调整为整个屏幕，并设置 scroll-y（上下滚动）或\nscroll-x（左右滚动）为 true。\n```\n<scroll-view scroll-y=\"true\">\n    <view>Hello World</view>\n</scroll-view>\n```\n小程序中不能直接使用 DOM 控制 WXML 元素。如果需要进行数据更新，需要使用 WXML 提供的数据绑定及元素渲染方法。还有一点需要注意的是：小程序的栅格排版系统使用的是 Flex\n布局，它是 W3C 在 2009 年提出的一种排版标准。\n#### 2. 绑定数据\n对于单个字段，开发者可以使用数据绑定的方法进行信息更新。绑定的数据除了在加载的时候可以更新，也可以在 JS 主程序中以函数形式进行更新，更新同样可以反映到界面上被绑定的数据中。\n\n#### 3. 条件渲染与列表（循环）渲染\n条件渲染适合带有意外情况提示的页面（如无法加载列表或详情时做出提示等等）。它的渲染带有触发条件，即符合条件时渲染这个页面，否则忽略或渲染另一段代码。\n```\n<view wx:if=\"{{ boyname == 'Tom' }}\">Hello,\nTom!</view>\n<view wx:elif=\"{{ girlname == 'Anna' }}\">Hello,\nAnna!</view>\n<view wx:else>You neither Tom nor Anna.</view>\n```\n两个花括号所包含的判断条件中的变量于主程序 JS 代码中的data 中声明。\n```\nPage({\ndata: {\nboyname: 'Tom',\ngirlname: 'Anna'\n}\n})\n```\n若需要在界面中构建一个列表，可以使用 WXML 中的循环渲染，将同一元素渲染代码进行集合。循环的数据可以通过数组的方式写入data 中供 WXML 访问。\n```\n<view wx:for=\"{{array}}\">\n{{index}}: {{item.message}}\n</view>\nPage({\ndata: {\narray: [{\nmessage: 'foo',\n}, {\nmessage: 'bar'\n}]\n}\n})\n```\n渲染完毕后，渲染判断条件的变动可以影响界面变动。\n\n#### 4. 模板与引用\nWXML 支持使用模板与引用减少代码体积。模板是在 WXML 代码中对相同的代码进行复用的方式。可以将多个模板写入至同一文件，并使用 import 在其他文件中进行引用。\n```\n<template name=\"grettings\">\n<view>\n<text>Hello, {{name}}</text>\n</view>\n</template>//some other codes\n<template is=\"grettings\" data=\"{{...name}}\" />\n```\n如果需要整个页面引用，需要使用到 include。\n```\n<include src=\"header.wxml\"/>\n<view> body </view>\n<include src=\"footer.wxml\"/>\n```\n\n#### 5. 样式\n通过 WXSS 样式表，开发者可以定义 WXML 中的元素样式。WXSS 与 CSS 代码一样，可以直接使用选择器选择元素。在 WXML中也可以直接定义元素的 id 和 class 以便于在 WXSS 文件中进\n行样式定义。\n\n#### 6. 用户操作与事件响应\n由于微信使用的不是 HTML，所以也不能通过添加超链接（ a 元素）的方式来监测用户的点击事件。对于需要监听点击事件的元素，应该在 WXML 中使用 bindtap 属性或 catchtap 属性进行绑定。\n```\n<view bindtap=\"tapName\"> Click me! </view>\n```\n除了点击一次，微信也提供按住、开始触摸、松手等事件响应在 WXML 中绑定好一个事件之后，就能在主程序 JS 中使用。\n```\nPage({\ntapName: function(someThingHere){\n// 执行这部分代码\n}\n})\n```\n其他 API 中也有其他相应的事件，这些事件可以在微信小程序的官方文档中查阅到。当 需 要 在 小 程 序 的 页 面 间 进 行 跳 转 时 ， 应 该 使 用wx.navigateTo() 方式。\n```\ntapName: function() {\nwx.navigateTo({\nurl: '../logs/logs'\n})\n}\n```\n需要注意的是，有关于页面层级跳转，微信将层级跳转限制到了五层。在开发时需要注意是否超过了相应限制。\n\n## 网络访问\n小程序支持三种请求方式。一种是直接的 HTTP 连接请求，请求后直接返回结果，连接结束。另一种是 Socket 持续性连接，当一方主动关闭连接时，连接结束。除了以上两种收发纯文本的连接方式，微信还提供了一个文件收发接口。小程序中录制的语音以及选择的照片都需要这个方式来进行上传。通过小程序访问网络需要服务器端必须支持 HTTPS 安全连接，且端口号必须为 443。同时，小程序只能访问开发者在登记小程序时所设定的服务器地址。\n\n## 多媒体与存储\n若需在小程序中播放多媒体（包括音视频）或进行数据存储，不能使用 HTML 5 中所提供的标准，必须使用微信提供的小程序多媒体播放控制接口及存储接口等。\n有关于声音的接口有音频播放与音乐播放两种接口。音频播放提供了播放、暂停和停止播放三种接口，不提供跳转至某个播放时间点的功能，也不能获取目前的播放进度。音乐播放接口提供除以上的基础播放控制外的音乐状态检查和监听等功能。小程序提供照片和视频数据交换接口。通过这个接口，小程序可以访问用户选定或拍摄的照片与视频。通过音频录制和视频照片接口获得的多媒体信息是临时的，需要通过小程序存储文件接口对文件进行永久保存。对于文本数据，小程序也提供了存储这类数据的接口。从诸如Android 或其他 app 平台转向的开发者需要注意的是，小程序不提供数据库式的本地数据保存形式，而是通过 「字段 - 值」的一对一形式进行保存。\n\n## 硬件相关\n小程序依托于微信，提供许多与硬件有关的 API。以下数据，小程序可以通过 API 获取到。\n1.系统相关信息（包括网络状态、设备型号、窗口尺寸等）\n2.重力感应数据\n3.罗盘数据\n通过以上 API，应该可以轻松写出「摇一摇」等互动性页面。但需要注意：由于这些数据只能主动获取，而不能通过这些数值变化的回调实时获取。\n\n## 推送服务\n小程序提供有推送服务，可以随时向用户发送必要的通知。但请注意，推送服务只能用于通知提醒，不能用于群发。小程序中，推送服务叫做「模板消息」（之前有开发过服务号的开发者应该比较熟悉）。开发者需要在微信小程序后台登记新的模板推送消息（比如：购买成功通知等）并审核通过后，才能在小程序中使用模板消息推送服务，具体审核标准建议参考相应文档。模板消息审核通过后，开发者需要先向微信服务器获取 Access Token，随后将该值、模板编号和模板中的动态变量（比如：订单号、价格等）提交给微信，由微信向用户推送通知。\n\n## 用户信息与微信支付\n小程序可以在用户同意的前提下获取到用户的信息。小程序首先要通过微信登录的接口，让用户授权登录。之后，小程序就可以展示并使用用户信息。使用微信登录的时候需要注意，消息需要经过签名确认其完整性之后，方能保证数据未经篡改。小程序中也可以使用微信支付。需要注意的是在发送支付请求时，需要在发送的消息中添加签名，以确认消息完整性。\n\n如果开发过程中遇到问题，最好的办法还是查阅微信官方的小程序开发文档，相信在文档中，你能找到绝大部分问题的解决办法。","slug":"wxapp1","published":1,"updated":"2017-02-06T08:03:53.948Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciyxtqww20005istuy0agsri4","content":"<h2 id=\"页面构建\"><a href=\"#页面构建\" class=\"headerlink\" title=\"页面构建\"></a>页面构建</h2><h4 id=\"1-基本逻辑\"><a href=\"#1-基本逻辑\" class=\"headerlink\" title=\"1. 基本逻辑\"></a>1. 基本逻辑</h4><p>WXML 和 WXSS 两种文件是小程序界面元素声明及样式描述文件。 WXML 最大的特点是以视图（ view）的方式串联界面元素，并通过程序逻辑（ AppService），将信息更新实时传递至视图层。<br>view 类似于 HTML 中的 div 元素。在构建的时候， view 可以被多级嵌套， view 内可以放置任意视觉元素。需要注意的是，元素一旦超出屏幕之外，用户是无法再看到的，这与 HTML 有较大不同。举一个例子，将手机屏幕想像成一个舞台，在舞台之外的演员是无法被观众看到的。</p>\n<p>小程序有专门用于滚动的视图，如果希望界面是一个可以自由滚动的界面（例如列表等），可以使用 scroll-view 视图，在 WXSS中将其大小调整为整个屏幕，并设置 scroll-y（上下滚动）或<br>scroll-x（左右滚动）为 true。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;scroll-view scroll-y=&quot;true&quot;&gt;</div><div class=\"line\">    &lt;view&gt;Hello World&lt;/view&gt;</div><div class=\"line\">&lt;/scroll-view&gt;</div></pre></td></tr></table></figure></p>\n<p>小程序中不能直接使用 DOM 控制 WXML 元素。如果需要进行数据更新，需要使用 WXML 提供的数据绑定及元素渲染方法。还有一点需要注意的是：小程序的栅格排版系统使用的是 Flex<br>布局，它是 W3C 在 2009 年提出的一种排版标准。</p>\n<h4 id=\"2-绑定数据\"><a href=\"#2-绑定数据\" class=\"headerlink\" title=\"2. 绑定数据\"></a>2. 绑定数据</h4><p>对于单个字段，开发者可以使用数据绑定的方法进行信息更新。绑定的数据除了在加载的时候可以更新，也可以在 JS 主程序中以函数形式进行更新，更新同样可以反映到界面上被绑定的数据中。</p>\n<h4 id=\"3-条件渲染与列表（循环）渲染\"><a href=\"#3-条件渲染与列表（循环）渲染\" class=\"headerlink\" title=\"3. 条件渲染与列表（循环）渲染\"></a>3. 条件渲染与列表（循环）渲染</h4><p>条件渲染适合带有意外情况提示的页面（如无法加载列表或详情时做出提示等等）。它的渲染带有触发条件，即符合条件时渲染这个页面，否则忽略或渲染另一段代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;view wx:if=&quot;&#123;&#123; boyname == &apos;Tom&apos; &#125;&#125;&quot;&gt;Hello,</div><div class=\"line\">Tom!&lt;/view&gt;</div><div class=\"line\">&lt;view wx:elif=&quot;&#123;&#123; girlname == &apos;Anna&apos; &#125;&#125;&quot;&gt;Hello,</div><div class=\"line\">Anna!&lt;/view&gt;</div><div class=\"line\">&lt;view wx:else&gt;You neither Tom nor Anna.&lt;/view&gt;</div></pre></td></tr></table></figure></p>\n<p>两个花括号所包含的判断条件中的变量于主程序 JS 代码中的data 中声明。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Page(&#123;</div><div class=\"line\">data: &#123;</div><div class=\"line\">boyname: &apos;Tom&apos;,</div><div class=\"line\">girlname: &apos;Anna&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>若需要在界面中构建一个列表，可以使用 WXML 中的循环渲染，将同一元素渲染代码进行集合。循环的数据可以通过数组的方式写入data 中供 WXML 访问。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;&gt;</div><div class=\"line\">&#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">Page(&#123;</div><div class=\"line\">data: &#123;</div><div class=\"line\">array: [&#123;</div><div class=\"line\">message: &apos;foo&apos;,</div><div class=\"line\">&#125;, &#123;</div><div class=\"line\">message: &apos;bar&apos;</div><div class=\"line\">&#125;]</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>渲染完毕后，渲染判断条件的变动可以影响界面变动。</p>\n<h4 id=\"4-模板与引用\"><a href=\"#4-模板与引用\" class=\"headerlink\" title=\"4. 模板与引用\"></a>4. 模板与引用</h4><p>WXML 支持使用模板与引用减少代码体积。模板是在 WXML 代码中对相同的代码进行复用的方式。可以将多个模板写入至同一文件，并使用 import 在其他文件中进行引用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;template name=&quot;grettings&quot;&gt;</div><div class=\"line\">&lt;view&gt;</div><div class=\"line\">&lt;text&gt;Hello, &#123;&#123;name&#125;&#125;&lt;/text&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">&lt;/template&gt;//some other codes</div><div class=\"line\">&lt;template is=&quot;grettings&quot; data=&quot;&#123;&#123;...name&#125;&#125;&quot; /&gt;</div></pre></td></tr></table></figure></p>\n<p>如果需要整个页面引用，需要使用到 include。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;include src=&quot;header.wxml&quot;/&gt;</div><div class=\"line\">&lt;view&gt; body &lt;/view&gt;</div><div class=\"line\">&lt;include src=&quot;footer.wxml&quot;/&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"5-样式\"><a href=\"#5-样式\" class=\"headerlink\" title=\"5. 样式\"></a>5. 样式</h4><p>通过 WXSS 样式表，开发者可以定义 WXML 中的元素样式。WXSS 与 CSS 代码一样，可以直接使用选择器选择元素。在 WXML中也可以直接定义元素的 id 和 class 以便于在 WXSS 文件中进<br>行样式定义。</p>\n<h4 id=\"6-用户操作与事件响应\"><a href=\"#6-用户操作与事件响应\" class=\"headerlink\" title=\"6. 用户操作与事件响应\"></a>6. 用户操作与事件响应</h4><p>由于微信使用的不是 HTML，所以也不能通过添加超链接（ a 元素）的方式来监测用户的点击事件。对于需要监听点击事件的元素，应该在 WXML 中使用 bindtap 属性或 catchtap 属性进行绑定。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;view bindtap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt;</div></pre></td></tr></table></figure></p>\n<p>除了点击一次，微信也提供按住、开始触摸、松手等事件响应在 WXML 中绑定好一个事件之后，就能在主程序 JS 中使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Page(&#123;</div><div class=\"line\">tapName: function(someThingHere)&#123;</div><div class=\"line\">// 执行这部分代码</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>其他 API 中也有其他相应的事件，这些事件可以在微信小程序的官方文档中查阅到。当 需 要 在 小 程 序 的 页 面 间 进 行 跳 转 时 ， 应 该 使 用wx.navigateTo() 方式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">tapName: function() &#123;</div><div class=\"line\">wx.navigateTo(&#123;</div><div class=\"line\">url: &apos;../logs/logs&apos;</div><div class=\"line\">&#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>需要注意的是，有关于页面层级跳转，微信将层级跳转限制到了五层。在开发时需要注意是否超过了相应限制。</p>\n<h2 id=\"网络访问\"><a href=\"#网络访问\" class=\"headerlink\" title=\"网络访问\"></a>网络访问</h2><p>小程序支持三种请求方式。一种是直接的 HTTP 连接请求，请求后直接返回结果，连接结束。另一种是 Socket 持续性连接，当一方主动关闭连接时，连接结束。除了以上两种收发纯文本的连接方式，微信还提供了一个文件收发接口。小程序中录制的语音以及选择的照片都需要这个方式来进行上传。通过小程序访问网络需要服务器端必须支持 HTTPS 安全连接，且端口号必须为 443。同时，小程序只能访问开发者在登记小程序时所设定的服务器地址。</p>\n<h2 id=\"多媒体与存储\"><a href=\"#多媒体与存储\" class=\"headerlink\" title=\"多媒体与存储\"></a>多媒体与存储</h2><p>若需在小程序中播放多媒体（包括音视频）或进行数据存储，不能使用 HTML 5 中所提供的标准，必须使用微信提供的小程序多媒体播放控制接口及存储接口等。<br>有关于声音的接口有音频播放与音乐播放两种接口。音频播放提供了播放、暂停和停止播放三种接口，不提供跳转至某个播放时间点的功能，也不能获取目前的播放进度。音乐播放接口提供除以上的基础播放控制外的音乐状态检查和监听等功能。小程序提供照片和视频数据交换接口。通过这个接口，小程序可以访问用户选定或拍摄的照片与视频。通过音频录制和视频照片接口获得的多媒体信息是临时的，需要通过小程序存储文件接口对文件进行永久保存。对于文本数据，小程序也提供了存储这类数据的接口。从诸如Android 或其他 app 平台转向的开发者需要注意的是，小程序不提供数据库式的本地数据保存形式，而是通过 「字段 - 值」的一对一形式进行保存。</p>\n<h2 id=\"硬件相关\"><a href=\"#硬件相关\" class=\"headerlink\" title=\"硬件相关\"></a>硬件相关</h2><p>小程序依托于微信，提供许多与硬件有关的 API。以下数据，小程序可以通过 API 获取到。<br>1.系统相关信息（包括网络状态、设备型号、窗口尺寸等）<br>2.重力感应数据<br>3.罗盘数据<br>通过以上 API，应该可以轻松写出「摇一摇」等互动性页面。但需要注意：由于这些数据只能主动获取，而不能通过这些数值变化的回调实时获取。</p>\n<h2 id=\"推送服务\"><a href=\"#推送服务\" class=\"headerlink\" title=\"推送服务\"></a>推送服务</h2><p>小程序提供有推送服务，可以随时向用户发送必要的通知。但请注意，推送服务只能用于通知提醒，不能用于群发。小程序中，推送服务叫做「模板消息」（之前有开发过服务号的开发者应该比较熟悉）。开发者需要在微信小程序后台登记新的模板推送消息（比如：购买成功通知等）并审核通过后，才能在小程序中使用模板消息推送服务，具体审核标准建议参考相应文档。模板消息审核通过后，开发者需要先向微信服务器获取 Access Token，随后将该值、模板编号和模板中的动态变量（比如：订单号、价格等）提交给微信，由微信向用户推送通知。</p>\n<h2 id=\"用户信息与微信支付\"><a href=\"#用户信息与微信支付\" class=\"headerlink\" title=\"用户信息与微信支付\"></a>用户信息与微信支付</h2><p>小程序可以在用户同意的前提下获取到用户的信息。小程序首先要通过微信登录的接口，让用户授权登录。之后，小程序就可以展示并使用用户信息。使用微信登录的时候需要注意，消息需要经过签名确认其完整性之后，方能保证数据未经篡改。小程序中也可以使用微信支付。需要注意的是在发送支付请求时，需要在发送的消息中添加签名，以确认消息完整性。</p>\n<p>如果开发过程中遇到问题，最好的办法还是查阅微信官方的小程序开发文档，相信在文档中，你能找到绝大部分问题的解决办法。</p>\n","excerpt":"","more":"<h2 id=\"页面构建\"><a href=\"#页面构建\" class=\"headerlink\" title=\"页面构建\"></a>页面构建</h2><h4 id=\"1-基本逻辑\"><a href=\"#1-基本逻辑\" class=\"headerlink\" title=\"1. 基本逻辑\"></a>1. 基本逻辑</h4><p>WXML 和 WXSS 两种文件是小程序界面元素声明及样式描述文件。 WXML 最大的特点是以视图（ view）的方式串联界面元素，并通过程序逻辑（ AppService），将信息更新实时传递至视图层。<br>view 类似于 HTML 中的 div 元素。在构建的时候， view 可以被多级嵌套， view 内可以放置任意视觉元素。需要注意的是，元素一旦超出屏幕之外，用户是无法再看到的，这与 HTML 有较大不同。举一个例子，将手机屏幕想像成一个舞台，在舞台之外的演员是无法被观众看到的。</p>\n<p>小程序有专门用于滚动的视图，如果希望界面是一个可以自由滚动的界面（例如列表等），可以使用 scroll-view 视图，在 WXSS中将其大小调整为整个屏幕，并设置 scroll-y（上下滚动）或<br>scroll-x（左右滚动）为 true。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;scroll-view scroll-y=&quot;true&quot;&gt;</div><div class=\"line\">    &lt;view&gt;Hello World&lt;/view&gt;</div><div class=\"line\">&lt;/scroll-view&gt;</div></pre></td></tr></table></figure></p>\n<p>小程序中不能直接使用 DOM 控制 WXML 元素。如果需要进行数据更新，需要使用 WXML 提供的数据绑定及元素渲染方法。还有一点需要注意的是：小程序的栅格排版系统使用的是 Flex<br>布局，它是 W3C 在 2009 年提出的一种排版标准。</p>\n<h4 id=\"2-绑定数据\"><a href=\"#2-绑定数据\" class=\"headerlink\" title=\"2. 绑定数据\"></a>2. 绑定数据</h4><p>对于单个字段，开发者可以使用数据绑定的方法进行信息更新。绑定的数据除了在加载的时候可以更新，也可以在 JS 主程序中以函数形式进行更新，更新同样可以反映到界面上被绑定的数据中。</p>\n<h4 id=\"3-条件渲染与列表（循环）渲染\"><a href=\"#3-条件渲染与列表（循环）渲染\" class=\"headerlink\" title=\"3. 条件渲染与列表（循环）渲染\"></a>3. 条件渲染与列表（循环）渲染</h4><p>条件渲染适合带有意外情况提示的页面（如无法加载列表或详情时做出提示等等）。它的渲染带有触发条件，即符合条件时渲染这个页面，否则忽略或渲染另一段代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;view wx:if=&quot;&#123;&#123; boyname == &apos;Tom&apos; &#125;&#125;&quot;&gt;Hello,</div><div class=\"line\">Tom!&lt;/view&gt;</div><div class=\"line\">&lt;view wx:elif=&quot;&#123;&#123; girlname == &apos;Anna&apos; &#125;&#125;&quot;&gt;Hello,</div><div class=\"line\">Anna!&lt;/view&gt;</div><div class=\"line\">&lt;view wx:else&gt;You neither Tom nor Anna.&lt;/view&gt;</div></pre></td></tr></table></figure></p>\n<p>两个花括号所包含的判断条件中的变量于主程序 JS 代码中的data 中声明。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Page(&#123;</div><div class=\"line\">data: &#123;</div><div class=\"line\">boyname: &apos;Tom&apos;,</div><div class=\"line\">girlname: &apos;Anna&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>若需要在界面中构建一个列表，可以使用 WXML 中的循环渲染，将同一元素渲染代码进行集合。循环的数据可以通过数组的方式写入data 中供 WXML 访问。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;&gt;</div><div class=\"line\">&#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">Page(&#123;</div><div class=\"line\">data: &#123;</div><div class=\"line\">array: [&#123;</div><div class=\"line\">message: &apos;foo&apos;,</div><div class=\"line\">&#125;, &#123;</div><div class=\"line\">message: &apos;bar&apos;</div><div class=\"line\">&#125;]</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>渲染完毕后，渲染判断条件的变动可以影响界面变动。</p>\n<h4 id=\"4-模板与引用\"><a href=\"#4-模板与引用\" class=\"headerlink\" title=\"4. 模板与引用\"></a>4. 模板与引用</h4><p>WXML 支持使用模板与引用减少代码体积。模板是在 WXML 代码中对相同的代码进行复用的方式。可以将多个模板写入至同一文件，并使用 import 在其他文件中进行引用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;template name=&quot;grettings&quot;&gt;</div><div class=\"line\">&lt;view&gt;</div><div class=\"line\">&lt;text&gt;Hello, &#123;&#123;name&#125;&#125;&lt;/text&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">&lt;/template&gt;//some other codes</div><div class=\"line\">&lt;template is=&quot;grettings&quot; data=&quot;&#123;&#123;...name&#125;&#125;&quot; /&gt;</div></pre></td></tr></table></figure></p>\n<p>如果需要整个页面引用，需要使用到 include。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;include src=&quot;header.wxml&quot;/&gt;</div><div class=\"line\">&lt;view&gt; body &lt;/view&gt;</div><div class=\"line\">&lt;include src=&quot;footer.wxml&quot;/&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"5-样式\"><a href=\"#5-样式\" class=\"headerlink\" title=\"5. 样式\"></a>5. 样式</h4><p>通过 WXSS 样式表，开发者可以定义 WXML 中的元素样式。WXSS 与 CSS 代码一样，可以直接使用选择器选择元素。在 WXML中也可以直接定义元素的 id 和 class 以便于在 WXSS 文件中进<br>行样式定义。</p>\n<h4 id=\"6-用户操作与事件响应\"><a href=\"#6-用户操作与事件响应\" class=\"headerlink\" title=\"6. 用户操作与事件响应\"></a>6. 用户操作与事件响应</h4><p>由于微信使用的不是 HTML，所以也不能通过添加超链接（ a 元素）的方式来监测用户的点击事件。对于需要监听点击事件的元素，应该在 WXML 中使用 bindtap 属性或 catchtap 属性进行绑定。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;view bindtap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt;</div></pre></td></tr></table></figure></p>\n<p>除了点击一次，微信也提供按住、开始触摸、松手等事件响应在 WXML 中绑定好一个事件之后，就能在主程序 JS 中使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Page(&#123;</div><div class=\"line\">tapName: function(someThingHere)&#123;</div><div class=\"line\">// 执行这部分代码</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>其他 API 中也有其他相应的事件，这些事件可以在微信小程序的官方文档中查阅到。当 需 要 在 小 程 序 的 页 面 间 进 行 跳 转 时 ， 应 该 使 用wx.navigateTo() 方式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">tapName: function() &#123;</div><div class=\"line\">wx.navigateTo(&#123;</div><div class=\"line\">url: &apos;../logs/logs&apos;</div><div class=\"line\">&#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>需要注意的是，有关于页面层级跳转，微信将层级跳转限制到了五层。在开发时需要注意是否超过了相应限制。</p>\n<h2 id=\"网络访问\"><a href=\"#网络访问\" class=\"headerlink\" title=\"网络访问\"></a>网络访问</h2><p>小程序支持三种请求方式。一种是直接的 HTTP 连接请求，请求后直接返回结果，连接结束。另一种是 Socket 持续性连接，当一方主动关闭连接时，连接结束。除了以上两种收发纯文本的连接方式，微信还提供了一个文件收发接口。小程序中录制的语音以及选择的照片都需要这个方式来进行上传。通过小程序访问网络需要服务器端必须支持 HTTPS 安全连接，且端口号必须为 443。同时，小程序只能访问开发者在登记小程序时所设定的服务器地址。</p>\n<h2 id=\"多媒体与存储\"><a href=\"#多媒体与存储\" class=\"headerlink\" title=\"多媒体与存储\"></a>多媒体与存储</h2><p>若需在小程序中播放多媒体（包括音视频）或进行数据存储，不能使用 HTML 5 中所提供的标准，必须使用微信提供的小程序多媒体播放控制接口及存储接口等。<br>有关于声音的接口有音频播放与音乐播放两种接口。音频播放提供了播放、暂停和停止播放三种接口，不提供跳转至某个播放时间点的功能，也不能获取目前的播放进度。音乐播放接口提供除以上的基础播放控制外的音乐状态检查和监听等功能。小程序提供照片和视频数据交换接口。通过这个接口，小程序可以访问用户选定或拍摄的照片与视频。通过音频录制和视频照片接口获得的多媒体信息是临时的，需要通过小程序存储文件接口对文件进行永久保存。对于文本数据，小程序也提供了存储这类数据的接口。从诸如Android 或其他 app 平台转向的开发者需要注意的是，小程序不提供数据库式的本地数据保存形式，而是通过 「字段 - 值」的一对一形式进行保存。</p>\n<h2 id=\"硬件相关\"><a href=\"#硬件相关\" class=\"headerlink\" title=\"硬件相关\"></a>硬件相关</h2><p>小程序依托于微信，提供许多与硬件有关的 API。以下数据，小程序可以通过 API 获取到。<br>1.系统相关信息（包括网络状态、设备型号、窗口尺寸等）<br>2.重力感应数据<br>3.罗盘数据<br>通过以上 API，应该可以轻松写出「摇一摇」等互动性页面。但需要注意：由于这些数据只能主动获取，而不能通过这些数值变化的回调实时获取。</p>\n<h2 id=\"推送服务\"><a href=\"#推送服务\" class=\"headerlink\" title=\"推送服务\"></a>推送服务</h2><p>小程序提供有推送服务，可以随时向用户发送必要的通知。但请注意，推送服务只能用于通知提醒，不能用于群发。小程序中，推送服务叫做「模板消息」（之前有开发过服务号的开发者应该比较熟悉）。开发者需要在微信小程序后台登记新的模板推送消息（比如：购买成功通知等）并审核通过后，才能在小程序中使用模板消息推送服务，具体审核标准建议参考相应文档。模板消息审核通过后，开发者需要先向微信服务器获取 Access Token，随后将该值、模板编号和模板中的动态变量（比如：订单号、价格等）提交给微信，由微信向用户推送通知。</p>\n<h2 id=\"用户信息与微信支付\"><a href=\"#用户信息与微信支付\" class=\"headerlink\" title=\"用户信息与微信支付\"></a>用户信息与微信支付</h2><p>小程序可以在用户同意的前提下获取到用户的信息。小程序首先要通过微信登录的接口，让用户授权登录。之后，小程序就可以展示并使用用户信息。使用微信登录的时候需要注意，消息需要经过签名确认其完整性之后，方能保证数据未经篡改。小程序中也可以使用微信支付。需要注意的是在发送支付请求时，需要在发送的消息中添加签名，以确认消息完整性。</p>\n<p>如果开发过程中遇到问题，最好的办法还是查阅微信官方的小程序开发文档，相信在文档中，你能找到绝大部分问题的解决办法。</p>\n"},{"title":"微信小程序简单介绍","date":"2017-02-06T02:38:24.000Z","_content":"\n在语言方面，看上去小程序几乎重新定义了一套标准。但是实际上，它们与「前端三件套」 ——HTML、 CSS 和 JavaScript——差不太多。\n#### 对比一下小程序开发语言和「前端三件套」有什么异同点：\n一、 HTML 与 WXML：两者差异比较大，如果之前没有接触过Android 开发，可能会觉得有些头疼。事实上， WXML 更像是 Android 开发中的界面 XML ᧿述文件，更适合于程序界\n面的构建；而 HTML 则倾向于文章的展示（这与 HTML 的历史有关），以及互联网页面的构建。\n二、 WXSS 与 CSS：两者在语言上几乎没有差别，可以直接通用。\n三、 JS 文件：小程序的 JS 文件与前端开发使用的 JS 几乎没有区别，小程序的 JS 新增了微信的一些 API 接口，并去除了一些不必要的功能（如 DOM）。\n\n小程序开发需要学习的语言主要有：\n1. 微信标记语言  （weixin marked language,   wxml）\n2. 微信样式表（weixin style sheet, wxss ）\n3. javascript\n\n\n小程序的界面并非是一个网页，而是一个应用界面，以往网页前端常见的```<div>、<a>```等标签都不复存在，网页前端开发人员需要适应wxml的逻辑和写法。\n\n小程序使用了rpx（responsive pixel）作为尺寸单位（保证不同分辨率设备的元素正常显示），开发人员需要了解rpx与各种长度单位的换算比例。\n\n#### 为什么需要动态单位和 rpx？\n\n我们都知道，小程序是一个跨系统的平台。这就意味着，小程序会在不同的设备上运行，但不同设备的分辨率会有差异。\n在小程序中，如何在分辨率不同的设备上保证视觉元素的正常显示？这就需要名为 rpx 的动态尺寸单位。\n\n在显示屏上，每一个画面都是由无数的点阵形成的。这个点阵中，每一个点叫做像素，就是 pixel（缩写为 px）。这对于很多人来说都是常识。\n\n但是，随着 Retina 屏幕（即「视网膜屏」）的推出和高分屏的普及，1 px 所能代表的实际长度并非是一成不变的。对于跨平台、跨设备的应用来说，单纯使用 px 并不能满足需要。因为，这很难保证小程序的元素，能在不同设备上正常显示——同样 px 尺寸的元素，在高分屏上显示会明显要比在低分屏显得更小。因此，我们需要一个动态的长度单位。这个单位通过对不同屏幕的分辨率进行调整和适配，保证相同元素在不同屏幕上的展示是正常的。\n\n<font color=red face=“黑体”>苹果和 Google 对此都有相应的措施：</font>\n\n1.由于苹果对高分屏的优化良好，所以在 iOS 上，代码中的 1 px 所代表的实际像素数会根据不同设备动态调整，开发者不需要进行二次换算。\n2.由于 Android 设备碎片化严重，Google 不得不建立了一个新的名叫「density-independent pixel（密度无关像素，缩写为 dp）」的尺寸单位，以适应不同分辨率屏幕的尺寸换算。\n\n微信也为小程序提供了一个动态单位解决方案：它就是 responsive pixel（动态像素），简称 rpx。\n\n<font color='red'>Pixel与rpx、dp之间的换算</font>\n\n动态单位与 px 换算的基本概念是：选择一个分辨率作为基准，在基准分辨率中，一个像素点显示有多长，在其他屏幕上会显示同样长度。\n例如，dp 与 px 换算公式是：dp = px * (目标设备 dpi 分辨率 / 160)。\n但微信小程序的 rpx 换算方式，会与其他动态单位的换算方法有些出入。微信官方提供的换算方式更「傻瓜」一些：rpx = px * (目标设备宽 px 值 / 750)。\n\n<font color=red face=“黑体”>例如：</font>\n\n目标设备的宽度如果是 375px，按照 750rpx 进行换算，则等于 1rpx = 0.5px\n目标设备的宽度如果是 1125px，换算后 1rpx = 1.5px\n\n没错，如果将微信小程序放到平板电脑上运行，屏幕的宽度 px 值有可能会变化（横竖屏、分屏模式等等）。这时候，再以宽度为基准，就会出现元素显示不正确的问题。从这一点可以看出，微信团队目前并不希望将小程序扩展到手机以外的设备中。因此，开发者暂时可以专注于提高小程序在手机上的体验，无需担心多尺寸屏幕带来的适配问题。\n\n<font color=red face=“黑体”>那能不能直接让 rpx 和 dp 进行互换呢？当然不能！</font>\n\ndp 是以屏幕分辨率为基准的动态单位，而 rpx 是以长度为基准的动态单位。就像「米」和「平方厘米」不能互换一样，dp 和 rpx 两者也是不能直接进行互换的，除非微信官方将 rpx 设定为分辨率基准而非长度基准。\n\n#### 设计师该怎么做？\n由于微信使用了 rpx 动态单位，设计稿的尺寸单位也推荐使用 rpx。\n\n那么问题来了，如果要改用 rpx 单位，以什么尺寸的屏幕作为设计稿标准会比较合适呢？\n\n在微信官方的文档中，我们看到下面这样一句话：\n\n在 iPhone 6 上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx = 375px = 750 物理像素，1rpx = 0.5px = 1 物理像素。\n\n开发微信小程序时设计师可以用 iPhone 6 作为视觉稿的标准。\n也就是说，设计师在设计小程序时，可以这样做：\n直接以 iPhone 6 的屏幕尺寸（375×667）用作视觉稿尺寸，1 px = 0.5 rpx；\n以 1 px = 1 rpx 的标准，将设计稿尺寸设定为 750×1334。\n在将设计稿转交给开发人员之前，设计师需要清楚地描述设计稿尺寸和单位换算标准等，以便开发人员快速实现界面效果。\n\n","source":"_posts/wxappintroduction.md","raw":"---\ntitle: 微信小程序简单介绍\ndate: 2017-02-06 10:38:24\ntags: wxapp\n---\n\n在语言方面，看上去小程序几乎重新定义了一套标准。但是实际上，它们与「前端三件套」 ——HTML、 CSS 和 JavaScript——差不太多。\n#### 对比一下小程序开发语言和「前端三件套」有什么异同点：\n一、 HTML 与 WXML：两者差异比较大，如果之前没有接触过Android 开发，可能会觉得有些头疼。事实上， WXML 更像是 Android 开发中的界面 XML ᧿述文件，更适合于程序界\n面的构建；而 HTML 则倾向于文章的展示（这与 HTML 的历史有关），以及互联网页面的构建。\n二、 WXSS 与 CSS：两者在语言上几乎没有差别，可以直接通用。\n三、 JS 文件：小程序的 JS 文件与前端开发使用的 JS 几乎没有区别，小程序的 JS 新增了微信的一些 API 接口，并去除了一些不必要的功能（如 DOM）。\n\n小程序开发需要学习的语言主要有：\n1. 微信标记语言  （weixin marked language,   wxml）\n2. 微信样式表（weixin style sheet, wxss ）\n3. javascript\n\n\n小程序的界面并非是一个网页，而是一个应用界面，以往网页前端常见的```<div>、<a>```等标签都不复存在，网页前端开发人员需要适应wxml的逻辑和写法。\n\n小程序使用了rpx（responsive pixel）作为尺寸单位（保证不同分辨率设备的元素正常显示），开发人员需要了解rpx与各种长度单位的换算比例。\n\n#### 为什么需要动态单位和 rpx？\n\n我们都知道，小程序是一个跨系统的平台。这就意味着，小程序会在不同的设备上运行，但不同设备的分辨率会有差异。\n在小程序中，如何在分辨率不同的设备上保证视觉元素的正常显示？这就需要名为 rpx 的动态尺寸单位。\n\n在显示屏上，每一个画面都是由无数的点阵形成的。这个点阵中，每一个点叫做像素，就是 pixel（缩写为 px）。这对于很多人来说都是常识。\n\n但是，随着 Retina 屏幕（即「视网膜屏」）的推出和高分屏的普及，1 px 所能代表的实际长度并非是一成不变的。对于跨平台、跨设备的应用来说，单纯使用 px 并不能满足需要。因为，这很难保证小程序的元素，能在不同设备上正常显示——同样 px 尺寸的元素，在高分屏上显示会明显要比在低分屏显得更小。因此，我们需要一个动态的长度单位。这个单位通过对不同屏幕的分辨率进行调整和适配，保证相同元素在不同屏幕上的展示是正常的。\n\n<font color=red face=“黑体”>苹果和 Google 对此都有相应的措施：</font>\n\n1.由于苹果对高分屏的优化良好，所以在 iOS 上，代码中的 1 px 所代表的实际像素数会根据不同设备动态调整，开发者不需要进行二次换算。\n2.由于 Android 设备碎片化严重，Google 不得不建立了一个新的名叫「density-independent pixel（密度无关像素，缩写为 dp）」的尺寸单位，以适应不同分辨率屏幕的尺寸换算。\n\n微信也为小程序提供了一个动态单位解决方案：它就是 responsive pixel（动态像素），简称 rpx。\n\n<font color='red'>Pixel与rpx、dp之间的换算</font>\n\n动态单位与 px 换算的基本概念是：选择一个分辨率作为基准，在基准分辨率中，一个像素点显示有多长，在其他屏幕上会显示同样长度。\n例如，dp 与 px 换算公式是：dp = px * (目标设备 dpi 分辨率 / 160)。\n但微信小程序的 rpx 换算方式，会与其他动态单位的换算方法有些出入。微信官方提供的换算方式更「傻瓜」一些：rpx = px * (目标设备宽 px 值 / 750)。\n\n<font color=red face=“黑体”>例如：</font>\n\n目标设备的宽度如果是 375px，按照 750rpx 进行换算，则等于 1rpx = 0.5px\n目标设备的宽度如果是 1125px，换算后 1rpx = 1.5px\n\n没错，如果将微信小程序放到平板电脑上运行，屏幕的宽度 px 值有可能会变化（横竖屏、分屏模式等等）。这时候，再以宽度为基准，就会出现元素显示不正确的问题。从这一点可以看出，微信团队目前并不希望将小程序扩展到手机以外的设备中。因此，开发者暂时可以专注于提高小程序在手机上的体验，无需担心多尺寸屏幕带来的适配问题。\n\n<font color=red face=“黑体”>那能不能直接让 rpx 和 dp 进行互换呢？当然不能！</font>\n\ndp 是以屏幕分辨率为基准的动态单位，而 rpx 是以长度为基准的动态单位。就像「米」和「平方厘米」不能互换一样，dp 和 rpx 两者也是不能直接进行互换的，除非微信官方将 rpx 设定为分辨率基准而非长度基准。\n\n#### 设计师该怎么做？\n由于微信使用了 rpx 动态单位，设计稿的尺寸单位也推荐使用 rpx。\n\n那么问题来了，如果要改用 rpx 单位，以什么尺寸的屏幕作为设计稿标准会比较合适呢？\n\n在微信官方的文档中，我们看到下面这样一句话：\n\n在 iPhone 6 上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx = 375px = 750 物理像素，1rpx = 0.5px = 1 物理像素。\n\n开发微信小程序时设计师可以用 iPhone 6 作为视觉稿的标准。\n也就是说，设计师在设计小程序时，可以这样做：\n直接以 iPhone 6 的屏幕尺寸（375×667）用作视觉稿尺寸，1 px = 0.5 rpx；\n以 1 px = 1 rpx 的标准，将设计稿尺寸设定为 750×1334。\n在将设计稿转交给开发人员之前，设计师需要清楚地描述设计稿尺寸和单位换算标准等，以便开发人员快速实现界面效果。\n\n","slug":"wxappintroduction","published":1,"updated":"2017-02-06T07:44:12.612Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciyxtqww70008istucf0niihh","content":"<p>在语言方面，看上去小程序几乎重新定义了一套标准。但是实际上，它们与「前端三件套」 ——HTML、 CSS 和 JavaScript——差不太多。</p>\n<h4 id=\"对比一下小程序开发语言和「前端三件套」有什么异同点：\"><a href=\"#对比一下小程序开发语言和「前端三件套」有什么异同点：\" class=\"headerlink\" title=\"对比一下小程序开发语言和「前端三件套」有什么异同点：\"></a>对比一下小程序开发语言和「前端三件套」有什么异同点：</h4><p>一、 HTML 与 WXML：两者差异比较大，如果之前没有接触过Android 开发，可能会觉得有些头疼。事实上， WXML 更像是 Android 开发中的界面 XML ᧿述文件，更适合于程序界<br>面的构建；而 HTML 则倾向于文章的展示（这与 HTML 的历史有关），以及互联网页面的构建。<br>二、 WXSS 与 CSS：两者在语言上几乎没有差别，可以直接通用。<br>三、 JS 文件：小程序的 JS 文件与前端开发使用的 JS 几乎没有区别，小程序的 JS 新增了微信的一些 API 接口，并去除了一些不必要的功能（如 DOM）。</p>\n<p>小程序开发需要学习的语言主要有：</p>\n<ol>\n<li>微信标记语言  （weixin marked language,   wxml）</li>\n<li>微信样式表（weixin style sheet, wxss ）</li>\n<li>javascript</li>\n</ol>\n<p>小程序的界面并非是一个网页，而是一个应用界面，以往网页前端常见的<code>&lt;div&gt;、&lt;a&gt;</code>等标签都不复存在，网页前端开发人员需要适应wxml的逻辑和写法。</p>\n<p>小程序使用了rpx（responsive pixel）作为尺寸单位（保证不同分辨率设备的元素正常显示），开发人员需要了解rpx与各种长度单位的换算比例。</p>\n<h4 id=\"为什么需要动态单位和-rpx？\"><a href=\"#为什么需要动态单位和-rpx？\" class=\"headerlink\" title=\"为什么需要动态单位和 rpx？\"></a>为什么需要动态单位和 rpx？</h4><p>我们都知道，小程序是一个跨系统的平台。这就意味着，小程序会在不同的设备上运行，但不同设备的分辨率会有差异。<br>在小程序中，如何在分辨率不同的设备上保证视觉元素的正常显示？这就需要名为 rpx 的动态尺寸单位。</p>\n<p>在显示屏上，每一个画面都是由无数的点阵形成的。这个点阵中，每一个点叫做像素，就是 pixel（缩写为 px）。这对于很多人来说都是常识。</p>\n<p>但是，随着 Retina 屏幕（即「视网膜屏」）的推出和高分屏的普及，1 px 所能代表的实际长度并非是一成不变的。对于跨平台、跨设备的应用来说，单纯使用 px 并不能满足需要。因为，这很难保证小程序的元素，能在不同设备上正常显示——同样 px 尺寸的元素，在高分屏上显示会明显要比在低分屏显得更小。因此，我们需要一个动态的长度单位。这个单位通过对不同屏幕的分辨率进行调整和适配，保证相同元素在不同屏幕上的展示是正常的。</p>\n<font color=\"red\" face=\"“黑体”\">苹果和 Google 对此都有相应的措施：</font>\n\n<p>1.由于苹果对高分屏的优化良好，所以在 iOS 上，代码中的 1 px 所代表的实际像素数会根据不同设备动态调整，开发者不需要进行二次换算。<br>2.由于 Android 设备碎片化严重，Google 不得不建立了一个新的名叫「density-independent pixel（密度无关像素，缩写为 dp）」的尺寸单位，以适应不同分辨率屏幕的尺寸换算。</p>\n<p>微信也为小程序提供了一个动态单位解决方案：它就是 responsive pixel（动态像素），简称 rpx。</p>\n<font color=\"red\">Pixel与rpx、dp之间的换算</font>\n\n<p>动态单位与 px 换算的基本概念是：选择一个分辨率作为基准，在基准分辨率中，一个像素点显示有多长，在其他屏幕上会显示同样长度。<br>例如，dp 与 px 换算公式是：dp = px <em> (目标设备 dpi 分辨率 / 160)。<br>但微信小程序的 rpx 换算方式，会与其他动态单位的换算方法有些出入。微信官方提供的换算方式更「傻瓜」一些：rpx = px </em> (目标设备宽 px 值 / 750)。</p>\n<font color=\"red\" face=\"“黑体”\">例如：</font>\n\n<p>目标设备的宽度如果是 375px，按照 750rpx 进行换算，则等于 1rpx = 0.5px<br>目标设备的宽度如果是 1125px，换算后 1rpx = 1.5px</p>\n<p>没错，如果将微信小程序放到平板电脑上运行，屏幕的宽度 px 值有可能会变化（横竖屏、分屏模式等等）。这时候，再以宽度为基准，就会出现元素显示不正确的问题。从这一点可以看出，微信团队目前并不希望将小程序扩展到手机以外的设备中。因此，开发者暂时可以专注于提高小程序在手机上的体验，无需担心多尺寸屏幕带来的适配问题。</p>\n<font color=\"red\" face=\"“黑体”\">那能不能直接让 rpx 和 dp 进行互换呢？当然不能！</font>\n\n<p>dp 是以屏幕分辨率为基准的动态单位，而 rpx 是以长度为基准的动态单位。就像「米」和「平方厘米」不能互换一样，dp 和 rpx 两者也是不能直接进行互换的，除非微信官方将 rpx 设定为分辨率基准而非长度基准。</p>\n<h4 id=\"设计师该怎么做？\"><a href=\"#设计师该怎么做？\" class=\"headerlink\" title=\"设计师该怎么做？\"></a>设计师该怎么做？</h4><p>由于微信使用了 rpx 动态单位，设计稿的尺寸单位也推荐使用 rpx。</p>\n<p>那么问题来了，如果要改用 rpx 单位，以什么尺寸的屏幕作为设计稿标准会比较合适呢？</p>\n<p>在微信官方的文档中，我们看到下面这样一句话：</p>\n<p>在 iPhone 6 上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx = 375px = 750 物理像素，1rpx = 0.5px = 1 物理像素。</p>\n<p>开发微信小程序时设计师可以用 iPhone 6 作为视觉稿的标准。<br>也就是说，设计师在设计小程序时，可以这样做：<br>直接以 iPhone 6 的屏幕尺寸（375×667）用作视觉稿尺寸，1 px = 0.5 rpx；<br>以 1 px = 1 rpx 的标准，将设计稿尺寸设定为 750×1334。<br>在将设计稿转交给开发人员之前，设计师需要清楚地描述设计稿尺寸和单位换算标准等，以便开发人员快速实现界面效果。</p>\n","excerpt":"","more":"<p>在语言方面，看上去小程序几乎重新定义了一套标准。但是实际上，它们与「前端三件套」 ——HTML、 CSS 和 JavaScript——差不太多。</p>\n<h4 id=\"对比一下小程序开发语言和「前端三件套」有什么异同点：\"><a href=\"#对比一下小程序开发语言和「前端三件套」有什么异同点：\" class=\"headerlink\" title=\"对比一下小程序开发语言和「前端三件套」有什么异同点：\"></a>对比一下小程序开发语言和「前端三件套」有什么异同点：</h4><p>一、 HTML 与 WXML：两者差异比较大，如果之前没有接触过Android 开发，可能会觉得有些头疼。事实上， WXML 更像是 Android 开发中的界面 XML ᧿述文件，更适合于程序界<br>面的构建；而 HTML 则倾向于文章的展示（这与 HTML 的历史有关），以及互联网页面的构建。<br>二、 WXSS 与 CSS：两者在语言上几乎没有差别，可以直接通用。<br>三、 JS 文件：小程序的 JS 文件与前端开发使用的 JS 几乎没有区别，小程序的 JS 新增了微信的一些 API 接口，并去除了一些不必要的功能（如 DOM）。</p>\n<p>小程序开发需要学习的语言主要有：</p>\n<ol>\n<li>微信标记语言  （weixin marked language,   wxml）</li>\n<li>微信样式表（weixin style sheet, wxss ）</li>\n<li>javascript</li>\n</ol>\n<p>小程序的界面并非是一个网页，而是一个应用界面，以往网页前端常见的<code>&lt;div&gt;、&lt;a&gt;</code>等标签都不复存在，网页前端开发人员需要适应wxml的逻辑和写法。</p>\n<p>小程序使用了rpx（responsive pixel）作为尺寸单位（保证不同分辨率设备的元素正常显示），开发人员需要了解rpx与各种长度单位的换算比例。</p>\n<h4 id=\"为什么需要动态单位和-rpx？\"><a href=\"#为什么需要动态单位和-rpx？\" class=\"headerlink\" title=\"为什么需要动态单位和 rpx？\"></a>为什么需要动态单位和 rpx？</h4><p>我们都知道，小程序是一个跨系统的平台。这就意味着，小程序会在不同的设备上运行，但不同设备的分辨率会有差异。<br>在小程序中，如何在分辨率不同的设备上保证视觉元素的正常显示？这就需要名为 rpx 的动态尺寸单位。</p>\n<p>在显示屏上，每一个画面都是由无数的点阵形成的。这个点阵中，每一个点叫做像素，就是 pixel（缩写为 px）。这对于很多人来说都是常识。</p>\n<p>但是，随着 Retina 屏幕（即「视网膜屏」）的推出和高分屏的普及，1 px 所能代表的实际长度并非是一成不变的。对于跨平台、跨设备的应用来说，单纯使用 px 并不能满足需要。因为，这很难保证小程序的元素，能在不同设备上正常显示——同样 px 尺寸的元素，在高分屏上显示会明显要比在低分屏显得更小。因此，我们需要一个动态的长度单位。这个单位通过对不同屏幕的分辨率进行调整和适配，保证相同元素在不同屏幕上的展示是正常的。</p>\n<font color=red face=“黑体”>苹果和 Google 对此都有相应的措施：</font>\n\n<p>1.由于苹果对高分屏的优化良好，所以在 iOS 上，代码中的 1 px 所代表的实际像素数会根据不同设备动态调整，开发者不需要进行二次换算。<br>2.由于 Android 设备碎片化严重，Google 不得不建立了一个新的名叫「density-independent pixel（密度无关像素，缩写为 dp）」的尺寸单位，以适应不同分辨率屏幕的尺寸换算。</p>\n<p>微信也为小程序提供了一个动态单位解决方案：它就是 responsive pixel（动态像素），简称 rpx。</p>\n<font color='red'>Pixel与rpx、dp之间的换算</font>\n\n<p>动态单位与 px 换算的基本概念是：选择一个分辨率作为基准，在基准分辨率中，一个像素点显示有多长，在其他屏幕上会显示同样长度。<br>例如，dp 与 px 换算公式是：dp = px <em> (目标设备 dpi 分辨率 / 160)。<br>但微信小程序的 rpx 换算方式，会与其他动态单位的换算方法有些出入。微信官方提供的换算方式更「傻瓜」一些：rpx = px </em> (目标设备宽 px 值 / 750)。</p>\n<font color=red face=“黑体”>例如：</font>\n\n<p>目标设备的宽度如果是 375px，按照 750rpx 进行换算，则等于 1rpx = 0.5px<br>目标设备的宽度如果是 1125px，换算后 1rpx = 1.5px</p>\n<p>没错，如果将微信小程序放到平板电脑上运行，屏幕的宽度 px 值有可能会变化（横竖屏、分屏模式等等）。这时候，再以宽度为基准，就会出现元素显示不正确的问题。从这一点可以看出，微信团队目前并不希望将小程序扩展到手机以外的设备中。因此，开发者暂时可以专注于提高小程序在手机上的体验，无需担心多尺寸屏幕带来的适配问题。</p>\n<font color=red face=“黑体”>那能不能直接让 rpx 和 dp 进行互换呢？当然不能！</font>\n\n<p>dp 是以屏幕分辨率为基准的动态单位，而 rpx 是以长度为基准的动态单位。就像「米」和「平方厘米」不能互换一样，dp 和 rpx 两者也是不能直接进行互换的，除非微信官方将 rpx 设定为分辨率基准而非长度基准。</p>\n<h4 id=\"设计师该怎么做？\"><a href=\"#设计师该怎么做？\" class=\"headerlink\" title=\"设计师该怎么做？\"></a>设计师该怎么做？</h4><p>由于微信使用了 rpx 动态单位，设计稿的尺寸单位也推荐使用 rpx。</p>\n<p>那么问题来了，如果要改用 rpx 单位，以什么尺寸的屏幕作为设计稿标准会比较合适呢？</p>\n<p>在微信官方的文档中，我们看到下面这样一句话：</p>\n<p>在 iPhone 6 上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx = 375px = 750 物理像素，1rpx = 0.5px = 1 物理像素。</p>\n<p>开发微信小程序时设计师可以用 iPhone 6 作为视觉稿的标准。<br>也就是说，设计师在设计小程序时，可以这样做：<br>直接以 iPhone 6 的屏幕尺寸（375×667）用作视觉稿尺寸，1 px = 0.5 rpx；<br>以 1 px = 1 rpx 的标准，将设计稿尺寸设定为 750×1334。<br>在将设计稿转交给开发人员之前，设计师需要清楚地描述设计稿尺寸和单位换算标准等，以便开发人员快速实现界面效果。</p>\n"},{"title":"简易电商类小程序开发教程","date":"2017-02-06T08:07:17.000Z","_content":"电商类平台主要由首页、分类页、商品列表页、商品详情页、购物车、订单结算页和个人中心等几大模块组成。\n在开发过程中，也会穿插介绍一些常用简单内置组件的使用，最再后利用小程序的 template 模板，对自定义组件化开发的实现提供三种参考模式。\n\n#### 1、准备开工\n先新建一个文件夹 wxapponline 作为项目目录，里面包含：\n   1.common 目录——用来放置项目公用的文件\n   2.pages 目录——项目页面开发目录，里面的每个子目录代表一 个 独 立 页 面 ， 分 别 包 含 与 目 录 同 名 的 .wxml （ 必须）， .wxss， .js（ 必须）和 .json 文件\n   3.templates 目录——用来放置自定义的组件\n   4.utils 目录——用来放置工具类 js 文件\n   5.app.js——小程序逻辑\n   6.app.json——小程序公共设置\n   7.app.wxss——小程序公共样式表\n\n#### 2、轮播banner样式定义\n和大多数项目一样，最开始是首页的实现。\n首 页 在 pages/index 目 录 下 ， 包 括 index.wxml 、index.wxss、 index.js 三个文件。\n\n<font color=\"red\">实现 banner 轮播图，来看代码：</font>\n```\n/*** index.wxml ***/\n<swiper class=\"banner-swiper\"\nindicator-dots=\"{{ indicatorDots }}\"\nautoplay=\"{{ autoplay }}\" interval=\"{{ interval }}\"\nduration=\"{{ duration }}\">\n<swiper-item class=\"swiper-item\"\nwx:for=\"{{ banners }}\">\n<navigator\nurl=\"../detail/detail?id={{ item.productId }}\">\n<image src=\"{{ item.image }}\"\nclass=\"slide-image\"></image>\n</navigator>\n</swiper-item>\n</swiper>\n```\n值得注意的是， image 组件会有一个默认的样式.可以到官方文档中去查找images组件的默认样式。默认宽高可能在不同的版本中有不同的值。我们可以根据实际情况给它重新定义一个宽高值。单位：rpx;\n友情提：大多数小程序内置组件都会有自己的默认样式，我们可以利用开发工具中的wxml panel，多了解一下这些组件的默认样式，可以避免很多由组件默认样式引起的问题。\n另一个注意点是，不要将大图片放到项目目录中，因为小程序代码总大小不能超过 1 MB，而大图片会占用大量的空间，所以要尽量避免在项目目录中放置大图片。\n如有需要，建议只在项目目录中放置少量 icon 类的小图片，其他大图片可以上传到自己的服务器或者网盘中，然后在 src 中设置图片的网络资源地址。\n在手机测试或者正式上线之前，要注意是否有引用了本地大图片导致代码超出大小限制的问题。\n\n#### 3.准备获取 banner\t数据，并绑定到视图层\n```\n/*** index.js ***/\nPage({\ndata: {\nbanners: [], //初始化一个 banners 数组\n//以下四项设置 swiper 组件的参数值\nindicatorDots: true\n, autoplay: true, //开启自动切换\ninterval: 5000, //自动切换时间间隔\nduration: 1000 //滑动动画时长}\n});\n```\n在 Page 里的 data 会以 JSON 的形式由逻辑层传至视图层，然后在视图层中使用 Mustache 语法（双大括号）接收传入的数据，实现动态数据的数据绑定。经过绑定后的数据变动可以在视图中实时反应，也可以通过开发者工具中的 AppData Panel 中查看和编辑页面中的所有 data 数据。\n友情提醒：当你不知道 data 数据是否被设置成功的时候，可以到 AppData Panel 来查看一下，免去了手动打 console.log 进行调试的麻烦。\n\n实现动态数据绑定的另一个方式是使用 this.setData() 方法 ， this 在 这 里 代 表 的 是 Page ， 而 setData 是在PageX.prototype 中的方法，所以 this.setData() 实际上访问的是 Page.prototype.setData()。它可以用来新增和修改 this.data 里的值，同时还有一个重要的功能是将数据从逻辑层发送到视图层，从而实时改变页面的状态，保持逻辑层和视图层数据的一致性。需要注意的是，如果使用 this.data.property = value，同样可以设置 this.data 的值，但是它不会将数据发送到视图层，无法改变页面的状态。\n注意： 一 定 要 避 免 使 用this.data.property = value 的方式设置数据。\n\n#### 4.从服务器获取 banner数据\n现在我们的目的是要得到一个 banners 数组，然后利 用 wx:for 将 banners 数 组 中 的 每 一 项 渲 染 到swiper-item 中。我们可以在页面加载（ onLoad） 时，使用 wx.request() 发\n起一个 Ajax 请求，来获取到所需要的 banner 列表数据。先 来 看 一 下 wx.request(object) 的 使 用 方 法 。 首 先 是object 可以接受的参数值：\n```\n1. url：设置发送请求的地址。\n2. method：请求方式，默认为 GET，有效值： OPTIONS， GET，HEAD， POST， PUT， DELETE， TRACE， CONNECT。注意，所有值都要使用大写。 经过测试，若使用小写，在安卓中会导致无法发起请求，而在开发者工具和 iOS 中则正常。\n3. data：设置请求的参数。如果 method 值为 GET，这个函数会将 data 转换成 query 字符串，拼接在 url 后面，若 url 本身带有同名的 query 参数，那么 data 中的参数会覆盖 url 中的 query 参数；小 程 序 执 行 wx.request(object) 发 送 请 求 并 收 到success（成功）的消息后，会自动执行请求成功返回的回调函数。回调函数执行时，会自动收到类似这样的回调参数：\nres = {data: '服务器返回的数据', errMsg: '错误信息', statusCode: HTTP 状态码}\n```\n特别注意，在开发者工具和 iOS 中， res.statusCode 的类据类型是一个数值， 而在 Android 中的数据类型是一个字符串，所以在判断 res.statusCode 时不能直接使用 === 操作符，而应该用 == 操作符，或者是先对 res.statusCode 进行数据类型转换。现在，就可以在 onLoad 中调用 wx.request() 发起请求，访问获取 banner 列表的服务器 API。\n我们将各服务器 API 的访问地址都保存在 API_URL 对象，保存在 utils/config.js 中：\n```\n/*** config.js ***/\nconst CONFIG = {\nAPI_URL: {\nBANNER_QUERY: http://ifanr.com/api/banner\n}\n}\nmodule.exports = CONFIG;\n然 后 需 要 在 index.js 中 使 用 require 引 入utils/config.js 文件，引入路径为当前文件的相对路径：\n/*** index.js ***/\nvar CONFIG = require('../../utils/config.js');\n于是，我们就知道了在小程序中 js 模块化的方法，模块通过module.exports 对外暴露接口，在需要使用这些模块的文件中，使用 require(path) 将公共代码引入。发起 wx.request 请求：\n/*** index.js ***/\nvar CONFIG = require('../../utils/config.js');\nPage({\ndata: {...\n},\nonLoad: function () {\nvar _this = this;\nwx.request({\nurl: CONFIG.API_URL.BANNER_QUERY,\nmethod: 'GET',\ndata: {\nlimit: 6,\nimg_size: 'small'\n},\nsuccess: function (res) {\nif (res.statusCode == 200) {\n_this.setData({\nbanners: res.data.objects\n});\n}\n}\n});\n}\n});\n```\n在 wx.request() 的回调函数中判断 res.statusCode 是否 为 200 ， 若 为 200 则 代 表 请 求 成 功 ， 接 着 将 数 据 保 存 到banners 数组中。\n我 们 在 success 回 调 函 数 中 使 用_this.setData({ banners: res.data.objects }); 设置banners 的值。\n注意 ： 这 里 不 能 直 接 使 用this.setData() ，因为 success 回调函数是一个闭包，我们要先 在 闭 包 外 面 定 义 var _this = this; ， 再调用_this.setData()，以保证闭包内能到正确的 this 值。现在，在视图中我们就能看到完整的 banner 列表了。\n\n## 如何做商品列表\n#### 1.为布局而生的 Flex\n传统的布局方式一般都是基于 div 盒子模型，利用 float，position， display 来进行布局。每个前端开发者对这些布局方式都非常熟悉。对一些特殊的布局来说，使用这些属性并不方便，由此还衍生出各种 hack 方案。直到CSS3 提出了专为布局而生的解决方案，就是 Flex 布局。但是，由于浏览器的兼容问题，大多数开发者都不敢将 Flex 布局直接应用到实际项目之中。在常规项目中，大量应用 Flex 布局还需要一个过程。\n\n而对于 WeChat Only 的小程序来说，则完全不用担心有浏览器兼容的问题，它只要适配微信客户端即可。同时，由于小程序的布局不会非常复杂，所以，也不用过多地担心大量使用 Flex 引起的性能问题。我们可以放心地在小程序中使用 Flex 来处理布局。\n#### 2.如何更方便地使用 rpx\nrpx 的全称是 responsive pixel，它是小程序自己定义的一个尺寸单位，可以根据当前设备的屏幕宽度进行自适应。小程序中规定，所有的设备屏幕宽度都为 750rpx，根据设备屏\n幕实际宽度的不同， 1rpx 所代表的实际像素值也不一样。\n\n例如，在 iPhone 6 上，屏幕实际宽度为 375px，则 750rpx =375px， 1rpx = 0.5px；而在 iPhone 5 上，屏幕实际宽度为 320px，则 750rpx = 320px， 1rpx = 0.42px。\n其实，我们并不必关心每种设备屏幕下 1rpx 到底代表多少个像素，只要抓住 「所有的设备屏幕宽度都为 750rpx」这个原则，就能很好地实现对任意设备屏幕大小的自适应布局。强烈建议用 iPhone 6 作为视觉稿的标准，即将视觉稿总宽度设成 750px。这样，开发者就能很方便地对相关的尺寸进行量取。比如，在总宽度为 750px 的 iPhone 6 视觉稿中，量取一个图片的宽度为 200px，那么，这个图片的宽度即可设置为 200rpx。\n\n简单一句话解释：量取多少就设置多少。\n\n#### 3.Flex配合rpx的使用案例\n现在，我们就在小程序中使用 Flex 和 rpx 进行布局，体验一下这种解决方案的便利。\n第一个例子：货架列表效果图：\n<div align=center>\n ![](http://oi28tswuq.bkt.clouddn.com/images/wxapponline2.jpg)\n</div>\n\n首先还是贴两段代码，以下是 WXML 的实现：\n```\n/*** index.wxml ***/\n<view class=\"shelf-nav\">\n<view class=\"shelf-nav-item\"\nwx:for=\"{{ shelfNavList }}\">\n<navigator\nurl=\"../list/list?id={{ item.id }}\">\n<image src=\"{{ item.cover_image }}\"\nclass=\"shelf-nav-item__image\"> </image>\n<text>{{ item.name }}</text>\n</navigator>\n</view>\n</view>\n```\n然后 WXSS 的代码如下，在关键代码处已经给出简要注释：\n```\n/*** index.wxss ***/\n.shelf-nav {\ndisplay: flex; // 设 置 display: flex; 将 它 变 为flex 布局的元素\nflex-wrap: wrap; //当子元素总宽度超过父元素宽度时换行显示\npadding: 30rpx;\n}\n.shelf-nav-item {\nwidth: 25%; //因为每行显示 4 个货架，所以宽度设置为25%;\nmargin-bottom: 20rpx;\ntext-align: center; //让它中间的图片和标题居中显示\n}\n.shelf-nav-item__image {\nwidth: 130rpx; //在视觉稿中量取图片宽高为 130px\nheight: 130rpx; //于是设置 width 和 height 都设置为 130rpx;\nborder-radius: 50%; //把图片设置成圆形\nborder: 1px solid #d9d9d9; //加上外边框\n}\n```\n简单几步就完成了货架列表的布局， 并且完美兼容各种大小的设备屏幕。\n\n第二个例子：效果图如下：\n<div align=center>\n ![](http://oi28tswuq.bkt.clouddn.com/images/wxapponline3.png-public)\n</div>\n\n如上图所示， 需要做到的效果是标题居左，「查看更多」（即...）的图标居右并且垂直居中。\n代码结构如下：\n```\n/*** index.wxml ***/\n<view class=\"shelf-header\">\n<view class=\"shelf-title\">\n<text\nclass=\"shelf-title-en\">{{ shelf.english_name }}</\ntext>\n<text\nclass=\"shelf-title-cn\">{{ shelf.name }}</text>\n</view>\n<view class=\"shelf-more\">\n<navigator\nurl=\"../list/list?id={{ shelf.id }}\"\nclass=\"ifanrin-more-icon ifanrin\"> </navigator></view>\n</view>\n```\n有经验的同学一眼就可以看出，要实现需求需要：\n1/让 .shelf-title 向左浮动\n2/让 .shelf-more 水平方向右对齐、垂直方向居中\n3/最后还要给 .shelf-header clearfix 一下\n那现在来看看 Flex 是怎么做的：\n```\n/*** index.wxss ***/\n.shelf-header {\ndisplay: flex; //设置为 flex 布局的元素\njustify-content: space-between; //均匀排列每个元\n素，首、末两元素分别位于起点和终点\n}\n.shelf-more {\nalign-self: center; //设置居中\n}\n```\n只要区区几行代码，就能轻松使用 Flex 调整排版。\n接下来，发起一个请求获取数据，然后setData() 绑定数据：\n```\n/*** index.js ***/\nPage(){\n...,\nonLoad: function () {\nvar that = this;\nwx.request({\nurl: CONFIG.API_URL.SHELF_QUERY,\nmethod: 'GET',\ndata: {\nimg_size: 'small'\n},success: function (res) {\nthat.setData({\nshelfNavList: res.data.objects\n});\n}\n});\n},\n...\n}\n```\n此时列表页就基本完成了。\n\n#### 4、template模板的使用\n效果图如下：\n\n<div align=center>\n ![](http://oi28tswuq.bkt.clouddn.com/images/wxapponline1.jpg)\n</div>\n\n不难发现，这两个页面的列表的样式是一模一样的。那么，我们就可以把每个商品视为一个模块，暂且把这个商品模块称为 product-card，我们可以将它用 template 封装起来，\n在需要的地方就将它引入并进行调用。这里先要弄清楚一个概念， template 的主要功能更多的是在于定义一个 WXML 代码片段，然后在不同的地方调用。template 拥有自己的作用域， 而且只能使用 data 传入的数据。接下来看看template 到底如何使用。\n\n<font color=\"red\">1.定义 template 模板</font>\n\n为了方便代码组织，我们在 templates 目录下，新建一个productCard 文 件 夹 ， 并 在 product-card 文 件 夹 下 新 建productCard.wxml 和 productCard.wxss 文件。代码如下：\n```\n<template name=\"productCard\">\n<view class=\"product-card\">\n<navigator\nurl=\"../detail/detail?id={{ id }}\">\n<view style=\"background-image:\nurl({{ cover_image }})\" class=\"product-cover\">\n</view>\n<view>\n<text\nclass=\"product-title\">{{ title }}</text>\n<text class=\"product-price\">\n￥{{ price }}</text>\n</view>\n</navigator>\n</view>\n</template>\n```\n使用 name 属性，定义模板的名字，然后将代码片断保存在template 中。\n\n<font color=\"red\">2.引入 template 模板</font>\n以首页为例，当要使用到 productCard 模板时，我们只需要使用 import 引入模板。在需要显示的位置，外层用 wx:for 循环渲染列表， template为子项，使用 is 声明需要的使用的模板，用 data 传入数据：\n```\n/*** index.wxml ***/\n<import\nsrc=\"../../templates/productCard/productCard.wxml\n\" />\n<view class=\"product-list\">\n<block wx:for=\"{{ productNewList }}\" <template\nis=\"productCard\" data=\"{{ ...item }}\" /> </block>\n</view>\n留意 data=\"{{ ...item }} 的写法， item 是 wx:for 中代表数组当前项的默认变量名，\n item 前面的 ... 操作符相当于ES6 中的展开运算符，可用于需要解构赋值的地方.通 过 解 构 ，\n  template 中 就 可 以 直 接 写 成 {{ id }} ，{{ cover_image }} ， 而 不 用 写 {{ item.id }} ，\n  {{ item.cover_image }}。它的意义在于实现了 template 与 wx:for-item 之间的解耦，\n  比如这里设置了 wx:for-item=\"product\"，我们只要设改变data=\"{{ ...product }}\" 就可以了。\n如果数据没有通过解构，就要将 template 的 {{ item.id }}修改成 {{ product.id }}，很不方便。\n接着，是 productCard.wxss 的引入，先在 productCard写好样式，这里就不贴代码了\n```\n#### 5.模板的 WXSS文件如何引入\n在哪里可以引入 WXSS 文件？一种方法是在用到 productCard 模板的页面里引入，在这里是在 list.wxss 中 import 进来。另一种方法是，直接在 app.wxss 中引入。相比较于上一种方法，这个方法只需要一次引入，而所有用到 productCard 模板的页面都不用再去引入 productCard.wxss 了。\n```\n/*** app.wxss ***/\n@import \"./templates/productCard/productCard.wxss\";\n```\n获取商品列表数据，渲染视图先通过 onLoad 的 options 取得 id：\n```\n/*** list.js ***/\nonLoad: function (options) {\nvar id = options.id;\nthis.setData({\nshelfId: id\n});\n}\n```\n最 后 ， 调 用 wx:request() 获 取 商 品 列 表 数 据 ， 通 过setData() 设置 productNewList，即可在视图层渲染出完整的列表。\n```\n/*** list.js ***/\nonLoad: function (options) {\n...\nwx.request({\nurl: CONFIG.API_URL.PRODUCT_LIST,\nmethod: 'GET',\ndata: {\nshelf__id: this.data.shelfId\n},\nsuccess: function (res) {\nif (res.status == 200) {\nthat.setData({\nproductNewList: res.data.objects\n});\n}\n}\n});\n...\n}\n```\n如上面的代码所示，现在小程序会一次性将所有商品列表查询并渲染至页面中。现实中，这种做法显然是不科学的。我们还需要一个「加载更多」的功能。这个功能要求我们做到：用户访问时，页面首次加载 20 个商品，点击列表底部的「查看更多」按钮可再多加载 10 个商品。\n\n## 数据加载和图文排版\n####  1.「查看更多」功能\n效果图如下：\n\n<div align=center>\n ![](http://oi28tswuq.bkt.clouddn.com/images/wxapponline4.png-public)\n</div>\n\n一、 调用 Toast 提示\n通过调用 wx.showToast() ，可以实现上图中部的 Toast 提示（加载中）。微信提供的 Toast 组件有 success 和 loading 两种状态（旧版本的 loading 组件已经被废弃）。\n```\n/***list.js***/\nwx.showToast({\ntitle: '成功', //提示的文字信息icon: 'success', //图标，只支持\"success\"、 \"loading\"\nduration: 2000, //提示的延迟时间(毫秒)，最大为 10000\nsuccess: function() {}, //调用成功的回调函数\nfail: function() {}, //调用失败的回调函数\n//接口调用结束的回调函数（调用成功、失败都会执行）\ncomplete: function() {}\n})\n```\n需要注意的是， 当 showToast 执行时，整个页面是不可点击的。所以，不用考虑用户意外触发多次「查看更多」的问题。调用 wx.hideToast() 即可隐藏 Toast 提示框。现 在 ， 我 们 来 思 考 一 个 问 题 。 上 面 说到 wx.showToast 的 duration 最大值为 10000 毫秒，也就意味着当请求时间大于 10 秒，若没有返回数据时， loading 提示框会自动消失。\n\n当然这会带来一些问题：\n1.「查看更多」按钮重新变回可点击状态，可能造成请求的重复提交。\n2.加载提示消失与数据成功加载之间出现时间差。\n如何解决这个问题呢？其实不难！！！\n先给 loading 设置 10000 毫秒延迟时间，超过 10000 毫秒后，即使请求成功，也不保存任何数据。同时，将按钮文字改回「查看更多」即可。\n我 们 初 始 化 一 个 timeoutFlag 的 对 象 ， 使 用 timer =setTimeout() 设 置 9800 毫 秒 延 时 。 9800 毫 秒 后 ，以 timer 为 key 设置一个对象 { isTimeout: true }，每次发起请求时都会有一个 timer 作为标识。\n\n若请求成功时 timeoutFlag.timer 的值为 { isTimeout:true }，则不处理请求成功后的数据。为什么要设置 9800 毫秒而不是 10000 毫秒呢？\n那是因为 setTimeout 的计时并不准确，我们给出 200 毫秒的提前量，以防止代码出错。下面就来封装一个 _setTimeoutFlag 方法：\n```\n/***list.js***/\n_setTimeoutFlag: function () {\nvar that = this;\nvar timer = null;\ntimer = setTimeout(function () {\nthat.setData({\ntipText: '查看更多'\n});\ntimeoutFlag.timer = { isTimeout: true };\n}, 9800);\ntimeoutFlag.timer = { isTimeout: false };\nreturn timer;\n}\n```\n二、 构建与实现 loadMore 函数\n我们需要一个 loadMore 函数，来做到数据的分页查询。一般，都是通过设置两个查询参数来控制，分别是每次请求条数 limit 和每次请求起始数 offset（即从第几条获取数据）。以我们的需求为例：\n1.第一次获取 20 条： limit=20 & offset=0\n2.第二次再新增 10 条： limit=10 0& offset=20\n3.第三次再新增 10 条： limit=10 & offset=30\n当然，根据各自不同的分页实现， limit 和 offset 的命名也不相同，我们只要了解原理即可。\n\n根据以上逻辑，当用户点击「查看更多」按钮后，小程序在不同情况下应该给出相应的反应：\n1.按钮文字变为「正在加载...」，页面弹出「加载中...」的loading 提示框，设置 offset + 10 并发起请求；\n2.有新数据加载时，按钮文字变回「查看更多」，关闭 loading提示框，保存当前 offset；\n3.无新数据加载时，按钮文字变为「没有更多啦」，关闭loading 提示框。\n4.请求失败时，按钮文字变为「查看更多」，关闭 loading 提示框\n\n先在 list.wxml 中设置按钮，并绑定点击事件 loadMore;。\n```\n/***list.wxml***/\n<view class=\"btn-load-more\" bindtap=\"loadMore\">\n{{ tipText }}\n</view>\n```\n根 据 上 面 的 流 程 ， 封 装 一下 _getProductList 和 loadMore 方法。\n```\n/***list.js***/\nloadMore: function () {var that = this;\nthis.setData({\ntipText: '正在加载...'\n});\nwx.showToast({\ntitle: '加载中...',\nicon: 'loading',\nduration: 10000\n});\nvar timer = that._setTimeoutFlag();\nthis._getMoreProductList(timer);\n},\n_getMoreProductList: function (timer) {\nvar that = this;\nwx.request({\nurl: CONFIG.API_URL.PRODUCT_LIST +\nthis.data.orderBy,\nmethod: 'GET',\ndata: {\nlimit: 10,\noffset: this.data.offset + 10,\nshelf__id: this.data.shelfId,\nimg_size: 'small'\n},\nsuccess: function (data) {\nif (!timeoutFlag.timer.isTimeout) {\nif (data.data.objects.length > 1) {\nvar objects = that.data.productList\n.concat(data.data.objects);\nthat.setData({\nproductList: objects,\noffset: that.data.offset + 10,\ntipText: '查看更多'});\n} else {\nthat.setData({\ntipText: '没有更多啦'\n});\n}\n}\nclearTimeout(timer);\nwx.hideToast();\n},\nfail: function () {\nthat.setData({\ntipText: '查看更多'\n});\nwx.hideToast();\n}\n});\n}\n```\n至此，已经完整实现了商品列表页的开发，接下来进入商品详情页.\n\n#### 2.商品详情页与图文排版实现\n效果图如下：\n\n<div align=center>\n ![](http://oi28tswuq.bkt.clouddn.com/images/wxapponline5.png)\n</div>\n目前商品详情的图文介绍，一般都是通过后台的富文本编辑器来排版创建的，数据都是以 HTML 代码的形式保存下来，然后在页面上直接渲染出来。但是对于小程序来说， HTML形式的数据不能直接拿来使用，因为小程序根本不能解析 HTML 代码。此时，我们需要处理由富文本编辑器所创建的数据，将其转换为JSON 格式的数据，以便于在小程序里使用。\n现在有两种思路去解决这个问题：\n1.由前端去解析 HTML 格式的数据，用正则匹配 HTML 标签，然后转换成 JSON 数据；\n2.交由后端去解析，同时新增一个专用的 API，返回解析过的 JSON数据。\n这里选用的是第二种方案，获取到的 JSON 数据格式如下:\n\n```\n{\n\"description\": [\n{\n\"content\": \"xxx.jpg\",\n\"type\": \"image\"\n},\n{\n\"content\": \"商品᧿述文字\",\n\"type\": \"text\"\n}\n]\n}\n```\n我 们 只 要 将 获 取 的 数 据 用 wx:for 渲 染 出 来 ， 渲 染 时 判断 type 选择对应的 text 或 image 组件即可。\n```\n/***detail.wxml***/\n<block wx:for=\"{{ description }}\">\n<view\nclass=\"description-img\"\nwx:if=\"{{ item.type == 'image' }}\">\n<image\nclass=\"description-img-content\"\nsrc=\"{{ item.content }}\">\n</image>\n</view>\n<view\nclass=\"description-text\"\nwx:elif=\"{{ item.type == 'text' }}\">\n<text class=\"description-text-content\">\n{{ item.content }}\n</text>\n</view>\n</block>\n```\n仔细观察一下，可以发现，每一张图片的宽高都发生了不同程度的裁剪、拉伸或压缩。这是由于 image 组件的默认宽高导致的，这个问题在上面也说过，要特别留意小程序内置组件的默认样式，它们很可能会引起各种各样的问题。我们的期望是，图片能够按照原有的宽高比例进行显示，并且每一张图片的宽度都能撑满整个内容区域。这应该如何处理呢？这里就需要用到 image 组件的 load 事件，使用 bindload 属性将事件绑定在 image 组件中。我 们 可 以 用 event.detail = {height:' 图 片 高 度 px',width:'图片宽度 px'} 的方式调整图片宽高尺寸。\n我们定义一个 imageLoad 函数，作为 image 组件的 load 事件的处理函数，用 data-index 保存当前 wx:for 的 index 值作当前图片的索引值。detail.wxml 改写 image 组件如下：\n```\n<image\nclass=\"description-img-content\"\nsrc=\"{{ item.content }}\"\nbindload=\"imageLoad\"\ndata-index=\"{{ index }}\">\n</image>\ndetail.js 定义 imageLoad 函数如下：\ndata: {\nimages: {}\n},\nimageLoad: function (e) {\nvar realityWidth = e.detail.width; //获取图片实际宽度\nvar realityHeight = e.detail.height; //获取图片实际高度//获取图片的实际宽高比例\nvar proportion = realityWidth / realityHeight;//设置图片的渲染宽度， 750rpx - (2 * 40rpx) = 670rpx;\n//父元素的左右 padding 都是 40rpx\nvar viewWidth = 670;//按比例计算出图片的渲染高度\nvar viewHeight = 670 / proportion;\nvar images = this.data.images;//将图片的 data-index 值作为 images 对象的 key\n//用来储存该图片的计算后的渲染宽高\nimages[e.currentTarget.dataset.index] = {\nwidth: viewWidth,\nheight: viewHeight\n};\nthis.setData({\nimages: images\n});\n}\n```\n此 时 ，就 可 以 在 image 组 件 中 获 取到 images[index].width 和 images[index].height，并通过设置行内的 style 给每一个图片设置宽高了。\ndetail.wxml 改写 image 组件如下：\n```\n<image class=\"description-img-content\"\nsrc=\"{{ item.content }}\" bindload=\"imageLoad\"\ndata-index=\"{{ index }}\"\nstyle=\"width:{{ images[index].width }}rpx;\nheight:{{ images[index].height }}rpx\">\n</image>\n```\n此时在预览页面时，你会发现图片等就会正常显示了。\n\n#### 内容总结提示\n- Toast 提示：\n1.Toast 提 示 可 以 使 用 wx.showToast() 来 调 用 ， 使用 wx.hideToast() 隐藏。l 开发者可以自定义 Toast 展示时间、展示文案等。\n2.Toast 最长展示时间不能超过 10000 毫秒，开发者需要做好超时处理工作。\n\n- 图文排版：\n1.如果服务器中的数据是 HTML 数据，需要转换为 JSON，小程序才能解析。\n2.直接将图片进行排版，图片宽高会出现问题。开发者需要处理好图片的宽高问题。\n","source":"_posts/wxapp-online.md","raw":"---\ntitle: 简易电商类小程序开发教程\ndate: 2017-02-06 16:07:17\ntags: wxapp\n---\n电商类平台主要由首页、分类页、商品列表页、商品详情页、购物车、订单结算页和个人中心等几大模块组成。\n在开发过程中，也会穿插介绍一些常用简单内置组件的使用，最再后利用小程序的 template 模板，对自定义组件化开发的实现提供三种参考模式。\n\n#### 1、准备开工\n先新建一个文件夹 wxapponline 作为项目目录，里面包含：\n   1.common 目录——用来放置项目公用的文件\n   2.pages 目录——项目页面开发目录，里面的每个子目录代表一 个 独 立 页 面 ， 分 别 包 含 与 目 录 同 名 的 .wxml （ 必须）， .wxss， .js（ 必须）和 .json 文件\n   3.templates 目录——用来放置自定义的组件\n   4.utils 目录——用来放置工具类 js 文件\n   5.app.js——小程序逻辑\n   6.app.json——小程序公共设置\n   7.app.wxss——小程序公共样式表\n\n#### 2、轮播banner样式定义\n和大多数项目一样，最开始是首页的实现。\n首 页 在 pages/index 目 录 下 ， 包 括 index.wxml 、index.wxss、 index.js 三个文件。\n\n<font color=\"red\">实现 banner 轮播图，来看代码：</font>\n```\n/*** index.wxml ***/\n<swiper class=\"banner-swiper\"\nindicator-dots=\"{{ indicatorDots }}\"\nautoplay=\"{{ autoplay }}\" interval=\"{{ interval }}\"\nduration=\"{{ duration }}\">\n<swiper-item class=\"swiper-item\"\nwx:for=\"{{ banners }}\">\n<navigator\nurl=\"../detail/detail?id={{ item.productId }}\">\n<image src=\"{{ item.image }}\"\nclass=\"slide-image\"></image>\n</navigator>\n</swiper-item>\n</swiper>\n```\n值得注意的是， image 组件会有一个默认的样式.可以到官方文档中去查找images组件的默认样式。默认宽高可能在不同的版本中有不同的值。我们可以根据实际情况给它重新定义一个宽高值。单位：rpx;\n友情提：大多数小程序内置组件都会有自己的默认样式，我们可以利用开发工具中的wxml panel，多了解一下这些组件的默认样式，可以避免很多由组件默认样式引起的问题。\n另一个注意点是，不要将大图片放到项目目录中，因为小程序代码总大小不能超过 1 MB，而大图片会占用大量的空间，所以要尽量避免在项目目录中放置大图片。\n如有需要，建议只在项目目录中放置少量 icon 类的小图片，其他大图片可以上传到自己的服务器或者网盘中，然后在 src 中设置图片的网络资源地址。\n在手机测试或者正式上线之前，要注意是否有引用了本地大图片导致代码超出大小限制的问题。\n\n#### 3.准备获取 banner\t数据，并绑定到视图层\n```\n/*** index.js ***/\nPage({\ndata: {\nbanners: [], //初始化一个 banners 数组\n//以下四项设置 swiper 组件的参数值\nindicatorDots: true\n, autoplay: true, //开启自动切换\ninterval: 5000, //自动切换时间间隔\nduration: 1000 //滑动动画时长}\n});\n```\n在 Page 里的 data 会以 JSON 的形式由逻辑层传至视图层，然后在视图层中使用 Mustache 语法（双大括号）接收传入的数据，实现动态数据的数据绑定。经过绑定后的数据变动可以在视图中实时反应，也可以通过开发者工具中的 AppData Panel 中查看和编辑页面中的所有 data 数据。\n友情提醒：当你不知道 data 数据是否被设置成功的时候，可以到 AppData Panel 来查看一下，免去了手动打 console.log 进行调试的麻烦。\n\n实现动态数据绑定的另一个方式是使用 this.setData() 方法 ， this 在 这 里 代 表 的 是 Page ， 而 setData 是在PageX.prototype 中的方法，所以 this.setData() 实际上访问的是 Page.prototype.setData()。它可以用来新增和修改 this.data 里的值，同时还有一个重要的功能是将数据从逻辑层发送到视图层，从而实时改变页面的状态，保持逻辑层和视图层数据的一致性。需要注意的是，如果使用 this.data.property = value，同样可以设置 this.data 的值，但是它不会将数据发送到视图层，无法改变页面的状态。\n注意： 一 定 要 避 免 使 用this.data.property = value 的方式设置数据。\n\n#### 4.从服务器获取 banner数据\n现在我们的目的是要得到一个 banners 数组，然后利 用 wx:for 将 banners 数 组 中 的 每 一 项 渲 染 到swiper-item 中。我们可以在页面加载（ onLoad） 时，使用 wx.request() 发\n起一个 Ajax 请求，来获取到所需要的 banner 列表数据。先 来 看 一 下 wx.request(object) 的 使 用 方 法 。 首 先 是object 可以接受的参数值：\n```\n1. url：设置发送请求的地址。\n2. method：请求方式，默认为 GET，有效值： OPTIONS， GET，HEAD， POST， PUT， DELETE， TRACE， CONNECT。注意，所有值都要使用大写。 经过测试，若使用小写，在安卓中会导致无法发起请求，而在开发者工具和 iOS 中则正常。\n3. data：设置请求的参数。如果 method 值为 GET，这个函数会将 data 转换成 query 字符串，拼接在 url 后面，若 url 本身带有同名的 query 参数，那么 data 中的参数会覆盖 url 中的 query 参数；小 程 序 执 行 wx.request(object) 发 送 请 求 并 收 到success（成功）的消息后，会自动执行请求成功返回的回调函数。回调函数执行时，会自动收到类似这样的回调参数：\nres = {data: '服务器返回的数据', errMsg: '错误信息', statusCode: HTTP 状态码}\n```\n特别注意，在开发者工具和 iOS 中， res.statusCode 的类据类型是一个数值， 而在 Android 中的数据类型是一个字符串，所以在判断 res.statusCode 时不能直接使用 === 操作符，而应该用 == 操作符，或者是先对 res.statusCode 进行数据类型转换。现在，就可以在 onLoad 中调用 wx.request() 发起请求，访问获取 banner 列表的服务器 API。\n我们将各服务器 API 的访问地址都保存在 API_URL 对象，保存在 utils/config.js 中：\n```\n/*** config.js ***/\nconst CONFIG = {\nAPI_URL: {\nBANNER_QUERY: http://ifanr.com/api/banner\n}\n}\nmodule.exports = CONFIG;\n然 后 需 要 在 index.js 中 使 用 require 引 入utils/config.js 文件，引入路径为当前文件的相对路径：\n/*** index.js ***/\nvar CONFIG = require('../../utils/config.js');\n于是，我们就知道了在小程序中 js 模块化的方法，模块通过module.exports 对外暴露接口，在需要使用这些模块的文件中，使用 require(path) 将公共代码引入。发起 wx.request 请求：\n/*** index.js ***/\nvar CONFIG = require('../../utils/config.js');\nPage({\ndata: {...\n},\nonLoad: function () {\nvar _this = this;\nwx.request({\nurl: CONFIG.API_URL.BANNER_QUERY,\nmethod: 'GET',\ndata: {\nlimit: 6,\nimg_size: 'small'\n},\nsuccess: function (res) {\nif (res.statusCode == 200) {\n_this.setData({\nbanners: res.data.objects\n});\n}\n}\n});\n}\n});\n```\n在 wx.request() 的回调函数中判断 res.statusCode 是否 为 200 ， 若 为 200 则 代 表 请 求 成 功 ， 接 着 将 数 据 保 存 到banners 数组中。\n我 们 在 success 回 调 函 数 中 使 用_this.setData({ banners: res.data.objects }); 设置banners 的值。\n注意 ： 这 里 不 能 直 接 使 用this.setData() ，因为 success 回调函数是一个闭包，我们要先 在 闭 包 外 面 定 义 var _this = this; ， 再调用_this.setData()，以保证闭包内能到正确的 this 值。现在，在视图中我们就能看到完整的 banner 列表了。\n\n## 如何做商品列表\n#### 1.为布局而生的 Flex\n传统的布局方式一般都是基于 div 盒子模型，利用 float，position， display 来进行布局。每个前端开发者对这些布局方式都非常熟悉。对一些特殊的布局来说，使用这些属性并不方便，由此还衍生出各种 hack 方案。直到CSS3 提出了专为布局而生的解决方案，就是 Flex 布局。但是，由于浏览器的兼容问题，大多数开发者都不敢将 Flex 布局直接应用到实际项目之中。在常规项目中，大量应用 Flex 布局还需要一个过程。\n\n而对于 WeChat Only 的小程序来说，则完全不用担心有浏览器兼容的问题，它只要适配微信客户端即可。同时，由于小程序的布局不会非常复杂，所以，也不用过多地担心大量使用 Flex 引起的性能问题。我们可以放心地在小程序中使用 Flex 来处理布局。\n#### 2.如何更方便地使用 rpx\nrpx 的全称是 responsive pixel，它是小程序自己定义的一个尺寸单位，可以根据当前设备的屏幕宽度进行自适应。小程序中规定，所有的设备屏幕宽度都为 750rpx，根据设备屏\n幕实际宽度的不同， 1rpx 所代表的实际像素值也不一样。\n\n例如，在 iPhone 6 上，屏幕实际宽度为 375px，则 750rpx =375px， 1rpx = 0.5px；而在 iPhone 5 上，屏幕实际宽度为 320px，则 750rpx = 320px， 1rpx = 0.42px。\n其实，我们并不必关心每种设备屏幕下 1rpx 到底代表多少个像素，只要抓住 「所有的设备屏幕宽度都为 750rpx」这个原则，就能很好地实现对任意设备屏幕大小的自适应布局。强烈建议用 iPhone 6 作为视觉稿的标准，即将视觉稿总宽度设成 750px。这样，开发者就能很方便地对相关的尺寸进行量取。比如，在总宽度为 750px 的 iPhone 6 视觉稿中，量取一个图片的宽度为 200px，那么，这个图片的宽度即可设置为 200rpx。\n\n简单一句话解释：量取多少就设置多少。\n\n#### 3.Flex配合rpx的使用案例\n现在，我们就在小程序中使用 Flex 和 rpx 进行布局，体验一下这种解决方案的便利。\n第一个例子：货架列表效果图：\n<div align=center>\n ![](http://oi28tswuq.bkt.clouddn.com/images/wxapponline2.jpg)\n</div>\n\n首先还是贴两段代码，以下是 WXML 的实现：\n```\n/*** index.wxml ***/\n<view class=\"shelf-nav\">\n<view class=\"shelf-nav-item\"\nwx:for=\"{{ shelfNavList }}\">\n<navigator\nurl=\"../list/list?id={{ item.id }}\">\n<image src=\"{{ item.cover_image }}\"\nclass=\"shelf-nav-item__image\"> </image>\n<text>{{ item.name }}</text>\n</navigator>\n</view>\n</view>\n```\n然后 WXSS 的代码如下，在关键代码处已经给出简要注释：\n```\n/*** index.wxss ***/\n.shelf-nav {\ndisplay: flex; // 设 置 display: flex; 将 它 变 为flex 布局的元素\nflex-wrap: wrap; //当子元素总宽度超过父元素宽度时换行显示\npadding: 30rpx;\n}\n.shelf-nav-item {\nwidth: 25%; //因为每行显示 4 个货架，所以宽度设置为25%;\nmargin-bottom: 20rpx;\ntext-align: center; //让它中间的图片和标题居中显示\n}\n.shelf-nav-item__image {\nwidth: 130rpx; //在视觉稿中量取图片宽高为 130px\nheight: 130rpx; //于是设置 width 和 height 都设置为 130rpx;\nborder-radius: 50%; //把图片设置成圆形\nborder: 1px solid #d9d9d9; //加上外边框\n}\n```\n简单几步就完成了货架列表的布局， 并且完美兼容各种大小的设备屏幕。\n\n第二个例子：效果图如下：\n<div align=center>\n ![](http://oi28tswuq.bkt.clouddn.com/images/wxapponline3.png-public)\n</div>\n\n如上图所示， 需要做到的效果是标题居左，「查看更多」（即...）的图标居右并且垂直居中。\n代码结构如下：\n```\n/*** index.wxml ***/\n<view class=\"shelf-header\">\n<view class=\"shelf-title\">\n<text\nclass=\"shelf-title-en\">{{ shelf.english_name }}</\ntext>\n<text\nclass=\"shelf-title-cn\">{{ shelf.name }}</text>\n</view>\n<view class=\"shelf-more\">\n<navigator\nurl=\"../list/list?id={{ shelf.id }}\"\nclass=\"ifanrin-more-icon ifanrin\"> </navigator></view>\n</view>\n```\n有经验的同学一眼就可以看出，要实现需求需要：\n1/让 .shelf-title 向左浮动\n2/让 .shelf-more 水平方向右对齐、垂直方向居中\n3/最后还要给 .shelf-header clearfix 一下\n那现在来看看 Flex 是怎么做的：\n```\n/*** index.wxss ***/\n.shelf-header {\ndisplay: flex; //设置为 flex 布局的元素\njustify-content: space-between; //均匀排列每个元\n素，首、末两元素分别位于起点和终点\n}\n.shelf-more {\nalign-self: center; //设置居中\n}\n```\n只要区区几行代码，就能轻松使用 Flex 调整排版。\n接下来，发起一个请求获取数据，然后setData() 绑定数据：\n```\n/*** index.js ***/\nPage(){\n...,\nonLoad: function () {\nvar that = this;\nwx.request({\nurl: CONFIG.API_URL.SHELF_QUERY,\nmethod: 'GET',\ndata: {\nimg_size: 'small'\n},success: function (res) {\nthat.setData({\nshelfNavList: res.data.objects\n});\n}\n});\n},\n...\n}\n```\n此时列表页就基本完成了。\n\n#### 4、template模板的使用\n效果图如下：\n\n<div align=center>\n ![](http://oi28tswuq.bkt.clouddn.com/images/wxapponline1.jpg)\n</div>\n\n不难发现，这两个页面的列表的样式是一模一样的。那么，我们就可以把每个商品视为一个模块，暂且把这个商品模块称为 product-card，我们可以将它用 template 封装起来，\n在需要的地方就将它引入并进行调用。这里先要弄清楚一个概念， template 的主要功能更多的是在于定义一个 WXML 代码片段，然后在不同的地方调用。template 拥有自己的作用域， 而且只能使用 data 传入的数据。接下来看看template 到底如何使用。\n\n<font color=\"red\">1.定义 template 模板</font>\n\n为了方便代码组织，我们在 templates 目录下，新建一个productCard 文 件 夹 ， 并 在 product-card 文 件 夹 下 新 建productCard.wxml 和 productCard.wxss 文件。代码如下：\n```\n<template name=\"productCard\">\n<view class=\"product-card\">\n<navigator\nurl=\"../detail/detail?id={{ id }}\">\n<view style=\"background-image:\nurl({{ cover_image }})\" class=\"product-cover\">\n</view>\n<view>\n<text\nclass=\"product-title\">{{ title }}</text>\n<text class=\"product-price\">\n￥{{ price }}</text>\n</view>\n</navigator>\n</view>\n</template>\n```\n使用 name 属性，定义模板的名字，然后将代码片断保存在template 中。\n\n<font color=\"red\">2.引入 template 模板</font>\n以首页为例，当要使用到 productCard 模板时，我们只需要使用 import 引入模板。在需要显示的位置，外层用 wx:for 循环渲染列表， template为子项，使用 is 声明需要的使用的模板，用 data 传入数据：\n```\n/*** index.wxml ***/\n<import\nsrc=\"../../templates/productCard/productCard.wxml\n\" />\n<view class=\"product-list\">\n<block wx:for=\"{{ productNewList }}\" <template\nis=\"productCard\" data=\"{{ ...item }}\" /> </block>\n</view>\n留意 data=\"{{ ...item }} 的写法， item 是 wx:for 中代表数组当前项的默认变量名，\n item 前面的 ... 操作符相当于ES6 中的展开运算符，可用于需要解构赋值的地方.通 过 解 构 ，\n  template 中 就 可 以 直 接 写 成 {{ id }} ，{{ cover_image }} ， 而 不 用 写 {{ item.id }} ，\n  {{ item.cover_image }}。它的意义在于实现了 template 与 wx:for-item 之间的解耦，\n  比如这里设置了 wx:for-item=\"product\"，我们只要设改变data=\"{{ ...product }}\" 就可以了。\n如果数据没有通过解构，就要将 template 的 {{ item.id }}修改成 {{ product.id }}，很不方便。\n接着，是 productCard.wxss 的引入，先在 productCard写好样式，这里就不贴代码了\n```\n#### 5.模板的 WXSS文件如何引入\n在哪里可以引入 WXSS 文件？一种方法是在用到 productCard 模板的页面里引入，在这里是在 list.wxss 中 import 进来。另一种方法是，直接在 app.wxss 中引入。相比较于上一种方法，这个方法只需要一次引入，而所有用到 productCard 模板的页面都不用再去引入 productCard.wxss 了。\n```\n/*** app.wxss ***/\n@import \"./templates/productCard/productCard.wxss\";\n```\n获取商品列表数据，渲染视图先通过 onLoad 的 options 取得 id：\n```\n/*** list.js ***/\nonLoad: function (options) {\nvar id = options.id;\nthis.setData({\nshelfId: id\n});\n}\n```\n最 后 ， 调 用 wx:request() 获 取 商 品 列 表 数 据 ， 通 过setData() 设置 productNewList，即可在视图层渲染出完整的列表。\n```\n/*** list.js ***/\nonLoad: function (options) {\n...\nwx.request({\nurl: CONFIG.API_URL.PRODUCT_LIST,\nmethod: 'GET',\ndata: {\nshelf__id: this.data.shelfId\n},\nsuccess: function (res) {\nif (res.status == 200) {\nthat.setData({\nproductNewList: res.data.objects\n});\n}\n}\n});\n...\n}\n```\n如上面的代码所示，现在小程序会一次性将所有商品列表查询并渲染至页面中。现实中，这种做法显然是不科学的。我们还需要一个「加载更多」的功能。这个功能要求我们做到：用户访问时，页面首次加载 20 个商品，点击列表底部的「查看更多」按钮可再多加载 10 个商品。\n\n## 数据加载和图文排版\n####  1.「查看更多」功能\n效果图如下：\n\n<div align=center>\n ![](http://oi28tswuq.bkt.clouddn.com/images/wxapponline4.png-public)\n</div>\n\n一、 调用 Toast 提示\n通过调用 wx.showToast() ，可以实现上图中部的 Toast 提示（加载中）。微信提供的 Toast 组件有 success 和 loading 两种状态（旧版本的 loading 组件已经被废弃）。\n```\n/***list.js***/\nwx.showToast({\ntitle: '成功', //提示的文字信息icon: 'success', //图标，只支持\"success\"、 \"loading\"\nduration: 2000, //提示的延迟时间(毫秒)，最大为 10000\nsuccess: function() {}, //调用成功的回调函数\nfail: function() {}, //调用失败的回调函数\n//接口调用结束的回调函数（调用成功、失败都会执行）\ncomplete: function() {}\n})\n```\n需要注意的是， 当 showToast 执行时，整个页面是不可点击的。所以，不用考虑用户意外触发多次「查看更多」的问题。调用 wx.hideToast() 即可隐藏 Toast 提示框。现 在 ， 我 们 来 思 考 一 个 问 题 。 上 面 说到 wx.showToast 的 duration 最大值为 10000 毫秒，也就意味着当请求时间大于 10 秒，若没有返回数据时， loading 提示框会自动消失。\n\n当然这会带来一些问题：\n1.「查看更多」按钮重新变回可点击状态，可能造成请求的重复提交。\n2.加载提示消失与数据成功加载之间出现时间差。\n如何解决这个问题呢？其实不难！！！\n先给 loading 设置 10000 毫秒延迟时间，超过 10000 毫秒后，即使请求成功，也不保存任何数据。同时，将按钮文字改回「查看更多」即可。\n我 们 初 始 化 一 个 timeoutFlag 的 对 象 ， 使 用 timer =setTimeout() 设 置 9800 毫 秒 延 时 。 9800 毫 秒 后 ，以 timer 为 key 设置一个对象 { isTimeout: true }，每次发起请求时都会有一个 timer 作为标识。\n\n若请求成功时 timeoutFlag.timer 的值为 { isTimeout:true }，则不处理请求成功后的数据。为什么要设置 9800 毫秒而不是 10000 毫秒呢？\n那是因为 setTimeout 的计时并不准确，我们给出 200 毫秒的提前量，以防止代码出错。下面就来封装一个 _setTimeoutFlag 方法：\n```\n/***list.js***/\n_setTimeoutFlag: function () {\nvar that = this;\nvar timer = null;\ntimer = setTimeout(function () {\nthat.setData({\ntipText: '查看更多'\n});\ntimeoutFlag.timer = { isTimeout: true };\n}, 9800);\ntimeoutFlag.timer = { isTimeout: false };\nreturn timer;\n}\n```\n二、 构建与实现 loadMore 函数\n我们需要一个 loadMore 函数，来做到数据的分页查询。一般，都是通过设置两个查询参数来控制，分别是每次请求条数 limit 和每次请求起始数 offset（即从第几条获取数据）。以我们的需求为例：\n1.第一次获取 20 条： limit=20 & offset=0\n2.第二次再新增 10 条： limit=10 0& offset=20\n3.第三次再新增 10 条： limit=10 & offset=30\n当然，根据各自不同的分页实现， limit 和 offset 的命名也不相同，我们只要了解原理即可。\n\n根据以上逻辑，当用户点击「查看更多」按钮后，小程序在不同情况下应该给出相应的反应：\n1.按钮文字变为「正在加载...」，页面弹出「加载中...」的loading 提示框，设置 offset + 10 并发起请求；\n2.有新数据加载时，按钮文字变回「查看更多」，关闭 loading提示框，保存当前 offset；\n3.无新数据加载时，按钮文字变为「没有更多啦」，关闭loading 提示框。\n4.请求失败时，按钮文字变为「查看更多」，关闭 loading 提示框\n\n先在 list.wxml 中设置按钮，并绑定点击事件 loadMore;。\n```\n/***list.wxml***/\n<view class=\"btn-load-more\" bindtap=\"loadMore\">\n{{ tipText }}\n</view>\n```\n根 据 上 面 的 流 程 ， 封 装 一下 _getProductList 和 loadMore 方法。\n```\n/***list.js***/\nloadMore: function () {var that = this;\nthis.setData({\ntipText: '正在加载...'\n});\nwx.showToast({\ntitle: '加载中...',\nicon: 'loading',\nduration: 10000\n});\nvar timer = that._setTimeoutFlag();\nthis._getMoreProductList(timer);\n},\n_getMoreProductList: function (timer) {\nvar that = this;\nwx.request({\nurl: CONFIG.API_URL.PRODUCT_LIST +\nthis.data.orderBy,\nmethod: 'GET',\ndata: {\nlimit: 10,\noffset: this.data.offset + 10,\nshelf__id: this.data.shelfId,\nimg_size: 'small'\n},\nsuccess: function (data) {\nif (!timeoutFlag.timer.isTimeout) {\nif (data.data.objects.length > 1) {\nvar objects = that.data.productList\n.concat(data.data.objects);\nthat.setData({\nproductList: objects,\noffset: that.data.offset + 10,\ntipText: '查看更多'});\n} else {\nthat.setData({\ntipText: '没有更多啦'\n});\n}\n}\nclearTimeout(timer);\nwx.hideToast();\n},\nfail: function () {\nthat.setData({\ntipText: '查看更多'\n});\nwx.hideToast();\n}\n});\n}\n```\n至此，已经完整实现了商品列表页的开发，接下来进入商品详情页.\n\n#### 2.商品详情页与图文排版实现\n效果图如下：\n\n<div align=center>\n ![](http://oi28tswuq.bkt.clouddn.com/images/wxapponline5.png)\n</div>\n目前商品详情的图文介绍，一般都是通过后台的富文本编辑器来排版创建的，数据都是以 HTML 代码的形式保存下来，然后在页面上直接渲染出来。但是对于小程序来说， HTML形式的数据不能直接拿来使用，因为小程序根本不能解析 HTML 代码。此时，我们需要处理由富文本编辑器所创建的数据，将其转换为JSON 格式的数据，以便于在小程序里使用。\n现在有两种思路去解决这个问题：\n1.由前端去解析 HTML 格式的数据，用正则匹配 HTML 标签，然后转换成 JSON 数据；\n2.交由后端去解析，同时新增一个专用的 API，返回解析过的 JSON数据。\n这里选用的是第二种方案，获取到的 JSON 数据格式如下:\n\n```\n{\n\"description\": [\n{\n\"content\": \"xxx.jpg\",\n\"type\": \"image\"\n},\n{\n\"content\": \"商品᧿述文字\",\n\"type\": \"text\"\n}\n]\n}\n```\n我 们 只 要 将 获 取 的 数 据 用 wx:for 渲 染 出 来 ， 渲 染 时 判断 type 选择对应的 text 或 image 组件即可。\n```\n/***detail.wxml***/\n<block wx:for=\"{{ description }}\">\n<view\nclass=\"description-img\"\nwx:if=\"{{ item.type == 'image' }}\">\n<image\nclass=\"description-img-content\"\nsrc=\"{{ item.content }}\">\n</image>\n</view>\n<view\nclass=\"description-text\"\nwx:elif=\"{{ item.type == 'text' }}\">\n<text class=\"description-text-content\">\n{{ item.content }}\n</text>\n</view>\n</block>\n```\n仔细观察一下，可以发现，每一张图片的宽高都发生了不同程度的裁剪、拉伸或压缩。这是由于 image 组件的默认宽高导致的，这个问题在上面也说过，要特别留意小程序内置组件的默认样式，它们很可能会引起各种各样的问题。我们的期望是，图片能够按照原有的宽高比例进行显示，并且每一张图片的宽度都能撑满整个内容区域。这应该如何处理呢？这里就需要用到 image 组件的 load 事件，使用 bindload 属性将事件绑定在 image 组件中。我 们 可 以 用 event.detail = {height:' 图 片 高 度 px',width:'图片宽度 px'} 的方式调整图片宽高尺寸。\n我们定义一个 imageLoad 函数，作为 image 组件的 load 事件的处理函数，用 data-index 保存当前 wx:for 的 index 值作当前图片的索引值。detail.wxml 改写 image 组件如下：\n```\n<image\nclass=\"description-img-content\"\nsrc=\"{{ item.content }}\"\nbindload=\"imageLoad\"\ndata-index=\"{{ index }}\">\n</image>\ndetail.js 定义 imageLoad 函数如下：\ndata: {\nimages: {}\n},\nimageLoad: function (e) {\nvar realityWidth = e.detail.width; //获取图片实际宽度\nvar realityHeight = e.detail.height; //获取图片实际高度//获取图片的实际宽高比例\nvar proportion = realityWidth / realityHeight;//设置图片的渲染宽度， 750rpx - (2 * 40rpx) = 670rpx;\n//父元素的左右 padding 都是 40rpx\nvar viewWidth = 670;//按比例计算出图片的渲染高度\nvar viewHeight = 670 / proportion;\nvar images = this.data.images;//将图片的 data-index 值作为 images 对象的 key\n//用来储存该图片的计算后的渲染宽高\nimages[e.currentTarget.dataset.index] = {\nwidth: viewWidth,\nheight: viewHeight\n};\nthis.setData({\nimages: images\n});\n}\n```\n此 时 ，就 可 以 在 image 组 件 中 获 取到 images[index].width 和 images[index].height，并通过设置行内的 style 给每一个图片设置宽高了。\ndetail.wxml 改写 image 组件如下：\n```\n<image class=\"description-img-content\"\nsrc=\"{{ item.content }}\" bindload=\"imageLoad\"\ndata-index=\"{{ index }}\"\nstyle=\"width:{{ images[index].width }}rpx;\nheight:{{ images[index].height }}rpx\">\n</image>\n```\n此时在预览页面时，你会发现图片等就会正常显示了。\n\n#### 内容总结提示\n- Toast 提示：\n1.Toast 提 示 可 以 使 用 wx.showToast() 来 调 用 ， 使用 wx.hideToast() 隐藏。l 开发者可以自定义 Toast 展示时间、展示文案等。\n2.Toast 最长展示时间不能超过 10000 毫秒，开发者需要做好超时处理工作。\n\n- 图文排版：\n1.如果服务器中的数据是 HTML 数据，需要转换为 JSON，小程序才能解析。\n2.直接将图片进行排版，图片宽高会出现问题。开发者需要处理好图片的宽高问题。\n","slug":"wxapp-online","published":1,"updated":"2017-02-07T02:41:13.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciyxtqwx0000iistucimuak3p","content":"<p>电商类平台主要由首页、分类页、商品列表页、商品详情页、购物车、订单结算页和个人中心等几大模块组成。<br>在开发过程中，也会穿插介绍一些常用简单内置组件的使用，最再后利用小程序的 template 模板，对自定义组件化开发的实现提供三种参考模式。</p>\n<h4 id=\"1、准备开工\"><a href=\"#1、准备开工\" class=\"headerlink\" title=\"1、准备开工\"></a>1、准备开工</h4><p>先新建一个文件夹 wxapponline 作为项目目录，里面包含：<br>   1.common 目录——用来放置项目公用的文件<br>   2.pages 目录——项目页面开发目录，里面的每个子目录代表一 个 独 立 页 面 ， 分 别 包 含 与 目 录 同 名 的 .wxml （ 必须）， .wxss， .js（ 必须）和 .json 文件<br>   3.templates 目录——用来放置自定义的组件<br>   4.utils 目录——用来放置工具类 js 文件<br>   5.app.js——小程序逻辑<br>   6.app.json——小程序公共设置<br>   7.app.wxss——小程序公共样式表</p>\n<h4 id=\"2、轮播banner样式定义\"><a href=\"#2、轮播banner样式定义\" class=\"headerlink\" title=\"2、轮播banner样式定义\"></a>2、轮播banner样式定义</h4><p>和大多数项目一样，最开始是首页的实现。<br>首 页 在 pages/index 目 录 下 ， 包 括 index.wxml 、index.wxss、 index.js 三个文件。</p>\n<font color=\"red\">实现 banner 轮播图，来看代码：</font><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** index.wxml ***/</div><div class=\"line\">&lt;swiper class=&quot;banner-swiper&quot;</div><div class=\"line\">indicator-dots=&quot;&#123;&#123; indicatorDots &#125;&#125;&quot;</div><div class=\"line\">autoplay=&quot;&#123;&#123; autoplay &#125;&#125;&quot; interval=&quot;&#123;&#123; interval &#125;&#125;&quot;</div><div class=\"line\">duration=&quot;&#123;&#123; duration &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;swiper-item class=&quot;swiper-item&quot;</div><div class=\"line\">wx:for=&quot;&#123;&#123; banners &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;navigator</div><div class=\"line\">url=&quot;../detail/detail?id=&#123;&#123; item.productId &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;image src=&quot;&#123;&#123; item.image &#125;&#125;&quot;</div><div class=\"line\">class=&quot;slide-image&quot;&gt;&lt;/image&gt;</div><div class=\"line\">&lt;/navigator&gt;</div><div class=\"line\">&lt;/swiper-item&gt;</div><div class=\"line\">&lt;/swiper&gt;</div></pre></td></tr></table></figure><br><br>值得注意的是， image 组件会有一个默认的样式.可以到官方文档中去查找images组件的默认样式。默认宽高可能在不同的版本中有不同的值。我们可以根据实际情况给它重新定义一个宽高值。单位：rpx;<br>友情提：大多数小程序内置组件都会有自己的默认样式，我们可以利用开发工具中的wxml panel，多了解一下这些组件的默认样式，可以避免很多由组件默认样式引起的问题。<br>另一个注意点是，不要将大图片放到项目目录中，因为小程序代码总大小不能超过 1 MB，而大图片会占用大量的空间，所以要尽量避免在项目目录中放置大图片。<br>如有需要，建议只在项目目录中放置少量 icon 类的小图片，其他大图片可以上传到自己的服务器或者网盘中，然后在 src 中设置图片的网络资源地址。<br>在手机测试或者正式上线之前，要注意是否有引用了本地大图片导致代码超出大小限制的问题。<br><br>#### 3.准备获取 banner    数据，并绑定到视图层<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** index.js ***/</div><div class=\"line\">Page(&#123;</div><div class=\"line\">data: &#123;</div><div class=\"line\">banners: [], //初始化一个 banners 数组</div><div class=\"line\">//以下四项设置 swiper 组件的参数值</div><div class=\"line\">indicatorDots: true</div><div class=\"line\">, autoplay: true, //开启自动切换</div><div class=\"line\">interval: 5000, //自动切换时间间隔</div><div class=\"line\">duration: 1000 //滑动动画时长&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure><br><br>在 Page 里的 data 会以 JSON 的形式由逻辑层传至视图层，然后在视图层中使用 Mustache 语法（双大括号）接收传入的数据，实现动态数据的数据绑定。经过绑定后的数据变动可以在视图中实时反应，也可以通过开发者工具中的 AppData Panel 中查看和编辑页面中的所有 data 数据。<br>友情提醒：当你不知道 data 数据是否被设置成功的时候，可以到 AppData Panel 来查看一下，免去了手动打 console.log 进行调试的麻烦。<br><br>实现动态数据绑定的另一个方式是使用 this.setData() 方法 ， this 在 这 里 代 表 的 是 Page ， 而 setData 是在PageX.prototype 中的方法，所以 this.setData() 实际上访问的是 Page.prototype.setData()。它可以用来新增和修改 this.data 里的值，同时还有一个重要的功能是将数据从逻辑层发送到视图层，从而实时改变页面的状态，保持逻辑层和视图层数据的一致性。需要注意的是，如果使用 this.data.property = value，同样可以设置 this.data 的值，但是它不会将数据发送到视图层，无法改变页面的状态。<br>注意： 一 定 要 避 免 使 用this.data.property = value 的方式设置数据。<br><br>#### 4.从服务器获取 banner数据<br>现在我们的目的是要得到一个 banners 数组，然后利 用 wx:for 将 banners 数 组 中 的 每 一 项 渲 染 到swiper-item 中。我们可以在页面加载（ onLoad） 时，使用 wx.request() 发<br>起一个 Ajax 请求，来获取到所需要的 banner 列表数据。先 来 看 一 下 wx.request(object) 的 使 用 方 法 。 首 先 是object 可以接受的参数值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. url：设置发送请求的地址。</div><div class=\"line\">2. method：请求方式，默认为 GET，有效值： OPTIONS， GET，HEAD， POST， PUT， DELETE， TRACE， CONNECT。注意，所有值都要使用大写。 经过测试，若使用小写，在安卓中会导致无法发起请求，而在开发者工具和 iOS 中则正常。</div><div class=\"line\">3. data：设置请求的参数。如果 method 值为 GET，这个函数会将 data 转换成 query 字符串，拼接在 url 后面，若 url 本身带有同名的 query 参数，那么 data 中的参数会覆盖 url 中的 query 参数；小 程 序 执 行 wx.request(object) 发 送 请 求 并 收 到success（成功）的消息后，会自动执行请求成功返回的回调函数。回调函数执行时，会自动收到类似这样的回调参数：</div><div class=\"line\">res = &#123;data: &apos;服务器返回的数据&apos;, errMsg: &apos;错误信息&apos;, statusCode: HTTP 状态码&#125;</div></pre></td></tr></table></figure><br><br>特别注意，在开发者工具和 iOS 中， res.statusCode 的类据类型是一个数值， 而在 Android 中的数据类型是一个字符串，所以在判断 res.statusCode 时不能直接使用 === 操作符，而应该用 == 操作符，或者是先对 res.statusCode 进行数据类型转换。现在，就可以在 onLoad 中调用 wx.request() 发起请求，访问获取 banner 列表的服务器 API。<br>我们将各服务器 API 的访问地址都保存在 API_URL 对象，保存在 utils/config.js 中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** config.js ***/</div><div class=\"line\">const CONFIG = &#123;</div><div class=\"line\">API_URL: &#123;</div><div class=\"line\">BANNER_QUERY: http://ifanr.com/api/banner</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">module.exports = CONFIG;</div><div class=\"line\">然 后 需 要 在 index.js 中 使 用 require 引 入utils/config.js 文件，引入路径为当前文件的相对路径：</div><div class=\"line\">/*** index.js ***/</div><div class=\"line\">var CONFIG = require(&apos;../../utils/config.js&apos;);</div><div class=\"line\">于是，我们就知道了在小程序中 js 模块化的方法，模块通过module.exports 对外暴露接口，在需要使用这些模块的文件中，使用 require(path) 将公共代码引入。发起 wx.request 请求：</div><div class=\"line\">/*** index.js ***/</div><div class=\"line\">var CONFIG = require(&apos;../../utils/config.js&apos;);</div><div class=\"line\">Page(&#123;</div><div class=\"line\">data: &#123;...</div><div class=\"line\">&#125;,</div><div class=\"line\">onLoad: function () &#123;</div><div class=\"line\">var _this = this;</div><div class=\"line\">wx.request(&#123;</div><div class=\"line\">url: CONFIG.API_URL.BANNER_QUERY,</div><div class=\"line\">method: &apos;GET&apos;,</div><div class=\"line\">data: &#123;</div><div class=\"line\">limit: 6,</div><div class=\"line\">img_size: &apos;small&apos;</div><div class=\"line\">&#125;,</div><div class=\"line\">success: function (res) &#123;</div><div class=\"line\">if (res.statusCode == 200) &#123;</div><div class=\"line\">_this.setData(&#123;</div><div class=\"line\">banners: res.data.objects</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure><br><br>在 wx.request() 的回调函数中判断 res.statusCode 是否 为 200 ， 若 为 200 则 代 表 请 求 成 功 ， 接 着 将 数 据 保 存 到banners 数组中。<br>我 们 在 success 回 调 函 数 中 使 用_this.setData({ banners: res.data.objects }); 设置banners 的值。<br>注意 ： 这 里 不 能 直 接 使 用this.setData() ，因为 success 回调函数是一个闭包，我们要先 在 闭 包 外 面 定 义 var _this = this; ， 再调用_this.setData()，以保证闭包内能到正确的 this 值。现在，在视图中我们就能看到完整的 banner 列表了。<br><br>## 如何做商品列表<br>#### 1.为布局而生的 Flex<br>传统的布局方式一般都是基于 div 盒子模型，利用 float，position， display 来进行布局。每个前端开发者对这些布局方式都非常熟悉。对一些特殊的布局来说，使用这些属性并不方便，由此还衍生出各种 hack 方案。直到CSS3 提出了专为布局而生的解决方案，就是 Flex 布局。但是，由于浏览器的兼容问题，大多数开发者都不敢将 Flex 布局直接应用到实际项目之中。在常规项目中，大量应用 Flex 布局还需要一个过程。<br><br>而对于 WeChat Only 的小程序来说，则完全不用担心有浏览器兼容的问题，它只要适配微信客户端即可。同时，由于小程序的布局不会非常复杂，所以，也不用过多地担心大量使用 Flex 引起的性能问题。我们可以放心地在小程序中使用 Flex 来处理布局。<br>#### 2.如何更方便地使用 rpx<br>rpx 的全称是 responsive pixel，它是小程序自己定义的一个尺寸单位，可以根据当前设备的屏幕宽度进行自适应。小程序中规定，所有的设备屏幕宽度都为 750rpx，根据设备屏<br>幕实际宽度的不同， 1rpx 所代表的实际像素值也不一样。<br><br>例如，在 iPhone 6 上，屏幕实际宽度为 375px，则 750rpx =375px， 1rpx = 0.5px；而在 iPhone 5 上，屏幕实际宽度为 320px，则 750rpx = 320px， 1rpx = 0.42px。<br>其实，我们并不必关心每种设备屏幕下 1rpx 到底代表多少个像素，只要抓住 「所有的设备屏幕宽度都为 750rpx」这个原则，就能很好地实现对任意设备屏幕大小的自适应布局。强烈建议用 iPhone 6 作为视觉稿的标准，即将视觉稿总宽度设成 750px。这样，开发者就能很方便地对相关的尺寸进行量取。比如，在总宽度为 750px 的 iPhone 6 视觉稿中，量取一个图片的宽度为 200px，那么，这个图片的宽度即可设置为 200rpx。<br><br>简单一句话解释：量取多少就设置多少。<br><br>#### 3.Flex配合rpx的使用案例<br>现在，我们就在小程序中使用 Flex 和 rpx 进行布局，体验一下这种解决方案的便利。<br>第一个例子：货架列表效果图：<br><div align=\"center\"><br> <img src=\"http://oi28tswuq.bkt.clouddn.com/images/wxapponline2.jpg\" alt=\"\"><br></div><br><br>首先还是贴两段代码，以下是 WXML 的实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** index.wxml ***/</div><div class=\"line\">&lt;view class=&quot;shelf-nav&quot;&gt;</div><div class=\"line\">&lt;view class=&quot;shelf-nav-item&quot;</div><div class=\"line\">wx:for=&quot;&#123;&#123; shelfNavList &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;navigator</div><div class=\"line\">url=&quot;../list/list?id=&#123;&#123; item.id &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;image src=&quot;&#123;&#123; item.cover_image &#125;&#125;&quot;</div><div class=\"line\">class=&quot;shelf-nav-item__image&quot;&gt; &lt;/image&gt;</div><div class=\"line\">&lt;text&gt;&#123;&#123; item.name &#125;&#125;&lt;/text&gt;</div><div class=\"line\">&lt;/navigator&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">&lt;/view&gt;</div></pre></td></tr></table></figure><br><br>然后 WXSS 的代码如下，在关键代码处已经给出简要注释：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** index.wxss ***/</div><div class=\"line\">.shelf-nav &#123;</div><div class=\"line\">display: flex; // 设 置 display: flex; 将 它 变 为flex 布局的元素</div><div class=\"line\">flex-wrap: wrap; //当子元素总宽度超过父元素宽度时换行显示</div><div class=\"line\">padding: 30rpx;</div><div class=\"line\">&#125;</div><div class=\"line\">.shelf-nav-item &#123;</div><div class=\"line\">width: 25%; //因为每行显示 4 个货架，所以宽度设置为25%;</div><div class=\"line\">margin-bottom: 20rpx;</div><div class=\"line\">text-align: center; //让它中间的图片和标题居中显示</div><div class=\"line\">&#125;</div><div class=\"line\">.shelf-nav-item__image &#123;</div><div class=\"line\">width: 130rpx; //在视觉稿中量取图片宽高为 130px</div><div class=\"line\">height: 130rpx; //于是设置 width 和 height 都设置为 130rpx;</div><div class=\"line\">border-radius: 50%; //把图片设置成圆形</div><div class=\"line\">border: 1px solid #d9d9d9; //加上外边框</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br><br>简单几步就完成了货架列表的布局， 并且完美兼容各种大小的设备屏幕。<br><br>第二个例子：效果图如下：<br><div align=\"center\"><br> <img src=\"http://oi28tswuq.bkt.clouddn.com/images/wxapponline3.png-public\" alt=\"\"><br></div><br><br>如上图所示， 需要做到的效果是标题居左，「查看更多」（即…）的图标居右并且垂直居中。<br>代码结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** index.wxml ***/</div><div class=\"line\">&lt;view class=&quot;shelf-header&quot;&gt;</div><div class=\"line\">&lt;view class=&quot;shelf-title&quot;&gt;</div><div class=\"line\">&lt;text</div><div class=\"line\">class=&quot;shelf-title-en&quot;&gt;&#123;&#123; shelf.english_name &#125;&#125;&lt;/</div><div class=\"line\">text&gt;</div><div class=\"line\">&lt;text</div><div class=\"line\">class=&quot;shelf-title-cn&quot;&gt;&#123;&#123; shelf.name &#125;&#125;&lt;/text&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">&lt;view class=&quot;shelf-more&quot;&gt;</div><div class=\"line\">&lt;navigator</div><div class=\"line\">url=&quot;../list/list?id=&#123;&#123; shelf.id &#125;&#125;&quot;</div><div class=\"line\">class=&quot;ifanrin-more-icon ifanrin&quot;&gt; &lt;/navigator&gt;&lt;/view&gt;</div><div class=\"line\">&lt;/view&gt;</div></pre></td></tr></table></figure><br><br>有经验的同学一眼就可以看出，要实现需求需要：<br>1/让 .shelf-title 向左浮动<br>2/让 .shelf-more 水平方向右对齐、垂直方向居中<br>3/最后还要给 .shelf-header clearfix 一下<br>那现在来看看 Flex 是怎么做的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** index.wxss ***/</div><div class=\"line\">.shelf-header &#123;</div><div class=\"line\">display: flex; //设置为 flex 布局的元素</div><div class=\"line\">justify-content: space-between; //均匀排列每个元</div><div class=\"line\">素，首、末两元素分别位于起点和终点</div><div class=\"line\">&#125;</div><div class=\"line\">.shelf-more &#123;</div><div class=\"line\">align-self: center; //设置居中</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br><br>只要区区几行代码，就能轻松使用 Flex 调整排版。<br>接下来，发起一个请求获取数据，然后setData() 绑定数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** index.js ***/</div><div class=\"line\">Page()&#123;</div><div class=\"line\">...,</div><div class=\"line\">onLoad: function () &#123;</div><div class=\"line\">var that = this;</div><div class=\"line\">wx.request(&#123;</div><div class=\"line\">url: CONFIG.API_URL.SHELF_QUERY,</div><div class=\"line\">method: &apos;GET&apos;,</div><div class=\"line\">data: &#123;</div><div class=\"line\">img_size: &apos;small&apos;</div><div class=\"line\">&#125;,success: function (res) &#123;</div><div class=\"line\">that.setData(&#123;</div><div class=\"line\">shelfNavList: res.data.objects</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;,</div><div class=\"line\">...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br><br>此时列表页就基本完成了。<br><br>#### 4、template模板的使用<br>效果图如下：<br><br><div align=\"center\"><br> <img src=\"http://oi28tswuq.bkt.clouddn.com/images/wxapponline1.jpg\" alt=\"\"><br></div><br><br>不难发现，这两个页面的列表的样式是一模一样的。那么，我们就可以把每个商品视为一个模块，暂且把这个商品模块称为 product-card，我们可以将它用 template 封装起来，<br>在需要的地方就将它引入并进行调用。这里先要弄清楚一个概念， template 的主要功能更多的是在于定义一个 WXML 代码片段，然后在不同的地方调用。template 拥有自己的作用域， 而且只能使用 data 传入的数据。接下来看看template 到底如何使用。<br><br><font color=\"red\">1.定义 template 模板</font>\n\n<p>为了方便代码组织，我们在 templates 目录下，新建一个productCard 文 件 夹 ， 并 在 product-card 文 件 夹 下 新 建productCard.wxml 和 productCard.wxss 文件。代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;template name=&quot;productCard&quot;&gt;</div><div class=\"line\">&lt;view class=&quot;product-card&quot;&gt;</div><div class=\"line\">&lt;navigator</div><div class=\"line\">url=&quot;../detail/detail?id=&#123;&#123; id &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;view style=&quot;background-image:</div><div class=\"line\">url(&#123;&#123; cover_image &#125;&#125;)&quot; class=&quot;product-cover&quot;&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">&lt;view&gt;</div><div class=\"line\">&lt;text</div><div class=\"line\">class=&quot;product-title&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/text&gt;</div><div class=\"line\">&lt;text class=&quot;product-price&quot;&gt;</div><div class=\"line\">￥&#123;&#123; price &#125;&#125;&lt;/text&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">&lt;/navigator&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">&lt;/template&gt;</div></pre></td></tr></table></figure></p>\n<p>使用 name 属性，定义模板的名字，然后将代码片断保存在template 中。</p>\n<p><font color=\"red\">2.引入 template 模板</font><br>以首页为例，当要使用到 productCard 模板时，我们只需要使用 import 引入模板。在需要显示的位置，外层用 wx:for 循环渲染列表， template为子项，使用 is 声明需要的使用的模板，用 data 传入数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** index.wxml ***/</div><div class=\"line\">&lt;import</div><div class=\"line\">src=&quot;../../templates/productCard/productCard.wxml</div><div class=\"line\">&quot; /&gt;</div><div class=\"line\">&lt;view class=&quot;product-list&quot;&gt;</div><div class=\"line\">&lt;block wx:for=&quot;&#123;&#123; productNewList &#125;&#125;&quot; &lt;template</div><div class=\"line\">is=&quot;productCard&quot; data=&quot;&#123;&#123; ...item &#125;&#125;&quot; /&gt; &lt;/block&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">留意 data=&quot;&#123;&#123; ...item &#125;&#125; 的写法， item 是 wx:for 中代表数组当前项的默认变量名，</div><div class=\"line\"> item 前面的 ... 操作符相当于ES6 中的展开运算符，可用于需要解构赋值的地方.通 过 解 构 ，</div><div class=\"line\">  template 中 就 可 以 直 接 写 成 &#123;&#123; id &#125;&#125; ，&#123;&#123; cover_image &#125;&#125; ， 而 不 用 写 &#123;&#123; item.id &#125;&#125; ，</div><div class=\"line\">  &#123;&#123; item.cover_image &#125;&#125;。它的意义在于实现了 template 与 wx:for-item 之间的解耦，</div><div class=\"line\">  比如这里设置了 wx:for-item=&quot;product&quot;，我们只要设改变data=&quot;&#123;&#123; ...product &#125;&#125;&quot; 就可以了。</div><div class=\"line\">如果数据没有通过解构，就要将 template 的 &#123;&#123; item.id &#125;&#125;修改成 &#123;&#123; product.id &#125;&#125;，很不方便。</div><div class=\"line\">接着，是 productCard.wxss 的引入，先在 productCard写好样式，这里就不贴代码了</div></pre></td></tr></table></figure></p>\n<h4 id=\"5-模板的-WXSS文件如何引入\"><a href=\"#5-模板的-WXSS文件如何引入\" class=\"headerlink\" title=\"5.模板的 WXSS文件如何引入\"></a>5.模板的 WXSS文件如何引入</h4><p>在哪里可以引入 WXSS 文件？一种方法是在用到 productCard 模板的页面里引入，在这里是在 list.wxss 中 import 进来。另一种方法是，直接在 app.wxss 中引入。相比较于上一种方法，这个方法只需要一次引入，而所有用到 productCard 模板的页面都不用再去引入 productCard.wxss 了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** app.wxss ***/</div><div class=\"line\">@import &quot;./templates/productCard/productCard.wxss&quot;;</div></pre></td></tr></table></figure></p>\n<p>获取商品列表数据，渲染视图先通过 onLoad 的 options 取得 id：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** list.js ***/</div><div class=\"line\">onLoad: function (options) &#123;</div><div class=\"line\">var id = options.id;</div><div class=\"line\">this.setData(&#123;</div><div class=\"line\">shelfId: id</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最 后 ， 调 用 wx:request() 获 取 商 品 列 表 数 据 ， 通 过setData() 设置 productNewList，即可在视图层渲染出完整的列表。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** list.js ***/</div><div class=\"line\">onLoad: function (options) &#123;</div><div class=\"line\">...</div><div class=\"line\">wx.request(&#123;</div><div class=\"line\">url: CONFIG.API_URL.PRODUCT_LIST,</div><div class=\"line\">method: &apos;GET&apos;,</div><div class=\"line\">data: &#123;</div><div class=\"line\">shelf__id: this.data.shelfId</div><div class=\"line\">&#125;,</div><div class=\"line\">success: function (res) &#123;</div><div class=\"line\">if (res.status == 200) &#123;</div><div class=\"line\">that.setData(&#123;</div><div class=\"line\">productNewList: res.data.objects</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如上面的代码所示，现在小程序会一次性将所有商品列表查询并渲染至页面中。现实中，这种做法显然是不科学的。我们还需要一个「加载更多」的功能。这个功能要求我们做到：用户访问时，页面首次加载 20 个商品，点击列表底部的「查看更多」按钮可再多加载 10 个商品。</p>\n<h2 id=\"数据加载和图文排版\"><a href=\"#数据加载和图文排版\" class=\"headerlink\" title=\"数据加载和图文排版\"></a>数据加载和图文排版</h2><h4 id=\"1-「查看更多」功能\"><a href=\"#1-「查看更多」功能\" class=\"headerlink\" title=\"1.「查看更多」功能\"></a>1.「查看更多」功能</h4><p>效果图如下：</p>\n<div align=\"center\"><br> <img src=\"http://oi28tswuq.bkt.clouddn.com/images/wxapponline4.png-public\" alt=\"\"><br></div>\n\n<p>一、 调用 Toast 提示<br>通过调用 wx.showToast() ，可以实现上图中部的 Toast 提示（加载中）。微信提供的 Toast 组件有 success 和 loading 两种状态（旧版本的 loading 组件已经被废弃）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***list.js***/</div><div class=\"line\">wx.showToast(&#123;</div><div class=\"line\">title: &apos;成功&apos;, //提示的文字信息icon: &apos;success&apos;, //图标，只支持&quot;success&quot;、 &quot;loading&quot;</div><div class=\"line\">duration: 2000, //提示的延迟时间(毫秒)，最大为 10000</div><div class=\"line\">success: function() &#123;&#125;, //调用成功的回调函数</div><div class=\"line\">fail: function() &#123;&#125;, //调用失败的回调函数</div><div class=\"line\">//接口调用结束的回调函数（调用成功、失败都会执行）</div><div class=\"line\">complete: function() &#123;&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>需要注意的是， 当 showToast 执行时，整个页面是不可点击的。所以，不用考虑用户意外触发多次「查看更多」的问题。调用 wx.hideToast() 即可隐藏 Toast 提示框。现 在 ， 我 们 来 思 考 一 个 问 题 。 上 面 说到 wx.showToast 的 duration 最大值为 10000 毫秒，也就意味着当请求时间大于 10 秒，若没有返回数据时， loading 提示框会自动消失。</p>\n<p>当然这会带来一些问题：<br>1.「查看更多」按钮重新变回可点击状态，可能造成请求的重复提交。<br>2.加载提示消失与数据成功加载之间出现时间差。<br>如何解决这个问题呢？其实不难！！！<br>先给 loading 设置 10000 毫秒延迟时间，超过 10000 毫秒后，即使请求成功，也不保存任何数据。同时，将按钮文字改回「查看更多」即可。<br>我 们 初 始 化 一 个 timeoutFlag 的 对 象 ， 使 用 timer =setTimeout() 设 置 9800 毫 秒 延 时 。 9800 毫 秒 后 ，以 timer 为 key 设置一个对象 { isTimeout: true }，每次发起请求时都会有一个 timer 作为标识。</p>\n<p>若请求成功时 timeoutFlag.timer 的值为 { isTimeout:true }，则不处理请求成功后的数据。为什么要设置 9800 毫秒而不是 10000 毫秒呢？<br>那是因为 setTimeout 的计时并不准确，我们给出 200 毫秒的提前量，以防止代码出错。下面就来封装一个 _setTimeoutFlag 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***list.js***/</div><div class=\"line\">_setTimeoutFlag: function () &#123;</div><div class=\"line\">var that = this;</div><div class=\"line\">var timer = null;</div><div class=\"line\">timer = setTimeout(function () &#123;</div><div class=\"line\">that.setData(&#123;</div><div class=\"line\">tipText: &apos;查看更多&apos;</div><div class=\"line\">&#125;);</div><div class=\"line\">timeoutFlag.timer = &#123; isTimeout: true &#125;;</div><div class=\"line\">&#125;, 9800);</div><div class=\"line\">timeoutFlag.timer = &#123; isTimeout: false &#125;;</div><div class=\"line\">return timer;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>二、 构建与实现 loadMore 函数<br>我们需要一个 loadMore 函数，来做到数据的分页查询。一般，都是通过设置两个查询参数来控制，分别是每次请求条数 limit 和每次请求起始数 offset（即从第几条获取数据）。以我们的需求为例：<br>1.第一次获取 20 条： limit=20 &amp; offset=0<br>2.第二次再新增 10 条： limit=10 0&amp; offset=20<br>3.第三次再新增 10 条： limit=10 &amp; offset=30<br>当然，根据各自不同的分页实现， limit 和 offset 的命名也不相同，我们只要了解原理即可。</p>\n<p>根据以上逻辑，当用户点击「查看更多」按钮后，小程序在不同情况下应该给出相应的反应：<br>1.按钮文字变为「正在加载…」，页面弹出「加载中…」的loading 提示框，设置 offset + 10 并发起请求；<br>2.有新数据加载时，按钮文字变回「查看更多」，关闭 loading提示框，保存当前 offset；<br>3.无新数据加载时，按钮文字变为「没有更多啦」，关闭loading 提示框。<br>4.请求失败时，按钮文字变为「查看更多」，关闭 loading 提示框</p>\n<p>先在 list.wxml 中设置按钮，并绑定点击事件 loadMore;。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***list.wxml***/</div><div class=\"line\">&lt;view class=&quot;btn-load-more&quot; bindtap=&quot;loadMore&quot;&gt;</div><div class=\"line\">&#123;&#123; tipText &#125;&#125;</div><div class=\"line\">&lt;/view&gt;</div></pre></td></tr></table></figure></p>\n<p>根 据 上 面 的 流 程 ， 封 装 一下 _getProductList 和 loadMore 方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***list.js***/</div><div class=\"line\">loadMore: function () &#123;var that = this;</div><div class=\"line\">this.setData(&#123;</div><div class=\"line\">tipText: &apos;正在加载...&apos;</div><div class=\"line\">&#125;);</div><div class=\"line\">wx.showToast(&#123;</div><div class=\"line\">title: &apos;加载中...&apos;,</div><div class=\"line\">icon: &apos;loading&apos;,</div><div class=\"line\">duration: 10000</div><div class=\"line\">&#125;);</div><div class=\"line\">var timer = that._setTimeoutFlag();</div><div class=\"line\">this._getMoreProductList(timer);</div><div class=\"line\">&#125;,</div><div class=\"line\">_getMoreProductList: function (timer) &#123;</div><div class=\"line\">var that = this;</div><div class=\"line\">wx.request(&#123;</div><div class=\"line\">url: CONFIG.API_URL.PRODUCT_LIST +</div><div class=\"line\">this.data.orderBy,</div><div class=\"line\">method: &apos;GET&apos;,</div><div class=\"line\">data: &#123;</div><div class=\"line\">limit: 10,</div><div class=\"line\">offset: this.data.offset + 10,</div><div class=\"line\">shelf__id: this.data.shelfId,</div><div class=\"line\">img_size: &apos;small&apos;</div><div class=\"line\">&#125;,</div><div class=\"line\">success: function (data) &#123;</div><div class=\"line\">if (!timeoutFlag.timer.isTimeout) &#123;</div><div class=\"line\">if (data.data.objects.length &gt; 1) &#123;</div><div class=\"line\">var objects = that.data.productList</div><div class=\"line\">.concat(data.data.objects);</div><div class=\"line\">that.setData(&#123;</div><div class=\"line\">productList: objects,</div><div class=\"line\">offset: that.data.offset + 10,</div><div class=\"line\">tipText: &apos;查看更多&apos;&#125;);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">that.setData(&#123;</div><div class=\"line\">tipText: &apos;没有更多啦&apos;</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">clearTimeout(timer);</div><div class=\"line\">wx.hideToast();</div><div class=\"line\">&#125;,</div><div class=\"line\">fail: function () &#123;</div><div class=\"line\">that.setData(&#123;</div><div class=\"line\">tipText: &apos;查看更多&apos;</div><div class=\"line\">&#125;);</div><div class=\"line\">wx.hideToast();</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>至此，已经完整实现了商品列表页的开发，接下来进入商品详情页.</p>\n<h4 id=\"2-商品详情页与图文排版实现\"><a href=\"#2-商品详情页与图文排版实现\" class=\"headerlink\" title=\"2.商品详情页与图文排版实现\"></a>2.商品详情页与图文排版实现</h4><p>效果图如下：</p>\n<p><div align=\"center\"><br> <img src=\"http://oi28tswuq.bkt.clouddn.com/images/wxapponline5.png\" alt=\"\"><br></div><br>目前商品详情的图文介绍，一般都是通过后台的富文本编辑器来排版创建的，数据都是以 HTML 代码的形式保存下来，然后在页面上直接渲染出来。但是对于小程序来说， HTML形式的数据不能直接拿来使用，因为小程序根本不能解析 HTML 代码。此时，我们需要处理由富文本编辑器所创建的数据，将其转换为JSON 格式的数据，以便于在小程序里使用。<br>现在有两种思路去解决这个问题：<br>1.由前端去解析 HTML 格式的数据，用正则匹配 HTML 标签，然后转换成 JSON 数据；<br>2.交由后端去解析，同时新增一个专用的 API，返回解析过的 JSON数据。<br>这里选用的是第二种方案，获取到的 JSON 数据格式如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">&quot;description&quot;: [</div><div class=\"line\">&#123;</div><div class=\"line\">&quot;content&quot;: &quot;xxx.jpg&quot;,</div><div class=\"line\">&quot;type&quot;: &quot;image&quot;</div><div class=\"line\">&#125;,</div><div class=\"line\">&#123;</div><div class=\"line\">&quot;content&quot;: &quot;商品᧿述文字&quot;,</div><div class=\"line\">&quot;type&quot;: &quot;text&quot;</div><div class=\"line\">&#125;</div><div class=\"line\">]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我 们 只 要 将 获 取 的 数 据 用 wx:for 渲 染 出 来 ， 渲 染 时 判断 type 选择对应的 text 或 image 组件即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***detail.wxml***/</div><div class=\"line\">&lt;block wx:for=&quot;&#123;&#123; description &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;view</div><div class=\"line\">class=&quot;description-img&quot;</div><div class=\"line\">wx:if=&quot;&#123;&#123; item.type == &apos;image&apos; &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;image</div><div class=\"line\">class=&quot;description-img-content&quot;</div><div class=\"line\">src=&quot;&#123;&#123; item.content &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;/image&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">&lt;view</div><div class=\"line\">class=&quot;description-text&quot;</div><div class=\"line\">wx:elif=&quot;&#123;&#123; item.type == &apos;text&apos; &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;text class=&quot;description-text-content&quot;&gt;</div><div class=\"line\">&#123;&#123; item.content &#125;&#125;</div><div class=\"line\">&lt;/text&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">&lt;/block&gt;</div></pre></td></tr></table></figure></p>\n<p>仔细观察一下，可以发现，每一张图片的宽高都发生了不同程度的裁剪、拉伸或压缩。这是由于 image 组件的默认宽高导致的，这个问题在上面也说过，要特别留意小程序内置组件的默认样式，它们很可能会引起各种各样的问题。我们的期望是，图片能够按照原有的宽高比例进行显示，并且每一张图片的宽度都能撑满整个内容区域。这应该如何处理呢？这里就需要用到 image 组件的 load 事件，使用 bindload 属性将事件绑定在 image 组件中。我 们 可 以 用 event.detail = {height:’ 图 片 高 度 px’,width:’图片宽度 px’} 的方式调整图片宽高尺寸。<br>我们定义一个 imageLoad 函数，作为 image 组件的 load 事件的处理函数，用 data-index 保存当前 wx:for 的 index 值作当前图片的索引值。detail.wxml 改写 image 组件如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;image</div><div class=\"line\">class=&quot;description-img-content&quot;</div><div class=\"line\">src=&quot;&#123;&#123; item.content &#125;&#125;&quot;</div><div class=\"line\">bindload=&quot;imageLoad&quot;</div><div class=\"line\">data-index=&quot;&#123;&#123; index &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;/image&gt;</div><div class=\"line\">detail.js 定义 imageLoad 函数如下：</div><div class=\"line\">data: &#123;</div><div class=\"line\">images: &#123;&#125;</div><div class=\"line\">&#125;,</div><div class=\"line\">imageLoad: function (e) &#123;</div><div class=\"line\">var realityWidth = e.detail.width; //获取图片实际宽度</div><div class=\"line\">var realityHeight = e.detail.height; //获取图片实际高度//获取图片的实际宽高比例</div><div class=\"line\">var proportion = realityWidth / realityHeight;//设置图片的渲染宽度， 750rpx - (2 * 40rpx) = 670rpx;</div><div class=\"line\">//父元素的左右 padding 都是 40rpx</div><div class=\"line\">var viewWidth = 670;//按比例计算出图片的渲染高度</div><div class=\"line\">var viewHeight = 670 / proportion;</div><div class=\"line\">var images = this.data.images;//将图片的 data-index 值作为 images 对象的 key</div><div class=\"line\">//用来储存该图片的计算后的渲染宽高</div><div class=\"line\">images[e.currentTarget.dataset.index] = &#123;</div><div class=\"line\">width: viewWidth,</div><div class=\"line\">height: viewHeight</div><div class=\"line\">&#125;;</div><div class=\"line\">this.setData(&#123;</div><div class=\"line\">images: images</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>此 时 ，就 可 以 在 image 组 件 中 获 取到 images[index].width 和 images[index].height，并通过设置行内的 style 给每一个图片设置宽高了。<br>detail.wxml 改写 image 组件如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;image class=&quot;description-img-content&quot;</div><div class=\"line\">src=&quot;&#123;&#123; item.content &#125;&#125;&quot; bindload=&quot;imageLoad&quot;</div><div class=\"line\">data-index=&quot;&#123;&#123; index &#125;&#125;&quot;</div><div class=\"line\">style=&quot;width:&#123;&#123; images[index].width &#125;&#125;rpx;</div><div class=\"line\">height:&#123;&#123; images[index].height &#125;&#125;rpx&quot;&gt;</div><div class=\"line\">&lt;/image&gt;</div></pre></td></tr></table></figure></p>\n<p>此时在预览页面时，你会发现图片等就会正常显示了。</p>\n<h4 id=\"内容总结提示\"><a href=\"#内容总结提示\" class=\"headerlink\" title=\"内容总结提示\"></a>内容总结提示</h4><ul>\n<li><p>Toast 提示：<br>1.Toast 提 示 可 以 使 用 wx.showToast() 来 调 用 ， 使用 wx.hideToast() 隐藏。l 开发者可以自定义 Toast 展示时间、展示文案等。<br>2.Toast 最长展示时间不能超过 10000 毫秒，开发者需要做好超时处理工作。</p>\n</li>\n<li><p>图文排版：<br>1.如果服务器中的数据是 HTML 数据，需要转换为 JSON，小程序才能解析。<br>2.直接将图片进行排版，图片宽高会出现问题。开发者需要处理好图片的宽高问题。</p>\n</li>\n</ul>\n","excerpt":"","more":"<p>电商类平台主要由首页、分类页、商品列表页、商品详情页、购物车、订单结算页和个人中心等几大模块组成。<br>在开发过程中，也会穿插介绍一些常用简单内置组件的使用，最再后利用小程序的 template 模板，对自定义组件化开发的实现提供三种参考模式。</p>\n<h4 id=\"1、准备开工\"><a href=\"#1、准备开工\" class=\"headerlink\" title=\"1、准备开工\"></a>1、准备开工</h4><p>先新建一个文件夹 wxapponline 作为项目目录，里面包含：<br>   1.common 目录——用来放置项目公用的文件<br>   2.pages 目录——项目页面开发目录，里面的每个子目录代表一 个 独 立 页 面 ， 分 别 包 含 与 目 录 同 名 的 .wxml （ 必须）， .wxss， .js（ 必须）和 .json 文件<br>   3.templates 目录——用来放置自定义的组件<br>   4.utils 目录——用来放置工具类 js 文件<br>   5.app.js——小程序逻辑<br>   6.app.json——小程序公共设置<br>   7.app.wxss——小程序公共样式表</p>\n<h4 id=\"2、轮播banner样式定义\"><a href=\"#2、轮播banner样式定义\" class=\"headerlink\" title=\"2、轮播banner样式定义\"></a>2、轮播banner样式定义</h4><p>和大多数项目一样，最开始是首页的实现。<br>首 页 在 pages/index 目 录 下 ， 包 括 index.wxml 、index.wxss、 index.js 三个文件。</p>\n<font color=\"red\">实现 banner 轮播图，来看代码：</font><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** index.wxml ***/</div><div class=\"line\">&lt;swiper class=&quot;banner-swiper&quot;</div><div class=\"line\">indicator-dots=&quot;&#123;&#123; indicatorDots &#125;&#125;&quot;</div><div class=\"line\">autoplay=&quot;&#123;&#123; autoplay &#125;&#125;&quot; interval=&quot;&#123;&#123; interval &#125;&#125;&quot;</div><div class=\"line\">duration=&quot;&#123;&#123; duration &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;swiper-item class=&quot;swiper-item&quot;</div><div class=\"line\">wx:for=&quot;&#123;&#123; banners &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;navigator</div><div class=\"line\">url=&quot;../detail/detail?id=&#123;&#123; item.productId &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;image src=&quot;&#123;&#123; item.image &#125;&#125;&quot;</div><div class=\"line\">class=&quot;slide-image&quot;&gt;&lt;/image&gt;</div><div class=\"line\">&lt;/navigator&gt;</div><div class=\"line\">&lt;/swiper-item&gt;</div><div class=\"line\">&lt;/swiper&gt;</div></pre></td></tr></table></figure><br><br>值得注意的是， image 组件会有一个默认的样式.可以到官方文档中去查找images组件的默认样式。默认宽高可能在不同的版本中有不同的值。我们可以根据实际情况给它重新定义一个宽高值。单位：rpx;<br>友情提：大多数小程序内置组件都会有自己的默认样式，我们可以利用开发工具中的wxml panel，多了解一下这些组件的默认样式，可以避免很多由组件默认样式引起的问题。<br>另一个注意点是，不要将大图片放到项目目录中，因为小程序代码总大小不能超过 1 MB，而大图片会占用大量的空间，所以要尽量避免在项目目录中放置大图片。<br>如有需要，建议只在项目目录中放置少量 icon 类的小图片，其他大图片可以上传到自己的服务器或者网盘中，然后在 src 中设置图片的网络资源地址。<br>在手机测试或者正式上线之前，要注意是否有引用了本地大图片导致代码超出大小限制的问题。<br><br>#### 3.准备获取 banner    数据，并绑定到视图层<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** index.js ***/</div><div class=\"line\">Page(&#123;</div><div class=\"line\">data: &#123;</div><div class=\"line\">banners: [], //初始化一个 banners 数组</div><div class=\"line\">//以下四项设置 swiper 组件的参数值</div><div class=\"line\">indicatorDots: true</div><div class=\"line\">, autoplay: true, //开启自动切换</div><div class=\"line\">interval: 5000, //自动切换时间间隔</div><div class=\"line\">duration: 1000 //滑动动画时长&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure><br><br>在 Page 里的 data 会以 JSON 的形式由逻辑层传至视图层，然后在视图层中使用 Mustache 语法（双大括号）接收传入的数据，实现动态数据的数据绑定。经过绑定后的数据变动可以在视图中实时反应，也可以通过开发者工具中的 AppData Panel 中查看和编辑页面中的所有 data 数据。<br>友情提醒：当你不知道 data 数据是否被设置成功的时候，可以到 AppData Panel 来查看一下，免去了手动打 console.log 进行调试的麻烦。<br><br>实现动态数据绑定的另一个方式是使用 this.setData() 方法 ， this 在 这 里 代 表 的 是 Page ， 而 setData 是在PageX.prototype 中的方法，所以 this.setData() 实际上访问的是 Page.prototype.setData()。它可以用来新增和修改 this.data 里的值，同时还有一个重要的功能是将数据从逻辑层发送到视图层，从而实时改变页面的状态，保持逻辑层和视图层数据的一致性。需要注意的是，如果使用 this.data.property = value，同样可以设置 this.data 的值，但是它不会将数据发送到视图层，无法改变页面的状态。<br>注意： 一 定 要 避 免 使 用this.data.property = value 的方式设置数据。<br><br>#### 4.从服务器获取 banner数据<br>现在我们的目的是要得到一个 banners 数组，然后利 用 wx:for 将 banners 数 组 中 的 每 一 项 渲 染 到swiper-item 中。我们可以在页面加载（ onLoad） 时，使用 wx.request() 发<br>起一个 Ajax 请求，来获取到所需要的 banner 列表数据。先 来 看 一 下 wx.request(object) 的 使 用 方 法 。 首 先 是object 可以接受的参数值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. url：设置发送请求的地址。</div><div class=\"line\">2. method：请求方式，默认为 GET，有效值： OPTIONS， GET，HEAD， POST， PUT， DELETE， TRACE， CONNECT。注意，所有值都要使用大写。 经过测试，若使用小写，在安卓中会导致无法发起请求，而在开发者工具和 iOS 中则正常。</div><div class=\"line\">3. data：设置请求的参数。如果 method 值为 GET，这个函数会将 data 转换成 query 字符串，拼接在 url 后面，若 url 本身带有同名的 query 参数，那么 data 中的参数会覆盖 url 中的 query 参数；小 程 序 执 行 wx.request(object) 发 送 请 求 并 收 到success（成功）的消息后，会自动执行请求成功返回的回调函数。回调函数执行时，会自动收到类似这样的回调参数：</div><div class=\"line\">res = &#123;data: &apos;服务器返回的数据&apos;, errMsg: &apos;错误信息&apos;, statusCode: HTTP 状态码&#125;</div></pre></td></tr></table></figure><br><br>特别注意，在开发者工具和 iOS 中， res.statusCode 的类据类型是一个数值， 而在 Android 中的数据类型是一个字符串，所以在判断 res.statusCode 时不能直接使用 === 操作符，而应该用 == 操作符，或者是先对 res.statusCode 进行数据类型转换。现在，就可以在 onLoad 中调用 wx.request() 发起请求，访问获取 banner 列表的服务器 API。<br>我们将各服务器 API 的访问地址都保存在 API_URL 对象，保存在 utils/config.js 中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** config.js ***/</div><div class=\"line\">const CONFIG = &#123;</div><div class=\"line\">API_URL: &#123;</div><div class=\"line\">BANNER_QUERY: http://ifanr.com/api/banner</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">module.exports = CONFIG;</div><div class=\"line\">然 后 需 要 在 index.js 中 使 用 require 引 入utils/config.js 文件，引入路径为当前文件的相对路径：</div><div class=\"line\">/*** index.js ***/</div><div class=\"line\">var CONFIG = require(&apos;../../utils/config.js&apos;);</div><div class=\"line\">于是，我们就知道了在小程序中 js 模块化的方法，模块通过module.exports 对外暴露接口，在需要使用这些模块的文件中，使用 require(path) 将公共代码引入。发起 wx.request 请求：</div><div class=\"line\">/*** index.js ***/</div><div class=\"line\">var CONFIG = require(&apos;../../utils/config.js&apos;);</div><div class=\"line\">Page(&#123;</div><div class=\"line\">data: &#123;...</div><div class=\"line\">&#125;,</div><div class=\"line\">onLoad: function () &#123;</div><div class=\"line\">var _this = this;</div><div class=\"line\">wx.request(&#123;</div><div class=\"line\">url: CONFIG.API_URL.BANNER_QUERY,</div><div class=\"line\">method: &apos;GET&apos;,</div><div class=\"line\">data: &#123;</div><div class=\"line\">limit: 6,</div><div class=\"line\">img_size: &apos;small&apos;</div><div class=\"line\">&#125;,</div><div class=\"line\">success: function (res) &#123;</div><div class=\"line\">if (res.statusCode == 200) &#123;</div><div class=\"line\">_this.setData(&#123;</div><div class=\"line\">banners: res.data.objects</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure><br><br>在 wx.request() 的回调函数中判断 res.statusCode 是否 为 200 ， 若 为 200 则 代 表 请 求 成 功 ， 接 着 将 数 据 保 存 到banners 数组中。<br>我 们 在 success 回 调 函 数 中 使 用_this.setData({ banners: res.data.objects }); 设置banners 的值。<br>注意 ： 这 里 不 能 直 接 使 用this.setData() ，因为 success 回调函数是一个闭包，我们要先 在 闭 包 外 面 定 义 var _this = this; ， 再调用_this.setData()，以保证闭包内能到正确的 this 值。现在，在视图中我们就能看到完整的 banner 列表了。<br><br>## 如何做商品列表<br>#### 1.为布局而生的 Flex<br>传统的布局方式一般都是基于 div 盒子模型，利用 float，position， display 来进行布局。每个前端开发者对这些布局方式都非常熟悉。对一些特殊的布局来说，使用这些属性并不方便，由此还衍生出各种 hack 方案。直到CSS3 提出了专为布局而生的解决方案，就是 Flex 布局。但是，由于浏览器的兼容问题，大多数开发者都不敢将 Flex 布局直接应用到实际项目之中。在常规项目中，大量应用 Flex 布局还需要一个过程。<br><br>而对于 WeChat Only 的小程序来说，则完全不用担心有浏览器兼容的问题，它只要适配微信客户端即可。同时，由于小程序的布局不会非常复杂，所以，也不用过多地担心大量使用 Flex 引起的性能问题。我们可以放心地在小程序中使用 Flex 来处理布局。<br>#### 2.如何更方便地使用 rpx<br>rpx 的全称是 responsive pixel，它是小程序自己定义的一个尺寸单位，可以根据当前设备的屏幕宽度进行自适应。小程序中规定，所有的设备屏幕宽度都为 750rpx，根据设备屏<br>幕实际宽度的不同， 1rpx 所代表的实际像素值也不一样。<br><br>例如，在 iPhone 6 上，屏幕实际宽度为 375px，则 750rpx =375px， 1rpx = 0.5px；而在 iPhone 5 上，屏幕实际宽度为 320px，则 750rpx = 320px， 1rpx = 0.42px。<br>其实，我们并不必关心每种设备屏幕下 1rpx 到底代表多少个像素，只要抓住 「所有的设备屏幕宽度都为 750rpx」这个原则，就能很好地实现对任意设备屏幕大小的自适应布局。强烈建议用 iPhone 6 作为视觉稿的标准，即将视觉稿总宽度设成 750px。这样，开发者就能很方便地对相关的尺寸进行量取。比如，在总宽度为 750px 的 iPhone 6 视觉稿中，量取一个图片的宽度为 200px，那么，这个图片的宽度即可设置为 200rpx。<br><br>简单一句话解释：量取多少就设置多少。<br><br>#### 3.Flex配合rpx的使用案例<br>现在，我们就在小程序中使用 Flex 和 rpx 进行布局，体验一下这种解决方案的便利。<br>第一个例子：货架列表效果图：<br><div align=center><br> <img src=\"http://oi28tswuq.bkt.clouddn.com/images/wxapponline2.jpg\" alt=\"\"><br></div><br><br>首先还是贴两段代码，以下是 WXML 的实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** index.wxml ***/</div><div class=\"line\">&lt;view class=&quot;shelf-nav&quot;&gt;</div><div class=\"line\">&lt;view class=&quot;shelf-nav-item&quot;</div><div class=\"line\">wx:for=&quot;&#123;&#123; shelfNavList &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;navigator</div><div class=\"line\">url=&quot;../list/list?id=&#123;&#123; item.id &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;image src=&quot;&#123;&#123; item.cover_image &#125;&#125;&quot;</div><div class=\"line\">class=&quot;shelf-nav-item__image&quot;&gt; &lt;/image&gt;</div><div class=\"line\">&lt;text&gt;&#123;&#123; item.name &#125;&#125;&lt;/text&gt;</div><div class=\"line\">&lt;/navigator&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">&lt;/view&gt;</div></pre></td></tr></table></figure><br><br>然后 WXSS 的代码如下，在关键代码处已经给出简要注释：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** index.wxss ***/</div><div class=\"line\">.shelf-nav &#123;</div><div class=\"line\">display: flex; // 设 置 display: flex; 将 它 变 为flex 布局的元素</div><div class=\"line\">flex-wrap: wrap; //当子元素总宽度超过父元素宽度时换行显示</div><div class=\"line\">padding: 30rpx;</div><div class=\"line\">&#125;</div><div class=\"line\">.shelf-nav-item &#123;</div><div class=\"line\">width: 25%; //因为每行显示 4 个货架，所以宽度设置为25%;</div><div class=\"line\">margin-bottom: 20rpx;</div><div class=\"line\">text-align: center; //让它中间的图片和标题居中显示</div><div class=\"line\">&#125;</div><div class=\"line\">.shelf-nav-item__image &#123;</div><div class=\"line\">width: 130rpx; //在视觉稿中量取图片宽高为 130px</div><div class=\"line\">height: 130rpx; //于是设置 width 和 height 都设置为 130rpx;</div><div class=\"line\">border-radius: 50%; //把图片设置成圆形</div><div class=\"line\">border: 1px solid #d9d9d9; //加上外边框</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br><br>简单几步就完成了货架列表的布局， 并且完美兼容各种大小的设备屏幕。<br><br>第二个例子：效果图如下：<br><div align=center><br> <img src=\"http://oi28tswuq.bkt.clouddn.com/images/wxapponline3.png-public\" alt=\"\"><br></div><br><br>如上图所示， 需要做到的效果是标题居左，「查看更多」（即…）的图标居右并且垂直居中。<br>代码结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** index.wxml ***/</div><div class=\"line\">&lt;view class=&quot;shelf-header&quot;&gt;</div><div class=\"line\">&lt;view class=&quot;shelf-title&quot;&gt;</div><div class=\"line\">&lt;text</div><div class=\"line\">class=&quot;shelf-title-en&quot;&gt;&#123;&#123; shelf.english_name &#125;&#125;&lt;/</div><div class=\"line\">text&gt;</div><div class=\"line\">&lt;text</div><div class=\"line\">class=&quot;shelf-title-cn&quot;&gt;&#123;&#123; shelf.name &#125;&#125;&lt;/text&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">&lt;view class=&quot;shelf-more&quot;&gt;</div><div class=\"line\">&lt;navigator</div><div class=\"line\">url=&quot;../list/list?id=&#123;&#123; shelf.id &#125;&#125;&quot;</div><div class=\"line\">class=&quot;ifanrin-more-icon ifanrin&quot;&gt; &lt;/navigator&gt;&lt;/view&gt;</div><div class=\"line\">&lt;/view&gt;</div></pre></td></tr></table></figure><br><br>有经验的同学一眼就可以看出，要实现需求需要：<br>1/让 .shelf-title 向左浮动<br>2/让 .shelf-more 水平方向右对齐、垂直方向居中<br>3/最后还要给 .shelf-header clearfix 一下<br>那现在来看看 Flex 是怎么做的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** index.wxss ***/</div><div class=\"line\">.shelf-header &#123;</div><div class=\"line\">display: flex; //设置为 flex 布局的元素</div><div class=\"line\">justify-content: space-between; //均匀排列每个元</div><div class=\"line\">素，首、末两元素分别位于起点和终点</div><div class=\"line\">&#125;</div><div class=\"line\">.shelf-more &#123;</div><div class=\"line\">align-self: center; //设置居中</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br><br>只要区区几行代码，就能轻松使用 Flex 调整排版。<br>接下来，发起一个请求获取数据，然后setData() 绑定数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** index.js ***/</div><div class=\"line\">Page()&#123;</div><div class=\"line\">...,</div><div class=\"line\">onLoad: function () &#123;</div><div class=\"line\">var that = this;</div><div class=\"line\">wx.request(&#123;</div><div class=\"line\">url: CONFIG.API_URL.SHELF_QUERY,</div><div class=\"line\">method: &apos;GET&apos;,</div><div class=\"line\">data: &#123;</div><div class=\"line\">img_size: &apos;small&apos;</div><div class=\"line\">&#125;,success: function (res) &#123;</div><div class=\"line\">that.setData(&#123;</div><div class=\"line\">shelfNavList: res.data.objects</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;,</div><div class=\"line\">...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br><br>此时列表页就基本完成了。<br><br>#### 4、template模板的使用<br>效果图如下：<br><br><div align=center><br> <img src=\"http://oi28tswuq.bkt.clouddn.com/images/wxapponline1.jpg\" alt=\"\"><br></div><br><br>不难发现，这两个页面的列表的样式是一模一样的。那么，我们就可以把每个商品视为一个模块，暂且把这个商品模块称为 product-card，我们可以将它用 template 封装起来，<br>在需要的地方就将它引入并进行调用。这里先要弄清楚一个概念， template 的主要功能更多的是在于定义一个 WXML 代码片段，然后在不同的地方调用。template 拥有自己的作用域， 而且只能使用 data 传入的数据。接下来看看template 到底如何使用。<br><br><font color=\"red\">1.定义 template 模板</font>\n\n<p>为了方便代码组织，我们在 templates 目录下，新建一个productCard 文 件 夹 ， 并 在 product-card 文 件 夹 下 新 建productCard.wxml 和 productCard.wxss 文件。代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;template name=&quot;productCard&quot;&gt;</div><div class=\"line\">&lt;view class=&quot;product-card&quot;&gt;</div><div class=\"line\">&lt;navigator</div><div class=\"line\">url=&quot;../detail/detail?id=&#123;&#123; id &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;view style=&quot;background-image:</div><div class=\"line\">url(&#123;&#123; cover_image &#125;&#125;)&quot; class=&quot;product-cover&quot;&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">&lt;view&gt;</div><div class=\"line\">&lt;text</div><div class=\"line\">class=&quot;product-title&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/text&gt;</div><div class=\"line\">&lt;text class=&quot;product-price&quot;&gt;</div><div class=\"line\">￥&#123;&#123; price &#125;&#125;&lt;/text&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">&lt;/navigator&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">&lt;/template&gt;</div></pre></td></tr></table></figure></p>\n<p>使用 name 属性，定义模板的名字，然后将代码片断保存在template 中。</p>\n<p><font color=\"red\">2.引入 template 模板</font><br>以首页为例，当要使用到 productCard 模板时，我们只需要使用 import 引入模板。在需要显示的位置，外层用 wx:for 循环渲染列表， template为子项，使用 is 声明需要的使用的模板，用 data 传入数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** index.wxml ***/</div><div class=\"line\">&lt;import</div><div class=\"line\">src=&quot;../../templates/productCard/productCard.wxml</div><div class=\"line\">&quot; /&gt;</div><div class=\"line\">&lt;view class=&quot;product-list&quot;&gt;</div><div class=\"line\">&lt;block wx:for=&quot;&#123;&#123; productNewList &#125;&#125;&quot; &lt;template</div><div class=\"line\">is=&quot;productCard&quot; data=&quot;&#123;&#123; ...item &#125;&#125;&quot; /&gt; &lt;/block&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">留意 data=&quot;&#123;&#123; ...item &#125;&#125; 的写法， item 是 wx:for 中代表数组当前项的默认变量名，</div><div class=\"line\"> item 前面的 ... 操作符相当于ES6 中的展开运算符，可用于需要解构赋值的地方.通 过 解 构 ，</div><div class=\"line\">  template 中 就 可 以 直 接 写 成 &#123;&#123; id &#125;&#125; ，&#123;&#123; cover_image &#125;&#125; ， 而 不 用 写 &#123;&#123; item.id &#125;&#125; ，</div><div class=\"line\">  &#123;&#123; item.cover_image &#125;&#125;。它的意义在于实现了 template 与 wx:for-item 之间的解耦，</div><div class=\"line\">  比如这里设置了 wx:for-item=&quot;product&quot;，我们只要设改变data=&quot;&#123;&#123; ...product &#125;&#125;&quot; 就可以了。</div><div class=\"line\">如果数据没有通过解构，就要将 template 的 &#123;&#123; item.id &#125;&#125;修改成 &#123;&#123; product.id &#125;&#125;，很不方便。</div><div class=\"line\">接着，是 productCard.wxss 的引入，先在 productCard写好样式，这里就不贴代码了</div></pre></td></tr></table></figure></p>\n<h4 id=\"5-模板的-WXSS文件如何引入\"><a href=\"#5-模板的-WXSS文件如何引入\" class=\"headerlink\" title=\"5.模板的 WXSS文件如何引入\"></a>5.模板的 WXSS文件如何引入</h4><p>在哪里可以引入 WXSS 文件？一种方法是在用到 productCard 模板的页面里引入，在这里是在 list.wxss 中 import 进来。另一种方法是，直接在 app.wxss 中引入。相比较于上一种方法，这个方法只需要一次引入，而所有用到 productCard 模板的页面都不用再去引入 productCard.wxss 了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** app.wxss ***/</div><div class=\"line\">@import &quot;./templates/productCard/productCard.wxss&quot;;</div></pre></td></tr></table></figure></p>\n<p>获取商品列表数据，渲染视图先通过 onLoad 的 options 取得 id：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** list.js ***/</div><div class=\"line\">onLoad: function (options) &#123;</div><div class=\"line\">var id = options.id;</div><div class=\"line\">this.setData(&#123;</div><div class=\"line\">shelfId: id</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最 后 ， 调 用 wx:request() 获 取 商 品 列 表 数 据 ， 通 过setData() 设置 productNewList，即可在视图层渲染出完整的列表。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*** list.js ***/</div><div class=\"line\">onLoad: function (options) &#123;</div><div class=\"line\">...</div><div class=\"line\">wx.request(&#123;</div><div class=\"line\">url: CONFIG.API_URL.PRODUCT_LIST,</div><div class=\"line\">method: &apos;GET&apos;,</div><div class=\"line\">data: &#123;</div><div class=\"line\">shelf__id: this.data.shelfId</div><div class=\"line\">&#125;,</div><div class=\"line\">success: function (res) &#123;</div><div class=\"line\">if (res.status == 200) &#123;</div><div class=\"line\">that.setData(&#123;</div><div class=\"line\">productNewList: res.data.objects</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如上面的代码所示，现在小程序会一次性将所有商品列表查询并渲染至页面中。现实中，这种做法显然是不科学的。我们还需要一个「加载更多」的功能。这个功能要求我们做到：用户访问时，页面首次加载 20 个商品，点击列表底部的「查看更多」按钮可再多加载 10 个商品。</p>\n<h2 id=\"数据加载和图文排版\"><a href=\"#数据加载和图文排版\" class=\"headerlink\" title=\"数据加载和图文排版\"></a>数据加载和图文排版</h2><h4 id=\"1-「查看更多」功能\"><a href=\"#1-「查看更多」功能\" class=\"headerlink\" title=\"1.「查看更多」功能\"></a>1.「查看更多」功能</h4><p>效果图如下：</p>\n<div align=center><br> <img src=\"http://oi28tswuq.bkt.clouddn.com/images/wxapponline4.png-public\" alt=\"\"><br></div>\n\n<p>一、 调用 Toast 提示<br>通过调用 wx.showToast() ，可以实现上图中部的 Toast 提示（加载中）。微信提供的 Toast 组件有 success 和 loading 两种状态（旧版本的 loading 组件已经被废弃）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***list.js***/</div><div class=\"line\">wx.showToast(&#123;</div><div class=\"line\">title: &apos;成功&apos;, //提示的文字信息icon: &apos;success&apos;, //图标，只支持&quot;success&quot;、 &quot;loading&quot;</div><div class=\"line\">duration: 2000, //提示的延迟时间(毫秒)，最大为 10000</div><div class=\"line\">success: function() &#123;&#125;, //调用成功的回调函数</div><div class=\"line\">fail: function() &#123;&#125;, //调用失败的回调函数</div><div class=\"line\">//接口调用结束的回调函数（调用成功、失败都会执行）</div><div class=\"line\">complete: function() &#123;&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>需要注意的是， 当 showToast 执行时，整个页面是不可点击的。所以，不用考虑用户意外触发多次「查看更多」的问题。调用 wx.hideToast() 即可隐藏 Toast 提示框。现 在 ， 我 们 来 思 考 一 个 问 题 。 上 面 说到 wx.showToast 的 duration 最大值为 10000 毫秒，也就意味着当请求时间大于 10 秒，若没有返回数据时， loading 提示框会自动消失。</p>\n<p>当然这会带来一些问题：<br>1.「查看更多」按钮重新变回可点击状态，可能造成请求的重复提交。<br>2.加载提示消失与数据成功加载之间出现时间差。<br>如何解决这个问题呢？其实不难！！！<br>先给 loading 设置 10000 毫秒延迟时间，超过 10000 毫秒后，即使请求成功，也不保存任何数据。同时，将按钮文字改回「查看更多」即可。<br>我 们 初 始 化 一 个 timeoutFlag 的 对 象 ， 使 用 timer =setTimeout() 设 置 9800 毫 秒 延 时 。 9800 毫 秒 后 ，以 timer 为 key 设置一个对象 { isTimeout: true }，每次发起请求时都会有一个 timer 作为标识。</p>\n<p>若请求成功时 timeoutFlag.timer 的值为 { isTimeout:true }，则不处理请求成功后的数据。为什么要设置 9800 毫秒而不是 10000 毫秒呢？<br>那是因为 setTimeout 的计时并不准确，我们给出 200 毫秒的提前量，以防止代码出错。下面就来封装一个 _setTimeoutFlag 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***list.js***/</div><div class=\"line\">_setTimeoutFlag: function () &#123;</div><div class=\"line\">var that = this;</div><div class=\"line\">var timer = null;</div><div class=\"line\">timer = setTimeout(function () &#123;</div><div class=\"line\">that.setData(&#123;</div><div class=\"line\">tipText: &apos;查看更多&apos;</div><div class=\"line\">&#125;);</div><div class=\"line\">timeoutFlag.timer = &#123; isTimeout: true &#125;;</div><div class=\"line\">&#125;, 9800);</div><div class=\"line\">timeoutFlag.timer = &#123; isTimeout: false &#125;;</div><div class=\"line\">return timer;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>二、 构建与实现 loadMore 函数<br>我们需要一个 loadMore 函数，来做到数据的分页查询。一般，都是通过设置两个查询参数来控制，分别是每次请求条数 limit 和每次请求起始数 offset（即从第几条获取数据）。以我们的需求为例：<br>1.第一次获取 20 条： limit=20 &amp; offset=0<br>2.第二次再新增 10 条： limit=10 0&amp; offset=20<br>3.第三次再新增 10 条： limit=10 &amp; offset=30<br>当然，根据各自不同的分页实现， limit 和 offset 的命名也不相同，我们只要了解原理即可。</p>\n<p>根据以上逻辑，当用户点击「查看更多」按钮后，小程序在不同情况下应该给出相应的反应：<br>1.按钮文字变为「正在加载…」，页面弹出「加载中…」的loading 提示框，设置 offset + 10 并发起请求；<br>2.有新数据加载时，按钮文字变回「查看更多」，关闭 loading提示框，保存当前 offset；<br>3.无新数据加载时，按钮文字变为「没有更多啦」，关闭loading 提示框。<br>4.请求失败时，按钮文字变为「查看更多」，关闭 loading 提示框</p>\n<p>先在 list.wxml 中设置按钮，并绑定点击事件 loadMore;。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***list.wxml***/</div><div class=\"line\">&lt;view class=&quot;btn-load-more&quot; bindtap=&quot;loadMore&quot;&gt;</div><div class=\"line\">&#123;&#123; tipText &#125;&#125;</div><div class=\"line\">&lt;/view&gt;</div></pre></td></tr></table></figure></p>\n<p>根 据 上 面 的 流 程 ， 封 装 一下 _getProductList 和 loadMore 方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***list.js***/</div><div class=\"line\">loadMore: function () &#123;var that = this;</div><div class=\"line\">this.setData(&#123;</div><div class=\"line\">tipText: &apos;正在加载...&apos;</div><div class=\"line\">&#125;);</div><div class=\"line\">wx.showToast(&#123;</div><div class=\"line\">title: &apos;加载中...&apos;,</div><div class=\"line\">icon: &apos;loading&apos;,</div><div class=\"line\">duration: 10000</div><div class=\"line\">&#125;);</div><div class=\"line\">var timer = that._setTimeoutFlag();</div><div class=\"line\">this._getMoreProductList(timer);</div><div class=\"line\">&#125;,</div><div class=\"line\">_getMoreProductList: function (timer) &#123;</div><div class=\"line\">var that = this;</div><div class=\"line\">wx.request(&#123;</div><div class=\"line\">url: CONFIG.API_URL.PRODUCT_LIST +</div><div class=\"line\">this.data.orderBy,</div><div class=\"line\">method: &apos;GET&apos;,</div><div class=\"line\">data: &#123;</div><div class=\"line\">limit: 10,</div><div class=\"line\">offset: this.data.offset + 10,</div><div class=\"line\">shelf__id: this.data.shelfId,</div><div class=\"line\">img_size: &apos;small&apos;</div><div class=\"line\">&#125;,</div><div class=\"line\">success: function (data) &#123;</div><div class=\"line\">if (!timeoutFlag.timer.isTimeout) &#123;</div><div class=\"line\">if (data.data.objects.length &gt; 1) &#123;</div><div class=\"line\">var objects = that.data.productList</div><div class=\"line\">.concat(data.data.objects);</div><div class=\"line\">that.setData(&#123;</div><div class=\"line\">productList: objects,</div><div class=\"line\">offset: that.data.offset + 10,</div><div class=\"line\">tipText: &apos;查看更多&apos;&#125;);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">that.setData(&#123;</div><div class=\"line\">tipText: &apos;没有更多啦&apos;</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">clearTimeout(timer);</div><div class=\"line\">wx.hideToast();</div><div class=\"line\">&#125;,</div><div class=\"line\">fail: function () &#123;</div><div class=\"line\">that.setData(&#123;</div><div class=\"line\">tipText: &apos;查看更多&apos;</div><div class=\"line\">&#125;);</div><div class=\"line\">wx.hideToast();</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>至此，已经完整实现了商品列表页的开发，接下来进入商品详情页.</p>\n<h4 id=\"2-商品详情页与图文排版实现\"><a href=\"#2-商品详情页与图文排版实现\" class=\"headerlink\" title=\"2.商品详情页与图文排版实现\"></a>2.商品详情页与图文排版实现</h4><p>效果图如下：</p>\n<p><div align=center><br> <img src=\"http://oi28tswuq.bkt.clouddn.com/images/wxapponline5.png\" alt=\"\"><br></div><br>目前商品详情的图文介绍，一般都是通过后台的富文本编辑器来排版创建的，数据都是以 HTML 代码的形式保存下来，然后在页面上直接渲染出来。但是对于小程序来说， HTML形式的数据不能直接拿来使用，因为小程序根本不能解析 HTML 代码。此时，我们需要处理由富文本编辑器所创建的数据，将其转换为JSON 格式的数据，以便于在小程序里使用。<br>现在有两种思路去解决这个问题：<br>1.由前端去解析 HTML 格式的数据，用正则匹配 HTML 标签，然后转换成 JSON 数据；<br>2.交由后端去解析，同时新增一个专用的 API，返回解析过的 JSON数据。<br>这里选用的是第二种方案，获取到的 JSON 数据格式如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">&quot;description&quot;: [</div><div class=\"line\">&#123;</div><div class=\"line\">&quot;content&quot;: &quot;xxx.jpg&quot;,</div><div class=\"line\">&quot;type&quot;: &quot;image&quot;</div><div class=\"line\">&#125;,</div><div class=\"line\">&#123;</div><div class=\"line\">&quot;content&quot;: &quot;商品᧿述文字&quot;,</div><div class=\"line\">&quot;type&quot;: &quot;text&quot;</div><div class=\"line\">&#125;</div><div class=\"line\">]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我 们 只 要 将 获 取 的 数 据 用 wx:for 渲 染 出 来 ， 渲 染 时 判断 type 选择对应的 text 或 image 组件即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***detail.wxml***/</div><div class=\"line\">&lt;block wx:for=&quot;&#123;&#123; description &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;view</div><div class=\"line\">class=&quot;description-img&quot;</div><div class=\"line\">wx:if=&quot;&#123;&#123; item.type == &apos;image&apos; &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;image</div><div class=\"line\">class=&quot;description-img-content&quot;</div><div class=\"line\">src=&quot;&#123;&#123; item.content &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;/image&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">&lt;view</div><div class=\"line\">class=&quot;description-text&quot;</div><div class=\"line\">wx:elif=&quot;&#123;&#123; item.type == &apos;text&apos; &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;text class=&quot;description-text-content&quot;&gt;</div><div class=\"line\">&#123;&#123; item.content &#125;&#125;</div><div class=\"line\">&lt;/text&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\">&lt;/block&gt;</div></pre></td></tr></table></figure></p>\n<p>仔细观察一下，可以发现，每一张图片的宽高都发生了不同程度的裁剪、拉伸或压缩。这是由于 image 组件的默认宽高导致的，这个问题在上面也说过，要特别留意小程序内置组件的默认样式，它们很可能会引起各种各样的问题。我们的期望是，图片能够按照原有的宽高比例进行显示，并且每一张图片的宽度都能撑满整个内容区域。这应该如何处理呢？这里就需要用到 image 组件的 load 事件，使用 bindload 属性将事件绑定在 image 组件中。我 们 可 以 用 event.detail = {height:’ 图 片 高 度 px’,width:’图片宽度 px’} 的方式调整图片宽高尺寸。<br>我们定义一个 imageLoad 函数，作为 image 组件的 load 事件的处理函数，用 data-index 保存当前 wx:for 的 index 值作当前图片的索引值。detail.wxml 改写 image 组件如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;image</div><div class=\"line\">class=&quot;description-img-content&quot;</div><div class=\"line\">src=&quot;&#123;&#123; item.content &#125;&#125;&quot;</div><div class=\"line\">bindload=&quot;imageLoad&quot;</div><div class=\"line\">data-index=&quot;&#123;&#123; index &#125;&#125;&quot;&gt;</div><div class=\"line\">&lt;/image&gt;</div><div class=\"line\">detail.js 定义 imageLoad 函数如下：</div><div class=\"line\">data: &#123;</div><div class=\"line\">images: &#123;&#125;</div><div class=\"line\">&#125;,</div><div class=\"line\">imageLoad: function (e) &#123;</div><div class=\"line\">var realityWidth = e.detail.width; //获取图片实际宽度</div><div class=\"line\">var realityHeight = e.detail.height; //获取图片实际高度//获取图片的实际宽高比例</div><div class=\"line\">var proportion = realityWidth / realityHeight;//设置图片的渲染宽度， 750rpx - (2 * 40rpx) = 670rpx;</div><div class=\"line\">//父元素的左右 padding 都是 40rpx</div><div class=\"line\">var viewWidth = 670;//按比例计算出图片的渲染高度</div><div class=\"line\">var viewHeight = 670 / proportion;</div><div class=\"line\">var images = this.data.images;//将图片的 data-index 值作为 images 对象的 key</div><div class=\"line\">//用来储存该图片的计算后的渲染宽高</div><div class=\"line\">images[e.currentTarget.dataset.index] = &#123;</div><div class=\"line\">width: viewWidth,</div><div class=\"line\">height: viewHeight</div><div class=\"line\">&#125;;</div><div class=\"line\">this.setData(&#123;</div><div class=\"line\">images: images</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>此 时 ，就 可 以 在 image 组 件 中 获 取到 images[index].width 和 images[index].height，并通过设置行内的 style 给每一个图片设置宽高了。<br>detail.wxml 改写 image 组件如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;image class=&quot;description-img-content&quot;</div><div class=\"line\">src=&quot;&#123;&#123; item.content &#125;&#125;&quot; bindload=&quot;imageLoad&quot;</div><div class=\"line\">data-index=&quot;&#123;&#123; index &#125;&#125;&quot;</div><div class=\"line\">style=&quot;width:&#123;&#123; images[index].width &#125;&#125;rpx;</div><div class=\"line\">height:&#123;&#123; images[index].height &#125;&#125;rpx&quot;&gt;</div><div class=\"line\">&lt;/image&gt;</div></pre></td></tr></table></figure></p>\n<p>此时在预览页面时，你会发现图片等就会正常显示了。</p>\n<h4 id=\"内容总结提示\"><a href=\"#内容总结提示\" class=\"headerlink\" title=\"内容总结提示\"></a>内容总结提示</h4><ul>\n<li><p>Toast 提示：<br>1.Toast 提 示 可 以 使 用 wx.showToast() 来 调 用 ， 使用 wx.hideToast() 隐藏。l 开发者可以自定义 Toast 展示时间、展示文案等。<br>2.Toast 最长展示时间不能超过 10000 毫秒，开发者需要做好超时处理工作。</p>\n</li>\n<li><p>图文排版：<br>1.如果服务器中的数据是 HTML 数据，需要转换为 JSON，小程序才能解析。<br>2.直接将图片进行排版，图片宽高会出现问题。开发者需要处理好图片的宽高问题。</p>\n</li>\n</ul>\n"},{"title":"js中的类型","date":"2015-02-09T08:54:59.000Z","_content":"#### 内置类型\nJavaScript 有七种内置类型：\n空值（ null ）\n未定义（ undefined ）\n布尔值（ boolean ）\n数字（ number ）\n字符串（ string ）\n对象（ object ）\n符号（ symbol ， ES6 中新增）\n```\ntypeof undefined === \"undefined\"; // true\ntypeof true === \"boolean\"; // true\ntypeof 42 === \"number\"; // true\ntypeof \"42\" === \"string\"; // true\ntypeof { life: 42 } === \"object\"; // true\ntypeof null === \"object\"; // true  注意：null比较特殊\n// ES6中新加入的类型\ntypeof Symbol() === \"symbol\"; // true\n```\n注意：typeof 运算符总是会返回一个字符串。\n<font color=\"red\">typeof null</font>\ntypeof null === \"object\"; 返回true;它比较特殊，正确的返回结果应该是 \"null\" ， 但这个 bug由来已久， 在 JavaScript 中已经存在了将近二十年， 也许永远也不会修复，因为这牵涉到太多的 Web 系统， “修复”它会产生 更多的 bug， 令许多系统无法正常工作。\n因此我们需要使用复合条件来检测 null 值的类型：\n```\nvar a = null;\n(!a && typeof a === \"object\"); // true\n```\nnull 是基本类型中唯一的一个“假值”类型， typeof 对它的返回值为 \"object\" 。\n\n还有一种情况：\n```\ntypeof function a(){ /* .. */ } === \"function\"; // true\n```\n这样看来， function （ 函数） 也是 JavaScript 的一个内置类型。其实并不是这样的， 通过查阅规范就会知道，它实际上是 object 的一个“子类型”。 具体来说， 函数是“可调用对象”， 它有一个内部属性 `[[Call]]` ， 该属性使其可以被调用。\n函数不仅是对象， 还可以拥有属性。 例如：\n```\nfunction a(b,c) {\n/* .. */\n} \n```\n函数对象的 length 属性是其声明的参数的个数：a.length; 值为2.\n因为该函数声明了两个命名参数， b 和 c ， 所以其 length 值为 2\n\n```\ntypeof [1,2,3] === \"object\"; // true\n```\n 数组也是对象。 确切地说， 它也是 object 的一个“子类型” ， 数组的元素按数字顺序来进行索引（ 而非普通像对象那样通过字符串键值） ， 其 length 属性是元素的个数。\n \n#### 值和类型\nJavaScript 中的变量是没有类型的， 只有值才有 。 变量可以随时持有任何类型的值。换个角度来理解就是， JavaScript 不做“类型强制”； 也就是说， 语言引擎不要求变量 总是持有与其初始值同类型 的值。 一个变量可以现在被赋值为字符串类型值， 随后又被赋值为数字类型值。\n\n已在作用域中声明但还没有赋值的变量， 是 undefined 的。 相反， 还没有在作用域中声明过的变量， 是 undeclared（未声明） 的。如下：\n```\nvar a;\na; // undefined\nb; // ReferenceError: b is not defined(也可理解为未声明的意思)\n```\n```\nvar a;\ntypeof a; // \"undefined\"\ntypeof b; // \"undefined\"\n```\n请注意虽然 b 是一个 undeclared 变量， 但typeof b 并没有报错。 这是因为 typeof 有一个特殊的安全防范机制。\n\n\n\n\n\n\n","source":"_posts/jstype.md","raw":"---\ntitle: js中的类型\ndate: 2015-02-09 16:54:59\ntags: js\n---\n#### 内置类型\nJavaScript 有七种内置类型：\n空值（ null ）\n未定义（ undefined ）\n布尔值（ boolean ）\n数字（ number ）\n字符串（ string ）\n对象（ object ）\n符号（ symbol ， ES6 中新增）\n```\ntypeof undefined === \"undefined\"; // true\ntypeof true === \"boolean\"; // true\ntypeof 42 === \"number\"; // true\ntypeof \"42\" === \"string\"; // true\ntypeof { life: 42 } === \"object\"; // true\ntypeof null === \"object\"; // true  注意：null比较特殊\n// ES6中新加入的类型\ntypeof Symbol() === \"symbol\"; // true\n```\n注意：typeof 运算符总是会返回一个字符串。\n<font color=\"red\">typeof null</font>\ntypeof null === \"object\"; 返回true;它比较特殊，正确的返回结果应该是 \"null\" ， 但这个 bug由来已久， 在 JavaScript 中已经存在了将近二十年， 也许永远也不会修复，因为这牵涉到太多的 Web 系统， “修复”它会产生 更多的 bug， 令许多系统无法正常工作。\n因此我们需要使用复合条件来检测 null 值的类型：\n```\nvar a = null;\n(!a && typeof a === \"object\"); // true\n```\nnull 是基本类型中唯一的一个“假值”类型， typeof 对它的返回值为 \"object\" 。\n\n还有一种情况：\n```\ntypeof function a(){ /* .. */ } === \"function\"; // true\n```\n这样看来， function （ 函数） 也是 JavaScript 的一个内置类型。其实并不是这样的， 通过查阅规范就会知道，它实际上是 object 的一个“子类型”。 具体来说， 函数是“可调用对象”， 它有一个内部属性 `[[Call]]` ， 该属性使其可以被调用。\n函数不仅是对象， 还可以拥有属性。 例如：\n```\nfunction a(b,c) {\n/* .. */\n} \n```\n函数对象的 length 属性是其声明的参数的个数：a.length; 值为2.\n因为该函数声明了两个命名参数， b 和 c ， 所以其 length 值为 2\n\n```\ntypeof [1,2,3] === \"object\"; // true\n```\n 数组也是对象。 确切地说， 它也是 object 的一个“子类型” ， 数组的元素按数字顺序来进行索引（ 而非普通像对象那样通过字符串键值） ， 其 length 属性是元素的个数。\n \n#### 值和类型\nJavaScript 中的变量是没有类型的， 只有值才有 。 变量可以随时持有任何类型的值。换个角度来理解就是， JavaScript 不做“类型强制”； 也就是说， 语言引擎不要求变量 总是持有与其初始值同类型 的值。 一个变量可以现在被赋值为字符串类型值， 随后又被赋值为数字类型值。\n\n已在作用域中声明但还没有赋值的变量， 是 undefined 的。 相反， 还没有在作用域中声明过的变量， 是 undeclared（未声明） 的。如下：\n```\nvar a;\na; // undefined\nb; // ReferenceError: b is not defined(也可理解为未声明的意思)\n```\n```\nvar a;\ntypeof a; // \"undefined\"\ntypeof b; // \"undefined\"\n```\n请注意虽然 b 是一个 undeclared 变量， 但typeof b 并没有报错。 这是因为 typeof 有一个特殊的安全防范机制。\n\n\n\n\n\n\n","slug":"jstype","published":1,"updated":"2017-02-09T09:33:21.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizpcu9qr0000fctuxu27f307","content":"<h4 id=\"内置类型\"><a href=\"#内置类型\" class=\"headerlink\" title=\"内置类型\"></a>内置类型</h4><p>JavaScript 有七种内置类型：<br>空值（ null ）<br>未定义（ undefined ）<br>布尔值（ boolean ）<br>数字（ number ）<br>字符串（ string ）<br>对象（ object ）<br>符号（ symbol ， ES6 中新增）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">typeof undefined === &quot;undefined&quot;; // true</div><div class=\"line\">typeof true === &quot;boolean&quot;; // true</div><div class=\"line\">typeof 42 === &quot;number&quot;; // true</div><div class=\"line\">typeof &quot;42&quot; === &quot;string&quot;; // true</div><div class=\"line\">typeof &#123; life: 42 &#125; === &quot;object&quot;; // true</div><div class=\"line\">typeof null === &quot;object&quot;; // true  注意：null比较特殊</div><div class=\"line\">// ES6中新加入的类型</div><div class=\"line\">typeof Symbol() === &quot;symbol&quot;; // true</div></pre></td></tr></table></figure></p>\n<p>注意：typeof 运算符总是会返回一个字符串。</p>\n<p><font color=\"red\">typeof null</font><br>typeof null === “object”; 返回true;它比较特殊，正确的返回结果应该是 “null” ， 但这个 bug由来已久， 在 JavaScript 中已经存在了将近二十年， 也许永远也不会修复，因为这牵涉到太多的 Web 系统， “修复”它会产生 更多的 bug， 令许多系统无法正常工作。<br>因此我们需要使用复合条件来检测 null 值的类型：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = null;</div><div class=\"line\">(!a &amp;&amp; typeof a === &quot;object&quot;); // true</div></pre></td></tr></table></figure></p>\n<p>null 是基本类型中唯一的一个“假值”类型， typeof 对它的返回值为 “object” 。</p>\n<p>还有一种情况：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">typeof function a()&#123; /* .. */ &#125; === &quot;function&quot;; // true</div></pre></td></tr></table></figure></p>\n<p>这样看来， function （ 函数） 也是 JavaScript 的一个内置类型。其实并不是这样的， 通过查阅规范就会知道，它实际上是 object 的一个“子类型”。 具体来说， 函数是“可调用对象”， 它有一个内部属性 <code>[[Call]]</code> ， 该属性使其可以被调用。<br>函数不仅是对象， 还可以拥有属性。 例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function a(b,c) &#123;</div><div class=\"line\">/* .. */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>函数对象的 length 属性是其声明的参数的个数：a.length; 值为2.<br>因为该函数声明了两个命名参数， b 和 c ， 所以其 length 值为 2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">typeof [1,2,3] === &quot;object&quot;; // true</div></pre></td></tr></table></figure>\n<p> 数组也是对象。 确切地说， 它也是 object 的一个“子类型” ， 数组的元素按数字顺序来进行索引（ 而非普通像对象那样通过字符串键值） ， 其 length 属性是元素的个数。</p>\n<h4 id=\"值和类型\"><a href=\"#值和类型\" class=\"headerlink\" title=\"值和类型\"></a>值和类型</h4><p>JavaScript 中的变量是没有类型的， 只有值才有 。 变量可以随时持有任何类型的值。换个角度来理解就是， JavaScript 不做“类型强制”； 也就是说， 语言引擎不要求变量 总是持有与其初始值同类型 的值。 一个变量可以现在被赋值为字符串类型值， 随后又被赋值为数字类型值。</p>\n<p>已在作用域中声明但还没有赋值的变量， 是 undefined 的。 相反， 还没有在作用域中声明过的变量， 是 undeclared（未声明） 的。如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a;</div><div class=\"line\">a; // undefined</div><div class=\"line\">b; // ReferenceError: b is not defined(也可理解为未声明的意思)</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a;</div><div class=\"line\">typeof a; // &quot;undefined&quot;</div><div class=\"line\">typeof b; // &quot;undefined&quot;</div></pre></td></tr></table></figure>\n<p>请注意虽然 b 是一个 undeclared 变量， 但typeof b 并没有报错。 这是因为 typeof 有一个特殊的安全防范机制。</p>\n","excerpt":"","more":"<h4 id=\"内置类型\"><a href=\"#内置类型\" class=\"headerlink\" title=\"内置类型\"></a>内置类型</h4><p>JavaScript 有七种内置类型：<br>空值（ null ）<br>未定义（ undefined ）<br>布尔值（ boolean ）<br>数字（ number ）<br>字符串（ string ）<br>对象（ object ）<br>符号（ symbol ， ES6 中新增）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">typeof undefined === &quot;undefined&quot;; // true</div><div class=\"line\">typeof true === &quot;boolean&quot;; // true</div><div class=\"line\">typeof 42 === &quot;number&quot;; // true</div><div class=\"line\">typeof &quot;42&quot; === &quot;string&quot;; // true</div><div class=\"line\">typeof &#123; life: 42 &#125; === &quot;object&quot;; // true</div><div class=\"line\">typeof null === &quot;object&quot;; // true  注意：null比较特殊</div><div class=\"line\">// ES6中新加入的类型</div><div class=\"line\">typeof Symbol() === &quot;symbol&quot;; // true</div></pre></td></tr></table></figure></p>\n<p>注意：typeof 运算符总是会返回一个字符串。</p>\n<p><font color=\"red\">typeof null</font><br>typeof null === “object”; 返回true;它比较特殊，正确的返回结果应该是 “null” ， 但这个 bug由来已久， 在 JavaScript 中已经存在了将近二十年， 也许永远也不会修复，因为这牵涉到太多的 Web 系统， “修复”它会产生 更多的 bug， 令许多系统无法正常工作。<br>因此我们需要使用复合条件来检测 null 值的类型：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = null;</div><div class=\"line\">(!a &amp;&amp; typeof a === &quot;object&quot;); // true</div></pre></td></tr></table></figure></p>\n<p>null 是基本类型中唯一的一个“假值”类型， typeof 对它的返回值为 “object” 。</p>\n<p>还有一种情况：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">typeof function a()&#123; /* .. */ &#125; === &quot;function&quot;; // true</div></pre></td></tr></table></figure></p>\n<p>这样看来， function （ 函数） 也是 JavaScript 的一个内置类型。其实并不是这样的， 通过查阅规范就会知道，它实际上是 object 的一个“子类型”。 具体来说， 函数是“可调用对象”， 它有一个内部属性 <code>[[Call]]</code> ， 该属性使其可以被调用。<br>函数不仅是对象， 还可以拥有属性。 例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function a(b,c) &#123;</div><div class=\"line\">/* .. */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>函数对象的 length 属性是其声明的参数的个数：a.length; 值为2.<br>因为该函数声明了两个命名参数， b 和 c ， 所以其 length 值为 2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">typeof [1,2,3] === &quot;object&quot;; // true</div></pre></td></tr></table></figure>\n<p> 数组也是对象。 确切地说， 它也是 object 的一个“子类型” ， 数组的元素按数字顺序来进行索引（ 而非普通像对象那样通过字符串键值） ， 其 length 属性是元素的个数。</p>\n<h4 id=\"值和类型\"><a href=\"#值和类型\" class=\"headerlink\" title=\"值和类型\"></a>值和类型</h4><p>JavaScript 中的变量是没有类型的， 只有值才有 。 变量可以随时持有任何类型的值。换个角度来理解就是， JavaScript 不做“类型强制”； 也就是说， 语言引擎不要求变量 总是持有与其初始值同类型 的值。 一个变量可以现在被赋值为字符串类型值， 随后又被赋值为数字类型值。</p>\n<p>已在作用域中声明但还没有赋值的变量， 是 undefined 的。 相反， 还没有在作用域中声明过的变量， 是 undeclared（未声明） 的。如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a;</div><div class=\"line\">a; // undefined</div><div class=\"line\">b; // ReferenceError: b is not defined(也可理解为未声明的意思)</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a;</div><div class=\"line\">typeof a; // &quot;undefined&quot;</div><div class=\"line\">typeof b; // &quot;undefined&quot;</div></pre></td></tr></table></figure>\n<p>请注意虽然 b 是一个 undeclared 变量， 但typeof b 并没有报错。 这是因为 typeof 有一个特殊的安全防范机制。</p>\n"},{"title":"使用Benchmark.js和jsPerf分析代码性能","date":"2017-02-10T02:43:12.000Z","_content":"#### 前言\n前端开发中，掌握好浏览器的特性进行有针对性的性能调优是一项基本工作，同时，比较不同代码的执行速度也是一项关键的工作。\n\n比如，当我们想比较RegExp的test方法和String对象的indexOf方法查找字符串谁的速度更快的话，js代码在不同的浏览器，不同的操作系统环境运行的效率可能是不一样的，这就是为什么我们需要对其进行基准测试，在做基准测试方面，我们可以使用Benchmark.js和使用jsPerf（一个基于JSLitmus的基准测试库）。我们可以使用jsPerf来分享你的基准测试。\n\n#### Benchmark.js 的使用\n其实在很多github 开源项目中，往往都能看到benchmark文件夹。使用方法如下：\n首先在系统根目录下，通过npm intsall benchmark 来安装benchmark。该模块会被写入node_modules文件夹中，我们在test.js文件中通过require方法引入该模块。\n将如下代码写入test.js文件，该文件置于系统根目录下：\n```\nvar Benchmark = require('benchmark');\nvar suite = new Benchmark.Suite;\n\n// 添加测试\nsuite.add('RegExp#test', function() {\n    /o/.test('Hello World!');\n})\n    .add('String#indexOf', function() {\n        'Hello World!'.indexOf('o') > -1;\n    })\n// add listeners\n    .on('cycle', function(event) {\n        console.log(String(event.target));\n    })\n    .on('complete', function() {\n        console.log('Fastest is ' + this.filter('fastest').pluck('name'));\n    })\n// run async\n    .run({ 'async': true });\n```\n然后在控制台执行node test.js 可见输出结果如下：\n```\n➜  ~ git:(master) ✗ node test.js\nRegExp#test x 9,847,928 ops/sec ±1.47% (83 runs sampled)\nString#indexOf x 23,366,017 ops/sec ±0.91% (96 runs sampled)\nFastest is String#indexOf\n```\n结果最快的就是String对象的indexOf方法，其中，Ops/sec 测试结果以每秒钟执行测试代码的次数（Ops/sec）显示，这个数值越大越好。除了这个结果外，同时会显示测试过程中的统计误差，以及相对最好的慢了多少（%）;\n\n<font color=\"red\">call和apply的比较</font>\n```\nvar Benchmark = require('benchmark');\nvar suite = new Benchmark.Suite;\nvar arr1 = function (str) {\n    return [].slice.apply(str);\n};\nvar str2 = function (str) {\n    return [].slice.call(str);\n};\n// 添加测试\nsuite.add('arr1', function() {\n    arr1('test');\n})\n    .add('str2', function() {\n        str2('test');\n    })\n// add listeners\n    .on('cycle', function(event) {\n        console.log(String(event.target));\n    })\n    .on('complete', function() {\n        console.log('Fastest is ' + this.filter('fastest').pluck('name'));\n    })\n// run async\n    .run({ 'async': true });\n```\n输出如下内容：\n```\narr1 x 596,505 ops/sec ±1.14% (95 runs sampled)\nstr2 x 627,822 ops/sec ±1.27% (92 runs sampled)\nFastest is str2\n```\n<font color=\"red\">本地的使用</font>\n本地使用Benchmark需要引入如下三个文件：\n```\n<script src=\"lodash.js\"></script>\n<script src=\"platform.js\"></script>\n<script src=\"benchmark.js\"></script>\n```\n#### jsPerf 的使用\njsPerf 提供了一个简便的方式来创建和共享测试用例，并可以比较不同JavaScript代码段的性能。jsPerf也是基于Benchmark来运行的。\n打开jsPerf站点：http://jsperf.com/，先将必填的项目填了。其中，slug是短名称，会生成一个网址，因此不可与别人的重复。然后在Code snippets to compare 区域填入title和用于测试的code。最后点击save test case 完成验证即可。浏览器会自动跳转到测试页面.\nAsync选项框是用来测试一些异步调用的性能的，我们的代码没有使用异步方法，所以不必勾选。\n\n<font color=\"red\">运行测试</font>\n点击“Run tests”按钮开始测试两种算法的性能。建议在运行性能测试之前，关闭无关的浏览器页面，关闭其他程序，退出不必要的后台进程，以保证结果不受其他环境的影响。你也可以通过点击个别测试用例的名字单独运行这个例子.\njsPerf还会统计所有运行过这个测试用例的浏览器的比较结果，显示在下方的Browserscope区域，可以通过它直观地看出各个版本浏览器的性能横向和纵向比较情况。\n\n<font color=\"red\">查看别人的测试用例</font>\n我们可以通过 http://jsperf.com/browse 浏览最新提交的250项最新测试用例。我们也可以使用底部的Revisions来查看不同的版本，也就是不同浏览器的测试用例情况。\n\n#### 总结\nJohn Resig 在其博文 JavaScript基准测试的质量中提到，应该尽量考虑到每个测试结果的误差并去减小它。扩大测试的样本值，健全的测试执行，都能够起到减少误差的作用。\n","source":"_posts/codetest.md","raw":"---\ntitle: 使用Benchmark.js和jsPerf分析代码性能\ndate: 2017-02-10 10:43:12\ntags: Benchmark jsPerf\n---\n#### 前言\n前端开发中，掌握好浏览器的特性进行有针对性的性能调优是一项基本工作，同时，比较不同代码的执行速度也是一项关键的工作。\n\n比如，当我们想比较RegExp的test方法和String对象的indexOf方法查找字符串谁的速度更快的话，js代码在不同的浏览器，不同的操作系统环境运行的效率可能是不一样的，这就是为什么我们需要对其进行基准测试，在做基准测试方面，我们可以使用Benchmark.js和使用jsPerf（一个基于JSLitmus的基准测试库）。我们可以使用jsPerf来分享你的基准测试。\n\n#### Benchmark.js 的使用\n其实在很多github 开源项目中，往往都能看到benchmark文件夹。使用方法如下：\n首先在系统根目录下，通过npm intsall benchmark 来安装benchmark。该模块会被写入node_modules文件夹中，我们在test.js文件中通过require方法引入该模块。\n将如下代码写入test.js文件，该文件置于系统根目录下：\n```\nvar Benchmark = require('benchmark');\nvar suite = new Benchmark.Suite;\n\n// 添加测试\nsuite.add('RegExp#test', function() {\n    /o/.test('Hello World!');\n})\n    .add('String#indexOf', function() {\n        'Hello World!'.indexOf('o') > -1;\n    })\n// add listeners\n    .on('cycle', function(event) {\n        console.log(String(event.target));\n    })\n    .on('complete', function() {\n        console.log('Fastest is ' + this.filter('fastest').pluck('name'));\n    })\n// run async\n    .run({ 'async': true });\n```\n然后在控制台执行node test.js 可见输出结果如下：\n```\n➜  ~ git:(master) ✗ node test.js\nRegExp#test x 9,847,928 ops/sec ±1.47% (83 runs sampled)\nString#indexOf x 23,366,017 ops/sec ±0.91% (96 runs sampled)\nFastest is String#indexOf\n```\n结果最快的就是String对象的indexOf方法，其中，Ops/sec 测试结果以每秒钟执行测试代码的次数（Ops/sec）显示，这个数值越大越好。除了这个结果外，同时会显示测试过程中的统计误差，以及相对最好的慢了多少（%）;\n\n<font color=\"red\">call和apply的比较</font>\n```\nvar Benchmark = require('benchmark');\nvar suite = new Benchmark.Suite;\nvar arr1 = function (str) {\n    return [].slice.apply(str);\n};\nvar str2 = function (str) {\n    return [].slice.call(str);\n};\n// 添加测试\nsuite.add('arr1', function() {\n    arr1('test');\n})\n    .add('str2', function() {\n        str2('test');\n    })\n// add listeners\n    .on('cycle', function(event) {\n        console.log(String(event.target));\n    })\n    .on('complete', function() {\n        console.log('Fastest is ' + this.filter('fastest').pluck('name'));\n    })\n// run async\n    .run({ 'async': true });\n```\n输出如下内容：\n```\narr1 x 596,505 ops/sec ±1.14% (95 runs sampled)\nstr2 x 627,822 ops/sec ±1.27% (92 runs sampled)\nFastest is str2\n```\n<font color=\"red\">本地的使用</font>\n本地使用Benchmark需要引入如下三个文件：\n```\n<script src=\"lodash.js\"></script>\n<script src=\"platform.js\"></script>\n<script src=\"benchmark.js\"></script>\n```\n#### jsPerf 的使用\njsPerf 提供了一个简便的方式来创建和共享测试用例，并可以比较不同JavaScript代码段的性能。jsPerf也是基于Benchmark来运行的。\n打开jsPerf站点：http://jsperf.com/，先将必填的项目填了。其中，slug是短名称，会生成一个网址，因此不可与别人的重复。然后在Code snippets to compare 区域填入title和用于测试的code。最后点击save test case 完成验证即可。浏览器会自动跳转到测试页面.\nAsync选项框是用来测试一些异步调用的性能的，我们的代码没有使用异步方法，所以不必勾选。\n\n<font color=\"red\">运行测试</font>\n点击“Run tests”按钮开始测试两种算法的性能。建议在运行性能测试之前，关闭无关的浏览器页面，关闭其他程序，退出不必要的后台进程，以保证结果不受其他环境的影响。你也可以通过点击个别测试用例的名字单独运行这个例子.\njsPerf还会统计所有运行过这个测试用例的浏览器的比较结果，显示在下方的Browserscope区域，可以通过它直观地看出各个版本浏览器的性能横向和纵向比较情况。\n\n<font color=\"red\">查看别人的测试用例</font>\n我们可以通过 http://jsperf.com/browse 浏览最新提交的250项最新测试用例。我们也可以使用底部的Revisions来查看不同的版本，也就是不同浏览器的测试用例情况。\n\n#### 总结\nJohn Resig 在其博文 JavaScript基准测试的质量中提到，应该尽量考虑到每个测试结果的误差并去减小它。扩大测试的样本值，健全的测试执行，都能够起到减少误差的作用。\n","slug":"codetest","published":1,"updated":"2017-02-10T03:10:01.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizpcu9r30001fctuizhk7971","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>前端开发中，掌握好浏览器的特性进行有针对性的性能调优是一项基本工作，同时，比较不同代码的执行速度也是一项关键的工作。</p>\n<p>比如，当我们想比较RegExp的test方法和String对象的indexOf方法查找字符串谁的速度更快的话，js代码在不同的浏览器，不同的操作系统环境运行的效率可能是不一样的，这就是为什么我们需要对其进行基准测试，在做基准测试方面，我们可以使用Benchmark.js和使用jsPerf（一个基于JSLitmus的基准测试库）。我们可以使用jsPerf来分享你的基准测试。</p>\n<h4 id=\"Benchmark-js-的使用\"><a href=\"#Benchmark-js-的使用\" class=\"headerlink\" title=\"Benchmark.js 的使用\"></a>Benchmark.js 的使用</h4><p>其实在很多github 开源项目中，往往都能看到benchmark文件夹。使用方法如下：<br>首先在系统根目录下，通过npm intsall benchmark 来安装benchmark。该模块会被写入node_modules文件夹中，我们在test.js文件中通过require方法引入该模块。<br>将如下代码写入test.js文件，该文件置于系统根目录下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Benchmark = require(&apos;benchmark&apos;);</div><div class=\"line\">var suite = new Benchmark.Suite;</div><div class=\"line\"></div><div class=\"line\">// 添加测试</div><div class=\"line\">suite.add(&apos;RegExp#test&apos;, function() &#123;</div><div class=\"line\">    /o/.test(&apos;Hello World!&apos;);</div><div class=\"line\">&#125;)</div><div class=\"line\">    .add(&apos;String#indexOf&apos;, function() &#123;</div><div class=\"line\">        &apos;Hello World!&apos;.indexOf(&apos;o&apos;) &gt; -1;</div><div class=\"line\">    &#125;)</div><div class=\"line\">// add listeners</div><div class=\"line\">    .on(&apos;cycle&apos;, function(event) &#123;</div><div class=\"line\">        console.log(String(event.target));</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .on(&apos;complete&apos;, function() &#123;</div><div class=\"line\">        console.log(&apos;Fastest is &apos; + this.filter(&apos;fastest&apos;).pluck(&apos;name&apos;));</div><div class=\"line\">    &#125;)</div><div class=\"line\">// run async</div><div class=\"line\">    .run(&#123; &apos;async&apos;: true &#125;);</div></pre></td></tr></table></figure></p>\n<p>然后在控制台执行node test.js 可见输出结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">➜  ~ git:(master) ✗ node test.js</div><div class=\"line\">RegExp#test x 9,847,928 ops/sec ±1.47% (83 runs sampled)</div><div class=\"line\">String#indexOf x 23,366,017 ops/sec ±0.91% (96 runs sampled)</div><div class=\"line\">Fastest is String#indexOf</div></pre></td></tr></table></figure></p>\n<p>结果最快的就是String对象的indexOf方法，其中，Ops/sec 测试结果以每秒钟执行测试代码的次数（Ops/sec）显示，这个数值越大越好。除了这个结果外，同时会显示测试过程中的统计误差，以及相对最好的慢了多少（%）;</p>\n<p><font color=\"red\">call和apply的比较</font><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Benchmark = require(&apos;benchmark&apos;);</div><div class=\"line\">var suite = new Benchmark.Suite;</div><div class=\"line\">var arr1 = function (str) &#123;</div><div class=\"line\">    return [].slice.apply(str);</div><div class=\"line\">&#125;;</div><div class=\"line\">var str2 = function (str) &#123;</div><div class=\"line\">    return [].slice.call(str);</div><div class=\"line\">&#125;;</div><div class=\"line\">// 添加测试</div><div class=\"line\">suite.add(&apos;arr1&apos;, function() &#123;</div><div class=\"line\">    arr1(&apos;test&apos;);</div><div class=\"line\">&#125;)</div><div class=\"line\">    .add(&apos;str2&apos;, function() &#123;</div><div class=\"line\">        str2(&apos;test&apos;);</div><div class=\"line\">    &#125;)</div><div class=\"line\">// add listeners</div><div class=\"line\">    .on(&apos;cycle&apos;, function(event) &#123;</div><div class=\"line\">        console.log(String(event.target));</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .on(&apos;complete&apos;, function() &#123;</div><div class=\"line\">        console.log(&apos;Fastest is &apos; + this.filter(&apos;fastest&apos;).pluck(&apos;name&apos;));</div><div class=\"line\">    &#125;)</div><div class=\"line\">// run async</div><div class=\"line\">    .run(&#123; &apos;async&apos;: true &#125;);</div></pre></td></tr></table></figure></p>\n<p>输出如下内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">arr1 x 596,505 ops/sec ±1.14% (95 runs sampled)</div><div class=\"line\">str2 x 627,822 ops/sec ±1.27% (92 runs sampled)</div><div class=\"line\">Fastest is str2</div></pre></td></tr></table></figure></p>\n<p><font color=\"red\">本地的使用</font><br>本地使用Benchmark需要引入如下三个文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;lodash.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;platform.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;benchmark.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"jsPerf-的使用\"><a href=\"#jsPerf-的使用\" class=\"headerlink\" title=\"jsPerf 的使用\"></a>jsPerf 的使用</h4><p>jsPerf 提供了一个简便的方式来创建和共享测试用例，并可以比较不同JavaScript代码段的性能。jsPerf也是基于Benchmark来运行的。<br>打开jsPerf站点：<a href=\"http://jsperf.com/，先将必填的项目填了。其中，slug是短名称，会生成一个网址，因此不可与别人的重复。然后在Code\" target=\"_blank\" rel=\"external\">http://jsperf.com/，先将必填的项目填了。其中，slug是短名称，会生成一个网址，因此不可与别人的重复。然后在Code</a> snippets to compare 区域填入title和用于测试的code。最后点击save test case 完成验证即可。浏览器会自动跳转到测试页面.<br>Async选项框是用来测试一些异步调用的性能的，我们的代码没有使用异步方法，所以不必勾选。</p>\n<p><font color=\"red\">运行测试</font><br>点击“Run tests”按钮开始测试两种算法的性能。建议在运行性能测试之前，关闭无关的浏览器页面，关闭其他程序，退出不必要的后台进程，以保证结果不受其他环境的影响。你也可以通过点击个别测试用例的名字单独运行这个例子.<br>jsPerf还会统计所有运行过这个测试用例的浏览器的比较结果，显示在下方的Browserscope区域，可以通过它直观地看出各个版本浏览器的性能横向和纵向比较情况。</p>\n<p><font color=\"red\">查看别人的测试用例</font><br>我们可以通过 <a href=\"http://jsperf.com/browse\" target=\"_blank\" rel=\"external\">http://jsperf.com/browse</a> 浏览最新提交的250项最新测试用例。我们也可以使用底部的Revisions来查看不同的版本，也就是不同浏览器的测试用例情况。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>John Resig 在其博文 JavaScript基准测试的质量中提到，应该尽量考虑到每个测试结果的误差并去减小它。扩大测试的样本值，健全的测试执行，都能够起到减少误差的作用。</p>\n","excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>前端开发中，掌握好浏览器的特性进行有针对性的性能调优是一项基本工作，同时，比较不同代码的执行速度也是一项关键的工作。</p>\n<p>比如，当我们想比较RegExp的test方法和String对象的indexOf方法查找字符串谁的速度更快的话，js代码在不同的浏览器，不同的操作系统环境运行的效率可能是不一样的，这就是为什么我们需要对其进行基准测试，在做基准测试方面，我们可以使用Benchmark.js和使用jsPerf（一个基于JSLitmus的基准测试库）。我们可以使用jsPerf来分享你的基准测试。</p>\n<h4 id=\"Benchmark-js-的使用\"><a href=\"#Benchmark-js-的使用\" class=\"headerlink\" title=\"Benchmark.js 的使用\"></a>Benchmark.js 的使用</h4><p>其实在很多github 开源项目中，往往都能看到benchmark文件夹。使用方法如下：<br>首先在系统根目录下，通过npm intsall benchmark 来安装benchmark。该模块会被写入node_modules文件夹中，我们在test.js文件中通过require方法引入该模块。<br>将如下代码写入test.js文件，该文件置于系统根目录下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Benchmark = require(&apos;benchmark&apos;);</div><div class=\"line\">var suite = new Benchmark.Suite;</div><div class=\"line\"></div><div class=\"line\">// 添加测试</div><div class=\"line\">suite.add(&apos;RegExp#test&apos;, function() &#123;</div><div class=\"line\">    /o/.test(&apos;Hello World!&apos;);</div><div class=\"line\">&#125;)</div><div class=\"line\">    .add(&apos;String#indexOf&apos;, function() &#123;</div><div class=\"line\">        &apos;Hello World!&apos;.indexOf(&apos;o&apos;) &gt; -1;</div><div class=\"line\">    &#125;)</div><div class=\"line\">// add listeners</div><div class=\"line\">    .on(&apos;cycle&apos;, function(event) &#123;</div><div class=\"line\">        console.log(String(event.target));</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .on(&apos;complete&apos;, function() &#123;</div><div class=\"line\">        console.log(&apos;Fastest is &apos; + this.filter(&apos;fastest&apos;).pluck(&apos;name&apos;));</div><div class=\"line\">    &#125;)</div><div class=\"line\">// run async</div><div class=\"line\">    .run(&#123; &apos;async&apos;: true &#125;);</div></pre></td></tr></table></figure></p>\n<p>然后在控制台执行node test.js 可见输出结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">➜  ~ git:(master) ✗ node test.js</div><div class=\"line\">RegExp#test x 9,847,928 ops/sec ±1.47% (83 runs sampled)</div><div class=\"line\">String#indexOf x 23,366,017 ops/sec ±0.91% (96 runs sampled)</div><div class=\"line\">Fastest is String#indexOf</div></pre></td></tr></table></figure></p>\n<p>结果最快的就是String对象的indexOf方法，其中，Ops/sec 测试结果以每秒钟执行测试代码的次数（Ops/sec）显示，这个数值越大越好。除了这个结果外，同时会显示测试过程中的统计误差，以及相对最好的慢了多少（%）;</p>\n<p><font color=\"red\">call和apply的比较</font><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Benchmark = require(&apos;benchmark&apos;);</div><div class=\"line\">var suite = new Benchmark.Suite;</div><div class=\"line\">var arr1 = function (str) &#123;</div><div class=\"line\">    return [].slice.apply(str);</div><div class=\"line\">&#125;;</div><div class=\"line\">var str2 = function (str) &#123;</div><div class=\"line\">    return [].slice.call(str);</div><div class=\"line\">&#125;;</div><div class=\"line\">// 添加测试</div><div class=\"line\">suite.add(&apos;arr1&apos;, function() &#123;</div><div class=\"line\">    arr1(&apos;test&apos;);</div><div class=\"line\">&#125;)</div><div class=\"line\">    .add(&apos;str2&apos;, function() &#123;</div><div class=\"line\">        str2(&apos;test&apos;);</div><div class=\"line\">    &#125;)</div><div class=\"line\">// add listeners</div><div class=\"line\">    .on(&apos;cycle&apos;, function(event) &#123;</div><div class=\"line\">        console.log(String(event.target));</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .on(&apos;complete&apos;, function() &#123;</div><div class=\"line\">        console.log(&apos;Fastest is &apos; + this.filter(&apos;fastest&apos;).pluck(&apos;name&apos;));</div><div class=\"line\">    &#125;)</div><div class=\"line\">// run async</div><div class=\"line\">    .run(&#123; &apos;async&apos;: true &#125;);</div></pre></td></tr></table></figure></p>\n<p>输出如下内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">arr1 x 596,505 ops/sec ±1.14% (95 runs sampled)</div><div class=\"line\">str2 x 627,822 ops/sec ±1.27% (92 runs sampled)</div><div class=\"line\">Fastest is str2</div></pre></td></tr></table></figure></p>\n<p><font color=\"red\">本地的使用</font><br>本地使用Benchmark需要引入如下三个文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;lodash.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;platform.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;benchmark.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"jsPerf-的使用\"><a href=\"#jsPerf-的使用\" class=\"headerlink\" title=\"jsPerf 的使用\"></a>jsPerf 的使用</h4><p>jsPerf 提供了一个简便的方式来创建和共享测试用例，并可以比较不同JavaScript代码段的性能。jsPerf也是基于Benchmark来运行的。<br>打开jsPerf站点：<a href=\"http://jsperf.com/，先将必填的项目填了。其中，slug是短名称，会生成一个网址，因此不可与别人的重复。然后在Code\">http://jsperf.com/，先将必填的项目填了。其中，slug是短名称，会生成一个网址，因此不可与别人的重复。然后在Code</a> snippets to compare 区域填入title和用于测试的code。最后点击save test case 完成验证即可。浏览器会自动跳转到测试页面.<br>Async选项框是用来测试一些异步调用的性能的，我们的代码没有使用异步方法，所以不必勾选。</p>\n<p><font color=\"red\">运行测试</font><br>点击“Run tests”按钮开始测试两种算法的性能。建议在运行性能测试之前，关闭无关的浏览器页面，关闭其他程序，退出不必要的后台进程，以保证结果不受其他环境的影响。你也可以通过点击个别测试用例的名字单独运行这个例子.<br>jsPerf还会统计所有运行过这个测试用例的浏览器的比较结果，显示在下方的Browserscope区域，可以通过它直观地看出各个版本浏览器的性能横向和纵向比较情况。</p>\n<p><font color=\"red\">查看别人的测试用例</font><br>我们可以通过 <a href=\"http://jsperf.com/browse\">http://jsperf.com/browse</a> 浏览最新提交的250项最新测试用例。我们也可以使用底部的Revisions来查看不同的版本，也就是不同浏览器的测试用例情况。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>John Resig 在其博文 JavaScript基准测试的质量中提到，应该尽量考虑到每个测试结果的误差并去减小它。扩大测试的样本值，健全的测试执行，都能够起到减少误差的作用。</p>\n"},{"title":"js中的对象","date":"2016-02-09T05:21:25.000Z","_content":"#### 语法\n对象可以通过两种形式定义： 声明（ 文字） 形式和构造形式。\n对象的文字语法大概是这样：\n```\nvar myObj = {\nkey: value\n// ...\n};\n```\n构造形式大概是这样：\n```\nvar myObj = new Object();\nmyObj.key = value;\n```\n构造形式和文字形式生成的对象是一样的。 唯一的区别是， 在文字声明中你可以添加多个键 / 值对， 但是在构造形式中你必须逐个添加属性。“ 构造形式” 来创建对象是非常少见的,一般都用文字形式。\n\n#### 类型\n在 JavaScript 中一共有六种主要类型（ 术语是“ 语言类型”） ：string/number/boolean/null/undefined/object.\n注意， 简单基本类型（ string、 boolean、 number、 null 和 undefined） 本身并不是对象。null 有时会被当作一种对象类型， 但是这其实只是语言本身的一个 bug， 即对 null 执行\ntypeof null 时会返回字符串 \"object\"。 实际上， null 本身是基本类型。\n实际上， JavaScript 中有许多特殊的对象子类型， 可以称之为复杂基本类型。比如函数、数组...\n可以简单地理解为：javascript 引用类型的数据存放在堆内存，基本类型的数据存放在栈内存。\n\n<font color=\"red\">内置对象</font>\nJavaScript 中还有一些对象子类型， 通常被称为内置对象。 有些内置对象的名字看起来和简单基础类型一样， 不过实际上它们的关系更复杂.\n内置对象：String/Number/Boolean/Object/Function/Array/Date/RegExp/Error,这些内置函数可以当作构造函数（ 由 new 产生的函数调用） 来使用， 从而可以构造一个对应子类型的新对\n象。例子如下：\n```\nvar strPrimitive = \"I am a string\";\ntypeof strPrimitive; // \"string\"\nstrPrimitive instanceof String; // false\nvar strObject = new String( \"I am a string\" );\ntypeof strObject; // \"object\"\nstrObject instanceof String; // true\n// 检查 sub-type 对象\nObject.prototype.toString.call( strObject ); // [object String]\n```\n从代码中可以看到， strObject 是由 String 构造函数创建的一个对象;\n```\nvar strPrimitive = \"I am a string\";\nconsole.log( strPrimitive.length ); // 13\nconsole.log( strPrimitive.charAt( 3 ) ); // \"m\"\n```\n原始值 \"I am a string\" 并不是一个对象， 它只是一个字面量， 并且是一个不可变的值。如果要在这个字面量上执行一些操作， 比如获取长度、 访问其中某个字符等， 那需要将其\n转换为 String 对象。js在必要时语言会自动把字符串字面量转换成一个 String 对象，所以字符串也能直接使用length属性。数值字面量也是同样道理：42.359.toFixed(2)。\n\nnull 和 undefined 没有对应的构造形式， 它们只有文字形式。 相反， Date 只有构造， 没有文字形式。对于 Object、 Array、 Function 和 RegExp（ 正则表达式）来说，无论使用文字形式还是构造形式， 它们都是对象， 不是字面量。Error 对象很少在代码中显式创建， 一般是在抛出异常时被自动创建。 也可以使用 new Error(..) 这种构造形式来创建，不过一般来说用不着。\n\n##### 内容\n对象的内容是由一些存储在特定命名位置的（ 任意类型的） 值组成的，我们称之为属性。\n```\nvar myObject = {\na: 2\n};\nmyObject.a; // 2\nmyObject[\"a\"]; // 2\n```\n\n如果要访问 myObject 中 a 位置上的值， 我们需要使用 . 操作符或者 [] 操作符。 .a 语法通常被称为“ 属性访问”， `[\"a\"] `语法通常被称为“ 键访问”。 实际上它们访问的是同一个位\n置， 并且会返回相同的值 2， 所以这两个术语是可以互换的。当属性为number时，必须使用[]操作符。\n注：这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范， 而 `[\"..\"]`语法可以接受任意 UTF-8/Unicode 字符串作为属性名。 举例来说， 如果要引用名称为 \"SuperFun!\" 的属性， 那就必须使用 `[\"Super-Fun!\"]`语法访问， 因为 Super-Fun! 并不是一个有效的标识符属性名。\n小提示：对象的属性永远为字符串类型的。如果不是它也会隐式转换成字符串。\n\n<font color=\"red\">可计算属性名</font>\nES6 增加了可计算属性名， 可以在文字形式中使用 [] 包裹一个表达式来当作属性名：\n```\nvar prefix = \"foo\";\nvar myObject = {\n[prefix + \"bar\"]:\"hello\",\n[prefix + \"baz\"]: \"world\"\n};\nmyObject[\"foobar\"]; // hello\nmyObject[\"foobaz\"]; // world\n```\n可计算属性名最常用的场景可能是 ES6 的符号（ Symbol），简单来说， 它们是一种新的基础数据类型， 包含一个不透明且无法预测的值（从技术角度来说就是一个字符串）。一般来说你不会用到符号的实际值（ 因为理论上来说在不同的 JavaScript 引擎中值是不同的）， 所以通常接触到的是符号的名称， 比如 Symbol.Something（ something是随便起的） ：\n```\nvar myObject = {\n[Symbol.Something]: \"hello world\"\n}\n```\n<font color=\"red\">数组</font>\n数组也是对象， 所以虽然每个下标都是整数， 你仍然可以给数组添加属性：\n```\nvar myArray = [ \"foo\", 42, \"bar\" ];\nmyArray.baz = \"baz\";\nmyArray.length; // 3\nmyArray.baz; // \"baz\"\n```\n可以看到虽然添加了命名属性（ 无论是通过 . 语法还是 [] 语法）， 数组的 length 值并未发生变化。\n注意： 如果试图向数组添加一个属性， 但是属性名“ 看起来” 像一个数字， 那它会变成一个数值下标（ 因此会修改数组的内容而不是添加一个属性） ：\n```\nvar myArray = [ \"foo\", 42, \"bar\" ];\nmyArray[\"3\"] = \"baz\";\nmyArray.length; // 4\nmyArray[3]; // \"baz\"\n```\n<font color=\"red\">判断对象属性是否存在：</font>\n```\nvar myObject = {\na:2\n};\n(\"a\" in myObject); // true\n(\"b\" in myObject); // false\nmyObject.hasOwnProperty( \"a\" ); // true\nmyObject.hasOwnProperty( \"b\" ); // false\n```\nin 操作符会检查属性是否在对象及其 `[[Prototype]]`原型链中）。 相比之下，hasOwnProperty(..) 只会检查属性是否在 myObject 对象中， 不会检查 `[[Prototype]]`链。\n<font color=\"red\">枚举：</font>\n```\nvar myObject = { };\nObject.defineProperty(\nmyObject,\n\"a\",\n// 让 a 像普通属性一样可以枚举\n{ enumerable: true, value: 2 }\n);\nObject.defineProperty(\nmyObject,\n\"b\",\n// 让 b 不可枚举\n{ enumerable: false, value: 3 }\n);\nmyObject.b; // 3\n(\"b\" in myObject); // true\nmyObject.hasOwnProperty( \"b\" ); // true\n// .......\nfor (var k in myObject) {\nconsole.log( k, myObject[k] );\n} /\n/ \"a\" 2\n```\n可以看到， myObject.b 确实存在并且有访问值， 但是却不会出现在 for..in 循环中（ 尽管可以通过 in 操作符来判断是否存在）。 原因是“ 可枚举” 就相当于“ 可以出现在对象属性\n的遍历中”。\n注：在数组上应用 for..in 循环有时会产生出人意料的结果， 因为这种枚举不仅会包含所有数值索引， 还会包含所有可枚举属性。 最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引。\n\n也可以通过另一种方式来区分属性是否可枚举：\n```\nvar myObject = { };\nObject.defineProperty(\nmyObject,\n\"a\",\n// 让 a 像普通属性一样可以枚举\n{ enumerable: true, value: 2 }\n);\nObject.defineProperty(\nmyObject,\n\"b\",\n// 让 b 不可枚举\n{ enumerable: false, value: 3 }\n);\nmyObject.propertyIsEnumerable( \"a\" ); // true\nmyObject.propertyIsEnumerable( \"b\" ); // false\nObject.keys( myObject ); // [\"a\"]\nObject.getOwnPropertyNames( myObject ); // [\"a\", \"b\"]\n```\npropertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中（ 而不是在原型链上） 并且满足 enumerable:true。\nObject.keys(..) 会返回一个数组， 包含所有可枚举属性， Object.getOwnPropertyNames(..)会返回一个数组， 包含所有属性， 无论它们是否可枚举。\nin 和 hasOwnProperty(..) 的区别在于是否查找 `[[Prototype]]`链， 然而， Object.keys(..)和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性。\n\n#### 遍历\nfor..in 循环可以用来遍历对象的可枚举属性列表（ 包括 `[[Prototype]]` 链）。\n注：遍历数组下标时采用的是数字顺序（ for 循环或者其他迭代器）， 但是遍历对象属性时的顺序是不确定的， 在不同的 JavaScript 引擎中可能不一样。 因此，在不同的环境中需要保证一致性时， 一定不要相信任何观察到的顺序， 它们是不可靠的。\n\nES6 增加了一种用来遍历数组的 for..of 循环语法——遍历数组中的值\n```\nvar myArray = [ 1, 2, 3 ];\nfor (var v of myArray) {\nconsole.log( v );\n} /\n/ 1\n// 2\n// 3\n```\n数组有内置的 @@iterator， 因此 for..of 可以直接应用在数组上。 和数组不同， 普通的对象没有内置的 @@iterator， 所以无法自动完成 for..of 遍历。 \n\n#### 补充与扩展\n属性的特性可以通过属性描述符来控制， 比如 writable 和 configurable。 此外， 可以使用Object.preventExtensions(..)、 Object.seal(..) 和 Object.freeze(..)来设置对象（ 及其属性） 的不可变性级别。属性不一定包含值——它们可能是具备 getter/setter 的“ 访问描述符”。 此外， 属性可以是可枚举或者不可枚举的， 这决定了它们是否会出现在 for..in 循环中。可以使用 ES6 的 for..of 语法来遍历数据结构（ 数组、 对象， 等等） 中的值， for..of会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。\n\n\n\n\n\n\n","source":"_posts/jsobject.md","raw":"---\ntitle: js中的对象\ndate: 2016-02-09 13:21:25\ntags: js object\n---\n#### 语法\n对象可以通过两种形式定义： 声明（ 文字） 形式和构造形式。\n对象的文字语法大概是这样：\n```\nvar myObj = {\nkey: value\n// ...\n};\n```\n构造形式大概是这样：\n```\nvar myObj = new Object();\nmyObj.key = value;\n```\n构造形式和文字形式生成的对象是一样的。 唯一的区别是， 在文字声明中你可以添加多个键 / 值对， 但是在构造形式中你必须逐个添加属性。“ 构造形式” 来创建对象是非常少见的,一般都用文字形式。\n\n#### 类型\n在 JavaScript 中一共有六种主要类型（ 术语是“ 语言类型”） ：string/number/boolean/null/undefined/object.\n注意， 简单基本类型（ string、 boolean、 number、 null 和 undefined） 本身并不是对象。null 有时会被当作一种对象类型， 但是这其实只是语言本身的一个 bug， 即对 null 执行\ntypeof null 时会返回字符串 \"object\"。 实际上， null 本身是基本类型。\n实际上， JavaScript 中有许多特殊的对象子类型， 可以称之为复杂基本类型。比如函数、数组...\n可以简单地理解为：javascript 引用类型的数据存放在堆内存，基本类型的数据存放在栈内存。\n\n<font color=\"red\">内置对象</font>\nJavaScript 中还有一些对象子类型， 通常被称为内置对象。 有些内置对象的名字看起来和简单基础类型一样， 不过实际上它们的关系更复杂.\n内置对象：String/Number/Boolean/Object/Function/Array/Date/RegExp/Error,这些内置函数可以当作构造函数（ 由 new 产生的函数调用） 来使用， 从而可以构造一个对应子类型的新对\n象。例子如下：\n```\nvar strPrimitive = \"I am a string\";\ntypeof strPrimitive; // \"string\"\nstrPrimitive instanceof String; // false\nvar strObject = new String( \"I am a string\" );\ntypeof strObject; // \"object\"\nstrObject instanceof String; // true\n// 检查 sub-type 对象\nObject.prototype.toString.call( strObject ); // [object String]\n```\n从代码中可以看到， strObject 是由 String 构造函数创建的一个对象;\n```\nvar strPrimitive = \"I am a string\";\nconsole.log( strPrimitive.length ); // 13\nconsole.log( strPrimitive.charAt( 3 ) ); // \"m\"\n```\n原始值 \"I am a string\" 并不是一个对象， 它只是一个字面量， 并且是一个不可变的值。如果要在这个字面量上执行一些操作， 比如获取长度、 访问其中某个字符等， 那需要将其\n转换为 String 对象。js在必要时语言会自动把字符串字面量转换成一个 String 对象，所以字符串也能直接使用length属性。数值字面量也是同样道理：42.359.toFixed(2)。\n\nnull 和 undefined 没有对应的构造形式， 它们只有文字形式。 相反， Date 只有构造， 没有文字形式。对于 Object、 Array、 Function 和 RegExp（ 正则表达式）来说，无论使用文字形式还是构造形式， 它们都是对象， 不是字面量。Error 对象很少在代码中显式创建， 一般是在抛出异常时被自动创建。 也可以使用 new Error(..) 这种构造形式来创建，不过一般来说用不着。\n\n##### 内容\n对象的内容是由一些存储在特定命名位置的（ 任意类型的） 值组成的，我们称之为属性。\n```\nvar myObject = {\na: 2\n};\nmyObject.a; // 2\nmyObject[\"a\"]; // 2\n```\n\n如果要访问 myObject 中 a 位置上的值， 我们需要使用 . 操作符或者 [] 操作符。 .a 语法通常被称为“ 属性访问”， `[\"a\"] `语法通常被称为“ 键访问”。 实际上它们访问的是同一个位\n置， 并且会返回相同的值 2， 所以这两个术语是可以互换的。当属性为number时，必须使用[]操作符。\n注：这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范， 而 `[\"..\"]`语法可以接受任意 UTF-8/Unicode 字符串作为属性名。 举例来说， 如果要引用名称为 \"SuperFun!\" 的属性， 那就必须使用 `[\"Super-Fun!\"]`语法访问， 因为 Super-Fun! 并不是一个有效的标识符属性名。\n小提示：对象的属性永远为字符串类型的。如果不是它也会隐式转换成字符串。\n\n<font color=\"red\">可计算属性名</font>\nES6 增加了可计算属性名， 可以在文字形式中使用 [] 包裹一个表达式来当作属性名：\n```\nvar prefix = \"foo\";\nvar myObject = {\n[prefix + \"bar\"]:\"hello\",\n[prefix + \"baz\"]: \"world\"\n};\nmyObject[\"foobar\"]; // hello\nmyObject[\"foobaz\"]; // world\n```\n可计算属性名最常用的场景可能是 ES6 的符号（ Symbol），简单来说， 它们是一种新的基础数据类型， 包含一个不透明且无法预测的值（从技术角度来说就是一个字符串）。一般来说你不会用到符号的实际值（ 因为理论上来说在不同的 JavaScript 引擎中值是不同的）， 所以通常接触到的是符号的名称， 比如 Symbol.Something（ something是随便起的） ：\n```\nvar myObject = {\n[Symbol.Something]: \"hello world\"\n}\n```\n<font color=\"red\">数组</font>\n数组也是对象， 所以虽然每个下标都是整数， 你仍然可以给数组添加属性：\n```\nvar myArray = [ \"foo\", 42, \"bar\" ];\nmyArray.baz = \"baz\";\nmyArray.length; // 3\nmyArray.baz; // \"baz\"\n```\n可以看到虽然添加了命名属性（ 无论是通过 . 语法还是 [] 语法）， 数组的 length 值并未发生变化。\n注意： 如果试图向数组添加一个属性， 但是属性名“ 看起来” 像一个数字， 那它会变成一个数值下标（ 因此会修改数组的内容而不是添加一个属性） ：\n```\nvar myArray = [ \"foo\", 42, \"bar\" ];\nmyArray[\"3\"] = \"baz\";\nmyArray.length; // 4\nmyArray[3]; // \"baz\"\n```\n<font color=\"red\">判断对象属性是否存在：</font>\n```\nvar myObject = {\na:2\n};\n(\"a\" in myObject); // true\n(\"b\" in myObject); // false\nmyObject.hasOwnProperty( \"a\" ); // true\nmyObject.hasOwnProperty( \"b\" ); // false\n```\nin 操作符会检查属性是否在对象及其 `[[Prototype]]`原型链中）。 相比之下，hasOwnProperty(..) 只会检查属性是否在 myObject 对象中， 不会检查 `[[Prototype]]`链。\n<font color=\"red\">枚举：</font>\n```\nvar myObject = { };\nObject.defineProperty(\nmyObject,\n\"a\",\n// 让 a 像普通属性一样可以枚举\n{ enumerable: true, value: 2 }\n);\nObject.defineProperty(\nmyObject,\n\"b\",\n// 让 b 不可枚举\n{ enumerable: false, value: 3 }\n);\nmyObject.b; // 3\n(\"b\" in myObject); // true\nmyObject.hasOwnProperty( \"b\" ); // true\n// .......\nfor (var k in myObject) {\nconsole.log( k, myObject[k] );\n} /\n/ \"a\" 2\n```\n可以看到， myObject.b 确实存在并且有访问值， 但是却不会出现在 for..in 循环中（ 尽管可以通过 in 操作符来判断是否存在）。 原因是“ 可枚举” 就相当于“ 可以出现在对象属性\n的遍历中”。\n注：在数组上应用 for..in 循环有时会产生出人意料的结果， 因为这种枚举不仅会包含所有数值索引， 还会包含所有可枚举属性。 最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引。\n\n也可以通过另一种方式来区分属性是否可枚举：\n```\nvar myObject = { };\nObject.defineProperty(\nmyObject,\n\"a\",\n// 让 a 像普通属性一样可以枚举\n{ enumerable: true, value: 2 }\n);\nObject.defineProperty(\nmyObject,\n\"b\",\n// 让 b 不可枚举\n{ enumerable: false, value: 3 }\n);\nmyObject.propertyIsEnumerable( \"a\" ); // true\nmyObject.propertyIsEnumerable( \"b\" ); // false\nObject.keys( myObject ); // [\"a\"]\nObject.getOwnPropertyNames( myObject ); // [\"a\", \"b\"]\n```\npropertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中（ 而不是在原型链上） 并且满足 enumerable:true。\nObject.keys(..) 会返回一个数组， 包含所有可枚举属性， Object.getOwnPropertyNames(..)会返回一个数组， 包含所有属性， 无论它们是否可枚举。\nin 和 hasOwnProperty(..) 的区别在于是否查找 `[[Prototype]]`链， 然而， Object.keys(..)和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性。\n\n#### 遍历\nfor..in 循环可以用来遍历对象的可枚举属性列表（ 包括 `[[Prototype]]` 链）。\n注：遍历数组下标时采用的是数字顺序（ for 循环或者其他迭代器）， 但是遍历对象属性时的顺序是不确定的， 在不同的 JavaScript 引擎中可能不一样。 因此，在不同的环境中需要保证一致性时， 一定不要相信任何观察到的顺序， 它们是不可靠的。\n\nES6 增加了一种用来遍历数组的 for..of 循环语法——遍历数组中的值\n```\nvar myArray = [ 1, 2, 3 ];\nfor (var v of myArray) {\nconsole.log( v );\n} /\n/ 1\n// 2\n// 3\n```\n数组有内置的 @@iterator， 因此 for..of 可以直接应用在数组上。 和数组不同， 普通的对象没有内置的 @@iterator， 所以无法自动完成 for..of 遍历。 \n\n#### 补充与扩展\n属性的特性可以通过属性描述符来控制， 比如 writable 和 configurable。 此外， 可以使用Object.preventExtensions(..)、 Object.seal(..) 和 Object.freeze(..)来设置对象（ 及其属性） 的不可变性级别。属性不一定包含值——它们可能是具备 getter/setter 的“ 访问描述符”。 此外， 属性可以是可枚举或者不可枚举的， 这决定了它们是否会出现在 for..in 循环中。可以使用 ES6 的 for..of 语法来遍历数据结构（ 数组、 对象， 等等） 中的值， for..of会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。\n\n\n\n\n\n\n","slug":"jsobject","published":1,"updated":"2017-02-09T07:11:20.070Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizpcu9rw0003fctuxnikml1s","content":"<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>对象可以通过两种形式定义： 声明（ 文字） 形式和构造形式。<br>对象的文字语法大概是这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myObj = &#123;</div><div class=\"line\">key: value</div><div class=\"line\">// ...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>构造形式大概是这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myObj = new Object();</div><div class=\"line\">myObj.key = value;</div></pre></td></tr></table></figure></p>\n<p>构造形式和文字形式生成的对象是一样的。 唯一的区别是， 在文字声明中你可以添加多个键 / 值对， 但是在构造形式中你必须逐个添加属性。“ 构造形式” 来创建对象是非常少见的,一般都用文字形式。</p>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><p>在 JavaScript 中一共有六种主要类型（ 术语是“ 语言类型”） ：string/number/boolean/null/undefined/object.<br>注意， 简单基本类型（ string、 boolean、 number、 null 和 undefined） 本身并不是对象。null 有时会被当作一种对象类型， 但是这其实只是语言本身的一个 bug， 即对 null 执行<br>typeof null 时会返回字符串 “object”。 实际上， null 本身是基本类型。<br>实际上， JavaScript 中有许多特殊的对象子类型， 可以称之为复杂基本类型。比如函数、数组…<br>可以简单地理解为：javascript 引用类型的数据存放在堆内存，基本类型的数据存放在栈内存。</p>\n<p><font color=\"red\">内置对象</font><br>JavaScript 中还有一些对象子类型， 通常被称为内置对象。 有些内置对象的名字看起来和简单基础类型一样， 不过实际上它们的关系更复杂.<br>内置对象：String/Number/Boolean/Object/Function/Array/Date/RegExp/Error,这些内置函数可以当作构造函数（ 由 new 产生的函数调用） 来使用， 从而可以构造一个对应子类型的新对<br>象。例子如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var strPrimitive = &quot;I am a string&quot;;</div><div class=\"line\">typeof strPrimitive; // &quot;string&quot;</div><div class=\"line\">strPrimitive instanceof String; // false</div><div class=\"line\">var strObject = new String( &quot;I am a string&quot; );</div><div class=\"line\">typeof strObject; // &quot;object&quot;</div><div class=\"line\">strObject instanceof String; // true</div><div class=\"line\">// 检查 sub-type 对象</div><div class=\"line\">Object.prototype.toString.call( strObject ); // [object String]</div></pre></td></tr></table></figure></p>\n<p>从代码中可以看到， strObject 是由 String 构造函数创建的一个对象;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var strPrimitive = &quot;I am a string&quot;;</div><div class=\"line\">console.log( strPrimitive.length ); // 13</div><div class=\"line\">console.log( strPrimitive.charAt( 3 ) ); // &quot;m&quot;</div></pre></td></tr></table></figure></p>\n<p>原始值 “I am a string” 并不是一个对象， 它只是一个字面量， 并且是一个不可变的值。如果要在这个字面量上执行一些操作， 比如获取长度、 访问其中某个字符等， 那需要将其<br>转换为 String 对象。js在必要时语言会自动把字符串字面量转换成一个 String 对象，所以字符串也能直接使用length属性。数值字面量也是同样道理：42.359.toFixed(2)。</p>\n<p>null 和 undefined 没有对应的构造形式， 它们只有文字形式。 相反， Date 只有构造， 没有文字形式。对于 Object、 Array、 Function 和 RegExp（ 正则表达式）来说，无论使用文字形式还是构造形式， 它们都是对象， 不是字面量。Error 对象很少在代码中显式创建， 一般是在抛出异常时被自动创建。 也可以使用 new Error(..) 这种构造形式来创建，不过一般来说用不着。</p>\n<h5 id=\"内容\"><a href=\"#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h5><p>对象的内容是由一些存储在特定命名位置的（ 任意类型的） 值组成的，我们称之为属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myObject = &#123;</div><div class=\"line\">a: 2</div><div class=\"line\">&#125;;</div><div class=\"line\">myObject.a; // 2</div><div class=\"line\">myObject[&quot;a&quot;]; // 2</div></pre></td></tr></table></figure></p>\n<p>如果要访问 myObject 中 a 位置上的值， 我们需要使用 . 操作符或者 [] 操作符。 .a 语法通常被称为“ 属性访问”， <code>[&quot;a&quot;]</code>语法通常被称为“ 键访问”。 实际上它们访问的是同一个位<br>置， 并且会返回相同的值 2， 所以这两个术语是可以互换的。当属性为number时，必须使用[]操作符。<br>注：这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范， 而 <code>[&quot;..&quot;]</code>语法可以接受任意 UTF-8/Unicode 字符串作为属性名。 举例来说， 如果要引用名称为 “SuperFun!” 的属性， 那就必须使用 <code>[&quot;Super-Fun!&quot;]</code>语法访问， 因为 Super-Fun! 并不是一个有效的标识符属性名。<br>小提示：对象的属性永远为字符串类型的。如果不是它也会隐式转换成字符串。</p>\n<p><font color=\"red\">可计算属性名</font><br>ES6 增加了可计算属性名， 可以在文字形式中使用 [] 包裹一个表达式来当作属性名：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var prefix = &quot;foo&quot;;</div><div class=\"line\">var myObject = &#123;</div><div class=\"line\">[prefix + &quot;bar&quot;]:&quot;hello&quot;,</div><div class=\"line\">[prefix + &quot;baz&quot;]: &quot;world&quot;</div><div class=\"line\">&#125;;</div><div class=\"line\">myObject[&quot;foobar&quot;]; // hello</div><div class=\"line\">myObject[&quot;foobaz&quot;]; // world</div></pre></td></tr></table></figure></p>\n<p>可计算属性名最常用的场景可能是 ES6 的符号（ Symbol），简单来说， 它们是一种新的基础数据类型， 包含一个不透明且无法预测的值（从技术角度来说就是一个字符串）。一般来说你不会用到符号的实际值（ 因为理论上来说在不同的 JavaScript 引擎中值是不同的）， 所以通常接触到的是符号的名称， 比如 Symbol.Something（ something是随便起的） ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myObject = &#123;</div><div class=\"line\">[Symbol.Something]: &quot;hello world&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><font color=\"red\">数组</font><br>数组也是对象， 所以虽然每个下标都是整数， 你仍然可以给数组添加属性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myArray = [ &quot;foo&quot;, 42, &quot;bar&quot; ];</div><div class=\"line\">myArray.baz = &quot;baz&quot;;</div><div class=\"line\">myArray.length; // 3</div><div class=\"line\">myArray.baz; // &quot;baz&quot;</div></pre></td></tr></table></figure></p>\n<p>可以看到虽然添加了命名属性（ 无论是通过 . 语法还是 [] 语法）， 数组的 length 值并未发生变化。<br>注意： 如果试图向数组添加一个属性， 但是属性名“ 看起来” 像一个数字， 那它会变成一个数值下标（ 因此会修改数组的内容而不是添加一个属性） ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myArray = [ &quot;foo&quot;, 42, &quot;bar&quot; ];</div><div class=\"line\">myArray[&quot;3&quot;] = &quot;baz&quot;;</div><div class=\"line\">myArray.length; // 4</div><div class=\"line\">myArray[3]; // &quot;baz&quot;</div></pre></td></tr></table></figure></p>\n<p><font color=\"red\">判断对象属性是否存在：</font><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myObject = &#123;</div><div class=\"line\">a:2</div><div class=\"line\">&#125;;</div><div class=\"line\">(&quot;a&quot; in myObject); // true</div><div class=\"line\">(&quot;b&quot; in myObject); // false</div><div class=\"line\">myObject.hasOwnProperty( &quot;a&quot; ); // true</div><div class=\"line\">myObject.hasOwnProperty( &quot;b&quot; ); // false</div></pre></td></tr></table></figure></p>\n<p>in 操作符会检查属性是否在对象及其 <code>[[Prototype]]</code>原型链中）。 相比之下，hasOwnProperty(..) 只会检查属性是否在 myObject 对象中， 不会检查 <code>[[Prototype]]</code>链。</p>\n<p><font color=\"red\">枚举：</font><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myObject = &#123; &#125;;</div><div class=\"line\">Object.defineProperty(</div><div class=\"line\">myObject,</div><div class=\"line\">&quot;a&quot;,</div><div class=\"line\">// 让 a 像普通属性一样可以枚举</div><div class=\"line\">&#123; enumerable: true, value: 2 &#125;</div><div class=\"line\">);</div><div class=\"line\">Object.defineProperty(</div><div class=\"line\">myObject,</div><div class=\"line\">&quot;b&quot;,</div><div class=\"line\">// 让 b 不可枚举</div><div class=\"line\">&#123; enumerable: false, value: 3 &#125;</div><div class=\"line\">);</div><div class=\"line\">myObject.b; // 3</div><div class=\"line\">(&quot;b&quot; in myObject); // true</div><div class=\"line\">myObject.hasOwnProperty( &quot;b&quot; ); // true</div><div class=\"line\">// .......</div><div class=\"line\">for (var k in myObject) &#123;</div><div class=\"line\">console.log( k, myObject[k] );</div><div class=\"line\">&#125; /</div><div class=\"line\">/ &quot;a&quot; 2</div></pre></td></tr></table></figure></p>\n<p>可以看到， myObject.b 确实存在并且有访问值， 但是却不会出现在 for..in 循环中（ 尽管可以通过 in 操作符来判断是否存在）。 原因是“ 可枚举” 就相当于“ 可以出现在对象属性<br>的遍历中”。<br>注：在数组上应用 for..in 循环有时会产生出人意料的结果， 因为这种枚举不仅会包含所有数值索引， 还会包含所有可枚举属性。 最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引。</p>\n<p>也可以通过另一种方式来区分属性是否可枚举：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myObject = &#123; &#125;;</div><div class=\"line\">Object.defineProperty(</div><div class=\"line\">myObject,</div><div class=\"line\">&quot;a&quot;,</div><div class=\"line\">// 让 a 像普通属性一样可以枚举</div><div class=\"line\">&#123; enumerable: true, value: 2 &#125;</div><div class=\"line\">);</div><div class=\"line\">Object.defineProperty(</div><div class=\"line\">myObject,</div><div class=\"line\">&quot;b&quot;,</div><div class=\"line\">// 让 b 不可枚举</div><div class=\"line\">&#123; enumerable: false, value: 3 &#125;</div><div class=\"line\">);</div><div class=\"line\">myObject.propertyIsEnumerable( &quot;a&quot; ); // true</div><div class=\"line\">myObject.propertyIsEnumerable( &quot;b&quot; ); // false</div><div class=\"line\">Object.keys( myObject ); // [&quot;a&quot;]</div><div class=\"line\">Object.getOwnPropertyNames( myObject ); // [&quot;a&quot;, &quot;b&quot;]</div></pre></td></tr></table></figure></p>\n<p>propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中（ 而不是在原型链上） 并且满足 enumerable:true。<br>Object.keys(..) 会返回一个数组， 包含所有可枚举属性， Object.getOwnPropertyNames(..)会返回一个数组， 包含所有属性， 无论它们是否可枚举。<br>in 和 hasOwnProperty(..) 的区别在于是否查找 <code>[[Prototype]]</code>链， 然而， Object.keys(..)和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性。</p>\n<h4 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h4><p>for..in 循环可以用来遍历对象的可枚举属性列表（ 包括 <code>[[Prototype]]</code> 链）。<br>注：遍历数组下标时采用的是数字顺序（ for 循环或者其他迭代器）， 但是遍历对象属性时的顺序是不确定的， 在不同的 JavaScript 引擎中可能不一样。 因此，在不同的环境中需要保证一致性时， 一定不要相信任何观察到的顺序， 它们是不可靠的。</p>\n<p>ES6 增加了一种用来遍历数组的 for..of 循环语法——遍历数组中的值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myArray = [ 1, 2, 3 ];</div><div class=\"line\">for (var v of myArray) &#123;</div><div class=\"line\">console.log( v );</div><div class=\"line\">&#125; /</div><div class=\"line\">/ 1</div><div class=\"line\">// 2</div><div class=\"line\">// 3</div></pre></td></tr></table></figure></p>\n<p>数组有内置的 @@iterator， 因此 for..of 可以直接应用在数组上。 和数组不同， 普通的对象没有内置的 @@iterator， 所以无法自动完成 for..of 遍历。 </p>\n<h4 id=\"补充与扩展\"><a href=\"#补充与扩展\" class=\"headerlink\" title=\"补充与扩展\"></a>补充与扩展</h4><p>属性的特性可以通过属性描述符来控制， 比如 writable 和 configurable。 此外， 可以使用Object.preventExtensions(..)、 Object.seal(..) 和 Object.freeze(..)来设置对象（ 及其属性） 的不可变性级别。属性不一定包含值——它们可能是具备 getter/setter 的“ 访问描述符”。 此外， 属性可以是可枚举或者不可枚举的， 这决定了它们是否会出现在 for..in 循环中。可以使用 ES6 的 for..of 语法来遍历数据结构（ 数组、 对象， 等等） 中的值， for..of会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。</p>\n","excerpt":"","more":"<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>对象可以通过两种形式定义： 声明（ 文字） 形式和构造形式。<br>对象的文字语法大概是这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myObj = &#123;</div><div class=\"line\">key: value</div><div class=\"line\">// ...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>构造形式大概是这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myObj = new Object();</div><div class=\"line\">myObj.key = value;</div></pre></td></tr></table></figure></p>\n<p>构造形式和文字形式生成的对象是一样的。 唯一的区别是， 在文字声明中你可以添加多个键 / 值对， 但是在构造形式中你必须逐个添加属性。“ 构造形式” 来创建对象是非常少见的,一般都用文字形式。</p>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><p>在 JavaScript 中一共有六种主要类型（ 术语是“ 语言类型”） ：string/number/boolean/null/undefined/object.<br>注意， 简单基本类型（ string、 boolean、 number、 null 和 undefined） 本身并不是对象。null 有时会被当作一种对象类型， 但是这其实只是语言本身的一个 bug， 即对 null 执行<br>typeof null 时会返回字符串 “object”。 实际上， null 本身是基本类型。<br>实际上， JavaScript 中有许多特殊的对象子类型， 可以称之为复杂基本类型。比如函数、数组…<br>可以简单地理解为：javascript 引用类型的数据存放在堆内存，基本类型的数据存放在栈内存。</p>\n<p><font color=\"red\">内置对象</font><br>JavaScript 中还有一些对象子类型， 通常被称为内置对象。 有些内置对象的名字看起来和简单基础类型一样， 不过实际上它们的关系更复杂.<br>内置对象：String/Number/Boolean/Object/Function/Array/Date/RegExp/Error,这些内置函数可以当作构造函数（ 由 new 产生的函数调用） 来使用， 从而可以构造一个对应子类型的新对<br>象。例子如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var strPrimitive = &quot;I am a string&quot;;</div><div class=\"line\">typeof strPrimitive; // &quot;string&quot;</div><div class=\"line\">strPrimitive instanceof String; // false</div><div class=\"line\">var strObject = new String( &quot;I am a string&quot; );</div><div class=\"line\">typeof strObject; // &quot;object&quot;</div><div class=\"line\">strObject instanceof String; // true</div><div class=\"line\">// 检查 sub-type 对象</div><div class=\"line\">Object.prototype.toString.call( strObject ); // [object String]</div></pre></td></tr></table></figure></p>\n<p>从代码中可以看到， strObject 是由 String 构造函数创建的一个对象;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var strPrimitive = &quot;I am a string&quot;;</div><div class=\"line\">console.log( strPrimitive.length ); // 13</div><div class=\"line\">console.log( strPrimitive.charAt( 3 ) ); // &quot;m&quot;</div></pre></td></tr></table></figure></p>\n<p>原始值 “I am a string” 并不是一个对象， 它只是一个字面量， 并且是一个不可变的值。如果要在这个字面量上执行一些操作， 比如获取长度、 访问其中某个字符等， 那需要将其<br>转换为 String 对象。js在必要时语言会自动把字符串字面量转换成一个 String 对象，所以字符串也能直接使用length属性。数值字面量也是同样道理：42.359.toFixed(2)。</p>\n<p>null 和 undefined 没有对应的构造形式， 它们只有文字形式。 相反， Date 只有构造， 没有文字形式。对于 Object、 Array、 Function 和 RegExp（ 正则表达式）来说，无论使用文字形式还是构造形式， 它们都是对象， 不是字面量。Error 对象很少在代码中显式创建， 一般是在抛出异常时被自动创建。 也可以使用 new Error(..) 这种构造形式来创建，不过一般来说用不着。</p>\n<h5 id=\"内容\"><a href=\"#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h5><p>对象的内容是由一些存储在特定命名位置的（ 任意类型的） 值组成的，我们称之为属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myObject = &#123;</div><div class=\"line\">a: 2</div><div class=\"line\">&#125;;</div><div class=\"line\">myObject.a; // 2</div><div class=\"line\">myObject[&quot;a&quot;]; // 2</div></pre></td></tr></table></figure></p>\n<p>如果要访问 myObject 中 a 位置上的值， 我们需要使用 . 操作符或者 [] 操作符。 .a 语法通常被称为“ 属性访问”， <code>[&quot;a&quot;]</code>语法通常被称为“ 键访问”。 实际上它们访问的是同一个位<br>置， 并且会返回相同的值 2， 所以这两个术语是可以互换的。当属性为number时，必须使用[]操作符。<br>注：这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范， 而 <code>[&quot;..&quot;]</code>语法可以接受任意 UTF-8/Unicode 字符串作为属性名。 举例来说， 如果要引用名称为 “SuperFun!” 的属性， 那就必须使用 <code>[&quot;Super-Fun!&quot;]</code>语法访问， 因为 Super-Fun! 并不是一个有效的标识符属性名。<br>小提示：对象的属性永远为字符串类型的。如果不是它也会隐式转换成字符串。</p>\n<p><font color=\"red\">可计算属性名</font><br>ES6 增加了可计算属性名， 可以在文字形式中使用 [] 包裹一个表达式来当作属性名：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var prefix = &quot;foo&quot;;</div><div class=\"line\">var myObject = &#123;</div><div class=\"line\">[prefix + &quot;bar&quot;]:&quot;hello&quot;,</div><div class=\"line\">[prefix + &quot;baz&quot;]: &quot;world&quot;</div><div class=\"line\">&#125;;</div><div class=\"line\">myObject[&quot;foobar&quot;]; // hello</div><div class=\"line\">myObject[&quot;foobaz&quot;]; // world</div></pre></td></tr></table></figure></p>\n<p>可计算属性名最常用的场景可能是 ES6 的符号（ Symbol），简单来说， 它们是一种新的基础数据类型， 包含一个不透明且无法预测的值（从技术角度来说就是一个字符串）。一般来说你不会用到符号的实际值（ 因为理论上来说在不同的 JavaScript 引擎中值是不同的）， 所以通常接触到的是符号的名称， 比如 Symbol.Something（ something是随便起的） ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myObject = &#123;</div><div class=\"line\">[Symbol.Something]: &quot;hello world&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><font color=\"red\">数组</font><br>数组也是对象， 所以虽然每个下标都是整数， 你仍然可以给数组添加属性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myArray = [ &quot;foo&quot;, 42, &quot;bar&quot; ];</div><div class=\"line\">myArray.baz = &quot;baz&quot;;</div><div class=\"line\">myArray.length; // 3</div><div class=\"line\">myArray.baz; // &quot;baz&quot;</div></pre></td></tr></table></figure></p>\n<p>可以看到虽然添加了命名属性（ 无论是通过 . 语法还是 [] 语法）， 数组的 length 值并未发生变化。<br>注意： 如果试图向数组添加一个属性， 但是属性名“ 看起来” 像一个数字， 那它会变成一个数值下标（ 因此会修改数组的内容而不是添加一个属性） ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myArray = [ &quot;foo&quot;, 42, &quot;bar&quot; ];</div><div class=\"line\">myArray[&quot;3&quot;] = &quot;baz&quot;;</div><div class=\"line\">myArray.length; // 4</div><div class=\"line\">myArray[3]; // &quot;baz&quot;</div></pre></td></tr></table></figure></p>\n<p><font color=\"red\">判断对象属性是否存在：</font><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myObject = &#123;</div><div class=\"line\">a:2</div><div class=\"line\">&#125;;</div><div class=\"line\">(&quot;a&quot; in myObject); // true</div><div class=\"line\">(&quot;b&quot; in myObject); // false</div><div class=\"line\">myObject.hasOwnProperty( &quot;a&quot; ); // true</div><div class=\"line\">myObject.hasOwnProperty( &quot;b&quot; ); // false</div></pre></td></tr></table></figure></p>\n<p>in 操作符会检查属性是否在对象及其 <code>[[Prototype]]</code>原型链中）。 相比之下，hasOwnProperty(..) 只会检查属性是否在 myObject 对象中， 不会检查 <code>[[Prototype]]</code>链。</p>\n<p><font color=\"red\">枚举：</font><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myObject = &#123; &#125;;</div><div class=\"line\">Object.defineProperty(</div><div class=\"line\">myObject,</div><div class=\"line\">&quot;a&quot;,</div><div class=\"line\">// 让 a 像普通属性一样可以枚举</div><div class=\"line\">&#123; enumerable: true, value: 2 &#125;</div><div class=\"line\">);</div><div class=\"line\">Object.defineProperty(</div><div class=\"line\">myObject,</div><div class=\"line\">&quot;b&quot;,</div><div class=\"line\">// 让 b 不可枚举</div><div class=\"line\">&#123; enumerable: false, value: 3 &#125;</div><div class=\"line\">);</div><div class=\"line\">myObject.b; // 3</div><div class=\"line\">(&quot;b&quot; in myObject); // true</div><div class=\"line\">myObject.hasOwnProperty( &quot;b&quot; ); // true</div><div class=\"line\">// .......</div><div class=\"line\">for (var k in myObject) &#123;</div><div class=\"line\">console.log( k, myObject[k] );</div><div class=\"line\">&#125; /</div><div class=\"line\">/ &quot;a&quot; 2</div></pre></td></tr></table></figure></p>\n<p>可以看到， myObject.b 确实存在并且有访问值， 但是却不会出现在 for..in 循环中（ 尽管可以通过 in 操作符来判断是否存在）。 原因是“ 可枚举” 就相当于“ 可以出现在对象属性<br>的遍历中”。<br>注：在数组上应用 for..in 循环有时会产生出人意料的结果， 因为这种枚举不仅会包含所有数值索引， 还会包含所有可枚举属性。 最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引。</p>\n<p>也可以通过另一种方式来区分属性是否可枚举：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myObject = &#123; &#125;;</div><div class=\"line\">Object.defineProperty(</div><div class=\"line\">myObject,</div><div class=\"line\">&quot;a&quot;,</div><div class=\"line\">// 让 a 像普通属性一样可以枚举</div><div class=\"line\">&#123; enumerable: true, value: 2 &#125;</div><div class=\"line\">);</div><div class=\"line\">Object.defineProperty(</div><div class=\"line\">myObject,</div><div class=\"line\">&quot;b&quot;,</div><div class=\"line\">// 让 b 不可枚举</div><div class=\"line\">&#123; enumerable: false, value: 3 &#125;</div><div class=\"line\">);</div><div class=\"line\">myObject.propertyIsEnumerable( &quot;a&quot; ); // true</div><div class=\"line\">myObject.propertyIsEnumerable( &quot;b&quot; ); // false</div><div class=\"line\">Object.keys( myObject ); // [&quot;a&quot;]</div><div class=\"line\">Object.getOwnPropertyNames( myObject ); // [&quot;a&quot;, &quot;b&quot;]</div></pre></td></tr></table></figure></p>\n<p>propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中（ 而不是在原型链上） 并且满足 enumerable:true。<br>Object.keys(..) 会返回一个数组， 包含所有可枚举属性， Object.getOwnPropertyNames(..)会返回一个数组， 包含所有属性， 无论它们是否可枚举。<br>in 和 hasOwnProperty(..) 的区别在于是否查找 <code>[[Prototype]]</code>链， 然而， Object.keys(..)和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性。</p>\n<h4 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h4><p>for..in 循环可以用来遍历对象的可枚举属性列表（ 包括 <code>[[Prototype]]</code> 链）。<br>注：遍历数组下标时采用的是数字顺序（ for 循环或者其他迭代器）， 但是遍历对象属性时的顺序是不确定的， 在不同的 JavaScript 引擎中可能不一样。 因此，在不同的环境中需要保证一致性时， 一定不要相信任何观察到的顺序， 它们是不可靠的。</p>\n<p>ES6 增加了一种用来遍历数组的 for..of 循环语法——遍历数组中的值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myArray = [ 1, 2, 3 ];</div><div class=\"line\">for (var v of myArray) &#123;</div><div class=\"line\">console.log( v );</div><div class=\"line\">&#125; /</div><div class=\"line\">/ 1</div><div class=\"line\">// 2</div><div class=\"line\">// 3</div></pre></td></tr></table></figure></p>\n<p>数组有内置的 @@iterator， 因此 for..of 可以直接应用在数组上。 和数组不同， 普通的对象没有内置的 @@iterator， 所以无法自动完成 for..of 遍历。 </p>\n<h4 id=\"补充与扩展\"><a href=\"#补充与扩展\" class=\"headerlink\" title=\"补充与扩展\"></a>补充与扩展</h4><p>属性的特性可以通过属性描述符来控制， 比如 writable 和 configurable。 此外， 可以使用Object.preventExtensions(..)、 Object.seal(..) 和 Object.freeze(..)来设置对象（ 及其属性） 的不可变性级别。属性不一定包含值——它们可能是具备 getter/setter 的“ 访问描述符”。 此外， 属性可以是可枚举或者不可枚举的， 这决定了它们是否会出现在 for..in 循环中。可以使用 ES6 的 for..of 语法来遍历数据结构（ 数组、 对象， 等等） 中的值， for..of会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。</p>\n"},{"title":"爱的开始","date":"2017-02-14T09:15:48.000Z","_content":"<iframe style=\"margin:0 auto; display:block;\" frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=27731261&auto=1&height=66\"></iframe>\n\n2017年2月12日，在金莎鹿港小镇我们第一次相见。你迟到了（说好的11点，你临时修网线11点半多到的），按照国际惯例我应该是不耐烦了，因为我很讨厌迟到的人，除非是有不可控因素。一些可控因素的迟到在一定程序上说明没有引起对方足够的重视。但是那一刻我清楚地记得我很有耐心，说实话我都佩服我自己，我也不知道我哪来的耐心，大概是直觉告诉我你就是那个对的人。\n\n饭前，我一个人在麦当劳静静地听着音乐，怀着一种期盼地心情等待你的出现。\n\n饭间，通过简单地沟通我更加明确了方向，你就是我要等的那个人。吸引我的地方就是不但人美，而且还透露着一种独特的气质。此处应该有一个大写的表情：奸笑。\n\n饭毕，我们去了八大处，说说笑笑走着上去的，安安静静地坐揽车下来的。期间，看到你儿童般地步伐、天真灿烂的笑容，我心里油然而生一种幸福感，仿佛回到了童年。\n\n都说欣赏一个人，始于颜值，敬于才华，合于性格，久于善良，终于人品。我能告诉你们在这一天我用火眼金睛都看到了吗？答案是不能也得能。此刻让我想起来汪国真的一首诗：我不去想是否能够成功，既然选择了远方，便只顾风雨兼程！我不去想能否赢得爱情，既然钟情于玫瑰，就勇敢地吐露真诚。\n\n爱不是交易，爱也不是要求，爱是不求回报地付出，爱是相互欣赏与理解对方。愿能用我的真心换来你的实意，你若不离，我定不弃。最后贴上一句我很喜欢的话：但行好事，莫问前程，欢迎你和我一起，成为很酷的年轻人。\n\n#### 后记：\n记得之前通话期间我问过你的生日，在此记录下来，阴历11月29，我想到时候应该会有一个惊喜。\n\n17年2月 26日晚，我第一次认真地生气，是因为第一回打电话没人接，第二回打正在通话中，足足等了快一小时居然还没有回个电话，我本决定那天晚上不再给你打电话，但是我没有忍住，最终还是又打了。见了你之后对你就有一种说不出的感觉，那种感觉就像磁场，而磁场里只有你我共存。为了你我内心愿意放下从前的自己，对待你的态度和别人的就是不一样，这也不是我特意去做的，只是我内心的一种选择。","source":"_posts/lovestart.md","raw":"---\ntitle: 爱的开始\ndate: 2017-02-14 17:15:48\ntags:  生活\n---\n<iframe style=\"margin:0 auto; display:block;\" frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=27731261&auto=1&height=66\"></iframe>\n\n2017年2月12日，在金莎鹿港小镇我们第一次相见。你迟到了（说好的11点，你临时修网线11点半多到的），按照国际惯例我应该是不耐烦了，因为我很讨厌迟到的人，除非是有不可控因素。一些可控因素的迟到在一定程序上说明没有引起对方足够的重视。但是那一刻我清楚地记得我很有耐心，说实话我都佩服我自己，我也不知道我哪来的耐心，大概是直觉告诉我你就是那个对的人。\n\n饭前，我一个人在麦当劳静静地听着音乐，怀着一种期盼地心情等待你的出现。\n\n饭间，通过简单地沟通我更加明确了方向，你就是我要等的那个人。吸引我的地方就是不但人美，而且还透露着一种独特的气质。此处应该有一个大写的表情：奸笑。\n\n饭毕，我们去了八大处，说说笑笑走着上去的，安安静静地坐揽车下来的。期间，看到你儿童般地步伐、天真灿烂的笑容，我心里油然而生一种幸福感，仿佛回到了童年。\n\n都说欣赏一个人，始于颜值，敬于才华，合于性格，久于善良，终于人品。我能告诉你们在这一天我用火眼金睛都看到了吗？答案是不能也得能。此刻让我想起来汪国真的一首诗：我不去想是否能够成功，既然选择了远方，便只顾风雨兼程！我不去想能否赢得爱情，既然钟情于玫瑰，就勇敢地吐露真诚。\n\n爱不是交易，爱也不是要求，爱是不求回报地付出，爱是相互欣赏与理解对方。愿能用我的真心换来你的实意，你若不离，我定不弃。最后贴上一句我很喜欢的话：但行好事，莫问前程，欢迎你和我一起，成为很酷的年轻人。\n\n#### 后记：\n记得之前通话期间我问过你的生日，在此记录下来，阴历11月29，我想到时候应该会有一个惊喜。\n\n17年2月 26日晚，我第一次认真地生气，是因为第一回打电话没人接，第二回打正在通话中，足足等了快一小时居然还没有回个电话，我本决定那天晚上不再给你打电话，但是我没有忍住，最终还是又打了。见了你之后对你就有一种说不出的感觉，那种感觉就像磁场，而磁场里只有你我共存。为了你我内心愿意放下从前的自己，对待你的态度和别人的就是不一样，这也不是我特意去做的，只是我内心的一种选择。","slug":"lovestart","published":1,"updated":"2017-03-01T01:15:48.661Z","_id":"cizpcu9rz0004fctut4j8atre","comments":1,"layout":"post","photos":[],"link":"","content":"<iframe style=\"margin:0 auto; display:block;\" frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"530\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=27731261&auto=1&height=66\"></iframe>\n\n<p>2017年2月12日，在金莎鹿港小镇我们第一次相见。你迟到了（说好的11点，你临时修网线11点半多到的），按照国际惯例我应该是不耐烦了，因为我很讨厌迟到的人，除非是有不可控因素。一些可控因素的迟到在一定程序上说明没有引起对方足够的重视。但是那一刻我清楚地记得我很有耐心，说实话我都佩服我自己，我也不知道我哪来的耐心，大概是直觉告诉我你就是那个对的人。</p>\n<p>饭前，我一个人在麦当劳静静地听着音乐，怀着一种期盼地心情等待你的出现。</p>\n<p>饭间，通过简单地沟通我更加明确了方向，你就是我要等的那个人。吸引我的地方就是不但人美，而且还透露着一种独特的气质。此处应该有一个大写的表情：奸笑。</p>\n<p>饭毕，我们去了八大处，说说笑笑走着上去的，安安静静地坐揽车下来的。期间，看到你儿童般地步伐、天真灿烂的笑容，我心里油然而生一种幸福感，仿佛回到了童年。</p>\n<p>都说欣赏一个人，始于颜值，敬于才华，合于性格，久于善良，终于人品。我能告诉你们在这一天我用火眼金睛都看到了吗？答案是不能也得能。此刻让我想起来汪国真的一首诗：我不去想是否能够成功，既然选择了远方，便只顾风雨兼程！我不去想能否赢得爱情，既然钟情于玫瑰，就勇敢地吐露真诚。</p>\n<p>爱不是交易，爱也不是要求，爱是不求回报地付出，爱是相互欣赏与理解对方。愿能用我的真心换来你的实意，你若不离，我定不弃。最后贴上一句我很喜欢的话：但行好事，莫问前程，欢迎你和我一起，成为很酷的年轻人。</p>\n<h4 id=\"后记：\"><a href=\"#后记：\" class=\"headerlink\" title=\"后记：\"></a>后记：</h4><p>记得之前通话期间我问过你的生日，在此记录下来，阴历11月29，我想到时候应该会有一个惊喜。</p>\n<p>17年2月 26日晚，我第一次认真地生气，是因为第一回打电话没人接，第二回打正在通话中，足足等了快一小时居然还没有回个电话，我本决定那天晚上不再给你打电话，但是我没有忍住，最终还是又打了。见了你之后对你就有一种说不出的感觉，那种感觉就像磁场，而磁场里只有你我共存。为了你我内心愿意放下从前的自己，对待你的态度和别人的就是不一样，这也不是我特意去做的，只是我内心的一种选择。</p>\n","excerpt":"","more":"<iframe style=\"margin:0 auto; display:block;\" frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=27731261&auto=1&height=66\"></iframe>\n\n<p>2017年2月12日，在金莎鹿港小镇我们第一次相见。你迟到了（说好的11点，你临时修网线11点半多到的），按照国际惯例我应该是不耐烦了，因为我很讨厌迟到的人，除非是有不可控因素。一些可控因素的迟到在一定程序上说明没有引起对方足够的重视。但是那一刻我清楚地记得我很有耐心，说实话我都佩服我自己，我也不知道我哪来的耐心，大概是直觉告诉我你就是那个对的人。</p>\n<p>饭前，我一个人在麦当劳静静地听着音乐，怀着一种期盼地心情等待你的出现。</p>\n<p>饭间，通过简单地沟通我更加明确了方向，你就是我要等的那个人。吸引我的地方就是不但人美，而且还透露着一种独特的气质。此处应该有一个大写的表情：奸笑。</p>\n<p>饭毕，我们去了八大处，说说笑笑走着上去的，安安静静地坐揽车下来的。期间，看到你儿童般地步伐、天真灿烂的笑容，我心里油然而生一种幸福感，仿佛回到了童年。</p>\n<p>都说欣赏一个人，始于颜值，敬于才华，合于性格，久于善良，终于人品。我能告诉你们在这一天我用火眼金睛都看到了吗？答案是不能也得能。此刻让我想起来汪国真的一首诗：我不去想是否能够成功，既然选择了远方，便只顾风雨兼程！我不去想能否赢得爱情，既然钟情于玫瑰，就勇敢地吐露真诚。</p>\n<p>爱不是交易，爱也不是要求，爱是不求回报地付出，爱是相互欣赏与理解对方。愿能用我的真心换来你的实意，你若不离，我定不弃。最后贴上一句我很喜欢的话：但行好事，莫问前程，欢迎你和我一起，成为很酷的年轻人。</p>\n<h4 id=\"后记：\"><a href=\"#后记：\" class=\"headerlink\" title=\"后记：\"></a>后记：</h4><p>记得之前通话期间我问过你的生日，在此记录下来，阴历11月29，我想到时候应该会有一个惊喜。</p>\n<p>17年2月 26日晚，我第一次认真地生气，是因为第一回打电话没人接，第二回打正在通话中，足足等了快一小时居然还没有回个电话，我本决定那天晚上不再给你打电话，但是我没有忍住，最终还是又打了。见了你之后对你就有一种说不出的感觉，那种感觉就像磁场，而磁场里只有你我共存。为了你我内心愿意放下从前的自己，对待你的态度和别人的就是不一样，这也不是我特意去做的，只是我内心的一种选择。</p>\n"},{"title":"性能测试与调优","date":"2017-02-05T01:37:46.000Z","_content":"#### 性能测试\n在日常开发中，一般被问到如何测试某个运算的速度（ 执行时间） ， 绝大多数 JavaScript 开发人员都会从类似下面的代码开始：\n```\nvar start = (new Date()).getTime(); // 或者Date.now()\n// 进行一些操作\nvar end = (new Date()).getTime();\nconsole.log( \"Duration:\", (end - start) );\n```\n上面这段代码也是我首先能想到的，其实这种方案有很多错误，别担心，下面会介绍正确的测试方法。\n如果报告的时间是 0 ， 可能你会认为它的执行时间小于 1ms。 但是， 这并不十分精确。 有些平台的精度并没有达到 1ms， 而是以更大的递增间隔更新定时器。 比如， Windows（ 也就是 IE） 的早期版本上的精度只有 15ms， 这就意味着这个运算的运行时间至少需要这么长才不会被报告为 0 ！\n\n还有， 不管报告的时长是多少， 你能知道的唯一一点就是， 这个运算的这次特定的运行消耗了大概这么长时间。 而它是不是总是以这样的速度运行， 你基本上一无所知。你不知道引擎或系统在这个时候有没有受到什么影响， 以及其他时候这个运算会不会运行得更快。\n\n如果时长报告是 4 呢？ 你能更加确定它的运行需要大概 4ms 吗？ 不能。 它消耗的时间可能要短一些， 而且在获得 start 或end 时间戳之间也可能有其他一些延误。\n\n更麻烦的是， 你也不知道这个运算测试的环境是否过度优化了。 有可能 JavaScript 引擎找到了什么方法来优化你这个独立的测试用例， 但在更真实的程序中是无法进行这样的优化的，那么这个运算就会比测试时跑得慢。所以这样低置信度的测试几乎无力支持你的任何决策。 这个性能测试基本上是无用的。 更坏的是， 它是危险的， 因为它可能提供了错误的置信度，不仅是对你，还有那些没有深入思考带来测试结果的条件的人员。\n\n<font color=\"red\">重复</font>\n“也许， ”你现在会说， “那就用一个循环把它包起来， 这样整个测试的运行时间就会更长一些了。 ”如果重复一个运算 100 次，然后整个循环报告共消耗了 137ms， 那你就可以把它除以 100， 得到每次运算的平均用时为 1.37ms， 是这样吗？并不完全是这样。简单的数学平均值绝对不足以对你要外推到整个应用范围的性能作出判断。 迭代 100 次， 即使只有几个（ 过高或过低的） 的异常值也可以影响整个平均值， 然后在重复应用这个结论的时候， 你还会扩散这个误差， 产生更大的欺骗性。\n\n<font color=\"red\">Benchmark.js</font>\n任何有意义且可靠的性能测试都应该基于统计学上合理的实践。在这里介绍一个统计学上有效的性能测试工具，名为Benchmark.js. 官网地址：http://benchmarkjs.com/\nBenchmark.js当然可以用在浏览器中测试 JavaScript ， 它也可以在非浏览器环境中运行（ Node.js等）。\n为了简单展示一下， 下面介绍应该如何使用 Benchmark.js来运行一个快速的性能测试：\n```\nfunction foo() {\n// 要测试的运算\n} v\nar bench = new Benchmark(\n\"foo test\", // 测试名称\nfoo, // 要测试的函数（也即内容）\n{\n// .. // 可选的额外选项（参见文档）\n}\n);\nbench.hz; // 每秒运算数\nbench.stats.moe; // 出错边界\nbench.stats.variance; // 样本方差\n```\n在上面的代码片段中， 其实忽略了“额外选项”`{ .. }` 对象。 这里有两个选项是我们应该知道的： setup 和 teardown 。这两个选项使你可以定义在每个测试之前和之后调用的函数。\n提示：一定要理解， setup 和 teardown 代码不会在每个测试迭代都运行。 最好的理解方法是， 想像有一个外层循环（一轮一轮循环） 还有一个内层循环（一个测试一个测试循环） 。 setup 和 teardown 在每次外层循环（轮） 的开始和结束处运行， 而不是在内层循环中。关于 Benchmark.js的使用还有很多要学的，可以自行谷歌或者度娘。\n\n#### jsPerf.com\n尽管在所有的 JavaScript 运行环境下， Benchmark.js 都可用于测试代码的性能， 但有一点一定要强调， 如果你想要得到可靠的测试结论的话， 就需要在很多不同的环境（ 桌面浏览器、 移动设备， 等等） 中测试汇集测试结果。\n\n比如， 针对同样的测试高端桌面机器的性能很可能和智能手机上 Chrome 移动设备完全不同。 而电量充足的智能手机上的结果可能也和同一个智能手机但电量只有 2% 时完全不同，因为这时候设备将会开始关闭无线模块和处理器。如果想要在不止一个环境下得出像“X 比 Y 快”这样的有意义的结论成立， 那你需要在尽可能多的真实环境下进行实际测试。 仅仅因为在 Chrome 上某个 X 运算比 Y 快并不意味着这在所有的浏览器中都成立。 当然你可能还想要交叉引用多个浏览器上的测试运行结果， 并有用户的图形展示。\n\n有一个很棒的网站正是因这样的需求而诞生的， 名为 jsPerf（http://jsperf.com） 。 它使用前面介绍的 Benchmark.js 库来运行统计上精确可靠的测试， 并把测试结果放在一个公开可得的 URL上， 你可以把这个 URL转发给别人。每次测试运行的时候， 测试结果就会被收集并持久化， 累积的测试结果会被图形化， 并展示到一个页面上以供查看。更多学习请参照官网。\n\n#### 尾调用优化\nES6 包含了一个性能领域的特殊要求。 这与一个涉及函数调用的特定优化形式相关： 尾调用优化 （ TailCall Optimization， TCO） 。\n简单地说， 尾调用就是一个出现在另一个函数“结尾”处的函数调用。 这个调用结束后就没有其余事情要做了（ 除了可能要返回结果值） 。\n以下是一个非递归的尾调用的例子：\n```\nfunction foo(x) {\nreturn x;\n} f\nunction bar(y) {\nreturn foo( y + 1 ); // 尾调用\n}function baz() {\nreturn 1 + bar( 40 ); // 非尾调用\n} b\naz(); // 42\n```\nfoo(y+1) 是 bar(..) 中的尾调用， 因为在 foo(..) 完成后， bar(..) 也完成了， 并且只需要返回 foo(..) 调用的结果。 然而， bar(40) 不是尾调用， 因为在它完成后， 它的结果需要加上 1 才能由 baz() 返回。\n调用一个新的函数需要额外的一块预留内存来管理调用栈， 称为栈帧 。 所以前面的代码一般会同时需要为每个 baz() 、 bar(..) 和 foo(..) 保留一个栈帧。\n然而， 如果支持 TCO 的引擎能够意识到 foo(y+1) 调用位于尾部 ， 这意味着 bar(..) 基本上已经完成了， 那么在调用foo(..) 时， 它就不需要创建一个新的栈帧， 而是可以重用已有的 bar(..) 的栈帧。 这样不仅速度更快， 也更节省内存。\nES6 确保了 JavaScript 开发者从现在开始可以在所有符合 ES6+ 的浏览器中依赖这个优化。 这对 JavaScript 性能来说是一个胜利。\n\n#### 总结\n对一段代码进行有效的性能测试， 特别是与同样代码的另外一个选择对比来看看哪种方案更快， 需要认真注意细节。与其打造你自己的统计有效的性能测试逻辑， 不如直接使用 Benchmark.js 库， 它已经为你实现了这些。 但是， 编写测试要小心， 因为我们很容易就会构造一个看似有效实际却有缺陷的测试， 即使是微小的差异也可能扭曲结果， 使其完全不可靠。\n\n从尽可能多的环境中得到尽可能多的测试结果以消除硬件 / 设备的偏差， 这一点很重要。 jsPerf.com是很好的网站， 用于众包性能测试运行。\n\n尾调用优化是 ES6 要求的一种优化方法。 它使 JavaScript 中原本不可能的一些递归模式变得实际。 TCO 允许一个函数在结尾处调用另外一个函数来执行， 不需要任何额外资源。 这意味着， 对递归算法来说， 引擎不再需要限制栈深度。","source":"_posts/performancetest.md","raw":"---\ntitle: 性能测试与调优\ndate: 2017-02-05 09:37:46\ntags: js 性能调试\n---\n#### 性能测试\n在日常开发中，一般被问到如何测试某个运算的速度（ 执行时间） ， 绝大多数 JavaScript 开发人员都会从类似下面的代码开始：\n```\nvar start = (new Date()).getTime(); // 或者Date.now()\n// 进行一些操作\nvar end = (new Date()).getTime();\nconsole.log( \"Duration:\", (end - start) );\n```\n上面这段代码也是我首先能想到的，其实这种方案有很多错误，别担心，下面会介绍正确的测试方法。\n如果报告的时间是 0 ， 可能你会认为它的执行时间小于 1ms。 但是， 这并不十分精确。 有些平台的精度并没有达到 1ms， 而是以更大的递增间隔更新定时器。 比如， Windows（ 也就是 IE） 的早期版本上的精度只有 15ms， 这就意味着这个运算的运行时间至少需要这么长才不会被报告为 0 ！\n\n还有， 不管报告的时长是多少， 你能知道的唯一一点就是， 这个运算的这次特定的运行消耗了大概这么长时间。 而它是不是总是以这样的速度运行， 你基本上一无所知。你不知道引擎或系统在这个时候有没有受到什么影响， 以及其他时候这个运算会不会运行得更快。\n\n如果时长报告是 4 呢？ 你能更加确定它的运行需要大概 4ms 吗？ 不能。 它消耗的时间可能要短一些， 而且在获得 start 或end 时间戳之间也可能有其他一些延误。\n\n更麻烦的是， 你也不知道这个运算测试的环境是否过度优化了。 有可能 JavaScript 引擎找到了什么方法来优化你这个独立的测试用例， 但在更真实的程序中是无法进行这样的优化的，那么这个运算就会比测试时跑得慢。所以这样低置信度的测试几乎无力支持你的任何决策。 这个性能测试基本上是无用的。 更坏的是， 它是危险的， 因为它可能提供了错误的置信度，不仅是对你，还有那些没有深入思考带来测试结果的条件的人员。\n\n<font color=\"red\">重复</font>\n“也许， ”你现在会说， “那就用一个循环把它包起来， 这样整个测试的运行时间就会更长一些了。 ”如果重复一个运算 100 次，然后整个循环报告共消耗了 137ms， 那你就可以把它除以 100， 得到每次运算的平均用时为 1.37ms， 是这样吗？并不完全是这样。简单的数学平均值绝对不足以对你要外推到整个应用范围的性能作出判断。 迭代 100 次， 即使只有几个（ 过高或过低的） 的异常值也可以影响整个平均值， 然后在重复应用这个结论的时候， 你还会扩散这个误差， 产生更大的欺骗性。\n\n<font color=\"red\">Benchmark.js</font>\n任何有意义且可靠的性能测试都应该基于统计学上合理的实践。在这里介绍一个统计学上有效的性能测试工具，名为Benchmark.js. 官网地址：http://benchmarkjs.com/\nBenchmark.js当然可以用在浏览器中测试 JavaScript ， 它也可以在非浏览器环境中运行（ Node.js等）。\n为了简单展示一下， 下面介绍应该如何使用 Benchmark.js来运行一个快速的性能测试：\n```\nfunction foo() {\n// 要测试的运算\n} v\nar bench = new Benchmark(\n\"foo test\", // 测试名称\nfoo, // 要测试的函数（也即内容）\n{\n// .. // 可选的额外选项（参见文档）\n}\n);\nbench.hz; // 每秒运算数\nbench.stats.moe; // 出错边界\nbench.stats.variance; // 样本方差\n```\n在上面的代码片段中， 其实忽略了“额外选项”`{ .. }` 对象。 这里有两个选项是我们应该知道的： setup 和 teardown 。这两个选项使你可以定义在每个测试之前和之后调用的函数。\n提示：一定要理解， setup 和 teardown 代码不会在每个测试迭代都运行。 最好的理解方法是， 想像有一个外层循环（一轮一轮循环） 还有一个内层循环（一个测试一个测试循环） 。 setup 和 teardown 在每次外层循环（轮） 的开始和结束处运行， 而不是在内层循环中。关于 Benchmark.js的使用还有很多要学的，可以自行谷歌或者度娘。\n\n#### jsPerf.com\n尽管在所有的 JavaScript 运行环境下， Benchmark.js 都可用于测试代码的性能， 但有一点一定要强调， 如果你想要得到可靠的测试结论的话， 就需要在很多不同的环境（ 桌面浏览器、 移动设备， 等等） 中测试汇集测试结果。\n\n比如， 针对同样的测试高端桌面机器的性能很可能和智能手机上 Chrome 移动设备完全不同。 而电量充足的智能手机上的结果可能也和同一个智能手机但电量只有 2% 时完全不同，因为这时候设备将会开始关闭无线模块和处理器。如果想要在不止一个环境下得出像“X 比 Y 快”这样的有意义的结论成立， 那你需要在尽可能多的真实环境下进行实际测试。 仅仅因为在 Chrome 上某个 X 运算比 Y 快并不意味着这在所有的浏览器中都成立。 当然你可能还想要交叉引用多个浏览器上的测试运行结果， 并有用户的图形展示。\n\n有一个很棒的网站正是因这样的需求而诞生的， 名为 jsPerf（http://jsperf.com） 。 它使用前面介绍的 Benchmark.js 库来运行统计上精确可靠的测试， 并把测试结果放在一个公开可得的 URL上， 你可以把这个 URL转发给别人。每次测试运行的时候， 测试结果就会被收集并持久化， 累积的测试结果会被图形化， 并展示到一个页面上以供查看。更多学习请参照官网。\n\n#### 尾调用优化\nES6 包含了一个性能领域的特殊要求。 这与一个涉及函数调用的特定优化形式相关： 尾调用优化 （ TailCall Optimization， TCO） 。\n简单地说， 尾调用就是一个出现在另一个函数“结尾”处的函数调用。 这个调用结束后就没有其余事情要做了（ 除了可能要返回结果值） 。\n以下是一个非递归的尾调用的例子：\n```\nfunction foo(x) {\nreturn x;\n} f\nunction bar(y) {\nreturn foo( y + 1 ); // 尾调用\n}function baz() {\nreturn 1 + bar( 40 ); // 非尾调用\n} b\naz(); // 42\n```\nfoo(y+1) 是 bar(..) 中的尾调用， 因为在 foo(..) 完成后， bar(..) 也完成了， 并且只需要返回 foo(..) 调用的结果。 然而， bar(40) 不是尾调用， 因为在它完成后， 它的结果需要加上 1 才能由 baz() 返回。\n调用一个新的函数需要额外的一块预留内存来管理调用栈， 称为栈帧 。 所以前面的代码一般会同时需要为每个 baz() 、 bar(..) 和 foo(..) 保留一个栈帧。\n然而， 如果支持 TCO 的引擎能够意识到 foo(y+1) 调用位于尾部 ， 这意味着 bar(..) 基本上已经完成了， 那么在调用foo(..) 时， 它就不需要创建一个新的栈帧， 而是可以重用已有的 bar(..) 的栈帧。 这样不仅速度更快， 也更节省内存。\nES6 确保了 JavaScript 开发者从现在开始可以在所有符合 ES6+ 的浏览器中依赖这个优化。 这对 JavaScript 性能来说是一个胜利。\n\n#### 总结\n对一段代码进行有效的性能测试， 特别是与同样代码的另外一个选择对比来看看哪种方案更快， 需要认真注意细节。与其打造你自己的统计有效的性能测试逻辑， 不如直接使用 Benchmark.js 库， 它已经为你实现了这些。 但是， 编写测试要小心， 因为我们很容易就会构造一个看似有效实际却有缺陷的测试， 即使是微小的差异也可能扭曲结果， 使其完全不可靠。\n\n从尽可能多的环境中得到尽可能多的测试结果以消除硬件 / 设备的偏差， 这一点很重要。 jsPerf.com是很好的网站， 用于众包性能测试运行。\n\n尾调用优化是 ES6 要求的一种优化方法。 它使 JavaScript 中原本不可能的一些递归模式变得实际。 TCO 允许一个函数在结尾处调用另外一个函数来执行， 不需要任何额外资源。 这意味着， 对递归算法来说， 引擎不再需要限制栈深度。","slug":"performancetest","published":1,"updated":"2017-02-10T02:28:10.011Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizpcu9s10005fctudxo629hl","content":"<h4 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h4><p>在日常开发中，一般被问到如何测试某个运算的速度（ 执行时间） ， 绝大多数 JavaScript 开发人员都会从类似下面的代码开始：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var start = (new Date()).getTime(); // 或者Date.now()</div><div class=\"line\">// 进行一些操作</div><div class=\"line\">var end = (new Date()).getTime();</div><div class=\"line\">console.log( &quot;Duration:&quot;, (end - start) );</div></pre></td></tr></table></figure></p>\n<p>上面这段代码也是我首先能想到的，其实这种方案有很多错误，别担心，下面会介绍正确的测试方法。<br>如果报告的时间是 0 ， 可能你会认为它的执行时间小于 1ms。 但是， 这并不十分精确。 有些平台的精度并没有达到 1ms， 而是以更大的递增间隔更新定时器。 比如， Windows（ 也就是 IE） 的早期版本上的精度只有 15ms， 这就意味着这个运算的运行时间至少需要这么长才不会被报告为 0 ！</p>\n<p>还有， 不管报告的时长是多少， 你能知道的唯一一点就是， 这个运算的这次特定的运行消耗了大概这么长时间。 而它是不是总是以这样的速度运行， 你基本上一无所知。你不知道引擎或系统在这个时候有没有受到什么影响， 以及其他时候这个运算会不会运行得更快。</p>\n<p>如果时长报告是 4 呢？ 你能更加确定它的运行需要大概 4ms 吗？ 不能。 它消耗的时间可能要短一些， 而且在获得 start 或end 时间戳之间也可能有其他一些延误。</p>\n<p>更麻烦的是， 你也不知道这个运算测试的环境是否过度优化了。 有可能 JavaScript 引擎找到了什么方法来优化你这个独立的测试用例， 但在更真实的程序中是无法进行这样的优化的，那么这个运算就会比测试时跑得慢。所以这样低置信度的测试几乎无力支持你的任何决策。 这个性能测试基本上是无用的。 更坏的是， 它是危险的， 因为它可能提供了错误的置信度，不仅是对你，还有那些没有深入思考带来测试结果的条件的人员。</p>\n<p><font color=\"red\">重复</font><br>“也许， ”你现在会说， “那就用一个循环把它包起来， 这样整个测试的运行时间就会更长一些了。 ”如果重复一个运算 100 次，然后整个循环报告共消耗了 137ms， 那你就可以把它除以 100， 得到每次运算的平均用时为 1.37ms， 是这样吗？并不完全是这样。简单的数学平均值绝对不足以对你要外推到整个应用范围的性能作出判断。 迭代 100 次， 即使只有几个（ 过高或过低的） 的异常值也可以影响整个平均值， 然后在重复应用这个结论的时候， 你还会扩散这个误差， 产生更大的欺骗性。</p>\n<p><font color=\"red\">Benchmark.js</font><br>任何有意义且可靠的性能测试都应该基于统计学上合理的实践。在这里介绍一个统计学上有效的性能测试工具，名为Benchmark.js. 官网地址：<a href=\"http://benchmarkjs.com/\" target=\"_blank\" rel=\"external\">http://benchmarkjs.com/</a><br>Benchmark.js当然可以用在浏览器中测试 JavaScript ， 它也可以在非浏览器环境中运行（ Node.js等）。<br>为了简单展示一下， 下面介绍应该如何使用 Benchmark.js来运行一个快速的性能测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">// 要测试的运算</div><div class=\"line\">&#125; v</div><div class=\"line\">ar bench = new Benchmark(</div><div class=\"line\">&quot;foo test&quot;, // 测试名称</div><div class=\"line\">foo, // 要测试的函数（也即内容）</div><div class=\"line\">&#123;</div><div class=\"line\">// .. // 可选的额外选项（参见文档）</div><div class=\"line\">&#125;</div><div class=\"line\">);</div><div class=\"line\">bench.hz; // 每秒运算数</div><div class=\"line\">bench.stats.moe; // 出错边界</div><div class=\"line\">bench.stats.variance; // 样本方差</div></pre></td></tr></table></figure></p>\n<p>在上面的代码片段中， 其实忽略了“额外选项”<code>{ .. }</code> 对象。 这里有两个选项是我们应该知道的： setup 和 teardown 。这两个选项使你可以定义在每个测试之前和之后调用的函数。<br>提示：一定要理解， setup 和 teardown 代码不会在每个测试迭代都运行。 最好的理解方法是， 想像有一个外层循环（一轮一轮循环） 还有一个内层循环（一个测试一个测试循环） 。 setup 和 teardown 在每次外层循环（轮） 的开始和结束处运行， 而不是在内层循环中。关于 Benchmark.js的使用还有很多要学的，可以自行谷歌或者度娘。</p>\n<h4 id=\"jsPerf-com\"><a href=\"#jsPerf-com\" class=\"headerlink\" title=\"jsPerf.com\"></a>jsPerf.com</h4><p>尽管在所有的 JavaScript 运行环境下， Benchmark.js 都可用于测试代码的性能， 但有一点一定要强调， 如果你想要得到可靠的测试结论的话， 就需要在很多不同的环境（ 桌面浏览器、 移动设备， 等等） 中测试汇集测试结果。</p>\n<p>比如， 针对同样的测试高端桌面机器的性能很可能和智能手机上 Chrome 移动设备完全不同。 而电量充足的智能手机上的结果可能也和同一个智能手机但电量只有 2% 时完全不同，因为这时候设备将会开始关闭无线模块和处理器。如果想要在不止一个环境下得出像“X 比 Y 快”这样的有意义的结论成立， 那你需要在尽可能多的真实环境下进行实际测试。 仅仅因为在 Chrome 上某个 X 运算比 Y 快并不意味着这在所有的浏览器中都成立。 当然你可能还想要交叉引用多个浏览器上的测试运行结果， 并有用户的图形展示。</p>\n<p>有一个很棒的网站正是因这样的需求而诞生的， 名为 jsPerf（<a href=\"http://jsperf.com）\" target=\"_blank\" rel=\"external\">http://jsperf.com）</a> 。 它使用前面介绍的 Benchmark.js 库来运行统计上精确可靠的测试， 并把测试结果放在一个公开可得的 URL上， 你可以把这个 URL转发给别人。每次测试运行的时候， 测试结果就会被收集并持久化， 累积的测试结果会被图形化， 并展示到一个页面上以供查看。更多学习请参照官网。</p>\n<h4 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h4><p>ES6 包含了一个性能领域的特殊要求。 这与一个涉及函数调用的特定优化形式相关： 尾调用优化 （ TailCall Optimization， TCO） 。<br>简单地说， 尾调用就是一个出现在另一个函数“结尾”处的函数调用。 这个调用结束后就没有其余事情要做了（ 除了可能要返回结果值） 。<br>以下是一个非递归的尾调用的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo(x) &#123;</div><div class=\"line\">return x;</div><div class=\"line\">&#125; f</div><div class=\"line\">unction bar(y) &#123;</div><div class=\"line\">return foo( y + 1 ); // 尾调用</div><div class=\"line\">&#125;function baz() &#123;</div><div class=\"line\">return 1 + bar( 40 ); // 非尾调用</div><div class=\"line\">&#125; b</div><div class=\"line\">az(); // 42</div></pre></td></tr></table></figure></p>\n<p>foo(y+1) 是 bar(..) 中的尾调用， 因为在 foo(..) 完成后， bar(..) 也完成了， 并且只需要返回 foo(..) 调用的结果。 然而， bar(40) 不是尾调用， 因为在它完成后， 它的结果需要加上 1 才能由 baz() 返回。<br>调用一个新的函数需要额外的一块预留内存来管理调用栈， 称为栈帧 。 所以前面的代码一般会同时需要为每个 baz() 、 bar(..) 和 foo(..) 保留一个栈帧。<br>然而， 如果支持 TCO 的引擎能够意识到 foo(y+1) 调用位于尾部 ， 这意味着 bar(..) 基本上已经完成了， 那么在调用foo(..) 时， 它就不需要创建一个新的栈帧， 而是可以重用已有的 bar(..) 的栈帧。 这样不仅速度更快， 也更节省内存。<br>ES6 确保了 JavaScript 开发者从现在开始可以在所有符合 ES6+ 的浏览器中依赖这个优化。 这对 JavaScript 性能来说是一个胜利。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>对一段代码进行有效的性能测试， 特别是与同样代码的另外一个选择对比来看看哪种方案更快， 需要认真注意细节。与其打造你自己的统计有效的性能测试逻辑， 不如直接使用 Benchmark.js 库， 它已经为你实现了这些。 但是， 编写测试要小心， 因为我们很容易就会构造一个看似有效实际却有缺陷的测试， 即使是微小的差异也可能扭曲结果， 使其完全不可靠。</p>\n<p>从尽可能多的环境中得到尽可能多的测试结果以消除硬件 / 设备的偏差， 这一点很重要。 jsPerf.com是很好的网站， 用于众包性能测试运行。</p>\n<p>尾调用优化是 ES6 要求的一种优化方法。 它使 JavaScript 中原本不可能的一些递归模式变得实际。 TCO 允许一个函数在结尾处调用另外一个函数来执行， 不需要任何额外资源。 这意味着， 对递归算法来说， 引擎不再需要限制栈深度。</p>\n","excerpt":"","more":"<h4 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h4><p>在日常开发中，一般被问到如何测试某个运算的速度（ 执行时间） ， 绝大多数 JavaScript 开发人员都会从类似下面的代码开始：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var start = (new Date()).getTime(); // 或者Date.now()</div><div class=\"line\">// 进行一些操作</div><div class=\"line\">var end = (new Date()).getTime();</div><div class=\"line\">console.log( &quot;Duration:&quot;, (end - start) );</div></pre></td></tr></table></figure></p>\n<p>上面这段代码也是我首先能想到的，其实这种方案有很多错误，别担心，下面会介绍正确的测试方法。<br>如果报告的时间是 0 ， 可能你会认为它的执行时间小于 1ms。 但是， 这并不十分精确。 有些平台的精度并没有达到 1ms， 而是以更大的递增间隔更新定时器。 比如， Windows（ 也就是 IE） 的早期版本上的精度只有 15ms， 这就意味着这个运算的运行时间至少需要这么长才不会被报告为 0 ！</p>\n<p>还有， 不管报告的时长是多少， 你能知道的唯一一点就是， 这个运算的这次特定的运行消耗了大概这么长时间。 而它是不是总是以这样的速度运行， 你基本上一无所知。你不知道引擎或系统在这个时候有没有受到什么影响， 以及其他时候这个运算会不会运行得更快。</p>\n<p>如果时长报告是 4 呢？ 你能更加确定它的运行需要大概 4ms 吗？ 不能。 它消耗的时间可能要短一些， 而且在获得 start 或end 时间戳之间也可能有其他一些延误。</p>\n<p>更麻烦的是， 你也不知道这个运算测试的环境是否过度优化了。 有可能 JavaScript 引擎找到了什么方法来优化你这个独立的测试用例， 但在更真实的程序中是无法进行这样的优化的，那么这个运算就会比测试时跑得慢。所以这样低置信度的测试几乎无力支持你的任何决策。 这个性能测试基本上是无用的。 更坏的是， 它是危险的， 因为它可能提供了错误的置信度，不仅是对你，还有那些没有深入思考带来测试结果的条件的人员。</p>\n<p><font color=\"red\">重复</font><br>“也许， ”你现在会说， “那就用一个循环把它包起来， 这样整个测试的运行时间就会更长一些了。 ”如果重复一个运算 100 次，然后整个循环报告共消耗了 137ms， 那你就可以把它除以 100， 得到每次运算的平均用时为 1.37ms， 是这样吗？并不完全是这样。简单的数学平均值绝对不足以对你要外推到整个应用范围的性能作出判断。 迭代 100 次， 即使只有几个（ 过高或过低的） 的异常值也可以影响整个平均值， 然后在重复应用这个结论的时候， 你还会扩散这个误差， 产生更大的欺骗性。</p>\n<p><font color=\"red\">Benchmark.js</font><br>任何有意义且可靠的性能测试都应该基于统计学上合理的实践。在这里介绍一个统计学上有效的性能测试工具，名为Benchmark.js. 官网地址：<a href=\"http://benchmarkjs.com/\">http://benchmarkjs.com/</a><br>Benchmark.js当然可以用在浏览器中测试 JavaScript ， 它也可以在非浏览器环境中运行（ Node.js等）。<br>为了简单展示一下， 下面介绍应该如何使用 Benchmark.js来运行一个快速的性能测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">// 要测试的运算</div><div class=\"line\">&#125; v</div><div class=\"line\">ar bench = new Benchmark(</div><div class=\"line\">&quot;foo test&quot;, // 测试名称</div><div class=\"line\">foo, // 要测试的函数（也即内容）</div><div class=\"line\">&#123;</div><div class=\"line\">// .. // 可选的额外选项（参见文档）</div><div class=\"line\">&#125;</div><div class=\"line\">);</div><div class=\"line\">bench.hz; // 每秒运算数</div><div class=\"line\">bench.stats.moe; // 出错边界</div><div class=\"line\">bench.stats.variance; // 样本方差</div></pre></td></tr></table></figure></p>\n<p>在上面的代码片段中， 其实忽略了“额外选项”<code>{ .. }</code> 对象。 这里有两个选项是我们应该知道的： setup 和 teardown 。这两个选项使你可以定义在每个测试之前和之后调用的函数。<br>提示：一定要理解， setup 和 teardown 代码不会在每个测试迭代都运行。 最好的理解方法是， 想像有一个外层循环（一轮一轮循环） 还有一个内层循环（一个测试一个测试循环） 。 setup 和 teardown 在每次外层循环（轮） 的开始和结束处运行， 而不是在内层循环中。关于 Benchmark.js的使用还有很多要学的，可以自行谷歌或者度娘。</p>\n<h4 id=\"jsPerf-com\"><a href=\"#jsPerf-com\" class=\"headerlink\" title=\"jsPerf.com\"></a>jsPerf.com</h4><p>尽管在所有的 JavaScript 运行环境下， Benchmark.js 都可用于测试代码的性能， 但有一点一定要强调， 如果你想要得到可靠的测试结论的话， 就需要在很多不同的环境（ 桌面浏览器、 移动设备， 等等） 中测试汇集测试结果。</p>\n<p>比如， 针对同样的测试高端桌面机器的性能很可能和智能手机上 Chrome 移动设备完全不同。 而电量充足的智能手机上的结果可能也和同一个智能手机但电量只有 2% 时完全不同，因为这时候设备将会开始关闭无线模块和处理器。如果想要在不止一个环境下得出像“X 比 Y 快”这样的有意义的结论成立， 那你需要在尽可能多的真实环境下进行实际测试。 仅仅因为在 Chrome 上某个 X 运算比 Y 快并不意味着这在所有的浏览器中都成立。 当然你可能还想要交叉引用多个浏览器上的测试运行结果， 并有用户的图形展示。</p>\n<p>有一个很棒的网站正是因这样的需求而诞生的， 名为 jsPerf（<a href=\"http://jsperf.com）\">http://jsperf.com）</a> 。 它使用前面介绍的 Benchmark.js 库来运行统计上精确可靠的测试， 并把测试结果放在一个公开可得的 URL上， 你可以把这个 URL转发给别人。每次测试运行的时候， 测试结果就会被收集并持久化， 累积的测试结果会被图形化， 并展示到一个页面上以供查看。更多学习请参照官网。</p>\n<h4 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h4><p>ES6 包含了一个性能领域的特殊要求。 这与一个涉及函数调用的特定优化形式相关： 尾调用优化 （ TailCall Optimization， TCO） 。<br>简单地说， 尾调用就是一个出现在另一个函数“结尾”处的函数调用。 这个调用结束后就没有其余事情要做了（ 除了可能要返回结果值） 。<br>以下是一个非递归的尾调用的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo(x) &#123;</div><div class=\"line\">return x;</div><div class=\"line\">&#125; f</div><div class=\"line\">unction bar(y) &#123;</div><div class=\"line\">return foo( y + 1 ); // 尾调用</div><div class=\"line\">&#125;function baz() &#123;</div><div class=\"line\">return 1 + bar( 40 ); // 非尾调用</div><div class=\"line\">&#125; b</div><div class=\"line\">az(); // 42</div></pre></td></tr></table></figure></p>\n<p>foo(y+1) 是 bar(..) 中的尾调用， 因为在 foo(..) 完成后， bar(..) 也完成了， 并且只需要返回 foo(..) 调用的结果。 然而， bar(40) 不是尾调用， 因为在它完成后， 它的结果需要加上 1 才能由 baz() 返回。<br>调用一个新的函数需要额外的一块预留内存来管理调用栈， 称为栈帧 。 所以前面的代码一般会同时需要为每个 baz() 、 bar(..) 和 foo(..) 保留一个栈帧。<br>然而， 如果支持 TCO 的引擎能够意识到 foo(y+1) 调用位于尾部 ， 这意味着 bar(..) 基本上已经完成了， 那么在调用foo(..) 时， 它就不需要创建一个新的栈帧， 而是可以重用已有的 bar(..) 的栈帧。 这样不仅速度更快， 也更节省内存。<br>ES6 确保了 JavaScript 开发者从现在开始可以在所有符合 ES6+ 的浏览器中依赖这个优化。 这对 JavaScript 性能来说是一个胜利。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>对一段代码进行有效的性能测试， 特别是与同样代码的另外一个选择对比来看看哪种方案更快， 需要认真注意细节。与其打造你自己的统计有效的性能测试逻辑， 不如直接使用 Benchmark.js 库， 它已经为你实现了这些。 但是， 编写测试要小心， 因为我们很容易就会构造一个看似有效实际却有缺陷的测试， 即使是微小的差异也可能扭曲结果， 使其完全不可靠。</p>\n<p>从尽可能多的环境中得到尽可能多的测试结果以消除硬件 / 设备的偏差， 这一点很重要。 jsPerf.com是很好的网站， 用于众包性能测试运行。</p>\n<p>尾调用优化是 ES6 要求的一种优化方法。 它使 JavaScript 中原本不可能的一些递归模式变得实际。 TCO 允许一个函数在结尾处调用另外一个函数来执行， 不需要任何额外资源。 这意味着， 对递归算法来说， 引擎不再需要限制栈深度。</p>\n"},{"title":"人格面具","date":"2017-02-19T09:32:10.000Z","_content":"#### 前言\n村上春树在《海边的卡夫卡》里这样写道：“我相信所谓的命运不过是一个人的生理、心理、情感、性格等等因素所造成的一个人行动的最终结果。我也始终相信这些因素都是可以人为改变的。”\n\n就像我们总是抱怨越长大越发现知人知面不知心，可当我们握着无数个面具在不同情境下快速扮演一个适宜的角色，把真实的自己隐藏在重重厚茧之下时，又有几点真实？\n\n我们对生活展现的态度，也就是生活在我们身上映射的样子。\n\n#### 人格面具\n之前又被吐槽高冷，已经习以为常，我曾经也琢磨过，我哪里高冷了？要不要改变一下显得更有亲和力？试图“矫正”过，不过最别扭的是自己，我是一个十分看重边界的人，确实没办法在不了解彼此的情况下“自来熟”般地表现热络和亲昵，索性作罢。\n \n有人愿意给我贴上“高冷”标签，或者因此疏远，我也并不觉得可惜。别人对你有什么样的印象，并不都是准确的，而每个人看到的也未必都是一个人本来的样子。\n \n这层表象，就是所谓的“人格面具”。我们并不总是时刻表现出真实的自我，有时囿于环境差异，有时囿于对象的不同。我们需要这层面具的保护，它带给我们游刃有余的安全感，让我们在不同情境下能更快适应和融入，并且感到舒服。\n\n我们每个人都是这样，人前人后判若两人，把不适合展现于人前的东西妥善收好，在某个独自面对自己的时刻才肯摘掉面具，才肯让个性中被压抑的部分舒展和释放。\n\n#### 你看到的未必就是真实，你以为的也不过就是你以为而已。\n\n而一旦人格面具戴久了，或许自己都不太习惯看见自己最真实的一面，我们越来越适应外部世界的各种情境。我们在人前越来越游刃有余地表演别人需要的样子，有时甚至把这层表象误以为是真正的自己，这是一种无奈。\n \n更何况，人格面具从来不止一个。面对同事、家人、朋友、爱人、陌生人、敌人，面对工作、聚会、约会、谈判、交涉，每一个不同的人，每一个不同的场景，我们的内心都有一种预设，该表现怎么样的自我，该说怎样的话，都有它该匹配的剧本。就像不同场合适合不同着装一样，我们挑选着适合的衣服，也挑选着适合的人格面具，这是“社会化”的过程必不可少的一步。\n\n人心是比宇宙还浩瀚的地方，而人的复杂性远超任何科学，它没有公式可以计算，也没有精确的工具可以测量。我们都是在一寸一寸地体验自己人格中的维度，比喻成盲人摸象也不为过，个性就是有很多面，它是立体的、富有弹性的、充满奥秘的。\n\n#### 推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。\n\n我经历过怒目相视的时刻，但想到这双眼或许对别人温柔如水过，刚要燃起的愤怒也就悄悄熄灭了；我也担心过疲惫困顿的身影，但我相信这只是一个停顿，总有些力量会支撑他走下去，所以会用鼓励替代心疼；而那些看似放荡不羁的灵魂，也总会有珍视和在意的人和事，便不再羡慕他那表面的轻松和无谓了。\n \n我们体验到的只是对方转眼消失的一瞬，而对面的那个人却经历了无数个人生厚重的瞬间；我们看到的只是一个人的一面，而这个人其实跟自己一样，也不过是在诸多人格维度中展现了其中之一罢了。\n \n人们总是习惯在不了解对方的时候，就用一些标签和自以为是的评价为对方打上一个烙印，还往往以为这就是确定的真实。用这种似是而非的“确定性”否定了所有的可能性，或许才是人与人相处的最大障碍。\n \n有时候，不是命运缺少安排，也不是缘分太浅，只是你没有给别人时间和空间展示更丰富真实的自己，才同样让自己也错失了机会。又或者我们习惯了面具的存在，也快忘记了在别人靠近的时候，松动和敞开自己的内心，给他一个走进自己生活的机会。\n \n原来，每个人都不是你看到的那个样子，原来，每个人都需要一个真正认识彼此的机会。——注：文章参考于网络，仅供个人学习\n\n最后送大家一句话：真正支撑一个人活下去的不是安逸，而是对生活的不甘。我要经历一切，哪怕不完美！！！\n\n","source":"_posts/rengemianju.md","raw":"---\ntitle: 人格面具\ndate: 2017-02-19 17:32:10\ntags: 生活\n---\n#### 前言\n村上春树在《海边的卡夫卡》里这样写道：“我相信所谓的命运不过是一个人的生理、心理、情感、性格等等因素所造成的一个人行动的最终结果。我也始终相信这些因素都是可以人为改变的。”\n\n就像我们总是抱怨越长大越发现知人知面不知心，可当我们握着无数个面具在不同情境下快速扮演一个适宜的角色，把真实的自己隐藏在重重厚茧之下时，又有几点真实？\n\n我们对生活展现的态度，也就是生活在我们身上映射的样子。\n\n#### 人格面具\n之前又被吐槽高冷，已经习以为常，我曾经也琢磨过，我哪里高冷了？要不要改变一下显得更有亲和力？试图“矫正”过，不过最别扭的是自己，我是一个十分看重边界的人，确实没办法在不了解彼此的情况下“自来熟”般地表现热络和亲昵，索性作罢。\n \n有人愿意给我贴上“高冷”标签，或者因此疏远，我也并不觉得可惜。别人对你有什么样的印象，并不都是准确的，而每个人看到的也未必都是一个人本来的样子。\n \n这层表象，就是所谓的“人格面具”。我们并不总是时刻表现出真实的自我，有时囿于环境差异，有时囿于对象的不同。我们需要这层面具的保护，它带给我们游刃有余的安全感，让我们在不同情境下能更快适应和融入，并且感到舒服。\n\n我们每个人都是这样，人前人后判若两人，把不适合展现于人前的东西妥善收好，在某个独自面对自己的时刻才肯摘掉面具，才肯让个性中被压抑的部分舒展和释放。\n\n#### 你看到的未必就是真实，你以为的也不过就是你以为而已。\n\n而一旦人格面具戴久了，或许自己都不太习惯看见自己最真实的一面，我们越来越适应外部世界的各种情境。我们在人前越来越游刃有余地表演别人需要的样子，有时甚至把这层表象误以为是真正的自己，这是一种无奈。\n \n更何况，人格面具从来不止一个。面对同事、家人、朋友、爱人、陌生人、敌人，面对工作、聚会、约会、谈判、交涉，每一个不同的人，每一个不同的场景，我们的内心都有一种预设，该表现怎么样的自我，该说怎样的话，都有它该匹配的剧本。就像不同场合适合不同着装一样，我们挑选着适合的衣服，也挑选着适合的人格面具，这是“社会化”的过程必不可少的一步。\n\n人心是比宇宙还浩瀚的地方，而人的复杂性远超任何科学，它没有公式可以计算，也没有精确的工具可以测量。我们都是在一寸一寸地体验自己人格中的维度，比喻成盲人摸象也不为过，个性就是有很多面，它是立体的、富有弹性的、充满奥秘的。\n\n#### 推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。\n\n我经历过怒目相视的时刻，但想到这双眼或许对别人温柔如水过，刚要燃起的愤怒也就悄悄熄灭了；我也担心过疲惫困顿的身影，但我相信这只是一个停顿，总有些力量会支撑他走下去，所以会用鼓励替代心疼；而那些看似放荡不羁的灵魂，也总会有珍视和在意的人和事，便不再羡慕他那表面的轻松和无谓了。\n \n我们体验到的只是对方转眼消失的一瞬，而对面的那个人却经历了无数个人生厚重的瞬间；我们看到的只是一个人的一面，而这个人其实跟自己一样，也不过是在诸多人格维度中展现了其中之一罢了。\n \n人们总是习惯在不了解对方的时候，就用一些标签和自以为是的评价为对方打上一个烙印，还往往以为这就是确定的真实。用这种似是而非的“确定性”否定了所有的可能性，或许才是人与人相处的最大障碍。\n \n有时候，不是命运缺少安排，也不是缘分太浅，只是你没有给别人时间和空间展示更丰富真实的自己，才同样让自己也错失了机会。又或者我们习惯了面具的存在，也快忘记了在别人靠近的时候，松动和敞开自己的内心，给他一个走进自己生活的机会。\n \n原来，每个人都不是你看到的那个样子，原来，每个人都需要一个真正认识彼此的机会。——注：文章参考于网络，仅供个人学习\n\n最后送大家一句话：真正支撑一个人活下去的不是安逸，而是对生活的不甘。我要经历一切，哪怕不完美！！！\n\n","slug":"rengemianju","published":1,"updated":"2017-02-28T09:48:01.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizpcu9s50008fctu9ughd0tu","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>村上春树在《海边的卡夫卡》里这样写道：“我相信所谓的命运不过是一个人的生理、心理、情感、性格等等因素所造成的一个人行动的最终结果。我也始终相信这些因素都是可以人为改变的。”</p>\n<p>就像我们总是抱怨越长大越发现知人知面不知心，可当我们握着无数个面具在不同情境下快速扮演一个适宜的角色，把真实的自己隐藏在重重厚茧之下时，又有几点真实？</p>\n<p>我们对生活展现的态度，也就是生活在我们身上映射的样子。</p>\n<h4 id=\"人格面具\"><a href=\"#人格面具\" class=\"headerlink\" title=\"人格面具\"></a>人格面具</h4><p>之前又被吐槽高冷，已经习以为常，我曾经也琢磨过，我哪里高冷了？要不要改变一下显得更有亲和力？试图“矫正”过，不过最别扭的是自己，我是一个十分看重边界的人，确实没办法在不了解彼此的情况下“自来熟”般地表现热络和亲昵，索性作罢。</p>\n<p>有人愿意给我贴上“高冷”标签，或者因此疏远，我也并不觉得可惜。别人对你有什么样的印象，并不都是准确的，而每个人看到的也未必都是一个人本来的样子。</p>\n<p>这层表象，就是所谓的“人格面具”。我们并不总是时刻表现出真实的自我，有时囿于环境差异，有时囿于对象的不同。我们需要这层面具的保护，它带给我们游刃有余的安全感，让我们在不同情境下能更快适应和融入，并且感到舒服。</p>\n<p>我们每个人都是这样，人前人后判若两人，把不适合展现于人前的东西妥善收好，在某个独自面对自己的时刻才肯摘掉面具，才肯让个性中被压抑的部分舒展和释放。</p>\n<h4 id=\"你看到的未必就是真实，你以为的也不过就是你以为而已。\"><a href=\"#你看到的未必就是真实，你以为的也不过就是你以为而已。\" class=\"headerlink\" title=\"你看到的未必就是真实，你以为的也不过就是你以为而已。\"></a>你看到的未必就是真实，你以为的也不过就是你以为而已。</h4><p>而一旦人格面具戴久了，或许自己都不太习惯看见自己最真实的一面，我们越来越适应外部世界的各种情境。我们在人前越来越游刃有余地表演别人需要的样子，有时甚至把这层表象误以为是真正的自己，这是一种无奈。</p>\n<p>更何况，人格面具从来不止一个。面对同事、家人、朋友、爱人、陌生人、敌人，面对工作、聚会、约会、谈判、交涉，每一个不同的人，每一个不同的场景，我们的内心都有一种预设，该表现怎么样的自我，该说怎样的话，都有它该匹配的剧本。就像不同场合适合不同着装一样，我们挑选着适合的衣服，也挑选着适合的人格面具，这是“社会化”的过程必不可少的一步。</p>\n<p>人心是比宇宙还浩瀚的地方，而人的复杂性远超任何科学，它没有公式可以计算，也没有精确的工具可以测量。我们都是在一寸一寸地体验自己人格中的维度，比喻成盲人摸象也不为过，个性就是有很多面，它是立体的、富有弹性的、充满奥秘的。</p>\n<h4 id=\"推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。\"><a href=\"#推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。\" class=\"headerlink\" title=\"推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。\"></a>推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。</h4><p>我经历过怒目相视的时刻，但想到这双眼或许对别人温柔如水过，刚要燃起的愤怒也就悄悄熄灭了；我也担心过疲惫困顿的身影，但我相信这只是一个停顿，总有些力量会支撑他走下去，所以会用鼓励替代心疼；而那些看似放荡不羁的灵魂，也总会有珍视和在意的人和事，便不再羡慕他那表面的轻松和无谓了。</p>\n<p>我们体验到的只是对方转眼消失的一瞬，而对面的那个人却经历了无数个人生厚重的瞬间；我们看到的只是一个人的一面，而这个人其实跟自己一样，也不过是在诸多人格维度中展现了其中之一罢了。</p>\n<p>人们总是习惯在不了解对方的时候，就用一些标签和自以为是的评价为对方打上一个烙印，还往往以为这就是确定的真实。用这种似是而非的“确定性”否定了所有的可能性，或许才是人与人相处的最大障碍。</p>\n<p>有时候，不是命运缺少安排，也不是缘分太浅，只是你没有给别人时间和空间展示更丰富真实的自己，才同样让自己也错失了机会。又或者我们习惯了面具的存在，也快忘记了在别人靠近的时候，松动和敞开自己的内心，给他一个走进自己生活的机会。</p>\n<p>原来，每个人都不是你看到的那个样子，原来，每个人都需要一个真正认识彼此的机会。——注：文章参考于网络，仅供个人学习</p>\n<p>最后送大家一句话：真正支撑一个人活下去的不是安逸，而是对生活的不甘。我要经历一切，哪怕不完美！！！</p>\n","excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>村上春树在《海边的卡夫卡》里这样写道：“我相信所谓的命运不过是一个人的生理、心理、情感、性格等等因素所造成的一个人行动的最终结果。我也始终相信这些因素都是可以人为改变的。”</p>\n<p>就像我们总是抱怨越长大越发现知人知面不知心，可当我们握着无数个面具在不同情境下快速扮演一个适宜的角色，把真实的自己隐藏在重重厚茧之下时，又有几点真实？</p>\n<p>我们对生活展现的态度，也就是生活在我们身上映射的样子。</p>\n<h4 id=\"人格面具\"><a href=\"#人格面具\" class=\"headerlink\" title=\"人格面具\"></a>人格面具</h4><p>之前又被吐槽高冷，已经习以为常，我曾经也琢磨过，我哪里高冷了？要不要改变一下显得更有亲和力？试图“矫正”过，不过最别扭的是自己，我是一个十分看重边界的人，确实没办法在不了解彼此的情况下“自来熟”般地表现热络和亲昵，索性作罢。</p>\n<p>有人愿意给我贴上“高冷”标签，或者因此疏远，我也并不觉得可惜。别人对你有什么样的印象，并不都是准确的，而每个人看到的也未必都是一个人本来的样子。</p>\n<p>这层表象，就是所谓的“人格面具”。我们并不总是时刻表现出真实的自我，有时囿于环境差异，有时囿于对象的不同。我们需要这层面具的保护，它带给我们游刃有余的安全感，让我们在不同情境下能更快适应和融入，并且感到舒服。</p>\n<p>我们每个人都是这样，人前人后判若两人，把不适合展现于人前的东西妥善收好，在某个独自面对自己的时刻才肯摘掉面具，才肯让个性中被压抑的部分舒展和释放。</p>\n<h4 id=\"你看到的未必就是真实，你以为的也不过就是你以为而已。\"><a href=\"#你看到的未必就是真实，你以为的也不过就是你以为而已。\" class=\"headerlink\" title=\"你看到的未必就是真实，你以为的也不过就是你以为而已。\"></a>你看到的未必就是真实，你以为的也不过就是你以为而已。</h4><p>而一旦人格面具戴久了，或许自己都不太习惯看见自己最真实的一面，我们越来越适应外部世界的各种情境。我们在人前越来越游刃有余地表演别人需要的样子，有时甚至把这层表象误以为是真正的自己，这是一种无奈。</p>\n<p>更何况，人格面具从来不止一个。面对同事、家人、朋友、爱人、陌生人、敌人，面对工作、聚会、约会、谈判、交涉，每一个不同的人，每一个不同的场景，我们的内心都有一种预设，该表现怎么样的自我，该说怎样的话，都有它该匹配的剧本。就像不同场合适合不同着装一样，我们挑选着适合的衣服，也挑选着适合的人格面具，这是“社会化”的过程必不可少的一步。</p>\n<p>人心是比宇宙还浩瀚的地方，而人的复杂性远超任何科学，它没有公式可以计算，也没有精确的工具可以测量。我们都是在一寸一寸地体验自己人格中的维度，比喻成盲人摸象也不为过，个性就是有很多面，它是立体的、富有弹性的、充满奥秘的。</p>\n<h4 id=\"推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。\"><a href=\"#推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。\" class=\"headerlink\" title=\"推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。\"></a>推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。</h4><p>我经历过怒目相视的时刻，但想到这双眼或许对别人温柔如水过，刚要燃起的愤怒也就悄悄熄灭了；我也担心过疲惫困顿的身影，但我相信这只是一个停顿，总有些力量会支撑他走下去，所以会用鼓励替代心疼；而那些看似放荡不羁的灵魂，也总会有珍视和在意的人和事，便不再羡慕他那表面的轻松和无谓了。</p>\n<p>我们体验到的只是对方转眼消失的一瞬，而对面的那个人却经历了无数个人生厚重的瞬间；我们看到的只是一个人的一面，而这个人其实跟自己一样，也不过是在诸多人格维度中展现了其中之一罢了。</p>\n<p>人们总是习惯在不了解对方的时候，就用一些标签和自以为是的评价为对方打上一个烙印，还往往以为这就是确定的真实。用这种似是而非的“确定性”否定了所有的可能性，或许才是人与人相处的最大障碍。</p>\n<p>有时候，不是命运缺少安排，也不是缘分太浅，只是你没有给别人时间和空间展示更丰富真实的自己，才同样让自己也错失了机会。又或者我们习惯了面具的存在，也快忘记了在别人靠近的时候，松动和敞开自己的内心，给他一个走进自己生活的机会。</p>\n<p>原来，每个人都不是你看到的那个样子，原来，每个人都需要一个真正认识彼此的机会。——注：文章参考于网络，仅供个人学习</p>\n<p>最后送大家一句话：真正支撑一个人活下去的不是安逸，而是对生活的不甘。我要经历一切，哪怕不完美！！！</p>\n"},{"title":"程序性能之HTML5 Web Workers","date":"2017-02-10T03:53:05.000Z","_content":"#### 什么是 Web Worker？\n当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。\nweb worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。\n\n大家都知道JavaScript是单线程运作的。但是，单线程并不是组织程序执行的唯一方式。可以设想一下，把你的程序分为两个部分： 一部分运行在主 UI 线程下， 另外一部分运行在另一个完全独立的线程中。\n像浏览器这样的环境， 很容易提供多个 JavaScript 引擎实例， 各自运行在自己的线程上， 这样你可以在每个线程上运行不同的程序。 程序中每一个这样的独立的多线程部分被称为一个（ Web） Worker。 这种类型的并行化被称为任务并行 ，因为其重点在于把程序划分为多个块来并发运行。从 JavaScript 主程序（ 或另一个 Worker） 中， 可以这样实例化一个 Worker：\n```\nvar w1 = new Worker( \"http://some.url.1/mycoolworker.js\" );\n```\n这个 URL应该指向一个 JavaScript 文件的位置（ 而不是一个 HTML页面！ ） ， 这个文件将被加载到一个 Worker 中。 然后浏览器启动一个独立的线程， 让这个文件在这个线程中作为独立的程序运行。这种通过这样的 URL创建的 Worker 称为专用 Worker（ Dedicated Worker） 。 除了提供一个指向外部文件的 URL， 你还可以通过提供一个 Blob URL（ 另外一个 HTML5 特性） 创建一个在线 Worker（ Inline Worker)， 本质上就是一个存储在单个（ 二进制） 值中的在线文件。\n\nWorker 之间以及它们和主程序之间， 不会共享任何作用域或资源，  而是通过一个基本的事件消息机制相互联系。\nWorker w1 对象是一个事件侦听者和触发者， 可以通过订阅它来获得这个 Worker 发出的事件以及发送事件给这个 Worker。\n以下是如何侦听事件（ 其实就是固定的 \"message\" 事件） ：\n```\nw1.addEventListener( \"message\", function(evt){\n// evt.data\n} );\n```\n也可以发送 \"message\" 事件给这个 Worker：\n```\nw1.postMessage( \"something cool to say\" );\n```\n在这个 Worker 内部， 收发消息是完全对称的：\n```\n// \"mycoolworker.js\"\naddEventListener( \"message\", function(evt){\n// evt.data\n} );\npostMessage( \"a really cool reply\" );//postMessage() 方法 - 它用于向 HTML 页面传回一段消息。\n```\n注意， 专用 Worker 和创建它的程序之间是一对一的关系。 也就是说， \"message\" 事件没有任何歧义需要消除， 因为我们确定它只能来自这个一对一的关系： 它要么来自这个 Worker， 要么来自主页面。\n通常由主页面应用程序创建 Worker， 但若是需要的话， Worker 也可以实例化它自己的子 Worker， 称为 subworker。 有时候，把这样的细节委托给一个“主”Worker， 由它来创建其他 Worker 处理部分任务， 这样很有用。  要想使用subworker首先要确定浏览器是否支持。要在创建 Worker 的程序中终止 Worker， 可以调用 Worker 对象（ 就像前面代码中的 w1 ） 上的 terminate() 。 突然终止Worker 线程不会给它任何机会完成它的工作或者清理任何资源。 这就类似于通过关闭浏览器标签页来关闭页面。\n如果浏览器中有两个或多个页面（ 或同一页上的多个 tab ！ ） 试图从同一个文件 URL创建 Worker， 那么最终得到的实际上是完全独立的 Worker。\n\n#### Web Worker 通常应用于哪些方面呢？\n处理密集型数学计算\n大数据集排序\n数据处理（ 压缩、 音频分析、 图像处理等）\n高流量网络通信\n注释：web worker 通常不用于过于简单的脚本，而是用于更耗费 CPU 资源的任务。\n\n#### 检测 Web Worker 支持\n在创建 web worker 之前，请检测用户的浏览器是否支持它：\n```\nif(typeof(Worker)!==\"undefined\")\n  {\n  // Yes! Web worker support!\n  // Some code.....\n  }\nelse\n  {\n  // Sorry! No Web Worker support..\n  }\n```\n\n#### Worker环境\n在 Worker 内部是无法访问主程序的任何资源的。 这意味着你不能访问它的任何全局变量， 也不能访问页面的 DOM 或者其他资源。 记住， 这是一个完全独立的线程。\n但 是， 你可以执行网络操 作（ Ajax、 WebSockets） 以及设定定时 器。 还 有， Worker 可以访问几个重要的全局变量和功能的本地复本， 包括 navigator 、 location 、 JSON 和 applicationCache 。还可以通过 importScripts(..) 向 Worker 加载额外的 JavaScript 脚本：\n```\n// 在Worker内部\nimportScripts( \"foo.js\", \"bar.js\" );\n```\n这些脚本加载是同步的。 也就是说， importScripts(..) 调用会阻塞余下 Worker 的执行， 直到文件加载和执行完成。\n\n#### 数据传递\n可能已经注意到这些应用中的大多数有一个共性， 就是需要在线程之间通过事件机制传递大量的信息， 可能是双向的。\n\n如果要传递一个对象， 可以使用结构化克隆算法 （ structured clone algorithm） （ https://developer.mozilla.org/enUS/docs/Web/Guide/API/DOM/The_structured_clone_algorithm） 把这个对象复制到另一边。 这个算法非常高级， 甚至可以处理要复制的对象有循环引用的情况。这样就不用付出 to-string和 from-string的性能损失了， 但是这种方案还是要使用双倍的内存。IE10 及更高版本以及所有其他主流浏览器都支持这种方案。\n\n还有一个更好的选择， 特别是对于大数据集而言， 就是使用 Transferable 对象 （ http://updates.html5rocks.com/2011/12/TransferableObjects-Lightning-Fast)这时发生的是对象所有权的转移， 数据本身并没有移动。 一旦你把对象传递到一个 Worker 中， 在原来的位置上， 它就变为空的或者是不可访问的， 这样就消除了多线程编程作用域共享带来的混乱。当然，所有权传递是可以双向进行的。\n\n如果选择 Transferable 对象的话， 其实不需要做什么。 任何实现了 Transferable 接口（ http://developer.mozilla.org/enUS/docs/Web/API/Transferable ）的数据结构就自动按照这种方式传输（ Firefox和 Chrome 都支持） 。举例来说， 像 Uint8Array这样的带类型的数组 就是Transferable。 下面是如何使用 postMessage(..) 发送一个 Transferable 对象：\n```\n// 比如foo是一个Uint8Array\npostMessage( foo.buffer, [ foo.buffer ] );\n```\n第一个参数是一个原始缓冲区， 第二个是一个要传输的内容的列表。不支持 Transferable 对象的浏览器就降级到结构化克隆， 这会带来性能下降而不是彻底的功能失效。\n\n#### 共享 Worker\n如果你的站点或 app 允许加载同一个页面的多个 tab（ 一个常见的功能） ， 那你可能非常希望通过防止重复专用 Worker 来降低系统的资源使用。 在这一方面最常见的有限资源就是 socket 网络连接， 因为浏览器限制了到同一个主机的同时连接数目。 当然， 限制来自于同一客户端的连接数也减轻了你的资源压力。\n在这种情况下， 创建一个整个站点或 app 的所有页面实例都可以共享的中心 Worker 就非常有用了。\n这称为 SharedWorker ， 可通过下面的方式创建（ 只有 Firefox和 Chrome 支持这一功能）:\n```\nvar w1 = new SharedWorker( \"http://some.url.1/mycoolworker.js\" );\n```\n因为共享 Worker 可以与站点的多个程序实例或多个页面连接， 所以这个 Worker 需要通过某种方式来得知消息来自于哪个程序。 这个唯一标识符称为端口 （ port） ， 可以类比网络 socket 的端口。 因此， 调用程序必须使用 Worker 的 port 对象用于通信:\n```\nw1.port.addEventListener( \"message\", handleMessages );\n// ..\nw1.port.postMessage( \"something cool\" );\n```\n还有， 端口连接必须要初始化， 形式如下：\n```\nw1.port.start();\n```\n在共享 Worker 内部， 必须要处理额外的一个事件： \"connect\" 。 这个事件为这个特定的连接提供了端口对象。 保持多个连接独立的最简单办法就是使用 port 上的闭包，就像下面的代码一样， 把这个链接上的事件侦听和传递定义在 \"connect\" 事件的处理函数内部：\n```\n// 在共享Worker内部\naddEventListener( \"connect\", function(evt){\n// 这个连接分配的端口\nvar port = evt.ports[0];\nport.addEventListener( \"message\", function(evt){\n// ..\nport.postMessage( .. );\n// ..\n} );\n// 初始化端口连接\nport.start();\n} );\n```\n除了这个区别之外， 共享和专用 Worker 在功能和语义方面都是一样的.\n\n","source":"_posts/web-workers.md","raw":"---\ntitle: 程序性能之HTML5 Web Workers\ndate: 2017-02-10 11:53:05\ntags: h5 webworkers\n---\n#### 什么是 Web Worker？\n当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。\nweb worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。\n\n大家都知道JavaScript是单线程运作的。但是，单线程并不是组织程序执行的唯一方式。可以设想一下，把你的程序分为两个部分： 一部分运行在主 UI 线程下， 另外一部分运行在另一个完全独立的线程中。\n像浏览器这样的环境， 很容易提供多个 JavaScript 引擎实例， 各自运行在自己的线程上， 这样你可以在每个线程上运行不同的程序。 程序中每一个这样的独立的多线程部分被称为一个（ Web） Worker。 这种类型的并行化被称为任务并行 ，因为其重点在于把程序划分为多个块来并发运行。从 JavaScript 主程序（ 或另一个 Worker） 中， 可以这样实例化一个 Worker：\n```\nvar w1 = new Worker( \"http://some.url.1/mycoolworker.js\" );\n```\n这个 URL应该指向一个 JavaScript 文件的位置（ 而不是一个 HTML页面！ ） ， 这个文件将被加载到一个 Worker 中。 然后浏览器启动一个独立的线程， 让这个文件在这个线程中作为独立的程序运行。这种通过这样的 URL创建的 Worker 称为专用 Worker（ Dedicated Worker） 。 除了提供一个指向外部文件的 URL， 你还可以通过提供一个 Blob URL（ 另外一个 HTML5 特性） 创建一个在线 Worker（ Inline Worker)， 本质上就是一个存储在单个（ 二进制） 值中的在线文件。\n\nWorker 之间以及它们和主程序之间， 不会共享任何作用域或资源，  而是通过一个基本的事件消息机制相互联系。\nWorker w1 对象是一个事件侦听者和触发者， 可以通过订阅它来获得这个 Worker 发出的事件以及发送事件给这个 Worker。\n以下是如何侦听事件（ 其实就是固定的 \"message\" 事件） ：\n```\nw1.addEventListener( \"message\", function(evt){\n// evt.data\n} );\n```\n也可以发送 \"message\" 事件给这个 Worker：\n```\nw1.postMessage( \"something cool to say\" );\n```\n在这个 Worker 内部， 收发消息是完全对称的：\n```\n// \"mycoolworker.js\"\naddEventListener( \"message\", function(evt){\n// evt.data\n} );\npostMessage( \"a really cool reply\" );//postMessage() 方法 - 它用于向 HTML 页面传回一段消息。\n```\n注意， 专用 Worker 和创建它的程序之间是一对一的关系。 也就是说， \"message\" 事件没有任何歧义需要消除， 因为我们确定它只能来自这个一对一的关系： 它要么来自这个 Worker， 要么来自主页面。\n通常由主页面应用程序创建 Worker， 但若是需要的话， Worker 也可以实例化它自己的子 Worker， 称为 subworker。 有时候，把这样的细节委托给一个“主”Worker， 由它来创建其他 Worker 处理部分任务， 这样很有用。  要想使用subworker首先要确定浏览器是否支持。要在创建 Worker 的程序中终止 Worker， 可以调用 Worker 对象（ 就像前面代码中的 w1 ） 上的 terminate() 。 突然终止Worker 线程不会给它任何机会完成它的工作或者清理任何资源。 这就类似于通过关闭浏览器标签页来关闭页面。\n如果浏览器中有两个或多个页面（ 或同一页上的多个 tab ！ ） 试图从同一个文件 URL创建 Worker， 那么最终得到的实际上是完全独立的 Worker。\n\n#### Web Worker 通常应用于哪些方面呢？\n处理密集型数学计算\n大数据集排序\n数据处理（ 压缩、 音频分析、 图像处理等）\n高流量网络通信\n注释：web worker 通常不用于过于简单的脚本，而是用于更耗费 CPU 资源的任务。\n\n#### 检测 Web Worker 支持\n在创建 web worker 之前，请检测用户的浏览器是否支持它：\n```\nif(typeof(Worker)!==\"undefined\")\n  {\n  // Yes! Web worker support!\n  // Some code.....\n  }\nelse\n  {\n  // Sorry! No Web Worker support..\n  }\n```\n\n#### Worker环境\n在 Worker 内部是无法访问主程序的任何资源的。 这意味着你不能访问它的任何全局变量， 也不能访问页面的 DOM 或者其他资源。 记住， 这是一个完全独立的线程。\n但 是， 你可以执行网络操 作（ Ajax、 WebSockets） 以及设定定时 器。 还 有， Worker 可以访问几个重要的全局变量和功能的本地复本， 包括 navigator 、 location 、 JSON 和 applicationCache 。还可以通过 importScripts(..) 向 Worker 加载额外的 JavaScript 脚本：\n```\n// 在Worker内部\nimportScripts( \"foo.js\", \"bar.js\" );\n```\n这些脚本加载是同步的。 也就是说， importScripts(..) 调用会阻塞余下 Worker 的执行， 直到文件加载和执行完成。\n\n#### 数据传递\n可能已经注意到这些应用中的大多数有一个共性， 就是需要在线程之间通过事件机制传递大量的信息， 可能是双向的。\n\n如果要传递一个对象， 可以使用结构化克隆算法 （ structured clone algorithm） （ https://developer.mozilla.org/enUS/docs/Web/Guide/API/DOM/The_structured_clone_algorithm） 把这个对象复制到另一边。 这个算法非常高级， 甚至可以处理要复制的对象有循环引用的情况。这样就不用付出 to-string和 from-string的性能损失了， 但是这种方案还是要使用双倍的内存。IE10 及更高版本以及所有其他主流浏览器都支持这种方案。\n\n还有一个更好的选择， 特别是对于大数据集而言， 就是使用 Transferable 对象 （ http://updates.html5rocks.com/2011/12/TransferableObjects-Lightning-Fast)这时发生的是对象所有权的转移， 数据本身并没有移动。 一旦你把对象传递到一个 Worker 中， 在原来的位置上， 它就变为空的或者是不可访问的， 这样就消除了多线程编程作用域共享带来的混乱。当然，所有权传递是可以双向进行的。\n\n如果选择 Transferable 对象的话， 其实不需要做什么。 任何实现了 Transferable 接口（ http://developer.mozilla.org/enUS/docs/Web/API/Transferable ）的数据结构就自动按照这种方式传输（ Firefox和 Chrome 都支持） 。举例来说， 像 Uint8Array这样的带类型的数组 就是Transferable。 下面是如何使用 postMessage(..) 发送一个 Transferable 对象：\n```\n// 比如foo是一个Uint8Array\npostMessage( foo.buffer, [ foo.buffer ] );\n```\n第一个参数是一个原始缓冲区， 第二个是一个要传输的内容的列表。不支持 Transferable 对象的浏览器就降级到结构化克隆， 这会带来性能下降而不是彻底的功能失效。\n\n#### 共享 Worker\n如果你的站点或 app 允许加载同一个页面的多个 tab（ 一个常见的功能） ， 那你可能非常希望通过防止重复专用 Worker 来降低系统的资源使用。 在这一方面最常见的有限资源就是 socket 网络连接， 因为浏览器限制了到同一个主机的同时连接数目。 当然， 限制来自于同一客户端的连接数也减轻了你的资源压力。\n在这种情况下， 创建一个整个站点或 app 的所有页面实例都可以共享的中心 Worker 就非常有用了。\n这称为 SharedWorker ， 可通过下面的方式创建（ 只有 Firefox和 Chrome 支持这一功能）:\n```\nvar w1 = new SharedWorker( \"http://some.url.1/mycoolworker.js\" );\n```\n因为共享 Worker 可以与站点的多个程序实例或多个页面连接， 所以这个 Worker 需要通过某种方式来得知消息来自于哪个程序。 这个唯一标识符称为端口 （ port） ， 可以类比网络 socket 的端口。 因此， 调用程序必须使用 Worker 的 port 对象用于通信:\n```\nw1.port.addEventListener( \"message\", handleMessages );\n// ..\nw1.port.postMessage( \"something cool\" );\n```\n还有， 端口连接必须要初始化， 形式如下：\n```\nw1.port.start();\n```\n在共享 Worker 内部， 必须要处理额外的一个事件： \"connect\" 。 这个事件为这个特定的连接提供了端口对象。 保持多个连接独立的最简单办法就是使用 port 上的闭包，就像下面的代码一样， 把这个链接上的事件侦听和传递定义在 \"connect\" 事件的处理函数内部：\n```\n// 在共享Worker内部\naddEventListener( \"connect\", function(evt){\n// 这个连接分配的端口\nvar port = evt.ports[0];\nport.addEventListener( \"message\", function(evt){\n// ..\nport.postMessage( .. );\n// ..\n} );\n// 初始化端口连接\nport.start();\n} );\n```\n除了这个区别之外， 共享和专用 Worker 在功能和语义方面都是一样的.\n\n","slug":"web-workers","published":1,"updated":"2017-02-10T06:34:47.957Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizpcu9sn000gfcturm3msurk","content":"<h4 id=\"什么是-Web-Worker？\"><a href=\"#什么是-Web-Worker？\" class=\"headerlink\" title=\"什么是 Web Worker？\"></a>什么是 Web Worker？</h4><p>当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。<br>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</p>\n<p>大家都知道JavaScript是单线程运作的。但是，单线程并不是组织程序执行的唯一方式。可以设想一下，把你的程序分为两个部分： 一部分运行在主 UI 线程下， 另外一部分运行在另一个完全独立的线程中。<br>像浏览器这样的环境， 很容易提供多个 JavaScript 引擎实例， 各自运行在自己的线程上， 这样你可以在每个线程上运行不同的程序。 程序中每一个这样的独立的多线程部分被称为一个（ Web） Worker。 这种类型的并行化被称为任务并行 ，因为其重点在于把程序划分为多个块来并发运行。从 JavaScript 主程序（ 或另一个 Worker） 中， 可以这样实例化一个 Worker：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var w1 = new Worker( &quot;http://some.url.1/mycoolworker.js&quot; );</div></pre></td></tr></table></figure></p>\n<p>这个 URL应该指向一个 JavaScript 文件的位置（ 而不是一个 HTML页面！ ） ， 这个文件将被加载到一个 Worker 中。 然后浏览器启动一个独立的线程， 让这个文件在这个线程中作为独立的程序运行。这种通过这样的 URL创建的 Worker 称为专用 Worker（ Dedicated Worker） 。 除了提供一个指向外部文件的 URL， 你还可以通过提供一个 Blob URL（ 另外一个 HTML5 特性） 创建一个在线 Worker（ Inline Worker)， 本质上就是一个存储在单个（ 二进制） 值中的在线文件。</p>\n<p>Worker 之间以及它们和主程序之间， 不会共享任何作用域或资源，  而是通过一个基本的事件消息机制相互联系。<br>Worker w1 对象是一个事件侦听者和触发者， 可以通过订阅它来获得这个 Worker 发出的事件以及发送事件给这个 Worker。<br>以下是如何侦听事件（ 其实就是固定的 “message” 事件） ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">w1.addEventListener( &quot;message&quot;, function(evt)&#123;</div><div class=\"line\">// evt.data</div><div class=\"line\">&#125; );</div></pre></td></tr></table></figure></p>\n<p>也可以发送 “message” 事件给这个 Worker：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">w1.postMessage( &quot;something cool to say&quot; );</div></pre></td></tr></table></figure></p>\n<p>在这个 Worker 内部， 收发消息是完全对称的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// &quot;mycoolworker.js&quot;</div><div class=\"line\">addEventListener( &quot;message&quot;, function(evt)&#123;</div><div class=\"line\">// evt.data</div><div class=\"line\">&#125; );</div><div class=\"line\">postMessage( &quot;a really cool reply&quot; );//postMessage() 方法 - 它用于向 HTML 页面传回一段消息。</div></pre></td></tr></table></figure></p>\n<p>注意， 专用 Worker 和创建它的程序之间是一对一的关系。 也就是说， “message” 事件没有任何歧义需要消除， 因为我们确定它只能来自这个一对一的关系： 它要么来自这个 Worker， 要么来自主页面。<br>通常由主页面应用程序创建 Worker， 但若是需要的话， Worker 也可以实例化它自己的子 Worker， 称为 subworker。 有时候，把这样的细节委托给一个“主”Worker， 由它来创建其他 Worker 处理部分任务， 这样很有用。  要想使用subworker首先要确定浏览器是否支持。要在创建 Worker 的程序中终止 Worker， 可以调用 Worker 对象（ 就像前面代码中的 w1 ） 上的 terminate() 。 突然终止Worker 线程不会给它任何机会完成它的工作或者清理任何资源。 这就类似于通过关闭浏览器标签页来关闭页面。<br>如果浏览器中有两个或多个页面（ 或同一页上的多个 tab ！ ） 试图从同一个文件 URL创建 Worker， 那么最终得到的实际上是完全独立的 Worker。</p>\n<h4 id=\"Web-Worker-通常应用于哪些方面呢？\"><a href=\"#Web-Worker-通常应用于哪些方面呢？\" class=\"headerlink\" title=\"Web Worker 通常应用于哪些方面呢？\"></a>Web Worker 通常应用于哪些方面呢？</h4><p>处理密集型数学计算<br>大数据集排序<br>数据处理（ 压缩、 音频分析、 图像处理等）<br>高流量网络通信<br>注释：web worker 通常不用于过于简单的脚本，而是用于更耗费 CPU 资源的任务。</p>\n<h4 id=\"检测-Web-Worker-支持\"><a href=\"#检测-Web-Worker-支持\" class=\"headerlink\" title=\"检测 Web Worker 支持\"></a>检测 Web Worker 支持</h4><p>在创建 web worker 之前，请检测用户的浏览器是否支持它：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if(typeof(Worker)!==&quot;undefined&quot;)</div><div class=\"line\">  &#123;</div><div class=\"line\">  // Yes! Web worker support!</div><div class=\"line\">  // Some code.....</div><div class=\"line\">  &#125;</div><div class=\"line\">else</div><div class=\"line\">  &#123;</div><div class=\"line\">  // Sorry! No Web Worker support..</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"Worker环境\"><a href=\"#Worker环境\" class=\"headerlink\" title=\"Worker环境\"></a>Worker环境</h4><p>在 Worker 内部是无法访问主程序的任何资源的。 这意味着你不能访问它的任何全局变量， 也不能访问页面的 DOM 或者其他资源。 记住， 这是一个完全独立的线程。<br>但 是， 你可以执行网络操 作（ Ajax、 WebSockets） 以及设定定时 器。 还 有， Worker 可以访问几个重要的全局变量和功能的本地复本， 包括 navigator 、 location 、 JSON 和 applicationCache 。还可以通过 importScripts(..) 向 Worker 加载额外的 JavaScript 脚本：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 在Worker内部</div><div class=\"line\">importScripts( &quot;foo.js&quot;, &quot;bar.js&quot; );</div></pre></td></tr></table></figure></p>\n<p>这些脚本加载是同步的。 也就是说， importScripts(..) 调用会阻塞余下 Worker 的执行， 直到文件加载和执行完成。</p>\n<h4 id=\"数据传递\"><a href=\"#数据传递\" class=\"headerlink\" title=\"数据传递\"></a>数据传递</h4><p>可能已经注意到这些应用中的大多数有一个共性， 就是需要在线程之间通过事件机制传递大量的信息， 可能是双向的。</p>\n<p>如果要传递一个对象， 可以使用结构化克隆算法 （ structured clone algorithm） （ <a href=\"https://developer.mozilla.org/enUS/docs/Web/Guide/API/DOM/The_structured_clone_algorithm）\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/enUS/docs/Web/Guide/API/DOM/The_structured_clone_algorithm）</a> 把这个对象复制到另一边。 这个算法非常高级， 甚至可以处理要复制的对象有循环引用的情况。这样就不用付出 to-string和 from-string的性能损失了， 但是这种方案还是要使用双倍的内存。IE10 及更高版本以及所有其他主流浏览器都支持这种方案。</p>\n<p>还有一个更好的选择， 特别是对于大数据集而言， 就是使用 Transferable 对象 （ <a href=\"http://updates.html5rocks.com/2011/12/TransferableObjects-Lightning-Fast)这时发生的是对象所有权的转移，\" target=\"_blank\" rel=\"external\">http://updates.html5rocks.com/2011/12/TransferableObjects-Lightning-Fast)这时发生的是对象所有权的转移，</a> 数据本身并没有移动。 一旦你把对象传递到一个 Worker 中， 在原来的位置上， 它就变为空的或者是不可访问的， 这样就消除了多线程编程作用域共享带来的混乱。当然，所有权传递是可以双向进行的。</p>\n<p>如果选择 Transferable 对象的话， 其实不需要做什么。 任何实现了 Transferable 接口（ <a href=\"http://developer.mozilla.org/enUS/docs/Web/API/Transferable\" target=\"_blank\" rel=\"external\">http://developer.mozilla.org/enUS/docs/Web/API/Transferable</a> ）的数据结构就自动按照这种方式传输（ Firefox和 Chrome 都支持） 。举例来说， 像 Uint8Array这样的带类型的数组 就是Transferable。 下面是如何使用 postMessage(..) 发送一个 Transferable 对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 比如foo是一个Uint8Array</div><div class=\"line\">postMessage( foo.buffer, [ foo.buffer ] );</div></pre></td></tr></table></figure></p>\n<p>第一个参数是一个原始缓冲区， 第二个是一个要传输的内容的列表。不支持 Transferable 对象的浏览器就降级到结构化克隆， 这会带来性能下降而不是彻底的功能失效。</p>\n<h4 id=\"共享-Worker\"><a href=\"#共享-Worker\" class=\"headerlink\" title=\"共享 Worker\"></a>共享 Worker</h4><p>如果你的站点或 app 允许加载同一个页面的多个 tab（ 一个常见的功能） ， 那你可能非常希望通过防止重复专用 Worker 来降低系统的资源使用。 在这一方面最常见的有限资源就是 socket 网络连接， 因为浏览器限制了到同一个主机的同时连接数目。 当然， 限制来自于同一客户端的连接数也减轻了你的资源压力。<br>在这种情况下， 创建一个整个站点或 app 的所有页面实例都可以共享的中心 Worker 就非常有用了。<br>这称为 SharedWorker ， 可通过下面的方式创建（ 只有 Firefox和 Chrome 支持这一功能）:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var w1 = new SharedWorker( &quot;http://some.url.1/mycoolworker.js&quot; );</div></pre></td></tr></table></figure></p>\n<p>因为共享 Worker 可以与站点的多个程序实例或多个页面连接， 所以这个 Worker 需要通过某种方式来得知消息来自于哪个程序。 这个唯一标识符称为端口 （ port） ， 可以类比网络 socket 的端口。 因此， 调用程序必须使用 Worker 的 port 对象用于通信:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">w1.port.addEventListener( &quot;message&quot;, handleMessages );</div><div class=\"line\">// ..</div><div class=\"line\">w1.port.postMessage( &quot;something cool&quot; );</div></pre></td></tr></table></figure></p>\n<p>还有， 端口连接必须要初始化， 形式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">w1.port.start();</div></pre></td></tr></table></figure></p>\n<p>在共享 Worker 内部， 必须要处理额外的一个事件： “connect” 。 这个事件为这个特定的连接提供了端口对象。 保持多个连接独立的最简单办法就是使用 port 上的闭包，就像下面的代码一样， 把这个链接上的事件侦听和传递定义在 “connect” 事件的处理函数内部：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 在共享Worker内部</div><div class=\"line\">addEventListener( &quot;connect&quot;, function(evt)&#123;</div><div class=\"line\">// 这个连接分配的端口</div><div class=\"line\">var port = evt.ports[0];</div><div class=\"line\">port.addEventListener( &quot;message&quot;, function(evt)&#123;</div><div class=\"line\">// ..</div><div class=\"line\">port.postMessage( .. );</div><div class=\"line\">// ..</div><div class=\"line\">&#125; );</div><div class=\"line\">// 初始化端口连接</div><div class=\"line\">port.start();</div><div class=\"line\">&#125; );</div></pre></td></tr></table></figure></p>\n<p>除了这个区别之外， 共享和专用 Worker 在功能和语义方面都是一样的.</p>\n","excerpt":"","more":"<h4 id=\"什么是-Web-Worker？\"><a href=\"#什么是-Web-Worker？\" class=\"headerlink\" title=\"什么是 Web Worker？\"></a>什么是 Web Worker？</h4><p>当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。<br>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</p>\n<p>大家都知道JavaScript是单线程运作的。但是，单线程并不是组织程序执行的唯一方式。可以设想一下，把你的程序分为两个部分： 一部分运行在主 UI 线程下， 另外一部分运行在另一个完全独立的线程中。<br>像浏览器这样的环境， 很容易提供多个 JavaScript 引擎实例， 各自运行在自己的线程上， 这样你可以在每个线程上运行不同的程序。 程序中每一个这样的独立的多线程部分被称为一个（ Web） Worker。 这种类型的并行化被称为任务并行 ，因为其重点在于把程序划分为多个块来并发运行。从 JavaScript 主程序（ 或另一个 Worker） 中， 可以这样实例化一个 Worker：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var w1 = new Worker( &quot;http://some.url.1/mycoolworker.js&quot; );</div></pre></td></tr></table></figure></p>\n<p>这个 URL应该指向一个 JavaScript 文件的位置（ 而不是一个 HTML页面！ ） ， 这个文件将被加载到一个 Worker 中。 然后浏览器启动一个独立的线程， 让这个文件在这个线程中作为独立的程序运行。这种通过这样的 URL创建的 Worker 称为专用 Worker（ Dedicated Worker） 。 除了提供一个指向外部文件的 URL， 你还可以通过提供一个 Blob URL（ 另外一个 HTML5 特性） 创建一个在线 Worker（ Inline Worker)， 本质上就是一个存储在单个（ 二进制） 值中的在线文件。</p>\n<p>Worker 之间以及它们和主程序之间， 不会共享任何作用域或资源，  而是通过一个基本的事件消息机制相互联系。<br>Worker w1 对象是一个事件侦听者和触发者， 可以通过订阅它来获得这个 Worker 发出的事件以及发送事件给这个 Worker。<br>以下是如何侦听事件（ 其实就是固定的 “message” 事件） ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">w1.addEventListener( &quot;message&quot;, function(evt)&#123;</div><div class=\"line\">// evt.data</div><div class=\"line\">&#125; );</div></pre></td></tr></table></figure></p>\n<p>也可以发送 “message” 事件给这个 Worker：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">w1.postMessage( &quot;something cool to say&quot; );</div></pre></td></tr></table></figure></p>\n<p>在这个 Worker 内部， 收发消息是完全对称的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// &quot;mycoolworker.js&quot;</div><div class=\"line\">addEventListener( &quot;message&quot;, function(evt)&#123;</div><div class=\"line\">// evt.data</div><div class=\"line\">&#125; );</div><div class=\"line\">postMessage( &quot;a really cool reply&quot; );//postMessage() 方法 - 它用于向 HTML 页面传回一段消息。</div></pre></td></tr></table></figure></p>\n<p>注意， 专用 Worker 和创建它的程序之间是一对一的关系。 也就是说， “message” 事件没有任何歧义需要消除， 因为我们确定它只能来自这个一对一的关系： 它要么来自这个 Worker， 要么来自主页面。<br>通常由主页面应用程序创建 Worker， 但若是需要的话， Worker 也可以实例化它自己的子 Worker， 称为 subworker。 有时候，把这样的细节委托给一个“主”Worker， 由它来创建其他 Worker 处理部分任务， 这样很有用。  要想使用subworker首先要确定浏览器是否支持。要在创建 Worker 的程序中终止 Worker， 可以调用 Worker 对象（ 就像前面代码中的 w1 ） 上的 terminate() 。 突然终止Worker 线程不会给它任何机会完成它的工作或者清理任何资源。 这就类似于通过关闭浏览器标签页来关闭页面。<br>如果浏览器中有两个或多个页面（ 或同一页上的多个 tab ！ ） 试图从同一个文件 URL创建 Worker， 那么最终得到的实际上是完全独立的 Worker。</p>\n<h4 id=\"Web-Worker-通常应用于哪些方面呢？\"><a href=\"#Web-Worker-通常应用于哪些方面呢？\" class=\"headerlink\" title=\"Web Worker 通常应用于哪些方面呢？\"></a>Web Worker 通常应用于哪些方面呢？</h4><p>处理密集型数学计算<br>大数据集排序<br>数据处理（ 压缩、 音频分析、 图像处理等）<br>高流量网络通信<br>注释：web worker 通常不用于过于简单的脚本，而是用于更耗费 CPU 资源的任务。</p>\n<h4 id=\"检测-Web-Worker-支持\"><a href=\"#检测-Web-Worker-支持\" class=\"headerlink\" title=\"检测 Web Worker 支持\"></a>检测 Web Worker 支持</h4><p>在创建 web worker 之前，请检测用户的浏览器是否支持它：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if(typeof(Worker)!==&quot;undefined&quot;)</div><div class=\"line\">  &#123;</div><div class=\"line\">  // Yes! Web worker support!</div><div class=\"line\">  // Some code.....</div><div class=\"line\">  &#125;</div><div class=\"line\">else</div><div class=\"line\">  &#123;</div><div class=\"line\">  // Sorry! No Web Worker support..</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"Worker环境\"><a href=\"#Worker环境\" class=\"headerlink\" title=\"Worker环境\"></a>Worker环境</h4><p>在 Worker 内部是无法访问主程序的任何资源的。 这意味着你不能访问它的任何全局变量， 也不能访问页面的 DOM 或者其他资源。 记住， 这是一个完全独立的线程。<br>但 是， 你可以执行网络操 作（ Ajax、 WebSockets） 以及设定定时 器。 还 有， Worker 可以访问几个重要的全局变量和功能的本地复本， 包括 navigator 、 location 、 JSON 和 applicationCache 。还可以通过 importScripts(..) 向 Worker 加载额外的 JavaScript 脚本：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 在Worker内部</div><div class=\"line\">importScripts( &quot;foo.js&quot;, &quot;bar.js&quot; );</div></pre></td></tr></table></figure></p>\n<p>这些脚本加载是同步的。 也就是说， importScripts(..) 调用会阻塞余下 Worker 的执行， 直到文件加载和执行完成。</p>\n<h4 id=\"数据传递\"><a href=\"#数据传递\" class=\"headerlink\" title=\"数据传递\"></a>数据传递</h4><p>可能已经注意到这些应用中的大多数有一个共性， 就是需要在线程之间通过事件机制传递大量的信息， 可能是双向的。</p>\n<p>如果要传递一个对象， 可以使用结构化克隆算法 （ structured clone algorithm） （ <a href=\"https://developer.mozilla.org/enUS/docs/Web/Guide/API/DOM/The_structured_clone_algorithm）\">https://developer.mozilla.org/enUS/docs/Web/Guide/API/DOM/The_structured_clone_algorithm）</a> 把这个对象复制到另一边。 这个算法非常高级， 甚至可以处理要复制的对象有循环引用的情况。这样就不用付出 to-string和 from-string的性能损失了， 但是这种方案还是要使用双倍的内存。IE10 及更高版本以及所有其他主流浏览器都支持这种方案。</p>\n<p>还有一个更好的选择， 特别是对于大数据集而言， 就是使用 Transferable 对象 （ <a href=\"http://updates.html5rocks.com/2011/12/TransferableObjects-Lightning-Fast)这时发生的是对象所有权的转移，\">http://updates.html5rocks.com/2011/12/TransferableObjects-Lightning-Fast)这时发生的是对象所有权的转移，</a> 数据本身并没有移动。 一旦你把对象传递到一个 Worker 中， 在原来的位置上， 它就变为空的或者是不可访问的， 这样就消除了多线程编程作用域共享带来的混乱。当然，所有权传递是可以双向进行的。</p>\n<p>如果选择 Transferable 对象的话， 其实不需要做什么。 任何实现了 Transferable 接口（ <a href=\"http://developer.mozilla.org/enUS/docs/Web/API/Transferable\">http://developer.mozilla.org/enUS/docs/Web/API/Transferable</a> ）的数据结构就自动按照这种方式传输（ Firefox和 Chrome 都支持） 。举例来说， 像 Uint8Array这样的带类型的数组 就是Transferable。 下面是如何使用 postMessage(..) 发送一个 Transferable 对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 比如foo是一个Uint8Array</div><div class=\"line\">postMessage( foo.buffer, [ foo.buffer ] );</div></pre></td></tr></table></figure></p>\n<p>第一个参数是一个原始缓冲区， 第二个是一个要传输的内容的列表。不支持 Transferable 对象的浏览器就降级到结构化克隆， 这会带来性能下降而不是彻底的功能失效。</p>\n<h4 id=\"共享-Worker\"><a href=\"#共享-Worker\" class=\"headerlink\" title=\"共享 Worker\"></a>共享 Worker</h4><p>如果你的站点或 app 允许加载同一个页面的多个 tab（ 一个常见的功能） ， 那你可能非常希望通过防止重复专用 Worker 来降低系统的资源使用。 在这一方面最常见的有限资源就是 socket 网络连接， 因为浏览器限制了到同一个主机的同时连接数目。 当然， 限制来自于同一客户端的连接数也减轻了你的资源压力。<br>在这种情况下， 创建一个整个站点或 app 的所有页面实例都可以共享的中心 Worker 就非常有用了。<br>这称为 SharedWorker ， 可通过下面的方式创建（ 只有 Firefox和 Chrome 支持这一功能）:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var w1 = new SharedWorker( &quot;http://some.url.1/mycoolworker.js&quot; );</div></pre></td></tr></table></figure></p>\n<p>因为共享 Worker 可以与站点的多个程序实例或多个页面连接， 所以这个 Worker 需要通过某种方式来得知消息来自于哪个程序。 这个唯一标识符称为端口 （ port） ， 可以类比网络 socket 的端口。 因此， 调用程序必须使用 Worker 的 port 对象用于通信:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">w1.port.addEventListener( &quot;message&quot;, handleMessages );</div><div class=\"line\">// ..</div><div class=\"line\">w1.port.postMessage( &quot;something cool&quot; );</div></pre></td></tr></table></figure></p>\n<p>还有， 端口连接必须要初始化， 形式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">w1.port.start();</div></pre></td></tr></table></figure></p>\n<p>在共享 Worker 内部， 必须要处理额外的一个事件： “connect” 。 这个事件为这个特定的连接提供了端口对象。 保持多个连接独立的最简单办法就是使用 port 上的闭包，就像下面的代码一样， 把这个链接上的事件侦听和传递定义在 “connect” 事件的处理函数内部：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 在共享Worker内部</div><div class=\"line\">addEventListener( &quot;connect&quot;, function(evt)&#123;</div><div class=\"line\">// 这个连接分配的端口</div><div class=\"line\">var port = evt.ports[0];</div><div class=\"line\">port.addEventListener( &quot;message&quot;, function(evt)&#123;</div><div class=\"line\">// ..</div><div class=\"line\">port.postMessage( .. );</div><div class=\"line\">// ..</div><div class=\"line\">&#125; );</div><div class=\"line\">// 初始化端口连接</div><div class=\"line\">port.start();</div><div class=\"line\">&#125; );</div></pre></td></tr></table></figure></p>\n<p>除了这个区别之外， 共享和专用 Worker 在功能和语义方面都是一样的.</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cixrcdv4z0001jgtuj035a8dg","tag_id":"cixrcdv560003jgtuv7g7hxtc","_id":"cixrcdv5i0008jgtuldmrz4sp"},{"post_id":"cixrcdv530002jgtu16a84re9","tag_id":"cixrcdv5h0007jgtufllny146","_id":"cixrcdv5u000djgtud86qksqp"},{"post_id":"cixrcdv5q000ajgtuh4f5se3c","tag_id":"cixrcdv560003jgtuv7g7hxtc","_id":"cixrcdv5w000fjgtufnyexhqp"},{"post_id":"cixrcdv590004jgtukk23z3mi","tag_id":"cixrcdv5s000bjgtulbo8t1to","_id":"cixrcdv61000ijgtu2x030qo4"},{"post_id":"cixrcdv5d0005jgtuxldx8k7n","tag_id":"cixrcdv5x000gjgtu6zj25zcm","_id":"cixrcdv67000mjgtu64qka6kx"},{"post_id":"cixrcdv5e0006jgtuch22xz0x","tag_id":"cixrcdv64000kjgtujh2kg1x1","_id":"cixrcdv6h000qjgtuwwcgs9v7"},{"post_id":"cixrcdv5k0009jgtujvv3b589","tag_id":"cixrcdv6g000pjgtucos7li20","_id":"cixrcdv6p000vjgtudsa4rkz5"},{"post_id":"cixrcdv5t000cjgtuolih0nqu","tag_id":"cixrcdv6n000tjgtu1vkdiyc6","_id":"cixrcdv6x000zjgtuexs6k5rr"},{"post_id":"cixrcdv5v000ejgtuviv89vyk","tag_id":"cixrcdv6t000xjgtuxhndfscm","_id":"cixrcdv720013jgtuiairq9nz"},{"post_id":"cixrcdv60000hjgtuluwozd7m","tag_id":"cixrcdv6z0011jgtuie0skbbl","_id":"cixrcdv750017jgtueft6ef6j"},{"post_id":"cixrcdv760018jgtuz9lk9vwh","tag_id":"cixrcdv560003jgtuv7g7hxtc","_id":"cixrcdv7b001bjgtu2r15zc7y"},{"post_id":"cixrcdv63000jjgtugqiyxfvv","tag_id":"cixrcdv750016jgtu914uk3uz","_id":"cixrcdv7e001djgtujbmbphx4"},{"post_id":"cixrcdv65000ljgtuxfun0hk7","tag_id":"cixrcdv7a001ajgtulr3s9pp2","_id":"cixrcdv7i001hjgtuee0x18m6"},{"post_id":"cixrcdv68000njgtu177c0oj4","tag_id":"cixrcdv7g001fjgtuu5jx6bmb","_id":"cixrcdv7l001ljgtuinmvzljc"},{"post_id":"cixrcdv6a000ojgtu49swi9rp","tag_id":"cixrcdv7k001jjgtuxm50g5ic","_id":"cixrcdv7s001pjgtu6n586s48"},{"post_id":"cixrcdv6j000rjgtujvvi3zmi","tag_id":"cixrcdv7q001ojgtui1rx6f0n","_id":"cixrcdv7x001ujgtuwfjlbzf2"},{"post_id":"cixrcdv6m000sjgtui64nl14i","tag_id":"cixrcdv7u001sjgtupd1k2afa","_id":"cixrcdv80001yjgtuab70yhcc"},{"post_id":"cixrcdv6o000ujgtui41agc8v","tag_id":"cixrcdv7y001wjgtuu2joheqw","_id":"cixrcdv860022jgtu7yvdl98l"},{"post_id":"cixrcdv6r000wjgtu5jwrcckr","tag_id":"cixrcdv820020jgtu537w59ha","_id":"cixrcdv8a0026jgtu2tyw3e9i"},{"post_id":"cixrcdv6u000yjgtuh2fs49wg","tag_id":"cixrcdv890025jgtuqdzhs4q6","_id":"cixrcdv8f002bjgtuy8rj9dk0"},{"post_id":"cixrcdv6x0010jgtuxwltzqyh","tag_id":"cixrcdv8d0029jgtuh4cnxy3c","_id":"cixrcdv8k002fjgtu47l1qpcf"},{"post_id":"cixrcdv700012jgtul3i43m78","tag_id":"cixrcdv8i002djgtuj99kswuf","_id":"cixrcdv8p002jjgtukeonlr8w"},{"post_id":"cixrcdv720014jgtutcl5k1em","tag_id":"cixrcdv8m002hjgtuac98cwky","_id":"cixrcdv8s002njgtu0vdplylt"},{"post_id":"cixrcdv730015jgtuwq70a2xs","tag_id":"cixrcdv8r002mjgtuoomz72af","_id":"cixrcdv8y002sjgtuhi58z2ok"},{"post_id":"cixrcdv780019jgtu2g3j6xpi","tag_id":"cixrcdv8w002qjgtuzbozpx2z","_id":"cixrcdv92002wjgtu1byc576q"},{"post_id":"cixrcdv7c001cjgtu772kepka","tag_id":"cixrcdv90002ujgtuvxfjsua5","_id":"cixrcdv960030jgtu4gu14qwb"},{"post_id":"cixrcdv7e001ejgtugk0jhzxp","tag_id":"cixrcdv94002yjgtuxxsrxsea","_id":"cixrcdv9a0034jgtufdemrjk3"},{"post_id":"cixrcdv7h001gjgtu2bcced8r","tag_id":"cixrcdv990033jgtu9na1humt","_id":"cixrcdv9g0039jgtuv66zoyb7"},{"post_id":"cixrcdv7j001ijgtuuqtq2vvf","tag_id":"cixrcdv9e0037jgtuljcixp0q","_id":"cixrcdv9m003djgtuk1dz3k55"},{"post_id":"cixrcdv7k001kjgtukb42eebn","tag_id":"cixrcdv9k003bjgtunl8ei6p3","_id":"cixrcdv9r003hjgtuwh6iagjs"},{"post_id":"cixrcdv7p001njgtuon9tatt1","tag_id":"cixrcdv9o003fjgtuoe3tlcl4","_id":"cixrcdv9w003ljgtup4ugjop5"},{"post_id":"cixrcdv7s001qjgtumny39byr","tag_id":"cixrcdv9v003kjgtu5clt5yeo","_id":"cixrcdva4003qjgtujjp0njum"},{"post_id":"cixrcdv7t001rjgtu7r3vn5x8","tag_id":"cixrcdva0003ojgtujit2vydp","_id":"cixrcdvab003ujgtu3r374k9b"},{"post_id":"cixrcdva9003tjgtu1e2oy1g9","tag_id":"cixrcdv560003jgtuv7g7hxtc","_id":"cixrcdvab003vjgtuqelshit6"},{"post_id":"cixrcdv7v001tjgtuwa3mbvyw","tag_id":"cixrcdva7003sjgtupvgynh48","_id":"cixrcdvad003xjgtufpmxbsbw"},{"post_id":"cixrcdv7x001vjgtufe0ikjod","tag_id":"cixrcdvac003wjgtuiv8abq6u","_id":"cixrcdvaf003zjgtu79w3zpwp"},{"post_id":"cixrcdv7z001xjgtu7xanvyfg","tag_id":"cixrcdvae003yjgtugvmmlvke","_id":"cixrcdvap0041jgtu1sepq1r8"},{"post_id":"cixrcdv81001zjgtu1gqbyt6f","tag_id":"cixrcdvag0040jgtuh93r1yem","_id":"cixrcdvar0043jgtugedpxf0v"},{"post_id":"cixrcdv830021jgturgel8i3i","tag_id":"cixrcdvaq0042jgtuqostqzan","_id":"cixrcdvas0045jgtumw5tgzhn"},{"post_id":"cixrcdv870023jgtu91kbl7jw","tag_id":"cixrcdvar0044jgtu3oey4nj5","_id":"cixrcdvat0047jgtufpujgis1"},{"post_id":"cixrcdv880024jgtuy7hgn8mh","tag_id":"cixrcdvat0046jgtub7zz6jd8","_id":"cixrcdvau0049jgtuercln3w6"},{"post_id":"cixrcdv8a0027jgtuvbt7n0of","tag_id":"cixrcdvau0048jgtua6js3vy0","_id":"cixrcdvav004bjgtu1sbgmucy"},{"post_id":"cixrcdv8c0028jgtu4ju1rj0d","tag_id":"cixrcdvav004ajgtub5k35cya","_id":"cixrcdvaw004djgtu3h4iwr3x"},{"post_id":"cixrcdv8e002ajgtu0hvtafho","tag_id":"cixrcdvaw004cjgtu343pgbkz","_id":"cixrcdvax004fjgtucuztq0jk"},{"post_id":"cixrcdv8g002cjgtu9cpp3soj","tag_id":"cixrcdvax004ejgtun7wq71ly","_id":"cixrcdvay004hjgtuhqb93chh"},{"post_id":"cixrcdv8j002ejgtuer7h8clz","tag_id":"cixrcdvax004gjgtutfyoghqv","_id":"cixrcdvaz004jjgtu299m1q4k"},{"post_id":"cixrcdv8l002gjgtu8i1xkvqh","tag_id":"cixrcdvay004ijgtultkz0jdl","_id":"cixrcdvb0004ljgtudagdzbke"},{"post_id":"cixrcdv8n002ijgtujwugqkx2","tag_id":"cixrcdvaz004kjgtuucpvssoc","_id":"cixrcdvb2004njgtusvjqjg8e"},{"post_id":"cixrcdv8p002kjgtubwv8ft7n","tag_id":"cixrcdvaz004kjgtuucpvssoc","_id":"cixrcdvb3004pjgtu1yh02mqb"},{"post_id":"cixrcdv8q002ljgtuun3h8c92","tag_id":"cixrcdvb2004ojgtun1jos2sd","_id":"cixrcdvb4004rjgtut75jgqx0"},{"post_id":"cixrcdv8s002ojgtuw4dltqgl","tag_id":"cixrcdvb4004qjgtufyttojz0","_id":"cixrcdvb6004tjgtu2i9rylez"},{"post_id":"cixrcdv8v002pjgtuaba6l8hp","tag_id":"cixrcdvb5004sjgtucosndust","_id":"cixrcdvb7004vjgtujpdd3jdq"},{"post_id":"cixrcdv8x002rjgtuwld6lc1f","tag_id":"cixrcdvb7004ujgtuczyln9lj","_id":"cixrcdvb9004xjgtufx29wqkd"},{"post_id":"cixrcdv8z002tjgtunlf124xn","tag_id":"cixrcdvb8004wjgtu532g70rf","_id":"cixrcdvba004zjgtuhmyr98uo"},{"post_id":"cixrcdv91002vjgtutf1uu194","tag_id":"cixrcdvb8004wjgtu532g70rf","_id":"cixrcdvbb0051jgtuva35x7hz"},{"post_id":"cixrcdv93002xjgtuc5pl2eh8","tag_id":"cixrcdvb8004wjgtu532g70rf","_id":"cixrcdvbd0053jgtuprxzmyv2"},{"post_id":"cixrcdv95002zjgtuoqjq0d1y","tag_id":"cixrcdvbc0052jgtuzg73t82y","_id":"cixrcdvbe0055jgtu61pz4v2y"},{"post_id":"cixrcdv960031jgtucwua3ksq","tag_id":"cixrcdvbe0054jgtuyy11oyt8","_id":"cixrcdvbg0057jgtu2vm7w1yb"},{"post_id":"cixrcdv980032jgtufjjtqsle","tag_id":"cixrcdvbf0056jgtuas4iaioy","_id":"cixrcdvbh0059jgtubkbp4d28"},{"post_id":"cixrcdv9b0035jgtu0bp282sl","tag_id":"cixrcdvbg0058jgtusvgtsfl1","_id":"cixrcdvbk005bjgtue65s9on6"},{"post_id":"cixrcdv9d0036jgtujwqao8vj","tag_id":"cixrcdvb8004wjgtu532g70rf","_id":"cixrcdvbn005djgtu11wgvs3a"},{"post_id":"cixrcdv9f0038jgtuj7sij5t8","tag_id":"cixrcdvbl005cjgtumcdb081x","_id":"cixrcdvbp005fjgtuxd2tqxzv"},{"post_id":"cixrcdv9i003ajgtur3ywgwj4","tag_id":"cixrcdvbo005ejgtuswlgsd3j","_id":"cixrcdvbq005hjgtu3t2moh6h"},{"post_id":"cixrcdv9l003cjgtu6fvu7dn6","tag_id":"cixrcdvbp005gjgtuqgr5hw24","_id":"cixrcdvbr005jjgtu31v7z81u"},{"post_id":"cixrcdv9m003ejgtus8t6u7l1","tag_id":"cixrcdvbp005gjgtuqgr5hw24","_id":"cixrcdvbt005ljgtumsf6rfc8"},{"post_id":"cixrcdv9p003gjgtuh35q4nbb","tag_id":"cixrcdvbp005gjgtuqgr5hw24","_id":"cixrcdvbv005njgtu15ue1tk3"},{"post_id":"cixrcdv9s003ijgtuny5lyyfi","tag_id":"cixrcdvbp005gjgtuqgr5hw24","_id":"cixrcdvbx005pjgtu2grsoyb3"},{"post_id":"cixrcdv9t003jjgtu53t1mqaq","tag_id":"cixrcdvbp005gjgtuqgr5hw24","_id":"cixrcdvbz005rjgtu0ikabw21"},{"post_id":"cixrcdv9w003mjgtu8a87pldm","tag_id":"cixrcdvbx005qjgtumfoimgjj","_id":"cixrcdvc2005tjgtue3ljklk6"},{"post_id":"cixrcdv9y003njgtuhe1udgeo","tag_id":"cixrcdvc1005sjgtuq70mynly","_id":"cixrcdvc4005vjgtubrbl4csc"},{"post_id":"cixrcdva5003rjgtuqighgxsk","tag_id":"cixrcdvc2005ujgtucpofscsx","_id":"cixrcdvc4005wjgturbujue5c"},{"post_id":"cixtsystn0000pktup10kvynw","tag_id":"cixtsysuf0002pktu1zgp2tf9","_id":"cixtsysvw0007pktu8xeg9x20"},{"post_id":"cixtsysu60001pktu0nqlsbyw","tag_id":"cixtsysvu0006pktuau77c8df","_id":"cixtsysw00009pktui0mdccim"},{"post_id":"cixtsysvj0003pktu5uf51ejp","tag_id":"cixtsysvy0008pktu9eocblkj","_id":"cixtsysw3000bpktu7e9v2z79"},{"post_id":"cixtsysvm0004pktuzafgot5w","tag_id":"cixtsysw1000apktuldywejgr","_id":"cixtsysw5000dpktum0y716fk"},{"post_id":"cixtsysvq0005pktu5t7fwlsc","tag_id":"cixtsysw4000cpktut8gvi0al","_id":"cixtsysw7000epktuit6dldpq"},{"post_id":"cixzjjbk80000mgtuzim1mpsj","tag_id":"cixzjjbkx0002mgtuxryjzaqg","_id":"cixzjjbm40007mgtu8t9x69kf"},{"post_id":"cixzjjbkr0001mgtufk234wo1","tag_id":"cixzjjbm20006mgtu5rnlxazn","_id":"cixzjjbmf000cmgtumnmd9esh"},{"post_id":"cixzjjblt0003mgtumuqfp1gi","tag_id":"cixzjjbmc000amgtuu1kbk79d","_id":"cixzjjbml000fmgtubvxsugj8"},{"post_id":"cixzjjblx0004mgtuj32v3bv0","tag_id":"cixzjjbmj000emgtug3jcnvbm","_id":"cixzjjbmp000hmgtut3qpqzu1"},{"post_id":"cixzjjbm00005mgtuwztv5gsg","tag_id":"cixzjjbmj000emgtug3jcnvbm","_id":"cixzjjbms000jmgtug5p5cc85"},{"post_id":"cixzjjbm60008mgtudd00nvn6","tag_id":"cixzjjbmq000imgtuuxjlt6p8","_id":"cixzjjbmu000lmgtuydk6st7d"},{"post_id":"cixzjjbm90009mgtu25lcypq6","tag_id":"cixzjjbmj000emgtug3jcnvbm","_id":"cixzjjbmx000nmgtuvsuwef2c"},{"post_id":"cixzjjbme000bmgtuwytvfcpv","tag_id":"cixzjjbmj000emgtug3jcnvbm","_id":"cixzjjbmz000pmgtuy88hhmyx"},{"post_id":"cixzjjbmg000dmgtumj3yflg3","tag_id":"cixzjjbmj000emgtug3jcnvbm","_id":"cixzjjbn0000qmgtul22do4oq"},{"post_id":"cixzjjbnh000rmgtuoxf3zzdw","tag_id":"cixzjjbnj000smgtub4trirhu","_id":"cixzjjbnl000tmgtuxkeay7an"},{"post_id":"ciyr1umvi00005gtu91sderd8","tag_id":"ciyr1umw700025gtugd0lw7vm","_id":"ciyr1umy000075gtuq79g7afq"},{"post_id":"ciyr1umw100015gtun2vjcwpz","tag_id":"ciyr1umxy00065gtu5vzedqpn","_id":"ciyr1umy300095gtueypsezda"},{"post_id":"ciyr1umxm00035gtu4kwzdtl1","tag_id":"ciyr1umy100085gtuulaj7dma","_id":"ciyr1umy6000b5gtuadyhz82q"},{"post_id":"ciyr1umxr00045gtujgll01lk","tag_id":"ciyr1umy4000a5gtuplzck9v8","_id":"ciyr1umy9000d5gtunw1gxd62"},{"post_id":"ciyr1umxu00055gtu0lfhg7if","tag_id":"ciyr1umy7000c5gtu26ysf56q","_id":"ciyr1umya000e5gtux589cymc"},{"post_id":"ciyxtqwuf0000istu10i1mcd9","tag_id":"ciyxtqwv00002istu3ax1m8db","_id":"ciyxtqww60007istupicefqqw"},{"post_id":"ciyxtqwus0001istujbb9erty","tag_id":"ciyxtqww40006istu863qhw90","_id":"ciyxtqwwd000aistuzl9e0b0k"},{"post_id":"ciyxtqwvx0003istue21zooqv","tag_id":"ciyxtqwwc0009istuovzhnvvy","_id":"ciyxtqwwf000cistumovuvvz2"},{"post_id":"ciyxtqww00004istu5723lfkq","tag_id":"ciyxtqwwe000bistuaocgwxtd","_id":"ciyxtqwwh000eistuewpnc7ol"},{"post_id":"ciyxtqww20005istuy0agsri4","tag_id":"ciyxtqwwg000distu7vlxgkqw","_id":"ciyxtqwwl000gistufsbbvopd"},{"post_id":"ciyxtqww70008istucf0niihh","tag_id":"ciyxtqwwg000distu7vlxgkqw","_id":"ciyxtqwwm000histuncb37r95"},{"post_id":"ciyxtqwx0000iistucimuak3p","tag_id":"ciyxtqwwg000distu7vlxgkqw","_id":"ciyxtqwx3000jistuv09237pr"},{"post_id":"cizpcu9rz0004fctut4j8atre","tag_id":"cixrcdv560003jgtuv7g7hxtc","_id":"cizpcu9s40007fcturu65h5ts"},{"post_id":"cizpcu9qr0000fctuxu27f307","tag_id":"cizpcu9r80002fctu0xytopul","_id":"cizpcu9s70009fctudtasakqu"},{"post_id":"cizpcu9s50008fctu9ughd0tu","tag_id":"cixrcdv560003jgtuv7g7hxtc","_id":"cizpcu9sa000bfctu9ht535ph"},{"post_id":"cizpcu9r30001fctuizhk7971","tag_id":"cizpcu9s20006fctuzj9pu61w","_id":"cizpcu9sb000cfctu5fnseioo"},{"post_id":"cizpcu9rw0003fctuxnikml1s","tag_id":"cizpcu9s9000afctu1vx4jtp1","_id":"cizpcu9sc000efctu971d8pmy"},{"post_id":"cizpcu9s10005fctudxo629hl","tag_id":"cizpcu9sb000dfctuur4gef52","_id":"cizpcu9se000ffctuixh9mer0"},{"post_id":"cizpcu9sn000gfcturm3msurk","tag_id":"cizpcu9sp000hfctu3prqmw87","_id":"cizpcu9sq000ifctucehlrp6h"}],"Tag":[{"name":"生活","_id":"cixrcdv560003jgtuv7g7hxtc"},{"name":"js继承","_id":"cixrcdv5h0007jgtufllny146"},{"name":"ES6、promise","_id":"cixrcdv5s000bjgtulbo8t1to"},{"name":"es5 js","_id":"cixrcdv5x000gjgtu6zj25zcm"},{"name":"Jenkins CI","_id":"cixrcdv64000kjgtujh2kg1x1"},{"name":"angular、Karma","_id":"cixrcdv6g000pjgtucos7li20"},{"name":"angular decorator","_id":"cixrcdv6n000tjgtu1vkdiyc6"},{"name":"angular 服务","_id":"cixrcdv6t000xjgtuxhndfscm"},{"name":"angular、module、controller","_id":"cixrcdv6z0011jgtuie0skbbl"},{"name":"angular、$http","_id":"cixrcdv750016jgtu914uk3uz"},{"name":"angular、promise、$q、deferred","_id":"cixrcdv7a001ajgtulr3s9pp2"},{"name":"angular、表达式、filter","_id":"cixrcdv7g001fjgtuu5jx6bmb"},{"name":"angular、directive","_id":"cixrcdv7k001jjgtuxm50g5ic"},{"name":"angular、html5","_id":"cixrcdv7q001ojgtui1rx6f0n"},{"name":"angular $q promise","_id":"cixrcdv7u001sjgtupd1k2afa"},{"name":"angular $http $q promise","_id":"cixrcdv7y001wjgtuu2joheqw"},{"name":"angular、router","_id":"cixrcdv820020jgtu537w59ha"},{"name":"angular","_id":"cixrcdv890025jgtuqdzhs4q6"},{"name":"angular、ui-router","_id":"cixrcdv8d0029jgtuh4cnxy3c"},{"name":"js Array","_id":"cixrcdv8i002djgtuj99kswuf"},{"name":"js、变态题","_id":"cixrcdv8m002hjgtuac98cwky"},{"name":"blockchain","_id":"cixrcdv8r002mjgtuoomz72af"},{"name":"app,跨平台","_id":"cixrcdv8w002qjgtuzbozpx2z"},{"name":"js 柯里化","_id":"cixrcdv90002ujgtuvxfjsua5"},{"name":"前端脚手架","_id":"cixrcdv94002yjgtuxxsrxsea"},{"name":"mongoDB 数据库","_id":"cixrcdv990033jgtu9na1humt"},{"name":"wechat","_id":"cixrcdv9e0037jgtuljcixp0q"},{"name":"angular filter","_id":"cixrcdv9k003bjgtunl8ei6p3"},{"name":"js、跨域、document.domain","_id":"cixrcdv9o003fjgtuoe3tlcl4"},{"name":"js Higher-order-function","_id":"cixrcdv9v003kjgtu5clt5yeo"},{"name":"git github","_id":"cixrcdva0003ojgtujit2vydp"},{"name":"angularjs","_id":"cixrcdva7003sjgtupvgynh48"},{"name":"路由 html5","_id":"cixrcdvac003wjgtuiv8abq6u"},{"name":"js、设计模式","_id":"cixrcdvae003yjgtugvmmlvke"},{"name":"H5、bug","_id":"cixrcdvag0040jgtuh93r1yem"},{"name":"iframe","_id":"cixrcdvaq0042jgtuqostqzan"},{"name":"移动端、fixed","_id":"cixrcdvar0044jgtu3oey4nj5"},{"name":"解构赋值 es6","_id":"cixrcdvat0046jgtub7zz6jd8"},{"name":"jquery","_id":"cixrcdvau0048jgtua6js3vy0"},{"name":"js模块化、AMD、CMD、CommonJs","_id":"cixrcdvav004ajgtub5k35cya"},{"name":"js sea.js 模块化","_id":"cixrcdvaw004cjgtu343pgbkz"},{"name":"life、意念","_id":"cixrcdvax004ejgtun7wq71ly"},{"name":"mvp","_id":"cixrcdvax004gjgtutfyoghqv"},{"name":"node debug","_id":"cixrcdvay004ijgtultkz0jdl"},{"name":"node","_id":"cixrcdvaz004kjgtuucpvssoc"},{"name":"跨域、postMessage、html5","_id":"cixrcdvb2004ojgtun1jos2sd"},{"name":"javascript、object-oriented、继承","_id":"cixrcdvb4004qjgtufyttojz0"},{"name":"js 纯函数","_id":"cixrcdvb5004sjgtucosndust"},{"name":"前后端分享","_id":"cixrcdvb7004ujgtuczyln9lj"},{"name":"rap","_id":"cixrcdvb8004wjgtu532g70rf"},{"name":"react ant-design","_id":"cixrcdvbc0052jgtuzg73t82y"},{"name":"react","_id":"cixrcdvbe0054jgtuyy11oyt8"},{"name":"JS设计模式 设计模式","_id":"cixrcdvbf0056jgtuas4iaioy"},{"name":"markdown","_id":"cixrcdvbg0058jgtusvgtsfl1"},{"name":"web、前端","_id":"cixrcdvbl005cjgtumcdb081x"},{"name":"web、性能优化","_id":"cixrcdvbo005ejgtuswlgsd3j"},{"name":"node wechat","_id":"cixrcdvbp005gjgtuqgr5hw24"},{"name":"win10、linux","_id":"cixrcdvbx005qjgtumfoimgjj"},{"name":"window.history html5","_id":"cixrcdvc1005sjgtuq70mynly"},{"name":"人生","_id":"cixrcdvc2005ujgtucpofscsx"},{"name":"Lodash","_id":"cixtsysuf0002pktu1zgp2tf9"},{"name":"js lodash","_id":"cixtsysvu0006pktuau77c8df"},{"name":"lodash chain","_id":"cixtsysvy0008pktu9eocblkj"},{"name":"nodejs","_id":"cixtsysw1000apktuldywejgr"},{"name":"yarn npm","_id":"cixtsysw4000cpktut8gvi0al"},{"name":"aso","_id":"cixzjjbkx0002mgtuxryjzaqg"},{"name":"seo 新闻源","_id":"cixzjjbm20006mgtu5rnlxazn"},{"name":"web","_id":"cixzjjbmc000amgtuu1kbk79d"},{"name":"seo","_id":"cixzjjbmj000emgtug3jcnvbm"},{"name":"建站 seo","_id":"cixzjjbmq000imgtuuxjlt6p8"},{"name":"web 交互","_id":"cixzjjbnj000smgtub4trirhu"},{"name":"debugger","_id":"ciyr1umw700025gtugd0lw7vm"},{"name":"fit","_id":"ciyr1umxy00065gtu5vzedqpn"},{"name":"H5 移动端优化","_id":"ciyr1umy100085gtuulaj7dma"},{"name":"wechat webstorm","_id":"ciyr1umy4000a5gtuplzck9v8"},{"name":"性能优化","_id":"ciyr1umy7000c5gtu26ysf56q"},{"name":"js this","_id":"ciyxtqwv00002istu3ax1m8db"},{"name":"js closure","_id":"ciyxtqww40006istu863qhw90"},{"name":"flex css","_id":"ciyxtqwwc0009istuovzhnvvy"},{"name":"js scope","_id":"ciyxtqwwe000bistuaocgwxtd"},{"name":"wxapp","_id":"ciyxtqwwg000distu7vlxgkqw"},{"name":"js","_id":"cizpcu9r80002fctu0xytopul"},{"name":"Benchmark jsPerf","_id":"cizpcu9s20006fctuzj9pu61w"},{"name":"js object","_id":"cizpcu9s9000afctu1vx4jtp1"},{"name":"js 性能调试","_id":"cizpcu9sb000dfctuur4gef52"},{"name":"h5 webworkers","_id":"cizpcu9sp000hfctu3prqmw87"}]}}