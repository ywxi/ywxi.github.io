<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>闫文喜的个人前端博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="闫文喜 前端博客 web前端博客  web前端开发">
<meta property="og:type" content="website">
<meta property="og:title" content="闫文喜的个人前端博客">
<meta property="og:url" content="http://yoursite.com/page/10/index.html">
<meta property="og:site_name" content="闫文喜的个人前端博客">
<meta property="og:description" content="闫文喜 前端博客 web前端博客  web前端开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="闫文喜的个人前端博客">
<meta name="twitter:description" content="闫文喜 前端博客 web前端博客  web前端开发">
  
    <link rel="alternative" href="/atom.xml" title="闫文喜的个人前端博客" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">前端在路上</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/about">关于我</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/yanwenxi" title="github">github</a>
					        
								<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="mail">mail</a>
					        
								<a class="qq" target="_blank" href="http://www.webywx.com" title="qq">qq</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Benchmark-jsPerf/" style="font-size: 10px;">Benchmark jsPerf</a> <a href="/tags/ES6、promise/" style="font-size: 10px;">ES6、promise</a> <a href="/tags/H5-移动端优化/" style="font-size: 10px;">H5 移动端优化</a> <a href="/tags/H5、bug/" style="font-size: 10px;">H5、bug</a> <a href="/tags/JS设计模式-设计模式/" style="font-size: 10px;">JS设计模式 设计模式</a> <a href="/tags/Jenkins-CI/" style="font-size: 10px;">Jenkins CI</a> <a href="/tags/Lodash/" style="font-size: 10px;">Lodash</a> <a href="/tags/angular/" style="font-size: 10px;">angular</a> <a href="/tags/angular-http-q-promise/" style="font-size: 10px;">angular $http $q promise</a> <a href="/tags/angular-q-promise/" style="font-size: 10px;">angular $q promise</a> <a href="/tags/angular-decorator/" style="font-size: 10px;">angular decorator</a> <a href="/tags/angular-filter/" style="font-size: 10px;">angular filter</a> <a href="/tags/angular-服务/" style="font-size: 10px;">angular 服务</a> <a href="/tags/angularjs/" style="font-size: 10px;">angularjs</a> <a href="/tags/angular、-http/" style="font-size: 10px;">angular、$http</a> <a href="/tags/angular、Karma/" style="font-size: 10px;">angular、Karma</a> <a href="/tags/angular、directive/" style="font-size: 10px;">angular、directive</a> <a href="/tags/angular、html5/" style="font-size: 10px;">angular、html5</a> <a href="/tags/angular、module、controller/" style="font-size: 10px;">angular、module、controller</a> <a href="/tags/angular、promise、-q、deferred/" style="font-size: 10px;">angular、promise、$q、deferred</a> <a href="/tags/angular、router/" style="font-size: 10px;">angular、router</a> <a href="/tags/angular、ui-router/" style="font-size: 10px;">angular、ui-router</a> <a href="/tags/angular、表达式、filter/" style="font-size: 10px;">angular、表达式、filter</a> <a href="/tags/app-跨平台/" style="font-size: 10px;">app,跨平台</a> <a href="/tags/aso/" style="font-size: 10px;">aso</a> <a href="/tags/blockchain/" style="font-size: 10px;">blockchain</a> <a href="/tags/debugger/" style="font-size: 10px;">debugger</a> <a href="/tags/es5-js/" style="font-size: 10px;">es5 js</a> <a href="/tags/fit/" style="font-size: 10px;">fit</a> <a href="/tags/flex-css/" style="font-size: 10px;">flex css</a> <a href="/tags/git-github/" style="font-size: 10px;">git github</a> <a href="/tags/h5-webworkers/" style="font-size: 10px;">h5 webworkers</a> <a href="/tags/iframe/" style="font-size: 10px;">iframe</a> <a href="/tags/javascript、object-oriented、继承/" style="font-size: 10px;">javascript、object-oriented、继承</a> <a href="/tags/jquery/" style="font-size: 10px;">jquery</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/js-Array/" style="font-size: 10px;">js Array</a> <a href="/tags/js-Higher-order-function/" style="font-size: 10px;">js Higher-order-function</a> <a href="/tags/js-closure/" style="font-size: 10px;">js closure</a> <a href="/tags/js-lodash/" style="font-size: 10px;">js lodash</a> <a href="/tags/js-object/" style="font-size: 10px;">js object</a> <a href="/tags/js-scope/" style="font-size: 10px;">js scope</a> <a href="/tags/js-sea-js-模块化/" style="font-size: 10px;">js sea.js 模块化</a> <a href="/tags/js-this/" style="font-size: 10px;">js this</a> <a href="/tags/js-性能调试/" style="font-size: 10px;">js 性能调试</a> <a href="/tags/js-柯里化/" style="font-size: 10px;">js 柯里化</a> <a href="/tags/js-纯函数/" style="font-size: 10px;">js 纯函数</a> <a href="/tags/js、变态题/" style="font-size: 10px;">js、变态题</a> <a href="/tags/js、设计模式/" style="font-size: 10px;">js、设计模式</a> <a href="/tags/js、跨域、document-domain/" style="font-size: 10px;">js、跨域、document.domain</a> <a href="/tags/js模块化、AMD、CMD、CommonJs/" style="font-size: 10px;">js模块化、AMD、CMD、CommonJs</a> <a href="/tags/js继承/" style="font-size: 12px;">js继承</a> <a href="/tags/life、意念/" style="font-size: 10px;">life、意念</a> <a href="/tags/lodash-chain/" style="font-size: 10px;">lodash chain</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mongoDB-数据库/" style="font-size: 10px;">mongoDB 数据库</a> <a href="/tags/mvp/" style="font-size: 10px;">mvp</a> <a href="/tags/node/" style="font-size: 12px;">node</a> <a href="/tags/node-debug/" style="font-size: 10px;">node debug</a> <a href="/tags/node-wechat/" style="font-size: 18px;">node wechat</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/rap/" style="font-size: 16px;">rap</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/react-ant-design/" style="font-size: 10px;">react ant-design</a> <a href="/tags/seo/" style="font-size: 18px;">seo</a> <a href="/tags/seo-新闻源/" style="font-size: 10px;">seo 新闻源</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/web-交互/" style="font-size: 10px;">web 交互</a> <a href="/tags/web、前端/" style="font-size: 10px;">web、前端</a> <a href="/tags/web、性能优化/" style="font-size: 10px;">web、性能优化</a> <a href="/tags/wechat/" style="font-size: 10px;">wechat</a> <a href="/tags/wechat-webstorm/" style="font-size: 10px;">wechat webstorm</a> <a href="/tags/win10、linux/" style="font-size: 10px;">win10、linux</a> <a href="/tags/window-history-html5/" style="font-size: 10px;">window.history html5</a> <a href="/tags/wxapp/" style="font-size: 14px;">wxapp</a> <a href="/tags/yarn-npm/" style="font-size: 10px;">yarn npm</a> <a href="/tags/人生/" style="font-size: 10px;">人生</a> <a href="/tags/前后端分享/" style="font-size: 10px;">前后端分享</a> <a href="/tags/前端脚手架/" style="font-size: 10px;">前端脚手架</a> <a href="/tags/建站-seo/" style="font-size: 10px;">建站 seo</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/生活/" style="font-size: 20px;">生活</a> <a href="/tags/移动端、fixed/" style="font-size: 10px;">移动端、fixed</a> <a href="/tags/解构赋值-es6/" style="font-size: 10px;">解构赋值 es6</a> <a href="/tags/跨域、postMessage、html5/" style="font-size: 10px;">跨域、postMessage、html5</a> <a href="/tags/路由-html5/" style="font-size: 10px;">路由 html5</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.webywx.com/">前端博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.yanwenxi.site/">web小站</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">前端在路上</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">前端在路上</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/about">关于我</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/yanwenxi" title="github">github</a>
			        
						<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="mail">mail</a>
			        
						<a class="qq" target="_blank" href="http://www.webywx.com" title="qq">qq</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-aboutme" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/25/aboutme/" class="article-date">
  	<time datetime="2015-10-25T10:44:51.000Z" itemprop="datePublished">2015-10-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/25/aboutme/">
        keep real，be myself
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="我就是我，不一样的烟火"><a href="#我就是我，不一样的烟火" class="headerlink" title="我就是我，不一样的烟火"></a>我就是我，不一样的烟火</h2><p>我是英俊潇洒、玉树临风、天下无敌、人见人爱、花见花开、气死潘安、羞死宋玉、号称一朵梨花压海棠、宇宙第一高手,人送绰号玉面小鲜肉、山崩地裂水倒流鬼见愁、美貌与智慧结合、英雄与侠义化身——Scorpio~~~~哈哈哈！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生活/">生活</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Object.create" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/23/Object.create/" class="article-date">
  	<time datetime="2015-10-23T15:06:26.000Z" itemprop="datePublished">2015-10-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/23/Object.create/">
        一种新的对象创建方式——Object.create()
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Object.create() 方法创建一个拥有指定原型和若干个指定属性的对象。</p>
<ol>
<li>语法<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object.create(proto, [ propertiesObject ])</div></pre></td></tr></table></figure>
</li>
</ol>
<p>参数proto：一个对象，作为新创建对象的原型。如果 proto 参数不是 null 或一个对象值，则抛出一个 TypeError 异常。<br>propertiesObject：可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符。注意：该参数对象不能是 undefined，另外只有该对象中自身拥有的可枚举的属性才有效，也就是说该对象的原型链上属性是无效的。</p>
<h4 id="使用Object-create实现类式继承"><a href="#使用Object-create实现类式继承" class="headerlink" title="使用Object.create实现类式继承"></a>使用Object.create实现类式继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//Shape - superclass</div><div class="line">function Shape() &#123;</div><div class="line">  this.x = 0;</div><div class="line">  this.y = 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Shape.prototype.move = function(x, y) &#123;</div><div class="line">    this.x += x;</div><div class="line">    this.y += y;</div><div class="line">    console.info(&quot;Shape moved.&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// Rectangle - subclass</div><div class="line">function Rectangle() &#123;</div><div class="line">  Shape.call(this); //call super constructor.</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype = Object.create(Shape.prototype);</div><div class="line"></div><div class="line">var rect = new Rectangle();</div><div class="line"></div><div class="line">rect instanceof Rectangle //true.</div><div class="line">rect instanceof Shape //true.</div><div class="line"></div><div class="line">rect.move(1, 1); //Outputs, &quot;Shape moved.&quot;</div></pre></td></tr></table></figure>
<h4 id="使用Object-create-的-propertyObject-参数"><a href="#使用Object-create-的-propertyObject-参数" class="headerlink" title="使用Object.create 的 propertyObject 参数"></a>使用Object.create 的 propertyObject 参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">var o;</div><div class="line"></div><div class="line">// 创建一个原型为null的空对象</div><div class="line">o = Object.create(null);</div><div class="line"></div><div class="line"></div><div class="line">o = &#123;&#125;;</div><div class="line">// 以字面量方式创建的空对象就相当于:</div><div class="line">o = Object.create(Object.prototype);</div><div class="line"></div><div class="line"></div><div class="line">o = Object.create(Object.prototype, &#123;</div><div class="line">  // foo会成为所创建对象的数据属性</div><div class="line">  foo: &#123; writable:true, configurable:true, value: &quot;hello&quot; &#125;,</div><div class="line">  // bar会成为所创建对象的访问器属性</div><div class="line">  bar: &#123;</div><div class="line">    configurable: false,</div><div class="line">    get: function() &#123; return 10 &#125;,</div><div class="line">    set: function(value) &#123; console.log(&quot;Setting `o.bar` to&quot;, value) &#125;</div><div class="line">&#125;&#125;)</div><div class="line"></div><div class="line"></div><div class="line">function Constructor()&#123;&#125;</div><div class="line">o = new Constructor();</div><div class="line">// 上面的一句就相当于:</div><div class="line">o = Object.create(Constructor.prototype);</div><div class="line">// 当然,如果在Constructor函数中有一些初始化代码,Object.create不能执行那些代码</div><div class="line"></div><div class="line"></div><div class="line">// 创建一个以另一个空对象为原型,且拥有一个属性p的对象</div><div class="line">o = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;)</div><div class="line"></div><div class="line">// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:</div><div class="line">o.p = 24</div><div class="line">o.p</div><div class="line">//42</div><div class="line"></div><div class="line">o.q = 12</div><div class="line">for (var prop in o) &#123;</div><div class="line">   console.log(prop)</div><div class="line">&#125;</div><div class="line">//&quot;q&quot;</div><div class="line"></div><div class="line">delete o.p</div><div class="line">//false</div><div class="line"></div><div class="line">//创建一个可写的,可枚举的,可配置的属性p</div><div class="line">o2 = Object.create(&#123;&#125;, &#123; p: &#123; value: 42, writable: true, enumerable: true, configurable: true &#125; &#125;);</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es5-js/">es5 js</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-6jicheng" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/15/6jicheng/" class="article-date">
  	<time datetime="2015-10-15T06:12:39.000Z" itemprop="datePublished">2015-10-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/15/6jicheng/">
        js学习--6种继承方式
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>js中常用的继承方式: 子类继承父类的方法：</p>
<h3 id="1、原型继承"><a href="#1、原型继承" class="headerlink" title="1、原型继承"></a>1、原型继承</h3><p>子类的原型指向父类的一个实例  父类的私有和公有方法都是子类的公有方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function A()&#123;</div><div class="line">    this.x = 100;</div><div class="line">    this.y = 100;</div><div class="line">&#125;</div><div class="line">A.prototype.getX = function ()&#123;&#125;</div><div class="line"></div><div class="line">function B()&#123;</div><div class="line">    this.x = 100;</div><div class="line">&#125;</div><div class="line">B.prototype = new A(); //B的原型重新赋值A的实例==&gt;每个b实例都能通过自己的__proto__找到a上的所有的私有方法，并且还可以通过a.__proto__继续找到A.prototype上的所有属性 ==&gt; A这个类上的方法相对于B都是公有方法</div><div class="line">B.prototype.constructor = B; //由于重新修改了B的原型导致默认原型上的constructor丢失，我们需要自己添加上</div></pre></td></tr></table></figure></p>
<h3 id="2、call继承"><a href="#2、call继承" class="headerlink" title="2、call继承"></a>2、call继承</h3><p>在子类构造函数中 父类.call(this)  父类的私有变成子类的私有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function C()&#123;</div><div class="line">    this.x = 100; //d.x = 100</div><div class="line">&#125;</div><div class="line">C.prototype.getX = function ()&#123;&#125;;</div><div class="line">function D()&#123;</div><div class="line">    C.call(this); //构造函数中的this就是当前实例  this ==&gt; d     C.call(d);  ==&gt; 把C中的this修改成d</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3、冒充对象继承"><a href="#3、冒充对象继承" class="headerlink" title="3、冒充对象继承"></a>3、冒充对象继承</h3><p>循环遍历父类实例，然后父类实例的私有方法全部拿过来添加给子类实，如果不做hasOwnProperty判断那么就是把父类的公有的和私有的都拿过来当私有的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function E()&#123;</div><div class="line">    this.x = 100;</div><div class="line">    this.y = 200;</div><div class="line">&#125;</div><div class="line">E.prototype.getX = function ()&#123;&#125;</div><div class="line">function F()&#123;</div><div class="line">    var e = new E(); //e.x = 100;</div><div class="line">    for(var attr in e)&#123; //for in可以遍历到原型上的公有自定义属性</div><div class="line">        //attr = x</div><div class="line">        if(e.hasOwnProperty(attr))&#123; //如果这个判断不加，那么无论是公有的还是私有的都拿过来当私有的</div><div class="line">            this[attr] = e[attr];</div><div class="line">            //f[&apos;x&apos;] = e[&apos;x&apos;] ==&gt; f.x = 100;</div><div class="line">        &#125;</div><div class="line">        // e.propertyIsEnumerable() //可枚举属性  ==&gt; 简单理解：可以拿出来一一列举的属性</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-混合继承"><a href="#4-混合继承" class="headerlink" title="4 混合继承"></a>4 混合继承</h3><p>原型+call  ==&gt; 无论是私有的还是公有的都拿过来了 ==&gt; 子类的原型上的多了一套父类私有属但是不会产生问题。因为子类的私有属性也有一套相同的通过call继承拿过来的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function G()&#123;</div><div class="line">    this.x = 100;</div><div class="line">&#125;</div><div class="line">G.prototype.getX = function()&#123;&#125;;</div><div class="line">function H()&#123;</div><div class="line">    G.call(this);</div><div class="line">&#125;</div><div class="line">H.prototype = new G();</div><div class="line">H.prototype.constructor = H;</div></pre></td></tr></table></figure></p>
<h3 id="5-中间件继承"><a href="#5-中间件继承" class="headerlink" title="5 中间件继承"></a>5 中间件继承</h3><p>M.prototype.<strong>proto</strong> = K.prototype;  把父类的公有的当作子类的公有的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function K()&#123;</div><div class="line">    this.x = 100;</div><div class="line">&#125;</div><div class="line">k.prototype.getX = function ()&#123;&#125;;</div><div class="line">function M()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">M.prototype.__proto__ = K.prototype; //本来应该是直接指向Object.prototype。从K的原型上的__proto__也可以到Object.prototype==&gt; 在K.prototype上停留了下，K.prototype就是一个中间件  父类的公有当作子类的公有</div></pre></td></tr></table></figure></p>
<h3 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6 寄生组合式继承"></a>6 寄生组合式继承</h3><p> Object.create(xx.prototype)方法  ==&gt; 是把xx.prototype当作别人家的原型  不兼容，只能找到父类原型的方法。父类的私有属性访问不到。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Parent() &#123;</div><div class="line">    this.name = &quot;ywx&quot;;</div><div class="line">&#125;</div><div class="line">Parent.prototype.eat = function () &#123;</div><div class="line">    console.log(123);</div><div class="line">&#125;;</div><div class="line">function Child() &#123;&#125;</div><div class="line">//寄生组合式继承实现方式如下：</div><div class="line">Child.prototype = Object.create(Parent.prototype);</div><div class="line">var child=new Child();</div><div class="line">console.log(child.eat());//只有找到父类原型上的方法</div></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js继承/">js继承</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-qianduanxijie" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/29/qianduanxijie/" class="article-date">
  	<time datetime="2015-09-29T03:20:27.000Z" itemprop="datePublished">2015-09-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/29/qianduanxijie/">
        前端人员应注意的几点细节
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>合格前端开发工程师应该注意一些网页制作细节问题。细节如下：</p>
<h4 id="一、缺少网站必备的三要素"><a href="#一、缺少网站必备的三要素" class="headerlink" title="一、缺少网站必备的三要素"></a>一、缺少网站必备的三要素</h4><p>可能很多人做网站，都是直接用DW或者其它工具生成的网页，网站只有一个title。而缺少keywords(关键词)、description（描述）。为什么一个网页要加这三要素呢？可能很多人都不是很明白。因为我们所做出来的网站是为了做SEO优化的，为了提升网站在百度和其它搜索引擎的排名。如果没这三要素，请问你的网站怎么去做排名，又怎么去盈利呢？</p>
<div align="center"><br>    <img src="http://oi28tswuq.bkt.clouddn.com/images/sitesanyaosu.png-public" alt=""><br></div>

<h4 id="二、代码方面"><a href="#二、代码方面" class="headerlink" title="二、代码方面"></a>二、代码方面</h4><p>1.给代码加注释<br>身为一个合格的web前端人员，我认为首先第一点：得为html代码加注释，为什么说要给html代码加注释呢？是为了给后台程序人员写动态网页节省工作量，如果说你整个网页都没加注释，别人又怎么知道你这段代码表示的是什么？别人还要重新去了解你这段代码的意思是什么，是不是无意间给别人增加了工作量。以后前后端分离了就没有这么麻烦了，期待那一天的到来。</p>
<p>2.代码命名<br>在代码命名上，我们最好采用见名知意的英语单词，或者拼音简写来命名。让别人第一眼看你带就觉得你是一个专业的人士，而并非业余人员。比如：头部：header 尾部：footer 内容：content 关于我们：about….</p>
<p>3.代码美化上<br>在代码美化上，我觉得做到最好让别人一眼就可以看出来你这块是表明的是什么。</p>
<p>4.图片优化上<br>很多人可能对插入一张图片，就只有一个src(引用地址)。而缺少其它三大属性。一个<img>标签，包含四大要素，分别为：src(引用地址)、width(宽度)、height（高度）、alt(描述)，alt描述也是最为重要的一点。因为搜索引擎不识别图片，只有靠alt属性来告诉搜索引擎这张图片代表什么含义。同时也符合SEO优化。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>其实不管是做什么事情，细节真的很重要。细节决定成败，在高手与高手的较量中，往往是细节方面的处理。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-object-oriented-js" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/23/object-oriented-js/" class="article-date">
  	<time datetime="2015-06-23T05:06:26.000Z" itemprop="datePublished">2015-06-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/23/object-oriented-js/">
        面向对象的javascript及js中6种继承方式
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="面向对象的javascript及js中6种继承方式"><a href="#面向对象的javascript及js中6种继承方式" class="headerlink" title="面向对象的javascript及js中6种继承方式"></a>面向对象的javascript及js中6种继承方式</h4><p>   javascript 没有提供传统的面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。<br>   编程语言按照数据类型大致可以为两类：一类是静态类型语言，另一类是动态类型语言。<br>   静态类型语言在编译时便已经确定变量的类型，而<strong>动态类型</strong>语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。<br>   静态类型语言有java，.net，c等等。动态语言类型有javascript。js是一门典型的动态类型语言。</p>
<h5 id="静态语言类型的优缺点："><a href="#静态语言类型的优缺点：" class="headerlink" title="静态语言类型的优缺点："></a>静态语言类型的优缺点：</h5><p>   优点：一是在编译时就能发现类型不匹配的错误。二是程序中规定了数据类型，编译器可以针对这些信息对程序进行一些优化工作，提高程序的执行速度。<br>   缺点：一是迫使程序员依照强契约来编写程序，为每个变量规定数据类型。二是类型的声明也会增加更多的代码。</p>
<h5 id="动态语言类型的优缺点："><a href="#动态语言类型的优缺点：" class="headerlink" title="动态语言类型的优缺点："></a>动态语言类型的优缺点：</h5><p>   优点：一是编写的代码数量会减少，使代码看起来更加简洁。<br>   缺点：无法保证变量的类型，从而在程序的运行期可能发生跟类型相关的错误。</p>
<h4 id="鸭子类型（duck-typing）"><a href="#鸭子类型（duck-typing）" class="headerlink" title="鸭子类型（duck typing）"></a>鸭子类型（duck typing）</h4><p>   在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。鸭子类型的通俗说法是：如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。利用鸭子类型的思想，不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程”。面向接口编程是设计模式中最重要的思想。<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//模拟鸭子类型小故事</div><div class="line">var duck=&#123;</div><div class="line">    duckSinging:function () &#123;</div><div class="line">        console.log(&quot;嘎嘎嘎&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">var chicken=&#123;</div><div class="line">    duckSinging:function () &#123;</div><div class="line">        console.log(&quot;嘎嘎嘎&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">var choir=[];</div><div class="line">var joinChoir=function (animal) &#123;</div><div class="line">    if(animal &amp;&amp; typeof animal.duckSinging===&quot;function&quot;)&#123;</div><div class="line">        choir.push(animal);</div><div class="line">        console.log(&apos;恭喜加入合唱团&apos;);</div><div class="line">        console.log(&apos;合唱团已有成员数量：&apos;+choir.length);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">joinChoir(duck);</div><div class="line">joinChoir(chicken);</div></pre></td></tr></table></figure></p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态的含义：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//一段多&quot;多态&quot;的javascript代码</div><div class="line">var makeSound=function (animal) &#123;</div><div class="line">    if(animal instanceof Duck)&#123;</div><div class="line">        console.log(&apos;嘎嘎嘎&apos;);</div><div class="line">    &#125;else if(animal instanceof Chicken)&#123;</div><div class="line">        console.log(&apos;咯咯咯&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">var Duck=function () &#123;&#125;;</div><div class="line">var Chicken=function () &#123;&#125;;</div><div class="line">makeSound(new Duck());//嘎嘎嘎</div><div class="line">makeSound(new Chicken());//咯咯咯</div></pre></td></tr></table></figure></p>
<p>多态背后的思想是将做什么和谁去做以及怎样去做分离开来，也就是将不变的事物和可以改变的事物分离开来。在这个小故事<br>中，动物都会叫，这是不变的，但是不同类的动物具体怎么叫是可变的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//把不变的抽离出来</div><div class="line">var makeSound=function (animal) &#123;</div><div class="line">    animal.sound();</div><div class="line">&#125;;</div><div class="line">var Duck=function () &#123;&#125;;</div><div class="line">Duck.prototype.sound=function () &#123;</div><div class="line">    console.log(&apos;gagaga&apos;);</div><div class="line">&#125;;</div><div class="line">var Chicken=function () &#123;&#125;;</div><div class="line">Chicken.prototype.sound=function () &#123;</div><div class="line">    console.log(&apos;gegege&apos;);</div><div class="line">&#125;;</div><div class="line">makeSound(new Duck());//嘎嘎嘎</div><div class="line">makeSound(new Chicken());//咯咯咯</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//好处就是以后可以任意追加其他小动物，而不用修改公共代码</div><div class="line">var Dog=function()&#123;&#125;;</div><div class="line">Dog.prototype.sound=function () &#123;</div><div class="line">    console.log(&apos;wangwangwang&apos;);</div><div class="line">&#125;;</div><div class="line">makeSound(new Dog());//wangwangwang</div></pre></td></tr></table></figure>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装的目的是将信息隐藏。在JS中，只能依赖变量的作用域来实现封装特性，除了es6提供的let、Symbol外，一般通过自执行函数（IIFE）来创建作用域。这种方式封装的是数据。<br>封装不仅仅是隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等。</p>
<h4 id="原型模式和基于原型继承的JS对象系统"><a href="#原型模式和基于原型继承的JS对象系统" class="headerlink" title="原型模式和基于原型继承的JS对象系统"></a>原型模式和基于原型继承的JS对象系统</h4><p>js中常用的6种继承方式，即子类继承父类的方法：</p>
<ol>
<li><p>原型继承<br>子类的原型指向父类的一个实例  父类的私有和公有方法都是子类的公有方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//原型继承</div><div class="line">function A()&#123;</div><div class="line">    this.x = 100;</div><div class="line">    this.y = 100;</div><div class="line">&#125;</div><div class="line">A.prototype.getX = function ()&#123;&#125;</div><div class="line"></div><div class="line">function B()&#123;</div><div class="line">    this.x = 100;</div><div class="line">&#125;</div><div class="line">B.prototype = new A(); //B的原型重新赋值A的实例==&gt;每个b实例都能通过自己的__proto__找到a上的所有的私有方法，并且还可以通过a.__proto__继续找到A.prototype上的所有属性 ==&gt; A这个类上的方法相对于B都是公有方法</div><div class="line">B.prototype.constructor = B; //由于重新修改了B的原型导致默认原型上的constructor丢失，我们需要自己添加上</div></pre></td></tr></table></figure>
</li>
<li><p>call继承<br>在子类构造函数中, 父类.call(this)  父类的私有变成子类的私有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// call继承</div><div class="line">function C()&#123;</div><div class="line">    this.x = 100; //d.x = 100</div><div class="line">&#125;</div><div class="line">C.prototype.getX = function ()&#123;&#125;;</div><div class="line">function D()&#123;</div><div class="line">    C.call(this); //构造函数中的this就是当前实例  this ==&gt; d     C.call(d);  ==&gt; 把C中的this修改成d</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>冒充对象继承<br>循环遍历父类实例，然后父类实例的私有方法全部拿过来添加给子类实例，如果不做hasOwnProperty判断那么就是把父类的公有的和私有的都拿过来当私有的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//冒充对象继承</div><div class="line">function E()&#123;</div><div class="line">    this.x = 100;</div><div class="line">    this.y = 200;</div><div class="line">&#125;</div><div class="line">E.prototype.getX = function ()&#123;&#125;</div><div class="line">function F()&#123;</div><div class="line">    var e = new E(); //e.x = 100;</div><div class="line">    for(var attr in e)&#123; //for in可以遍历到原型上的公有自定义属性</div><div class="line">        //attr = x</div><div class="line">        if(e.hasOwnProperty(attr))&#123; //如果这个判断不加，那么无论是公有的还是私有的都拿过来当私有的</div><div class="line">            this[attr] = e[attr];//???  f[&apos;x&apos;] = e[&apos;x&apos;] ==&gt; f.x = 100;</div><div class="line">        &#125;</div><div class="line">        // e.propertyIsEnumerable() //可枚举属性  ==&gt; 可以拿出来一一列举的属性</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>混合继承<br>原型+call  ==&gt; 无论是私有的还是公有的都拿过来了 ==&gt; 子类的原型上的多了一套父类私有属但是不会产生问题。因为子类的私有属性也有一套相同的通过call继承拿过来的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//混合继承</div><div class="line">function G()&#123;</div><div class="line">    this.x = 100;</div><div class="line">&#125;</div><div class="line">G.prototype.getX = function()&#123;&#125;;</div><div class="line">function H()&#123;</div><div class="line">    G.call(this);</div><div class="line">&#125;</div><div class="line">H.prototype = new G();</div><div class="line">H.prototype.constructor = H;</div></pre></td></tr></table></figure>
</li>
<li><p>中间件继承<br>M.prototype.<strong>proto</strong> = K.prototype;  把父类的公有的当作子类的公有的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 中间件继承</div><div class="line">function K()&#123;</div><div class="line">    this.x = 100;</div><div class="line">&#125;</div><div class="line">k.prototype.getX = function ()&#123;&#125;;</div><div class="line">function M()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">M.prototype.__proto__ = K.prototype; //本来应该是直接指向Object.prototype。从K的原型上的__proto__也可以到Object.prototype==&gt; 在K.prototype上停留了下，K.prototype就是一个中间件  父类的公有当作子类的公有</div></pre></td></tr></table></figure>
</li>
<li><p>寄生组合式继承<br>Object.create(xx.prototype)方法  ==&gt; 是把xx.prototype当作别人家的原型  不兼容，只能找到父类原型的方法。父类的私有属性访问不到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Parent() &#123;</div><div class="line">    this.name = &quot;ywx&quot;;</div><div class="line">&#125;</div><div class="line">Parent.prototype.eat = function () &#123;</div><div class="line">    console.log(123);</div><div class="line">&#125;;</div><div class="line">function Child() &#123;&#125;</div><div class="line">//寄生组合式继承实现方式如下：</div><div class="line">Child.prototype = Object.create(Parent.prototype);</div><div class="line">var child=new Child();</div><div class="line">console.log(child.eat());//只有找到父类原型上的方法</div></pre></td></tr></table></figure>
<p>注：prototype是函数（一般指构造函数）的一个内置属性;<strong>proto</strong>是一个对象（即实例）拥有的内置属性,是JS内部使用寻找原型链的属性。 实例.<strong>proto</strong>=构造函数.prototype;</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript、object-oriented、继承/">javascript、object-oriented、继承</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-aso" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/16/aso/" class="article-date">
  	<time datetime="2015-06-16T02:40:50.000Z" itemprop="datePublished">2015-06-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/16/aso/">
        APP推广第一步:五大ASO优化方法
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ASO,全称(AppStoreOptimization),俗称应用市场优化,是一项让开发者的APP更容易被用户在App Store内搜索到的APP推广技术。第一次听别人说这个词的时候还不了解，度娘了解了下在此记录，和seo理论差不太多，操作方法应该还是有不少差异的！<br>　　APP上架后的曝光度,是所有资金短缺的开发者让自己的应用进入市场的一大短板。那么你该如何在App Store获得曝光度?如果你认为ASO是一个选择,那么你就走对路了!更多用户主要是通过检索来发现应用。通过这一途径获得曝光度的应用数量远甚于口头传播,以及浏览热门榜单等途径。<br>　　下面就来介绍IOS的ASO优化的五大方法:</p>
<h4 id="1-关键词"><a href="#1-关键词" class="headerlink" title="1. 关键词"></a>1. 关键词</h4><p>　　关键词虽然无趣,但你提升排名就是离不开关键词。关键词决定了人们在App Store进行搜索时,你的应用出现在检索结果列表中的排名情况。因为较高的排名可以让你的游戏获得更高的曝光度,所以有必要知道如何在为应用命名时,以及在iTunes Connect表格中使用关键词。<br>　　为了获得最大数量的关键词,你必须分析自己的竞争对手,看看最适合它们的关键词是什么。我们还要查看行业顶级工作室所使用的是哪类关键词,以借鉴他们的关键词策略。<br>　　在此你要用100个字符来描述与应用最为相关的关键词。<br>　　不要使用空格,要用逗号隔开关键词。<br>　　用普遍的语言和简短的文字。<br>　　要从用户角度出发,想想如果是你在寻找一款APP,你如何检索?</p>
<h4 id="2-应用标题"><a href="#2-应用标题" class="headerlink" title="2. 应用标题"></a>2. 应用标题</h4><p>　　你的应用名称是VITAL,尽量简化它。<br>　　虽然它并不一定是独特的,但要让它具有描述性。<br>　　要令其与应用类型或者你的目标用户想要的结果相关。<br>　　你的应用名称字符在检索结果中只会出现25个。要确保显示其中最重要的信息,以免漏掉重要内容。<br>　　你并不需要使用“免费”一词。如果你的应用是免费的,App Store在分类时会自动将其归入“免费”类型。</p>
<h4 id="3-应用描述"><a href="#3-应用描述" class="headerlink" title="3. 应用描述"></a>3. 应用描述</h4><p>　　虽然它并不会编入App Store索引,但仍然会发挥作用。<br>　　文本的第一行内容相当重要,因为它代表你从群体中脱颖而出的机会。<br>　　描述你应用的内容,并重复你应用中最重要的关键字。</p>
<h4 id="4-评分和评价"><a href="#4-评分和评价" class="headerlink" title="4.评分和评价"></a>4.评分和评价</h4><p>　　你无法完全掌控它们,但你还是可以让形势朝有利于自己的方向发展。<br>　　创造优秀的内容可以产生好评。<br>　　在用户“感到快乐”的时候请求其评价,例如,在用户完成一个奖励任务或者击败一次高分时。记住要引导,而不是强迫。</p>
<h4 id="5-下载量"><a href="#5-下载量" class="headerlink" title="5. 下载量"></a>5. 下载量</h4><p>　　你可能没有足够的财力购买安装量,所以在设计上多花点心思吧。<br>　　让你的应用图标在同类产品中脱颖而出。<br>　　用截图来显示应用的自然流程,以便用户一眼就能看出它的运行方式。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>　　一定要记住要同时运用这些影响ASO的不同层面,不可偏废其中之一,它们是相辅相成的!ASO优化并不是一撮而就,这是一个长期的工作,我们需要的是一步一步的去完善它,在不久的将来你一定会成功。参考来源于网络。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/aso/">aso</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-zhaoji-life" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/27/zhaoji-life/" class="article-date">
  	<time datetime="2015-03-27T01:20:24.000Z" itemprop="datePublished">2015-03-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/27/zhaoji-life/">
        你的人生如此着急，你过好了吗？
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我读后感觉写得很好，所以记录下来分享给大家，希望有所感悟，能对你起到一定的帮助！</p>
<p>我所看到的人，都在急，特别的急！急着要男朋友，急着要女朋友，女朋友着急要房子，要车子，想旅游，又想享受生活，想安逸，男朋友又得拼命工作，阅历不深却又着急看透世界，甚至于连一篇文章都没有时间读完，告诉我，你们究竟急的是什么？</p>
<p><strong>别着急，慢慢来</strong></p>
<p>我不知道这代人怎么想的，我并不认同八零后和七零后还有六零后的区别，现在的八零后当务之急便是房子了，还有那可怜的爱情，这在七零后和六零后的时候，是根本不需要操心的，你说，这社会是进步了？还是退步了？我也是个八零后，同样想着各种各样的事，同样急着这社会上大多数人急的事。</p>
<p>看了一篇文章，似乎有些释然，文章上说“你所急的事，一定是最不需要快速解决的，你所不在乎的事，恰恰需要你马上行动。”起初看到这句话，没办法理解，可是接下来的一句话却让我如梦初醒，“因为一粒种子，就是要慢慢成熟，谁也决定不了它成长的速度，而你手里的苹果，耽搁了时间，就不再好吃了，还原世界本来的面目，一切慢慢来”。</p>
<p>现在的爱情也是，急的不行，男人们遇见姑娘急着上床，姑娘们遇见男人，急着迅速掀底，到底值不值得交往，即便是交往了，也急着结婚，父母催，亲戚催，结婚了，马上要了孩子，孩子出来了，马上急着别落在起跑线上，各种补习班，上了小学，急着中学，上了高中，急着大学，上了大学，又急工作，循环往复，周而复始，人们早都忘了事物的本来面目。</p>
<p>爱情就该慢慢来，在我刚刚遇见你的时候，你也刚好爱上我，就在一起吧，想厮守一辈子了，管它嫁妆房子，有你就好，结婚生子，顺其自然，孩子有它的童年，就像我们有过的童年一样，事情本来就该慢慢来，可是现在的时代，都提前了，屁股上都着火了，可是谁都找不到灭火器。</p>
<p><strong>亲爱的，你慢慢飞</strong></p>
<p>中国的改革开放太快了，快的让民众来不及反映，地图上圈里的城市，深圳， 上海 ，发了。所有的中国人都开始急了，急下海，急炒股。</p>
<p>中国用火箭的速度在发展着，却忽略了一批又一批的善良的人们，那些点燃火箭升空的人，早已消失在火箭腾空时，激起的尘土中了。</p>
<p>所有的速度都让民众目不暇接，所有的变化让孩子们甚至找不到家的方向，那些迎着朝阳出门的人，背着月光回家的时候，可能看到的只是废墟，因为这一切都来不急让你等待，因为，高楼大厦崛起的速度，一定快过你回家的速度。</p>
<p>每当下班的时候站在天桥上，或是地铁里，看着低头行走的年轻人，每个人的脸上都是一种表情，麻木，平淡，疲惫，又无奈，我想上前拽住每个人，告诉他们，慢慢飞，可是，我办不到，我不是精神病人，我只是旁观者，看着人群在我身边走过，而我也只能跟随人群的脚步，因为慢了，我赶不上回家的最后一班车。</p>
<p><strong>你猜，我是走，还是跑？</strong></p>
<p>很多事情，很多人，都已不是原来的样子，朋友说，计划永远没有变化快，我说，那是你的钱没的太快，在这个时代，好人和坏人，没办法区分，就像“狼”和“哈士奇”也没办法区分一样，只是希望，“狼别生气，人把你当狗，也愿狗别高兴，人心虚了，才把你当狼”。</p>
<p>现在的人太容易孤独，彷徨，烦躁，急迫，其实，你之所以感到孤独，并不是没有人关心你，而是你在乎的那个人没有关心你。</p>
<p>很多刚毕业的学生，都急着奔向远方，认为他的理想都在远方，而有的同学，却慢慢的回家，想想自己到底要做什么，该做什么，三年后，当年去找理想的人，把自己也丢了，当年慢慢的人，做了老板，开了个小店，娶了媳妇，生了孩子，虽然他可能没吃过太多次的肯德基，没去过太多次的咖啡厅，也没有带着媳妇去吃必胜客，可是，谁能说他走的慢了？</p>
<p>有的时候，走，真的比跑快，因为走着，不会错过风景，知道目标；而跑的人，会落下太多的人，最后孤独一人，因为你跑的太快，别人跟不上。</p>
<p><strong>安静，我们都该休息了</strong></p>
<p>一个人，一辈子最重要的事，其实就是选对身边的人，炊烟起了，我在门口等你。夕阳下了，我在山边等你。叶子黄了，我在树下等你。月儿弯了，我在十五等你。细雨来了，我在伞下等你。流水冻了，我在河畔等你。生命累了，我在天堂等你。我们老了，我在来生等你。</p>
<p>我们都累了，是时候慢慢的停下来，放慢脚步，好好的看一本书，好好的听听爱你的人，要对你说的话，看看我们在急着往前走的时候，落下了什么东西，到底是朋友，还是父母，还是你最珍贵的爱情。。。</p>
<p>这个时代，无论多快，我们总该找到自己的节奏——试着寻找一个“灭火器”，把身后的“火”灭了吧。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/人生/">人生</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-jstype" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/02/09/jstype/" class="article-date">
  	<time datetime="2015-02-09T08:54:59.000Z" itemprop="datePublished">2015-02-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/09/jstype/">
        js中的类型
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h4><p>JavaScript 有七种内置类型：<br>空值（ null ）<br>未定义（ undefined ）<br>布尔值（ boolean ）<br>数字（ number ）<br>字符串（ string ）<br>对象（ object ）<br>符号（ symbol ， ES6 中新增）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typeof undefined === &quot;undefined&quot;; // true</div><div class="line">typeof true === &quot;boolean&quot;; // true</div><div class="line">typeof 42 === &quot;number&quot;; // true</div><div class="line">typeof &quot;42&quot; === &quot;string&quot;; // true</div><div class="line">typeof &#123; life: 42 &#125; === &quot;object&quot;; // true</div><div class="line">typeof null === &quot;object&quot;; // true  注意：null比较特殊</div><div class="line">// ES6中新加入的类型</div><div class="line">typeof Symbol() === &quot;symbol&quot;; // true</div></pre></td></tr></table></figure></p>
<p>注意：typeof 运算符总是会返回一个字符串。</p>
<p><font color="red">typeof null</font><br>typeof null === “object”; 返回true;它比较特殊，正确的返回结果应该是 “null” ， 但这个 bug由来已久， 在 JavaScript 中已经存在了将近二十年， 也许永远也不会修复，因为这牵涉到太多的 Web 系统， “修复”它会产生 更多的 bug， 令许多系统无法正常工作。<br>因此我们需要使用复合条件来检测 null 值的类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var a = null;</div><div class="line">(!a &amp;&amp; typeof a === &quot;object&quot;); // true</div></pre></td></tr></table></figure></p>
<p>null 是基本类型中唯一的一个“假值”类型， typeof 对它的返回值为 “object” 。</p>
<p>还有一种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typeof function a()&#123; /* .. */ &#125; === &quot;function&quot;; // true</div></pre></td></tr></table></figure></p>
<p>这样看来， function （ 函数） 也是 JavaScript 的一个内置类型。其实并不是这样的， 通过查阅规范就会知道，它实际上是 object 的一个“子类型”。 具体来说， 函数是“可调用对象”， 它有一个内部属性 <code>[[Call]]</code> ， 该属性使其可以被调用。<br>函数不仅是对象， 还可以拥有属性。 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function a(b,c) &#123;</div><div class="line">/* .. */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数对象的 length 属性是其声明的参数的个数：a.length; 值为2.<br>因为该函数声明了两个命名参数， b 和 c ， 所以其 length 值为 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typeof [1,2,3] === &quot;object&quot;; // true</div></pre></td></tr></table></figure>
<p> 数组也是对象。 确切地说， 它也是 object 的一个“子类型” ， 数组的元素按数字顺序来进行索引（ 而非普通像对象那样通过字符串键值） ， 其 length 属性是元素的个数。</p>
<h4 id="值和类型"><a href="#值和类型" class="headerlink" title="值和类型"></a>值和类型</h4><p>JavaScript 中的变量是没有类型的， 只有值才有 。 变量可以随时持有任何类型的值。换个角度来理解就是， JavaScript 不做“类型强制”； 也就是说， 语言引擎不要求变量 总是持有与其初始值同类型 的值。 一个变量可以现在被赋值为字符串类型值， 随后又被赋值为数字类型值。</p>
<p>已在作用域中声明但还没有赋值的变量， 是 undefined 的。 相反， 还没有在作用域中声明过的变量， 是 undeclared（未声明） 的。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a;</div><div class="line">a; // undefined</div><div class="line">b; // ReferenceError: b is not defined(也可理解为未声明的意思)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a;</div><div class="line">typeof a; // &quot;undefined&quot;</div><div class="line">typeof b; // &quot;undefined&quot;</div></pre></td></tr></table></figure>
<p>请注意虽然 b 是一个 undeclared 变量， 但typeof b 并没有报错。 这是因为 typeof 有一个特殊的安全防范机制。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-scope" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/02/08/scope/" class="article-date">
  	<time datetime="2015-02-08T07:13:43.000Z" itemprop="datePublished">2015-02-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/08/scope/">
        作用域预编译及引发异常问题
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h4><p>var a=2;执行分为两个过程：<br>代码执行前先进行预编译，此时只是声明了一个变量a，此时a的值为undefined，当代码运行到a=2时，变量a才会赋值2。<br>总结： 变量的赋值操作会执行两个动作， 首先编译器会在当前作用域中声明一个变量（ 如果之前没有声明过）， 然后在运行时引擎会在作用域中查找该变量， 如果能够找到就会对<br>它赋值。</p>
<h4 id="类型错误"><a href="#类型错误" class="headerlink" title="类型错误"></a>类型错误</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo(a) &#123;</div><div class="line">console.log( a + b );</div><div class="line">b = a;</div><div class="line">&#125; </div><div class="line">foo( 2 );</div></pre></td></tr></table></figure>
<p>上述代码在严格模式中 找不到变量b时（此句对应 console.log( a + b )）， 并不会创建并返回一个全局变量， 引擎会抛出一个ReferenceError 异常。在非严格模式下，如果找不到变量b（此句对应b=a，给b赋值时它会看预编译的时候有没有声明b，如果没有声明，在非严格模式下它会声明并给其赋值），在全局作用域中就会创建一个具有该名称的变量b， 并将其返还给引擎</p>
<p>如果你对一个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用， 或着引用 null 或 undefined 类型的值中的属性， 那么引擎会抛出另外一种类型的异常， 叫作 TypeError。例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var a=12;</div><div class="line">var b=null;</div></pre></td></tr></table></figure></p>
<p>执行a(),b.property或者b.length都会抛出一个TypeError异常。</p>
<p>总结：ReferenceError 同作用域判别失败相关（在相关作用域内及全局作用域内没有找到变量）， 而 TypeError 则代表作用域判别成功了(在作用域内找到了变量)， 但是对结果的操作是非法或不合理的。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>作用域是一套规则， 用于确定在何处以及如何查找变量（ 标识符）。 如果查找的目的是对变量进行赋值， 那么就会使用 LHS 查询； 如果目的是获取变量的值， 就会使用 RHS 查询。</p>
<p>赋值操作符会导致 LHS 查询。 ＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。</p>
<p>JavaScript 引擎首先会在代码执行前对其进行编译， 在这个过程中， 像 var a = 2 这样的声明会被分解成两个独立的步骤：<br>1.首先， var a 在其作用域中声明新变量。 这会在最开始的阶段， 也就是代码执行前进行。<br>2.接下来， a = 2 会查询（ LHS 查询） 变量 a 并对其进行赋值</p>
<p>LHS 和 RHS 查询都会在当前执行作用域中开始， 如果有需要（ 也就是说它们没有找到所需的标识符）， 就会向上级作用域继续查找目标标识符， 这样每次上升一级作用域， 最后抵达全局作用域（ 顶层）， 无论找到或没找到都将停止。不成功的 RHS 引用会导致抛出 ReferenceError 异常。 不成功的 LHS 引用会导致自动隐式地创建一个全局变量（ 非严格模式下）， 该变量使用 LHS 引用的目标作为标识符， 或者抛出 ReferenceError 异常（ 严格模式下）</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js-scope/">js scope</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-test-makrdown" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/02/02/test-makrdown/" class="article-date">
  	<time datetime="2015-02-02T02:04:31.000Z" itemprop="datePublished">2015-02-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/02/test-makrdown/">
        markdown 语法入大门
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-Markdown是什么？"><a href="#1-Markdown是什么？" class="headerlink" title="1. Markdown是什么？"></a>1. Markdown是<em>什么</em>？</h3><p><strong>Markdown</strong>是一种轻量级<strong>标记语言</strong>，它以纯文本形式(<em>易读、易写、易更改</em>)编写文档，并最终以HTML格式发布。<br><strong>Markdown</strong>也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本<em>Markdown.pl</em>。</p>
<h3 id="4-怎么使用？"><a href="#4-怎么使用？" class="headerlink" title="4. 怎么使用？"></a>4. <em>怎么</em>使用？</h3><p>如果不算<strong>扩展</strong>，Markdown的语法绝对<strong>简单</strong>到让你爱不释手。</p>
<p>废话太多，下面正文，Markdown语法主要分为如下几大部分：<br><strong>标题</strong>，<strong>段落</strong>，<strong>区块引用</strong>，<strong>代码区块</strong>，<strong>强调</strong>，<strong>列表</strong>，<strong>分割线</strong>，<strong>链接</strong>，<strong>图片</strong>，<strong>反斜杠 <code>\</code></strong>，<strong>符号’`’</strong>。</p>
<h4 id="4-1-标题"><a href="#4-1-标题" class="headerlink" title="4.1 标题"></a>4.1 标题</h4><p>两种形式：<br>1）使用<code>=</code>和<code>-</code>标记一级和二级标题。</p>
<blockquote>
<p>一级标题<br><code>=========</code><br>二级标题<br><code>---------</code></p>
</blockquote>
<p>效果：</p>
<blockquote>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote>
<p>2）使用<code>#</code>，可表示1-6级标题。</p>
<blockquote>
<p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题</p>
</blockquote>
<p>效果：</p>
<blockquote>
<h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote>
<h4 id="4-2-段落"><a href="#4-2-段落" class="headerlink" title="4.2 段落"></a>4.2 段落</h4><p>段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用<strong>两个以上</strong>空格加上回车（引用中换行省略回车）。</p>
<h4 id="4-3-区块引用"><a href="#4-3-区块引用" class="headerlink" title="4.3 区块引用"></a>4.3 区块引用</h4><p>在段落的每行或者只在第一行使用符号<code>&gt;</code>,还可使用多个嵌套引用，如：</p>
<blockquote>
<p>> 区块引用<br>>&gt; 嵌套引用</p>
</blockquote>
<p>效果：</p>
<blockquote>
<p>区块引用</p>
<blockquote>
<p>嵌套引用</p>
</blockquote>
</blockquote>
<h4 id="4-4-代码区块"><a href="#4-4-代码区块" class="headerlink" title="4.4 代码区块"></a>4.4 代码区块</h4><p>代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如<br>普通段落：</p>
<p>void main()<br>{<br>    printf(“Hello, Markdown.”);<br>}</p>
<p>代码区块：</p>
<pre><code>void main()
{
    printf(&quot;Hello, Markdown.&quot;);
}
</code></pre><p><strong>注意</strong>:需要和普通段落之间存在空行。</p>
<h4 id="4-5-强调"><a href="#4-5-强调" class="headerlink" title="4.5 强调"></a>4.5 强调</h4><p>在强调内容两侧分别加上<code>*</code>或者<code>_</code>，如：</p>
<blockquote>
<p>*斜体*，_斜体_<br>**粗体**，__粗体__</p>
</blockquote>
<p>效果：</p>
<blockquote>
<p><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong></p>
</blockquote>
<h4 id="4-6-列表"><a href="#4-6-列表" class="headerlink" title="4.6 列表"></a>4.6 列表</h4><p>使用<code>·</code>、<code>+</code>、或<code>-</code>标记无序列表，如：</p>
<blockquote>
<p>-（+*） 第一项<br>-（+*） 第二项<br>- （+*）第三项</p>
</blockquote>
<p><strong>注意</strong>：标记后面最少有一个<em>空格</em>或<em>制表符</em>。若不在引用区块中，必须和前方段落之间存在空行。</p>
<p>效果：</p>
<blockquote>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
<p>有序列表的标记方式是将上述的符号换成数字,并辅以<code>.</code>，如：</p>
<blockquote>
<p>1 . 第一项<br>2 . 第二项<br>3 . 第三项</p>
</blockquote>
<p>效果：</p>
<blockquote>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
</blockquote>
<h4 id="4-7-分割线"><a href="#4-7-分割线" class="headerlink" title="4.7 分割线"></a>4.7 分割线</h4><p>分割线最常使用就是三个或以上<code>*</code>，还可以使用<code>-</code>和<code>_</code>。</p>
<h4 id="4-8-链接"><a href="#4-8-链接" class="headerlink" title="4.8 链接"></a>4.8 链接</h4><p>链接可以由两种形式生成：<strong>行内式</strong>和<strong>参考式</strong>。<br><strong>行内式</strong>：</p>
<blockquote>
<p>[ywx的Markdown](https:://github.com/yanwenxi)。</p>
</blockquote>
<p>效果：</p>
<blockquote>
<p><a href="https:://github.com/yanwenxi" target="_blank" rel="external">ywx的Markdown</a>。</p>
</blockquote>
<p><strong>参考式</strong>：</p>
<blockquote>
<p>[ywx的Markdown1][1]<br>[ywx的Markdown2][2]<br>[1]:https:://github.com/yanwenxi”<br>[2]:https:://github.com/yanwenxi”</p>
</blockquote>
<p>效果：</p>
<blockquote>
<p>[ywx的Markdown1][1]<br>[ywx的Markdown2][2]</p>
</blockquote>
<h4 id="4-9-图片"><a href="#4-9-图片" class="headerlink" title="4.9 图片"></a>4.9 图片</h4><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个<code>！</code>。</p>
<h4 id="4-10-反斜杠"><a href="#4-10-反斜杠" class="headerlink" title="4.10 反斜杠\"></a>4.10 反斜杠<code>\</code></h4><p>相当于<strong>反转义</strong>作用。使符号成为普通符号。</p>
<h4 id="4-11-符号’-’"><a href="#4-11-符号’-’" class="headerlink" title="4.11 符号’`’"></a>4.11 符号’`’</h4><p>起到标记作用。如：</p>
<blockquote>
<p>`ctrl+a`</p>
</blockquote>
<p>效果：</p>
<blockquote>
<p><code>ctrl+a</code></p>
<hr>
<p><strong>注意</strong>：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。</p>
<hr>
<p>以上基本是所有traditonal markdown的语法。</p>
</blockquote>
<h3 id="其它："><a href="#其它：" class="headerlink" title="其它："></a>其它：</h3><p>列表的使用(非traditonal markdown)：</p>
<p>用<code>|</code>表示表格纵向边界，表头和表内容用<code>-</code>隔开，并可用<code>:</code>进行对齐设置，两边都有<code>:</code>则表示居中，若不加<code>:</code>则默认左对齐。</p>
<p>关于其它扩展语法可参见具体工具的使用说明。</p>
<h3 id="markdown里写html标签"><a href="#markdown里写html标签" class="headerlink" title="markdown里写html标签"></a>markdown里写html标签</h3><p>若直接在md里直接写</p><p>,这样不能正确解析出来，需要在英文状态下按esc输出“<code>`”，用此包住标签即可。
例：</code></p><p><code>,</code><script></p>
<h4 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h4><p>使用 <em>* 或者 __ 表示粗体。使用 </em> 或者 <em> 表示斜体。<br>注意:前后的 * 或 </em> 与要 加粗或倾斜 的字体之间不能有空格。</p>
<h4 id="markdown里如何加入angular中的"><a href="#markdown里如何加入angular中的" class="headerlink" title="markdown里如何加入angular中的{ { } }"></a>markdown里如何加入angular中的{ { } }</h4><p>我了个去去去，坑了我一上午的时间，文章一直报错，所以标记下：{ { } }要显示在页面上，必须用转义符，并且第个{都需要转义，在代码块中不用转义了，但是在代码高亮显示的时候也必须转义。</p>
</script></p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/markdown/">markdown</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/9/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/11/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2017 前端在路上
      </div>
        <div class="footer-right">
          <a href="http://webywx.com/" target="_blank">webywx</a>  Theme <a href="https://yanwenxi.site" target="_blank">前端在路上</a> by Scorpio
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>