<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>闫文喜的个人前端博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="闫文喜 前端博客 web前端博客  web前端开发">
<meta property="og:type" content="website">
<meta property="og:title" content="闫文喜的个人前端博客">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="闫文喜的个人前端博客">
<meta property="og:description" content="闫文喜 前端博客 web前端博客  web前端开发">
<meta property="og:locale" content="ch">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="闫文喜的个人前端博客">
<meta name="twitter:description" content="闫文喜 前端博客 web前端博客  web前端开发">
  
    <link rel="alternative" href="/atom.xml" title="闫文喜的个人前端博客" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">前端在路上</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/about">关于我</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/yanwenxi" title="github">github</a>
					        
								<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="mail">mail</a>
					        
								<a class="qq" target="_blank" href="http://www.webywx.com" title="qq">qq</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Benchmark-jsPerf/" style="font-size: 10px;">Benchmark jsPerf</a> <a href="/tags/ES6、promise/" style="font-size: 10px;">ES6、promise</a> <a href="/tags/GraphQL/" style="font-size: 10px;">GraphQL</a> <a href="/tags/H5-移动端优化/" style="font-size: 10px;">H5 移动端优化</a> <a href="/tags/H5、bug/" style="font-size: 10px;">H5、bug</a> <a href="/tags/JS设计模式-设计模式/" style="font-size: 10px;">JS设计模式 设计模式</a> <a href="/tags/Jenkins-CI/" style="font-size: 10px;">Jenkins CI</a> <a href="/tags/Lodash/" style="font-size: 10px;">Lodash</a> <a href="/tags/angular/" style="font-size: 10px;">angular</a> <a href="/tags/angular-http-q-promise/" style="font-size: 10px;">angular $http $q promise</a> <a href="/tags/angular-q-promise/" style="font-size: 10px;">angular $q promise</a> <a href="/tags/angular-decorator/" style="font-size: 10px;">angular decorator</a> <a href="/tags/angular-filter/" style="font-size: 10px;">angular filter</a> <a href="/tags/angular-服务/" style="font-size: 10px;">angular 服务</a> <a href="/tags/angularjs/" style="font-size: 10px;">angularjs</a> <a href="/tags/angular、-http/" style="font-size: 10px;">angular、$http</a> <a href="/tags/angular、Karma/" style="font-size: 10px;">angular、Karma</a> <a href="/tags/angular、directive/" style="font-size: 10px;">angular、directive</a> <a href="/tags/angular、html5/" style="font-size: 10px;">angular、html5</a> <a href="/tags/angular、module、controller/" style="font-size: 10px;">angular、module、controller</a> <a href="/tags/angular、promise、-q、deferred/" style="font-size: 10px;">angular、promise、$q、deferred</a> <a href="/tags/angular、router/" style="font-size: 10px;">angular、router</a> <a href="/tags/angular、ui-router/" style="font-size: 10px;">angular、ui-router</a> <a href="/tags/angular、表达式、filter/" style="font-size: 10px;">angular、表达式、filter</a> <a href="/tags/app-跨平台/" style="font-size: 10px;">app,跨平台</a> <a href="/tags/aso/" style="font-size: 10px;">aso</a> <a href="/tags/blockchain/" style="font-size: 10px;">blockchain</a> <a href="/tags/class/" style="font-size: 10px;">class</a> <a href="/tags/css-1px/" style="font-size: 10px;">css 1px</a> <a href="/tags/css3/" style="font-size: 10px;">css3</a> <a href="/tags/debugger/" style="font-size: 10px;">debugger</a> <a href="/tags/es5-js/" style="font-size: 10px;">es5 js</a> <a href="/tags/es6/" style="font-size: 10px;">es6</a> <a href="/tags/fit/" style="font-size: 10px;">fit</a> <a href="/tags/flex-css/" style="font-size: 10px;">flex css</a> <a href="/tags/flexbox/" style="font-size: 10px;">flexbox</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/git-github/" style="font-size: 10px;">git github</a> <a href="/tags/h5-webworkers/" style="font-size: 10px;">h5 webworkers</a> <a href="/tags/ifelse/" style="font-size: 10px;">ifelse</a> <a href="/tags/iframe/" style="font-size: 10px;">iframe</a> <a href="/tags/javascript、object-oriented、继承/" style="font-size: 10px;">javascript、object-oriented、继承</a> <a href="/tags/jest/" style="font-size: 10px;">jest</a> <a href="/tags/jquery/" style="font-size: 10px;">jquery</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/js-Array/" style="font-size: 10px;">js Array</a> <a href="/tags/js-Higher-order-function/" style="font-size: 10px;">js Higher-order-function</a> <a href="/tags/js-closure/" style="font-size: 10px;">js closure</a> <a href="/tags/js-lodash/" style="font-size: 10px;">js lodash</a> <a href="/tags/js-object/" style="font-size: 10px;">js object</a> <a href="/tags/js-scope/" style="font-size: 10px;">js scope</a> <a href="/tags/js-sea-js-模块化/" style="font-size: 10px;">js sea.js 模块化</a> <a href="/tags/js-this/" style="font-size: 10px;">js this</a> <a href="/tags/js-性能调试/" style="font-size: 10px;">js 性能调试</a> <a href="/tags/js-柯里化/" style="font-size: 10px;">js 柯里化</a> <a href="/tags/js-纯函数/" style="font-size: 10px;">js 纯函数</a> <a href="/tags/jsapi/" style="font-size: 10px;">jsapi</a> <a href="/tags/jsevent/" style="font-size: 10px;">jsevent</a> <a href="/tags/js、变态题/" style="font-size: 10px;">js、变态题</a> <a href="/tags/js、设计模式/" style="font-size: 10px;">js、设计模式</a> <a href="/tags/js、跨域、document-domain/" style="font-size: 10px;">js、跨域、document.domain</a> <a href="/tags/js异步编程/" style="font-size: 10px;">js异步编程</a> <a href="/tags/js模块化、AMD、CMD、CommonJs/" style="font-size: 10px;">js模块化、AMD、CMD、CommonJs</a> <a href="/tags/js继承/" style="font-size: 10px;">js继承</a> <a href="/tags/life、意念/" style="font-size: 10px;">life、意念</a> <a href="/tags/lodash-chain/" style="font-size: 10px;">lodash chain</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/maxhosts/" style="font-size: 10px;">maxhosts</a> <a href="/tags/mongoDB-数据库/" style="font-size: 10px;">mongoDB 数据库</a> <a href="/tags/mvp/" style="font-size: 10px;">mvp</a> <a href="/tags/mvvm/" style="font-size: 10px;">mvvm</a> <a href="/tags/node/" style="font-size: 12px;">node</a> <a href="/tags/node-debug/" style="font-size: 10px;">node debug</a> <a href="/tags/node-wechat/" style="font-size: 18px;">node wechat</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/node、enentLoop/" style="font-size: 10px;">node、enentLoop</a> <a href="/tags/promise、es6/" style="font-size: 10px;">promise、es6</a> <a href="/tags/rap/" style="font-size: 16px;">rap</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/react-ant-design/" style="font-size: 10px;">react ant-design</a> <a href="/tags/reflow、repaint/" style="font-size: 10px;">reflow、repaint</a> <a href="/tags/seo/" style="font-size: 18px;">seo</a> <a href="/tags/seo-新闻源/" style="font-size: 10px;">seo 新闻源</a> <a href="/tags/token、OAuth、鉴权/" style="font-size: 10px;">token、OAuth、鉴权</a> <a href="/tags/vh、vw、css3/" style="font-size: 10px;">vh、vw、css3</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/vuex/" style="font-size: 10px;">vuex</a> <a href="/tags/vue、多面应用/" style="font-size: 10px;">vue、多面应用</a> <a href="/tags/web/" style="font-size: 12px;">web</a> <a href="/tags/web-交互/" style="font-size: 10px;">web 交互</a> <a href="/tags/web、前端/" style="font-size: 10px;">web、前端</a> <a href="/tags/web、性能优化/" style="font-size: 10px;">web、性能优化</a> <a href="/tags/web缓存/" style="font-size: 10px;">web缓存</a> <a href="/tags/wechat/" style="font-size: 10px;">wechat</a> <a href="/tags/wechat-webstorm/" style="font-size: 10px;">wechat webstorm</a> <a href="/tags/win10、linux/" style="font-size: 10px;">win10、linux</a> <a href="/tags/window-history-html5/" style="font-size: 10px;">window.history html5</a> <a href="/tags/wxapp/" style="font-size: 14px;">wxapp</a> <a href="/tags/xss、csrf/" style="font-size: 10px;">xss、csrf</a> <a href="/tags/yarn-npm/" style="font-size: 10px;">yarn npm</a> <a href="/tags/人生/" style="font-size: 10px;">人生</a> <a href="/tags/前后端分享/" style="font-size: 10px;">前后端分享</a> <a href="/tags/前端脚手架/" style="font-size: 10px;">前端脚手架</a> <a href="/tags/埋点统计/" style="font-size: 10px;">埋点统计</a> <a href="/tags/建站-seo/" style="font-size: 10px;">建站 seo</a> <a href="/tags/性能、异常上报/" style="font-size: 10px;">性能、异常上报</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/生活/" style="font-size: 20px;">生活</a> <a href="/tags/移动端、fixed/" style="font-size: 10px;">移动端、fixed</a> <a href="/tags/统计、cloc/" style="font-size: 10px;">统计、cloc</a> <a href="/tags/解构赋值-es6/" style="font-size: 10px;">解构赋值 es6</a> <a href="/tags/跨域、postMessage、html5/" style="font-size: 10px;">跨域、postMessage、html5</a> <a href="/tags/路由-html5/" style="font-size: 10px;">路由 html5</a> <a href="/tags/防抖、节流/" style="font-size: 10px;">防抖、节流</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.webywx.com/">前端博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.yanwenxi.site/">web小站</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">前端在路上</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">前端在路上</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/about">关于我</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/yanwenxi" title="github">github</a>
			        
						<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="mail">mail</a>
			        
						<a class="qq" target="_blank" href="http://www.webywx.com" title="qq">qq</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-MVVM实现原理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/10/MVVM实现原理/" class="article-date">
  	<time datetime="2017-12-10T06:12:39.000Z" itemprop="datePublished">2017-12-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/10/MVVM实现原理/">
        mvvm实现原理相关记录
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="mvvm实现原理"><a href="#mvvm实现原理" class="headerlink" title="mvvm实现原理"></a>mvvm实现原理</h3><ol>
<li><p>Compile模板编译</p>
</li>
<li><p>Observer数据劫持</p>
</li>
<li><p>Watcher观察者</p>
</li>
<li><p>Dep发布订阅模式</p>
<h4 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h4><p><img src="http://oi28tswuq.bkt.clouddn.com/vue/mvvm.jpeg" alt="mvvm原理图"></p>
<h3 id="vue中实现双向绑定"><a href="#vue中实现双向绑定" class="headerlink" title="vue中实现双向绑定"></a>vue中实现双向绑定</h3></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">index.html:</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">	&lt;input type=&apos;text&apos; v-model=&quot;message&quot;&gt;&lt;/input&gt;</span><br><span class="line">	&#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;watcher.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;observer.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;compile.js&quot;&gt;&lt;/script&gt;//先引入compile.js，因为mvvm.js依赖于compile.js,所以要先加载进来</span><br><span class="line">&lt;script src=&quot;MVVM.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	let vm=new MVVM(&#123;</span><br><span class="line">        el:&apos;#app&apos;,也可写成document.getElementById(&quot;app&quot;);</span><br><span class="line">        data:&#123;</span><br><span class="line">            message1:&apos;hello yxn&apos;,</span><br><span class="line">            message:&#123;</span><br><span class="line">                a:1,</span><br><span class="line">                b:2</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">MVVM.JS:</span><br><span class="line">class MVVM&#123;</span><br><span class="line">    constructor(options)&#123;</span><br><span class="line">        //一开始先把可用的东西挂载到实例上</span><br><span class="line">        this.$el=options.el;</span><br><span class="line">        this.$data=options.data;</span><br><span class="line">        </span><br><span class="line">        //如果有要编译的模板就开始编译，用元素和数据进行编译。此处为了后续扩展，把编译封装成一个类。</span><br><span class="line">        if(this.$el)&#123;</span><br><span class="line">        	//数据劫持 就是把对象的所有属性改成get和set方法</span><br><span class="line">        	new Observer(this.$data);</span><br><span class="line">        	this.proxyData(this.$data);</span><br><span class="line">            new Compile(this.$el,this);//直接传入this，方便获取更多的数据(属性)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    proxyData(data)&#123;//代理数据，控制台直接用vm.xx获取数据，就不用使用vm.$data.xx来获取数据了。</span><br><span class="line">        Object.keys(data).forEach(key=&gt;&#123;</span><br><span class="line">            Object.defineProperty(this,key,&#123;</span><br><span class="line">                get()&#123;</span><br><span class="line">                    return data[key];</span><br><span class="line">                &#125;,</span><br><span class="line">                set(newValue)&#123;</span><br><span class="line">                    return data[key]=newValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">compile.js</span><br><span class="line">class Compile&#123;</span><br><span class="line">    constructor(el,vm)&#123;  //vm代表MVVM的当前实例</span><br><span class="line">        this.el=this.isElementNode(el)?el:document.querySelctor(el);</span><br><span class="line">        this.vm=vm;</span><br><span class="line">        //如果这个元素能获取到，就开始编译</span><br><span class="line">        if(this.el)&#123;</span><br><span class="line">          1.先把这些真实的dom移入到内存中 fragment(避免频繁操作dom消耗性能)</span><br><span class="line">          let fragment=this.nodeTofragment(this.el);</span><br><span class="line">          2.编译=》提取想要的元素节点v-model和文本节点&#123;&#123;&#125;&#125;</span><br><span class="line">          this.compile(fragment);</span><br><span class="line">          3.把编译好的fragment在塞回到页面里去</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*用到的辅助方法*/</span><br><span class="line">    isDirective(name)&#123;</span><br><span class="line">        return name.includes(&apos;v-&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    isElementNode(node)&#123;</span><br><span class="line">        return node.nodeType===1;</span><br><span class="line">    &#125;</span><br><span class="line">    /*用到的核心方法*/</span><br><span class="line">    compileElement(node)&#123;</span><br><span class="line">       //带v-model v-text,v-一系列</span><br><span class="line">        let attrs=node.attributes;</span><br><span class="line">        Array.form(attrs).forEach(attr=&gt;&#123;</span><br><span class="line">            //判断属性名字是不是包含v-   属性包含值和名</span><br><span class="line">            let attrName=attr.name;</span><br><span class="line">            if(this.isDirective(attrName))&#123; //取到对应的值放到节点中</span><br><span class="line">                let expr=attr.value; // node this.vm.$data expr</span><br><span class="line">                let [,type]=attrName.split(&apos;-&apos;);</span><br><span class="line">                CompileUtil[type](node,this.vm,expr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    compileText(node)&#123;</span><br><span class="line">        //带&#123;&#123;&#125;&#125;</span><br><span class="line">        let text = node.textContent;//取文本中的内容</span><br><span class="line">        let reg=/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g;</span><br><span class="line">        if(reg.test(expr))&#123;</span><br><span class="line">            CompileUtil[&apos;text&apos;](node,this.vm,expr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    compile(fragment)&#123;</span><br><span class="line">        let childNodes=fragment.childNodes;//获取的元素不包括子节点</span><br><span class="line">        Array.from(childNodes).forEach(node=&gt;&#123;</span><br><span class="line">            if(this.isElementNode(node))&#123;//元素节点，还需要继续深入查找是否还有子节点。箭头函数没有this指向问题，都指向最外层。</span><br><span class="line">            	this.compileElement(node);</span><br><span class="line">                this.compile(node);</span><br><span class="line">            &#125;else&#123;//文本节点</span><br><span class="line">               this.compileText(node)； </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    nodeTofragment(el)&#123; //需要将el中的内容全部放到内存中</span><br><span class="line">       //文档碎片，不是真实的dom,是内存中的dom</span><br><span class="line">        let fragment =document.createDocumentFragment();</span><br><span class="line">        let firstChild;</span><br><span class="line">        while(firstChild=el.firstChild)&#123;</span><br><span class="line">            fragment.appendChild(firstChild);</span><br><span class="line">        &#125;</span><br><span class="line">        return fragment;//内存中的dom节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">CompileUtil=&#123;</span><br><span class="line">	getVal(vm,expr)&#123; //获取实例上对应的数据</span><br><span class="line">        expr=expr.split(&apos;.&apos;);//[message,a,b]</span><br><span class="line">        return expr.reduce((prev,next)=&gt;&#123;</span><br><span class="line">            return prev[next];</span><br><span class="line">        &#125;,vm.$data);</span><br><span class="line">	&#125;,</span><br><span class="line">	getTextVal(vm,expr)&#123; //获取编译后文本的结果</span><br><span class="line">        return expr.replace(/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g,(...arguments)=&gt;&#123;</span><br><span class="line">            return this.getVal(vm,arguments[1]);</span><br><span class="line">        &#125;)</span><br><span class="line">	&#125;,</span><br><span class="line">    text(node,vm,expr)&#123; //文本处理 &#123;&#123;a&#125;&#125;</span><br><span class="line">        let updateFn=this.updater[&apos;textUpdater&apos;];</span><br><span class="line">        //&#123;&#123;message.a&#125;&#125;=&gt;&apos;ywx&apos;</span><br><span class="line">        let value=this.getTextVal(vm,expr);</span><br><span class="line">        expr.replace(/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g,(...arguments)=&gt;&#123;</span><br><span class="line">            new Watcher(vm,arguments[1],(newValue)=&gt;&#123;</span><br><span class="line">            	//如果数据变化了，文本节点需要重新获取依赖的属性更新文本中的内容</span><br><span class="line">                updateFn&amp;&amp;updateFn(node,this.getTextVal(vm,expr));</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        updateFn&amp;&amp;updateFn(node,value);</span><br><span class="line">    &#125;,</span><br><span class="line">    setVal(vm,expr,value)&#123;</span><br><span class="line">        expr=expr.split(&apos;.&apos;);</span><br><span class="line">        return expr.reduce((prev,next,currentIndex)=&gt;&#123;</span><br><span class="line">            if(currentIndex===expr.length-1)&#123;</span><br><span class="line">                return prev[next]=value;</span><br><span class="line">            &#125;</span><br><span class="line">            return prev[next];</span><br><span class="line">        &#125;,vm.$data)</span><br><span class="line">    &#125;,</span><br><span class="line">    model(node,vm,expr)&#123; //输入框处理</span><br><span class="line">        let updateFn=this.updater[&apos;modelUpdater&apos;];</span><br><span class="line">        //这里应该加一个监控，数据变化了应该调用这个watch的callback</span><br><span class="line">        new Watcher(vm,expr,(newValue)=&gt;&#123;</span><br><span class="line">        	//当值变化后会调用cb 将新的值传递过来</span><br><span class="line">             updateFn&amp;&amp;updateFn(node,this.getVal(vm.expr));</span><br><span class="line">        &#125;)</span><br><span class="line">        node.addEventListener(&apos;input&apos;,e=&gt;&#123;</span><br><span class="line">            let newValue =e.target.value;</span><br><span class="line">            this.setVal(vm,expr,newValue)</span><br><span class="line">        &#125;)</span><br><span class="line">        updateFn&amp;&amp;updateFn(node,this.getVal(vm.expr));</span><br><span class="line">    &#125;,</span><br><span class="line">    updater:&#123;</span><br><span class="line">        textUpdater(node,value)&#123; //文本更新</span><br><span class="line">            node.textContent=value;</span><br><span class="line">        &#125;,</span><br><span class="line">        modelUpdater(node,value)&#123; //输入框更新</span><br><span class="line">            node.value=value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">observer.js  </span><br><span class="line">class Observer&#123;</span><br><span class="line">    constructor(data)&#123;</span><br><span class="line">        this.observer(data);</span><br><span class="line">    &#125;</span><br><span class="line">    observer(data)&#123;</span><br><span class="line">        //要对这个data数据的所有属性改成set和get的形式</span><br><span class="line">        if(!data || typeof data !== &apos;object&apos;)&#123;//数据不存在或者数据不是对象，就不用劫持了</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //要将数据一一劫持，先获取到data的key和value</span><br><span class="line">        Object.keys(data).forEach(key=&gt;&#123;</span><br><span class="line">            //劫持</span><br><span class="line">            this.defineReactive(data,key,data[key])；</span><br><span class="line">            this.observer(data[key])//深度劫持</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    //定义响应式</span><br><span class="line">    defineReactive(obj,key,value)&#123;</span><br><span class="line">        let that=this;</span><br><span class="line">        let dep=new Dep();//每个变化的数据，都会对应一个数组，这个数组存放所有更新的操作。</span><br><span class="line">        Object.defineProperty(obj,key,&#123;</span><br><span class="line">            enumerable:true,</span><br><span class="line">            configurable:true,</span><br><span class="line">            get()&#123;</span><br><span class="line">            	//获取属性值的时候可以todo.....</span><br><span class="line">            	Dep.target &amp;&amp;dep.addSub(Dep.target);</span><br><span class="line">                return value;</span><br><span class="line">            &#125;</span><br><span class="line">            set(newValue)&#123; </span><br><span class="line">            	//设置属性值的时候可以todo.....(做一些想做的事)</span><br><span class="line">                if(newValue != value)&#123;</span><br><span class="line">                	that.observer(newValue);//如果新值是对象还得继续劫持，这里面的this不是实例。</span><br><span class="line">                    value = newValue;</span><br><span class="line">                    dep.notify();//通知所有人，数据更新了。</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dep&#123;</span><br><span class="line">    //发布订阅</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.subs=[];</span><br><span class="line">    &#125;</span><br><span class="line">    addSub(watcher)&#123;</span><br><span class="line">        this.subs.push(watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    notify()&#123;</span><br><span class="line">        this.subs.forEach(watcher=&gt;watcher.update());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">watcher.js</span><br><span class="line">//观察者的目的就是给需要变化的那个元素增加一个观察者，当数据变化后执行对应的方法。</span><br><span class="line">class Watcher&#123;</span><br><span class="line">    constructor(vm,expr,cb)&#123;</span><br><span class="line">        this.vm=vm;</span><br><span class="line">        this.expr=expr;</span><br><span class="line">        this.cb=cb;</span><br><span class="line">        //先获取一下老值</span><br><span class="line">        this.value=this.get();</span><br><span class="line">    &#125;</span><br><span class="line">    getVal(vm,expr)&#123;</span><br><span class="line">        expr=expr.split(&apos;.&apos;);</span><br><span class="line">        return expr.reduce((prev,next)=&gt;&#123;</span><br><span class="line">            return prev[next];</span><br><span class="line">        &#125;,vm.$data);</span><br><span class="line">    &#125;</span><br><span class="line">    get()&#123;</span><br><span class="line">    	Dep.target=this;</span><br><span class="line">        let value=this.getVal(this.vm,this.expr);</span><br><span class="line">        Dep.target=null;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    //对外暴露的方法</span><br><span class="line">    update()&#123;</span><br><span class="line">        let newValue=this.getVal(this.vm,this.expr);</span><br><span class="line">        let oldValue=this.value;</span><br><span class="line">        if(newValue != oldValue)&#123;</span><br><span class="line">            this.cb(newValue);//对应watch的callback;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//用新值和老值进行对比，如果发生变化，就调用更新方法</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mvvm/">mvvm</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-JsEvent-loop" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/15/JsEvent-loop/" class="article-date">
  	<time datetime="2017-11-15T06:12:39.000Z" itemprop="datePublished">2017-11-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/15/JsEvent-loop/">
        js事件循环
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="JS是单线程的"><a href="#JS是单线程的" class="headerlink" title="JS是单线程的"></a>JS是单线程的</h3><p>js是单线程的脚本语言，在同一时间只能干一件事，为了协调事件、用互交互、脚本和UI渲染等行为，防止主线程阻塞，Event Loop方案就诞生了</p>
<p>为什么是单线程呢？举个粟子，js主要用途之一是操作DOM，假如js同时有两个线程，同时对同一个dom进行操作，这时浏览器会蒙蔽了，不知道听哪个线程了，没有办法谁的优先级高，所以避免此问题，js是单线程的。</p>
<h3 id="执行栈与任务队列"><a href="#执行栈与任务队列" class="headerlink" title="执行栈与任务队列"></a>执行栈与任务队列</h3><p>#####1、执行栈</p>
<p>当执行某个函数、用户点击一次鼠标或者发送ajax等时，只要指定过回调函数，这些事件发生时就会进入执行栈中，等待主线程读取，遵循先进先出原则。</p>
<h4 id="2、主线程"><a href="#2、主线程" class="headerlink" title="2、主线程"></a>2、主线程</h4><p>主线程跟执行栈是不同的概念，主线程规定现在执行执行栈中的哪个事件。</p>
<p>当遇到一个异步事件后，并不会一直等待异步事件的返回结果，而是将这个事件挂在与执行栈不同的队列中，我们称之为任务队列（Task Queue）</p>
<p>当主线程执行栈中的所有代码执行完成后种（同步代码），主线程会去查看任务队列是否有任务，如果有，那么主线程会依次执行那些任务队列中的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">let a = () =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;任务队列函数1&apos;)</span><br><span class="line">    &#125;, 0)</span><br><span class="line">    for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        console.log(&apos;a的for循环&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;a事件执行完&apos;)</span><br><span class="line">&#125;</span><br><span class="line">let b = () =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;任务队列函数2&apos;)</span><br><span class="line">    &#125;, 0)</span><br><span class="line">    for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        console.log(&apos;b的for循环&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;b事件执行完&apos;)</span><br><span class="line">&#125;</span><br><span class="line">let c = () =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;任务队列函数3&apos;)</span><br><span class="line">    &#125;, 0)</span><br><span class="line">    for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        console.log(&apos;c的for循环&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;c事件执行完&apos;)</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line">b();</span><br><span class="line">c();</span><br><span class="line">// 当a、b、c函数都执行完成之后，三个setTimeout才会依次执行</span><br><span class="line">输出结果：5次a的for循环、a事件执行完、5次b的for循环、b事件执行完、5次c的for循环、c事件执行完、任务队列函数1、任务队列函数2、任务队列函数3</span><br></pre></td></tr></table></figure>
<h3 id="js异步执行的运行机制"><a href="#js异步执行的运行机制" class="headerlink" title="js异步执行的运行机制"></a>js异步执行的运行机制</h3><p>1、所有任务都在主线程上执行，形成一个执行栈。</p>
<p>2、主线程之外，还存在一个任务队列task queue，只要异步任务有了运行结果，就在任务队列之中放置一个事件。</p>
<p>3、一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，那些对应的异步任务、结束等待状态，进入执行栈并开始执行。</p>
<p>4、主线程不断重复上面的第三步。</p>
<h3 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h3><p>异步任务分为 宏任务macrotask和微任务microtask,不同的API注册的任务会依次进入自身对应的队列中，然后等待Event Loop将它们依次压入执行栈中执行。</p>
<p>宏任务：script(整体代码)、setTimeout   setInterval  UI渲染 I/O  postMessage   MessageChannel   setImmediate(node环境)</p>
<p>微任务：Promise  MutaionObserver  process.nextTick(node环境)</p>
<h3 id="Event-Loop-事件循环"><a href="#Event-Loop-事件循环" class="headerlink" title="Event Loop 事件循环"></a>Event Loop 事件循环</h3><p>事件循环中，每一次循环称为tick,每一tick的任务如下：</p>
<p>1、执行栈选择最先进入队列的宏任务（通常是script整体代码），如果有则执行。</p>
<p>2、检查是否存在Microtask，如果存在则不停的执行，直到清空microtask队列。</p>
<p>3、更新render（每一次事件循环，浏览器都可能会去更新渲染）</p>
<p>4、重复以上步骤</p>
<p>总结：宏任务—&gt;所有微任务—&gt;宏任务</p>
<p>可以这么理解哈：1、可将所有任务看成两个队列，执行队列与事件队列</p>
<p>​    2、执行队列是同步的，事件队列是异步的，宏任务放入事件列表，微任务放入执行队列之后，事件队列之前。</p>
<p>​    3、当执行完同步代码之后，就会执行位于执行列表之后的微任务，然后再执行事件列表中的宏任务。</p>
<h3 id="练练手"><a href="#练练手" class="headerlink" title="练练手"></a>练练手</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//执行顺序的问题</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">&#125;);</span><br><span class="line">new Promise(function(resolve,reject)&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">    resolve(3)</span><br><span class="line">&#125;).then(function(val)&#123;</span><br><span class="line">    console.log(val)</span><br><span class="line">&#125;);</span><br><span class="line">console.log(4);</span><br><span class="line">输出结果：2、4、3、1</span><br><span class="line">//分析</span><br><span class="line">1、先执行script同步代码</span><br><span class="line">	先执行new Promise中的打印2，then后面的不执行属于微任务(new Promise是同步代码)，然后执行打印4</span><br><span class="line">2、执行script宏任务后，执行微任务，打印3，没有其他的微任务了。</span><br><span class="line">3、执行另一个宏任务，定时器打印1.</span><br></pre></td></tr></table></figure>
<p>来源链接：<a href="https://segmentfault.com/a/1190000015317434?utm_medium=hao.caibaojian.com&amp;utm_source=hao.caibaojian.com&amp;share_user=1030000000178452" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015317434?utm_medium=hao.caibaojian.com&amp;utm_source=hao.caibaojian.com&amp;share_user=1030000000178452</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jsevent/">jsevent</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-xingneng" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/15/xingneng/" class="article-date">
  	<time datetime="2017-11-15T06:12:39.000Z" itemprop="datePublished">2017-11-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/15/xingneng/">
        前端性能与异常上报
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="一、异常捕获"><a href="#一、异常捕获" class="headerlink" title="一、异常捕获"></a>一、异常捕获</h4><p>对于web来说，需要捕获的异常无非就是以下两种</p>
<ul>
<li>接口调用情况</li>
<li>页面逻辑是否错误，例如用户进入页面显示白屏。</li>
</ul>
<p>对于接口调用情况，在前端通常需要上报客户端相关参数，例如：用户OS与浏览器版本、请求参数（如页面ID）；而对于页面逻辑是否错误问题，通常除了用户OS与浏览器版本外，需要的是报错的堆栈信息及具体报错位置。</p>
<p>#####异常捕获方法</p>
<h5 id="全局捕获"><a href="#全局捕获" class="headerlink" title="全局捕获"></a>全局捕获</h5><p>可以通过全局监听异常来捕获，通过window.onerror或者addEventListener,举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.onerror = function(errorMessage,scriptURI,lineNo,columnNo,error)&#123;</span><br><span class="line">    console.log(&apos;errorMessage: &apos; + errorMessage); // 异常信息</span><br><span class="line">  console.log(&apos;scriptURI: &apos; + scriptURI); // 异常文件路径</span><br><span class="line">  console.log(&apos;lineNo: &apos; + lineNo); // 异常行号</span><br><span class="line">  console.log(&apos;columnNo: &apos; + columnNo); // 异常列号</span><br><span class="line">  console.log(&apos;error: &apos; + error); // 异常堆栈信息</span><br><span class="line">  // ...</span><br><span class="line">  // 异常上报</span><br><span class="line">&#125;</span><br><span class="line">throw new Error(&apos;这是一个错误示例&apos;)</span><br></pre></td></tr></table></figure>
<p>通过<code>window.onerror</code>事件，可以得到具体的异常信息、异常文件的URL、异常的行号与列号及异常的堆栈信息，再捕获异常后，统一上报至我们的日志服务器。</p>
<p>亦或是，通过<code>window.addEventListener</code>方法来进行异常上报，道理同理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;error&apos;,function(各个参数)&#123;</span><br><span class="line">    console.log(arguments); </span><br><span class="line">  // 异常上报</span><br><span class="line">&#125;)</span><br><span class="line">throw new Error(&apos;这是一个错误&apos;);</span><br></pre></td></tr></table></figure>
<h5 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h5><p>使用<code>try... catch</code>虽然能够较好地进行异常捕获，不至于使得页面由于一处错误挂掉，但<code>try ... catch</code>捕获方式显得过于臃肿，大多代码使用<code>try ... catch</code>包裹，影响代码可读性。</p>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="跨域脚本无法准确捕获异常"><a href="#跨域脚本无法准确捕获异常" class="headerlink" title="跨域脚本无法准确捕获异常"></a>跨域脚本无法准确捕获异常</h5><p>跨域之后<code>window.onerror</code>根本捕获不到正确的异常信息，而是统一返回一个<code>Script error</code>，</p>
<p>解决方案：对<code>script</code>标签增加一个<code>crossorigin=”anonymous”</code>，并且服务器添加<code>Access-Control-Allow-Origin</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://cdn.xxx.com/index.js&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index.js</span><br><span class="line">throw new Error(&apos;这是一个错误&apos;)//此时onerror就能正常监听到indexjs抛出的错误</span><br></pre></td></tr></table></figure>
<h5 id="sourceMap"><a href="#sourceMap" class="headerlink" title="sourceMap"></a>sourceMap</h5><p>通常在生产环境下的代码是经过<code>webpack</code>打包后压缩混淆的代码，我们发现所有的报错的代码行数都在第一行了，为什么呢？这是因为在生产环境下，我们的代码被压缩成了一行：</p>
<p>解决办法是开启<code>webpack</code>的<code>source-map</code>，我们利用<code>webpack</code>打包后的生成的一份<code>.map</code>的脚本文件就可以让浏览器对错误位置进行追踪了。其实就是<code>webpack.config.js</code>中加上一行<code>devtool: &#39;source-map&#39;</code>.</p>
<p>开启<code>source-map</code>的缺陷是兼容性，目前只有<code>Chrome</code>浏览器和<code>Firefox</code>浏览器才对<code>source-map</code>支持。不过我们对这一类情况也有解决办法。可以使用引入<code>npm</code>库来支持<code>source-map</code>，这个库可以运行在客户端也可以运行在服务端。</p>
<h3 id="二、性能监控"><a href="#二、性能监控" class="headerlink" title="二、性能监控"></a>二、性能监控</h3><h4 id="最简单的性能监控"><a href="#最简单的性能监控" class="headerlink" title="最简单的性能监控"></a>最简单的性能监控</h4><p>最常见的性能监控需求则是需要我们统计用户从开始请求页面到所有<code>DOM</code>元素渲染完成的时间，也就是俗称的首屏加载时间，<code>DOM</code>提供了这一接口，监听<code>document</code>的<code>DOMContentLoaded</code>事件与<code>window</code>的<code>load</code>事件可统计页面首屏加载时间即所有<code>DOM</code>渲染时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;&lt;/title&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // 记录页面加载开始时间</span><br><span class="line">    var timerStart = Date.now();</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;!-- 加载静态资源，如样式资源 --&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- 加载静态JS资源 --&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    document.addEventListener(&apos;DOMContentLoaded&apos;, function() &#123;</span><br><span class="line">      console.log(&quot;DOM 挂载时间: &quot;, Date.now() - timerStart);</span><br><span class="line">      // 性能日志上报</span><br><span class="line">    &#125;);</span><br><span class="line">    window.addEventListener(&apos;load&apos;, function() &#123;</span><br><span class="line">      console.log(&quot;所有资源加载完成时间: &quot;, Date.now()-timerStart);</span><br><span class="line">      // 性能日志上报</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>对于使用框架，如<code>Vue</code>或者说<code>React</code>，组件是异步渲染然后挂载到<code>DOM</code>的，在页面初始化时并没有太多的<code>DOM</code>节点，可以参考下文<a href="https://link.juejin.im/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000013016763" target="_blank" rel="noopener">关于首屏时间采集自动化的解决方案</a>来对渲染时间进行打点。</p>
<h4 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h4><p>但是以上时间的监控过于粗略，例如我们想统计文档的网络加载耗时、解析<code>DOM</code>的耗时与渲染<code>DOM</code>的耗时，就不太好办到了，所幸的是浏览器提供了<code>window.performance</code>接口，几乎所有的浏览器都支持此接口。</p>
<p><code>window,performance</code>主要包括有<code>memory</code>、<code>navigation</code>、<code>timing</code>以及<code>timeOrigin</code>及<code>onresourcetimingbufferfull</code>方法。</p>
<h4 id="计算网站性能"><a href="#计算网站性能" class="headerlink" title="计算网站性能"></a>计算网站性能</h4><p>使用<code>performance</code>的<code>timing</code>属性，可以拿到页面性能相关的数据</p>
<h3 id="三、日志上报"><a href="#三、日志上报" class="headerlink" title="三、日志上报"></a>三、日志上报</h3><p>####单独的日志域名</p>
<p>对于日志上报使用单独的日志域名的目的是避免对业务造成影响。其一，对于服务器来说，我们肯定不希望占用业务服务器的计算资源，也不希望过多的日志在业务服务器堆积，造成业务服务器的存储空间不够的情况。其二，我们知道在页面初始化的过程中，会对页面加载时间、PV、UV等数据进行上报，这些上报请求会和加载业务数据几乎是同时刻发出，而浏览器一般会对同一个域名的请求量有并发数的限制，如<code>Chrome</code>会有对并发数为<code>6</code>个的限制。因此需要对日志系统单独设定域名，最小化对页面加载性能造成的影响。</p>
<h4 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h4><p>对于单独的日志域名，肯定会涉及到跨域的问题，采取的解决方案一般有以下两种：</p>
<ul>
<li>一种是构造空的<code>Image</code>对象的方式，其原因是请求图片并不涉及到跨域的问题；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var url = &apos;xxx&apos;;</span><br><span class="line">new Image().src = url;</span><br></pre></td></tr></table></figure>
<ul>
<li>利用<code>Ajax</code>上报日志，必须对日志服务器接口开启跨域请求头部<code>Access-Control-Allow-Origin:*</code>，这里<code>Ajax</code>就并不强制使用<code>GET</code>请求了，即可克服<code>URL</code>长度限制的问题。</li>
</ul>
<p>大多使用的是第一种的方式，也就是构造空的<code>Image</code>对象，但是我们知道对于<code>GET</code>请求会有长度的限制，需要确保的是请求的长度不会超过阈值。</p>
<h4 id="省去响应主体"><a href="#省去响应主体" class="headerlink" title="省去响应主体"></a>省去响应主体</h4><p>使用的是第一种的方式，也就是构造空的<code>Image</code>对象，但是我们知道对于<code>GET</code>请求会有长度的限制，需要确保的是请求的长度不会超过阈值。</p>
<h4 id="合并上报"><a href="#合并上报" class="headerlink" title="合并上报"></a>合并上报</h4><p>类似于雪碧图的思想，如果我们的应用需要上报的日志数量很多，那么有必要合并日志进行统一的上报。</p>
<p>解决方案可以是尝试在用户离开页面或者组件销毁时发送一个异步的<code>POST</code>请求来进行上报，但是尝试在卸载（<code>unload</code>）文档之前向<code>web</code>服务器发送数据。保证在文档卸载期间发送数据一直是一个困难。因为用户代理通常会忽略在卸载事件处理器中产生的异步<code>XMLHttpRequest</code>，因为此时已经会跳转到下一个页面。所以这里是必须设置为同步的<code>XMLHttpRequest</code>请求。</p>
<p>使用同步的方式势必会对用户体验造成影响，甚至会让用户感受到浏览器卡死感觉，对于产品而言，体验非常不好，可以使用<code>sendBeacon()</code>方法，将会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。这就解决了提交分析数据时的所有的问题：使它可靠，异步并且不会影响下一页面的加载。此外，代码实际上还要比其他技术简单！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;unload&apos;, logData, false);</span><br><span class="line"></span><br><span class="line">function logData() &#123;</span><br><span class="line">    navigator.sendBeacon(&quot;/log&quot;, analyticsData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>代码难免有问题，对于异常可以使用<code>window.onerror</code>或者<code>addEventListener</code>的方式添加全局的异常捕获侦听函数，但可能使用这种方式无法正确捕获到错误：对于跨域的脚本，需要对<code>script</code>标签增加一个<code>crossorigin=”anonymous”</code>；对于生产环境打包的代码，无法正确定位到异常产生的行数，可以使用<code>source-map</code>来解决；而对于使用框架的情况，需要在框架统一的异常捕获处埋点。</p>
<p>而对于性能的监控，所幸的是浏览器提供了<code>window.performance API</code>，通过这个<code>API</code>，很便捷地获取到当前页面性能相关的数据。</p>
<p>而这些异常和性能数据如何上报呢？一般说来，为了避免对业务产生的影响，会单独建立日志服务器和日志域名，但对于不同的域名，又会产生跨域的问题。我们可以通过构造空的<code>Image</code>对象来解决，亦或是通过设定跨域请求头部<code>Access-Control-Allow-Origin:*</code>来解决。此外，如果上报的性能和日志数据高频触发，则可以在页面<code>unload</code>时统一上报，而<code>unload</code>时的异步请求又可能会被浏览器所忽略，且不能改为同步请求。此时<code>navigator.sendBeacon API</code>可算帮了我们大忙，它可用于通过<code>HTTP</code>将少量数据异步传输到<code>Web</code>服务器。而忽略页面<code>unload</code>时的影响。</p>
<p>出处链接：<a href="https://juejin.im/post/5b5dcfb46fb9a04f8f37afbb" target="_blank" rel="noopener">https://juejin.im/post/5b5dcfb46fb9a04f8f37afbb</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/性能、异常上报/">性能、异常上报</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-TDZ" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/15/TDZ/" class="article-date">
  	<time datetime="2017-11-15T06:12:39.000Z" itemprop="datePublished">2017-11-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/15/TDZ/">
        es6中的暂时性死区
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a><strong>暂时性死区</strong></h4><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var tmp = 123;</span><br><span class="line">if (true) &#123;</span><br><span class="line">  tmp = &apos;abc&apos;; // ReferenceError</span><br><span class="line">  let tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p>
<p>ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  // TDZ开始</span><br><span class="line">  tmp = &apos;abc&apos;; // ReferenceError</span><br><span class="line">  console.log(tmp); // ReferenceError</span><br><span class="line"></span><br><span class="line">  let tmp; // TDZ结束</span><br><span class="line">  console.log(tmp); // undefined</span><br><span class="line"></span><br><span class="line">  tmp = 123;</span><br><span class="line">  console.log(tmp); // 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，在<code>let</code>命令声明变量<code>tmp</code>之前，都属于变量<code>tmp</code>的“死区”。</p>
<p>“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof x; // ReferenceError</span><br><span class="line">let x;</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>x</code>使用<code>let</code>命令声明，所以在声明之前，都属于<code>x</code>的“死区”，只要用到该变量就会报错。因此，<code>typeof</code>运行时就会抛出一个<code>ReferenceError</code>。</p>
<p>作为比较，如果一个变量根本没有被声明，使用<code>typeof</code>反而不会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof undeclared_variable // &quot;undefined&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>undeclared_variable</code>是一个不存在的变量名，结果返回“undefined”。所以，在没有<code>let</code>之前，<code>typeof</code>运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p>
<p>有些“死区”比较隐蔽，不太容易发现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function bar(x = y, y = 2) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); // 报错</span><br></pre></td></tr></table></figure>
<p>上面代码中，调用<code>bar</code>函数之所以报错（某些实现可能不报错），是因为参数<code>x</code>默认值等于另一个参数<code>y</code>，而此时<code>y</code>还没有声明，属于”死区“。如果<code>y</code>的默认值是<code>x</code>，就不会报错，因为此时<code>x</code>已经声明了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function bar(x = 2, y = x) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line">bar(); // [2, 2]</span><br></pre></td></tr></table></figure>
<p>另外，下面的代码也会报错，与<code>var</code>的行为不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 不报错</span><br><span class="line">var x = x;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">let x = x;</span><br><span class="line">// ReferenceError: x is not defined</span><br></pre></td></tr></table></figure>
<p>上面代码报错，也是因为暂时性死区。使用<code>let</code>声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量<code>x</code>的声明语句还没有执行完成前，就去取<code>x</code>的值，导致报错”x 未定义“。</p>
<p>ES6 规定暂时性死区和<code>let</code>、<code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p>
<p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
<p>参考链接：<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/let</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-macfixhosts" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/15/macfixhosts/" class="article-date">
  	<time datetime="2017-10-15T06:12:39.000Z" itemprop="datePublished">2017-10-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/15/macfixhosts/">
        mac更改hosts权限的三种方法
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1、命令行"><a href="#1、命令行" class="headerlink" title="1、命令行"></a>1、命令行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod og+w /etc/hosts</span><br></pre></td></tr></table></figure>
<h4 id="2、显示简介里修改"><a href="#2、显示简介里修改" class="headerlink" title="2、显示简介里修改"></a>2、显示简介里修改</h4><p>前往-&gt;前往文件夹（shift+command+g）,在路径中输入/private,在etc文件夹上右键-&gt;显示简介-&gt;在最下面找到共享与权限，将everyone的权限修改为读与写（注意打开右下角的小锁才能修改）。然后进入etc文件夹后，找到hosts文件同样把everyone权限改为读和写。此时就能修改hosts文件了。</p>
<h4 id="3、复制替换"><a href="#3、复制替换" class="headerlink" title="3、复制替换"></a>3、复制替换</h4><p>shift+command+g,输入/etc/hosts,找到hosts复制一份，然后更改复制的那份hosts文件，改好后替换原来的。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maxhosts/">maxhosts</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Vuex" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/15/Vuex/" class="article-date">
  	<time datetime="2017-10-15T06:12:39.000Z" itemprop="datePublished">2017-10-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/15/Vuex/">
        vue状态管理器Vuex
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>是一个专为vue.js应用程序开发的状态管理模式</p>
<p>当我们构建一个中大型的单页应用程序时，vuex可以更好地帮助我们在组件外部统一管理状态</p>
<h3 id="Vuex核心概念"><a href="#Vuex核心概念" class="headerlink" title="Vuex核心概念"></a>Vuex核心概念</h3><p>State/Getters/Mutations/Actions/Modules</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">State</span><br><span class="line">State是唯一的数据源。特点：单一状态树</span><br><span class="line">const Counter = &#123;//定义一个组件Counter</span><br><span class="line">    template:`&lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;`</span><br><span class="line">    computed:&#123;//计算属性</span><br><span class="line">        count()&#123;</span><br><span class="line">            return this.$store.state.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Getters</span><br><span class="line">通过Getters可以派生出一些新的状态</span><br><span class="line">const store =new Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        todos:[</span><br><span class="line">            &#123;id:1,age:10,done:true&#125;,</span><br><span class="line">            &#123;id:2,age:18,done:false&#125;</span><br><span class="line">        ]，</span><br><span class="line">        name:&apos;ywx&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;</span><br><span class="line">        doneTodos:state=&gt;&#123;</span><br><span class="line">            return state.todos.filiter(todo=&gt;todo.done)</span><br><span class="line">        &#125;,</span><br><span class="line">        userName(state)&#123;</span><br><span class="line">            return state.name+&apos;,hello&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">在组件中的computed中取userName；</span><br><span class="line">computed:&#123;</span><br><span class="line">    userName()&#123;</span><br><span class="line">        return this.$store.getters.userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Mutations</span><br><span class="line">更改Vuex的store中的状态的唯一方法是提交mutation</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        count:1,</span><br><span class="line">        price:10</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;//定义的方法不能有异步方法</span><br><span class="line">        add(state,num)&#123;</span><br><span class="line">            state.count+=num;//变更状态</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions:&#123;</span><br><span class="line">        add(context,num)&#123;</span><br><span class="line">            context.commit(&apos;add&apos;,num)//触发的是mutations里的add方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">在组件中更改状态的触发方式为：this.$store.commit(&apos;add&apos;,8)；也可以通过dispatch调度actions里的方法进行更改状态，this.$store.dispatch(&apos;add&apos;,8),调用actions里的add方法进行触发mutations里的add方法从而改变状态。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Actions</span><br><span class="line">Action提交的是mutation,而不是直接变更状态，它可以包含任意异步操作</span><br><span class="line">例子同上</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Modules</span><br><span class="line">面对复杂的应用程序，当管理的状态比较多时，可以将vuex的store对象分割成模块(modules)</span><br><span class="line">const moduleA = &#123;</span><br><span class="line">    state:&#123;&#125;,</span><br><span class="line">    mutations:&#123;&#125;,</span><br><span class="line">    actions:&#123;&#125;,</span><br><span class="line">    getters:&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">const moduleB= &#123;</span><br><span class="line">    state:&#123;&#125;,</span><br><span class="line">    mutations:&#123;&#125;,</span><br><span class="line">    actions:&#123;&#125;,</span><br><span class="line">    getters:&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    modules:&#123;</span><br><span class="line">        a:moduleA,</span><br><span class="line">        b:moduleB</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注：在公共state中定义的变量就不用在组件中的data中定义了，要在组件中的计算属性computed中来动态取state中的值。定义好的store要添加到new Vue的对象中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">第一种：</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el:&apos;#app&apos;,</span><br><span class="line">    store,</span><br><span class="line">    data()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    computed:&#123; //这样页面中就能使用count 和price这两个变量了。需要更多变量可以按此格式加state里对应的变量</span><br><span class="line">        count()&#123;</span><br><span class="line">            return this.$store.state.count;</span><br><span class="line">        &#125;,</span><br><span class="line">        price()&#123;</span><br><span class="line">            return this.$store.state.price;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">第二种：</span><br><span class="line">当computed里用到变量很多的时候，这种写法不优雅，此时可以引入mapState</span><br><span class="line">import &#123;mapState&#125; from &apos;vuex&apos;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el:&apos;#app&apos;,</span><br><span class="line">    data()&#123;&#125;,</span><br><span class="line">    store,</span><br><span class="line">    computed:&#123;</span><br><span class="line">        ...mapState([&apos;count&apos;,&apos;price&apos;]); //这种写法简便，功能和上面是一样的。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vuex/">vuex</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-debounceAndthrottle" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/15/debounceAndthrottle/" class="article-date">
  	<time datetime="2017-09-15T06:12:39.000Z" itemprop="datePublished">2017-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/15/debounceAndthrottle/">
        防抖和节流的节流的相关学习
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是防抖和节流"><a href="#什么是防抖和节流" class="headerlink" title="什么是防抖和节流"></a>什么是防抖和节流</h3><p>两者都是优化高频率执行js代码的一种手段。防抖常用于用户注册时手机号码和邮箱验证了，只有等用户输完了，才去检查格式是否正常等。节流常用于监听页面滚动事件。</p>
<p>比如搜索框，用户在输入的时候使用<code>change</code>事件去调用搜索，如果用户每一次输入都去搜索的话，那得消耗多大的服务器资源，即使你的服务器很强大，但是也不带这么玩的。</p>
<h4 id="一、防抖—debounce"><a href="#一、防抖—debounce" class="headerlink" title="一、防抖—debounce"></a>一、防抖—debounce</h4><p>其中的一种解决方案就是每次用户停止输入后，延迟超过500ms时，才去搜索此时的String,这就是防抖。</p>
<p>原理：将若干个函数调用合并成一次，并在给定时间过去之后仅被调用一次。</p>
<p>代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let timer=null;</span><br><span class="line">function debounce(fn,delay)&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        let context=this;</span><br><span class="line">        let args=arguments;</span><br><span class="line">        //清掉正在执行的函数，并重新执行</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(function()&#123;</span><br><span class="line">            fn.applay(context,args);</span><br><span class="line">        &#125;,delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let flag= 0;</span><br><span class="line">function foo()&#123;</span><br><span class="line">    flag++;</span><br><span class="line">    console.log(flag);</span><br><span class="line">&#125;</span><br><span class="line">document.body.addEventListener(&apos;scroll&apos;,debounce(foo,2000));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1.debounce函数封装后，返回内部函数。</p>
<p>2.每一次事件被触发，都会清除当前的timer然后重新设置超时并调用。这会导致每一次高频事件都会取消前一次的超时调用，导致事件处理程序不能被触发</p>
<p>3.只有当高频事件停止，最后一次事件触发的超时调用才能在delay时间后执行</p>
</blockquote>
<h4 id="二、节流—throttle（这种解释有点啰嗦，不便理解，直接看最后）"><a href="#二、节流—throttle（这种解释有点啰嗦，不便理解，直接看最后）" class="headerlink" title="二、节流—throttle（这种解释有点啰嗦，不便理解，直接看最后）"></a>二、节流—throttle（这种解释有点啰嗦，不便理解，直接看最后）</h4><p>节流这种解决方案比防抖要宽松些，这时我们不想用户一味的输入，而是给用户一些搜索提示，所以在当中限制每过500ms就查询一次此时的String,这就是节流。</p>
<p>原理：节流函数不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数。</p>
<p>代码实现有两种，一种是时间戳，另一种是定时器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">时间戳方法：</span><br><span class="line">let prev=Date.now();</span><br><span class="line">function throttle(fn,delay)&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        const context=this;</span><br><span class="line">        const args=arguments;</span><br><span class="line">        let now= Date.now();</span><br><span class="line">        if(now-prev&gt;=delay)&#123;</span><br><span class="line">            fn.apply(context,args);</span><br><span class="line">            prev=Date.now();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当高频事件触发时，第一次应该会立即执行（给事件绑定函数与真正触发事件的间隔如果大于delay的话），然后再怎么频繁触发事件，也都是会每delay秒才执行一次，而当最后一次事件触发完毕后，事件也不会再被执行。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">定时器方法：当触发事件的时候，设置一个定时器，再触发事件的时候，如果定时器存在，就不执行；直到delay后，定时器执行执行函数，清空定时器，这样就可以设置下个定时器了。</span><br><span class="line">let timer=null;</span><br><span class="line">function throttle(fn,delay)&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        let context=this;</span><br><span class="line">        let args=arguments;</span><br><span class="line">        if(!timer)&#123;</span><br><span class="line">            timer=setTimeout(function()&#123;</span><br><span class="line">                fn.apply(context,args);</span><br><span class="line">                timer=null;</span><br><span class="line">            &#125;,delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当第一次触发事件时，肯定不会立即执行函数，而是在delay秒后才执行，之后连续不断的触发，也会第delay秒执行一次。当最后一次停止触发后，由于定时器的delay延迟，可能还会执行一次函数</p>
</blockquote>
<p>最后，综合使用时间戳和定时器，完成一个事件触发时立即执行，触发完毕还能执行一次的节流函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let timer=null;</span><br><span class="line">let startTime = Date.now();</span><br><span class="line">function throttle(fn,delay)&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        let currentTime=Date.now();</span><br><span class="line">        let remaining=delay-(currentTime-startTime);</span><br><span class="line">        const context=this;</span><br><span class="line">        const args=argumnets;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        if(remaining&lt;=0)&#123;</span><br><span class="line">            fn.apply(context,args);</span><br><span class="line">            startTime=Date.now();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            timer=setTimeout(fn,remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要在每个delay时间中一定会执行一次函数，因此在节流函数使用开始时间、当前时间与delay来计算remaining,当小于等于0时表示该执行函数了。如果还没到时间的话就设定在remaining时间后发生，当然在remaining时间中如果又一次发生事件，那么会取消当前的计时器，并重新计算一个remaining来判断当前状态。</p>
</blockquote>
<h4 id="节流的另一种实现：更易于理解"><a href="#节流的另一种实现：更易于理解" class="headerlink" title="节流的另一种实现：更易于理解"></a>节流的另一种实现：更易于理解</h4><p>原理：声明一个变量当标志，记录当前代码是否在执行，如果空闲，则可以正常触发函数执行。如果代码正在运行，刚取消这次方法执行，直接return.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let canRun=true;</span><br><span class="line">document.getElementById(&apos;throttle&apos;).onscroll=function()&#123;</span><br><span class="line">    if(!canRun)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    canRun=false;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(&apos;函数节流&apos;)；</span><br><span class="line">        canRun=true;</span><br><span class="line">    &#125;,500);</span><br><span class="line">&#125;</span><br><span class="line">当高频触发时，每隔500ms执行一次。</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/防抖、节流/">防抖、节流</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-flexbox" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/08/15/flexbox/" class="article-date">
  	<time datetime="2017-08-15T06:12:39.000Z" itemprop="datePublished">2017-08-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/flexbox/">
        flexbox布局学习
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="适用于父元素上："><a href="#适用于父元素上：" class="headerlink" title="适用于父元素上："></a>适用于父元素上：</h3><p>display:flex;  //设置为弹性盒模型</p>
<p>flex-direction：row/row-reverse/column/column-reverse 确定主轴方向,此设置项设置的是子元素的排列方向。</p>
<p>flex-wrap:nowrap/wrap/wrap-reverse   弹性盒的子元素超出父容器时是否换行。</p>
<p>flex-flow: ‘flex-direction’ ‘flex-wrap’    两者的复合写法</p>
<p>justify-content:flex-start/flex-end/center/space-between/space-around  确定在主轴方向上的对齐方式</p>
<p>align-items:flex-start/flex-end/center/baseline/stretch 确定子元素在交叉轴上的对齐方式（stretch：意思是尽可能的拉伸，子元素不能设置高度才能生效。）</p>
<p>align-content: flex-start/flex-end/center/space-between/space-around /stretch 用来处理交叉轴的空白区域。(只有一行此属性不生效，适用于超出换行的情况)</p>
<h3 id="适用于子元素上："><a href="#适用于子元素上：" class="headerlink" title="适用于子元素上："></a>适用于子元素上：</h3><p>align-self: 用来覆盖父容器指定的对齐方式（交叉轴方向）。除了align-items值之外，还可以设置为auto;当其设置为auto时，其计算值是父节点的属性align-items的值。如果该节点没有父节点，则计算值为“stretch”.</p>
<p>order:用整数值来定义排列顺序，数值小的排在前面。可以为负值。</p>
<h5 id="下面是不常用的"><a href="#下面是不常用的" class="headerlink" title="下面是不常用的"></a>下面是不常用的</h5><p>flex-grow:<number>(default 0)   不允许为负值。设置或检索弹性盒的扩展比例。如果有剩余空间，根据弹性盒子元素所设置的扩展因子作为比率为分配剩余的空间。当有多余空间时此属性起作用。</number></p>
<p>flex-shrink:<number>(default 1)  设置或检索弹性盒的收缩比率（根据弹性盒子元素所设置的收缩因子作为比率来收缩空间）当有内容溢出时此属性起作用。</number></p>
<p>Flex:none或者flex-grow flex-shrink flex-basic  复合属性。设置或检索伸缩盒对象的子元素如何分配空间。值为none,计算值为 0 0 auto.如果缩写flex:1,则计算值为 1 1 0%;</p>
<p>Flex-basis:定义弹性盒子元素的默认基准值。子元素扩展内容或者收缩内容时以flex-basis的值为基准。</p>
<p>Flex-basis的值可以为auto、百分比、具体的px值。设置为百分比时是相对于父元素的百分比。如果设置了除auto以外的值 ，则对子元素设置的width不起作用。如果设置值为auto,则宽度以width值为准。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flex:0 1 auto; =&gt;flex的默认值</span><br><span class="line">flex:1;=&gt;flex:1 1 0%;</span><br><span class="line">flex:none;=&gt;flex：0 0 auto;</span><br><span class="line">flex:auto;=&gt;flex:1 1 auto;</span><br></pre></td></tr></table></figure>
<p>最后记住：flex也有兼容性问题。分为09版本和12版本，兼容写法可以参考swiper。其实每个版本只是属性名和值不一样，意思是一样滴。</p>
<p>下面举个三栏布局的应用粟子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    *&#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .wrap &gt; *&#123;</span><br><span class="line">        height: 100px;</span><br><span class="line">        width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    .wrap&#123;</span><br><span class="line">        display: flex;</span><br><span class="line">        flex-wrap: wrap;</span><br><span class="line">    &#125;</span><br><span class="line">    .header&#123;</span><br><span class="line">         background-color: red;</span><br><span class="line">     &#125;</span><br><span class="line">    .main&#123;</span><br><span class="line">        background-color: #27ff21;</span><br><span class="line">        height: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    .aside1&#123;</span><br><span class="line">        background-color: #fff419;</span><br><span class="line">        height: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    .aside2&#123;</span><br><span class="line">        background-color: #3b24ff;</span><br><span class="line">        height: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    .footer&#123;</span><br><span class="line">        background-color: #ff985c;</span><br><span class="line">    &#125;</span><br><span class="line">    @media all and (min-width: 600px) &#123;</span><br><span class="line">        .aside&#123;</span><br><span class="line">            flex:1 0%;/*省略了收缩比例，等同于flex:1 1 0%*/</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @media all and (min-width: 800px) &#123;</span><br><span class="line">        .main&#123;</span><br><span class="line">            flex:2 0%;/*flex-basis设置为除auto以处的值，此时宽度不生效了*/</span><br><span class="line">        &#125;</span><br><span class="line">        .aside1&#123;</span><br><span class="line">            order: -1;</span><br><span class="line">        &#125;</span><br><span class="line">        .header&#123;</span><br><span class="line">            order:-2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;header&quot;&gt;header&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;aside aside1&quot;&gt;aside1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;aside aside2&quot;&gt;aside2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flexbox/">flexbox</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-repaintandreflow" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/08/15/repaintandreflow/" class="article-date">
  	<time datetime="2017-08-15T06:12:39.000Z" itemprop="datePublished">2017-08-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/repaintandreflow/">
        浏览器渲染之重排与重绘
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#####一、url从输入到页面展示的过程</p>
<p>首先，我们假设输入的url的请求为最简单的Http请求，以GET请求为例，大致分以下几个步骤：</p>
<ol>
<li>用户在浏览器的地址栏输入访问的URL地址。浏览器会先根据这个URL查看浏览器缓存-系统缓存-路由器缓存，若缓存中有，直接跳到第6步操作，若没有，则按照下面的步骤进行操作。</li>
<li>浏览器根据输入的URL地址解析出主机名。</li>
<li>浏览器将主机名转换成服务器ip地址。浏览器先查找本地DNS缓存列表，看缓存里面是否存在这个ip,如果有则进入第4步，如果缓存中不存在这个ip地址，就再向浏览器默认的DNS服务器发送查询请求，同时缓存当前这个ip到DNS缓存列表中。</li>
<li>拿到ip地址后，浏览器再从URL中解析出端口号。</li>
<li>拿到ip和端口后，浏览器会建立一条与目标Web服务器的TCP连接，也就是传说中的三次握手。</li>
<li>浏览器向服务器发送一条HTTP请求报文。</li>
<li>服务器向浏览器返回一条HTTP响应报文。</li>
<li>关闭连接 浏览器解析文档。</li>
<li>如果文档中有资源则重复6、7、8动作，直至资源全部加载完毕。</li>
</ol>
<h4 id="二、为什么操作Dom会变慢"><a href="#二、为什么操作Dom会变慢" class="headerlink" title="二、为什么操作Dom会变慢"></a>二、为什么操作Dom会变慢</h4><p>在浏览器中，javasrcipt和dom是分开来实现的。第一次通过js操作dom的时候，就需要先去连接js和dom.我们可以这样理解：把DOM和JavaScript比作两个岛，他们之间通过一个收费的桥连接着，每一次访问DOM的时候，就需要经过这座桥，并且给“过路费”，访问的次数越多，路费就会越高，并且访问到DOM后，操作具体的DOM还需要给“操作费”，由于浏览器访问DOM的操作很多，因此，“路费”和“操作费”自然会增加，这就是为什么操作DOM会很慢的原因</p>
<h4 id="三、浏览器渲染html的步骤："><a href="#三、浏览器渲染html的步骤：" class="headerlink" title="三、浏览器渲染html的步骤："></a>三、浏览器渲染html的步骤：</h4><p>HTML渲染大致分为如下几步：</p>
<ol>
<li>HTML被HTML解析器解析成DOM Tree, css则被css解析器解析成CSSOM Tree。</li>
<li>DOM Tree和CSSOM Tree解析完成后，被附加到一起，形成渲染树（Render Tree）。</li>
<li>节点信息计算(重排或者叫回流)，这个过程被叫做Reflow。即根据渲染树计算每个节点的几何信息。</li>
<li>渲染绘制(重绘)，这个过程被叫做(Painting 或者 Repaint)。即根据计算好的信息绘制整个页面。</li>
</ol>
<p>以上4步简述浏览器的一次渲染过程，理论上，每一次的dom更改或者css几何属性更改，都会引起一次浏览器的重排/重绘过程，而如果是css的非几何属性更改，则只会引起重绘过程。所以说重排一定会引起重绘，而重绘不一定会引起重排。</p>
<h4 id="四、回流-重排（reflow）"><a href="#四、回流-重排（reflow）" class="headerlink" title="四、回流/重排（reflow）"></a>四、回流/重排（reflow）</h4><p>浏览器渲染页面默认采用的是流式布局模型（Flow Based Layout）</p>
<p>所谓重排，实际上是根据渲染树中每个渲染对象的信息，计算出各自渲染对象的几何信息（DOM对象的位置和尺寸大小），并将其安置在界面中的正确位置。</p>
<p>由于浏览器渲染界面是基于流式布局模型的，也就是某一个DOM节点信息更改了，就需要对DOM结构进行重新计算，重新布局界面，再次引发回流，只是这个结构更改程度会决定周边DOM更改范围，即全局范围和局部范围，全局范围就是从根节点<code>html</code>开始对整个渲染树进行重新布局，例如当我们改变了窗口尺寸或方向或者是修改了根元素的尺寸或者字体大小等；而局部布局可以是对渲染树的某部分或某一个渲染对象进行重新布局。</p>
<p>在此，总结会引起重排的操作有：</p>
<ol>
<li>页面首次渲染。</li>
<li>浏览器窗口大小发生改变。</li>
<li>元素尺寸或位置发生改变。</li>
<li>元素内容变化（文字数量或图片大小等等）。</li>
<li>元素字体大小变化。</li>
<li>添加或者删除可见的DOM元素。</li>
<li>激活CSS伪类（例如：:hover）。</li>
<li>设置style属性</li>
<li>查询某些属性或调用某些方法。</li>
</ol>
<p>重排也叫回流，实际上，reflow的字面意思也是回流，标准文档之所以叫做回流（Reflow）,是因为浏览器渲染是基于“流式布局”的模型，流实际就使我们常说的文档流，当dom或者css几何属性发生改变的时候，文档流会受到波动联动的去更改，流就好比一条河里的水，回流就好比向河里扔了一块石头，激起涟漪，然后引起周边水流受到波及，所以叫做回流.</p>
<h4 id="五、重绘（Repainting）"><a href="#五、重绘（Repainting）" class="headerlink" title="五、重绘（Repainting）"></a>五、重绘（Repainting）</h4><p>所谓重绘，就是当页面中元素样式的改变并不影响它在文档流中的位置时，例如更改了字体颜色,浏览器会将新样式赋予给元素并重新绘制的过程称。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>我们知道操作DOM是一个高成本的操作，不仅是因为本身js与DOM的链接访问，还包括操作DOM后悔引起一连串的连锁反应（重排），因此，从性能优化角度，我们可以从以下几个方面着手：</p>
<ul>
<li>减少DOM操作<ul>
<li>最小化DOM访问次数，尽量缓存访问DOM的样式信息，避免过度触发回流。</li>
<li>如果在一个局部方法中需要多次访问同一个dom，则先暂存它的引用。</li>
</ul>
</li>
<li>采用更优的API替代消费高的api，转换优化消费高的集合<ul>
<li>用querySelectorAll()替代getElementByXX()。</li>
<li>开启动画的GPU加速，把渲染计算交给GPU。</li>
<li>少用HTML集合（类数组）来遍历，因为集合遍历比真数组遍历耗费更高。</li>
<li>用事件委托来减少事件处理器的数量。</li>
</ul>
</li>
<li>减少重排<ul>
<li>避免设置大量的style属性，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow，所以最好是使用class属性</li>
<li>实现元素的动画，它的position属性，最好是设为absoulte或fixed，这样不会影响其他元素的布局</li>
<li>动画实现的速度的选择。比如实现一个动画，以1个像素为单位移动这样最平滑，但是reflow就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多。</li>
<li>不要使用table布局，因为table中某个元素旦触发了reflow，那么整个table的元素都会触发reflow。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围</li>
</ul>
</li>
<li>css及动画处理<ul>
<li>少用css表达式</li>
<li>减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；</li>
<li>动画尽量使用在绝对定位或固定定位的元素上；</li>
<li>隐藏在屏幕外，或在页面滚动时，尽量停止动画；</li>
</ul>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/reflow、repaint/">reflow、repaint</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-transformVsTranslation" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/08/15/transformVsTranslation/" class="article-date">
  	<time datetime="2017-08-15T06:12:39.000Z" itemprop="datePublished">2017-08-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/transformVsTranslation/">
        CSS3中 translate、transform和translation，和动画animation
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1、translate-移动，它是transform的一个方法"><a href="#1、translate-移动，它是transform的一个方法" class="headerlink" title="1、translate:移动，它是transform的一个方法"></a>1、translate:移动，它是transform的一个方法</h4><p>通过translate（）方法，元素从当前位置移动，根据给定的left、top大小来对元素x轴、y轴平移。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">用法：</span><br><span class="line">transform:translate(50px,60px);</span><br><span class="line">应用：元素水平垂直居中</span><br><span class="line">div&#123;</span><br><span class="line">    position:absolute;</span><br><span class="line">    top:50%;</span><br><span class="line">    left:50%;</span><br><span class="line">    width:100px;</span><br><span class="line">    height:100px;</span><br><span class="line">    border:2px solid red;</span><br><span class="line">    transform:translate(-50px,-50px);//属性需加前缀，达到兼容，此处省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、transform-改变、变形"><a href="#2、transform-改变、变形" class="headerlink" title="2、transform:改变、变形"></a>2、transform:改变、变形</h4><p>transform主要包括以下几种：</p>
<p>旋转：rotate() 顺时针旋转给定的角度，可以为负值。rotate(50deg)</p>
<p>扭曲：skew() 元素翻转给定的角度，根据给定的水平线和垂直线参数。skew(20deg,30deg)</p>
<p>缩放：scale() 放大或者缩小，参数为宽度与高度的倍数。第一个参数为宽度的。scale(2,0.5);</p>
<p>移动：translate() 平移 参数为沿x轴与y轴平移的距离。translate(20px,50px);</p>
<p>Transform-origin: 改变被转换元素的位置  transform-origin: x-axis y-axis z-axis;</p>
<h4 id="3、transition-允许css属性值在一定的时间内平滑的过渡（过渡动画）"><a href="#3、transition-允许css属性值在一定的时间内平滑的过渡（过渡动画）" class="headerlink" title="3、transition:允许css属性值在一定的时间内平滑的过渡（过渡动画）"></a>3、transition:允许css属性值在一定的时间内平滑的过渡（过渡动画）</h4><p>transition作用是指定了某一个属(如width/lef等)在两个值之前如何过渡</p>
<p>transition主要包含四个属性值</p>
<p>1、执行变换的属性：transition-property;</p>
<p>2、变换完成的时间：transition-duration;</p>
<p>3、指定变换效果的转速出线：transition-timing-function;</p>
<p>4、定义变换延迟的时间:transition-delay;</p>
<p>连写：transition:property duration timing-function delay;</p>
<h4 id="4、animation"><a href="#4、animation" class="headerlink" title="4、animation"></a>4、animation</h4><p>语法 animation: name duration timing-function delay iteration-count direction;<br>animation-name 规定需要绑定到选择器的 keyframe 名称。。<br>animation-duration 规定完成动画所花费的时间，以秒或毫秒计。<br>animation-timing-function 规定动画的速度曲线。<br>animation-delay 规定在动画开始之前的延迟。<br>animation-iteration-count 规定动画应该播放的次数。<br>animation-direction 规定是否应该轮流反向播放动画。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">html:&lt;div&gt;&lt;/div&gt;</span><br><span class="line">css:</span><br><span class="line">div&#123;</span><br><span class="line">    width:100px;</span><br><span class="line">    height:200px;</span><br><span class="line">    border:1px solid red;</span><br><span class="line">    position:relative;</span><br><span class="line">    animation:mymove 3s infinite;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes mymove  //animation与keyframes需要加前缀，此处省略</span><br><span class="line">&#123;</span><br><span class="line">from &#123;left:0px;&#125;</span><br><span class="line">to &#123;left:200px;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css3/">css3</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2018 前端在路上
      </div>
        <div class="footer-right">
          <a href="http://webywx.com/" target="_blank">webywx</a>  Theme <a href="https://yanwenxi.site" target="_blank">前端在路上</a> by Scorpio
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>