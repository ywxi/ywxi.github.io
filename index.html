<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>闫文喜的个人前端博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="闫文喜 前端博客 web前端博客  web前端开发">
<meta property="og:type" content="website">
<meta property="og:title" content="闫文喜的个人前端博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="闫文喜的个人前端博客">
<meta property="og:description" content="闫文喜 前端博客 web前端博客  web前端开发">
<meta property="og:locale" content="ch">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="闫文喜的个人前端博客">
<meta name="twitter:description" content="闫文喜 前端博客 web前端博客  web前端开发">
  
    <link rel="alternative" href="/atom.xml" title="闫文喜的个人前端博客" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">前端在路上</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/about">关于我</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/yanwenxi" title="github">github</a>
					        
								<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="mail">mail</a>
					        
								<a class="qq" target="_blank" href="http://www.webywx.com" title="qq">qq</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Benchmark-jsPerf/" style="font-size: 10px;">Benchmark jsPerf</a> <a href="/tags/ES6、promise/" style="font-size: 10px;">ES6、promise</a> <a href="/tags/H5-移动端优化/" style="font-size: 10px;">H5 移动端优化</a> <a href="/tags/H5、bug/" style="font-size: 10px;">H5、bug</a> <a href="/tags/JS设计模式-设计模式/" style="font-size: 10px;">JS设计模式 设计模式</a> <a href="/tags/Jenkins-CI/" style="font-size: 10px;">Jenkins CI</a> <a href="/tags/Lodash/" style="font-size: 10px;">Lodash</a> <a href="/tags/angular/" style="font-size: 10px;">angular</a> <a href="/tags/angular-http-q-promise/" style="font-size: 10px;">angular $http $q promise</a> <a href="/tags/angular-q-promise/" style="font-size: 10px;">angular $q promise</a> <a href="/tags/angular-decorator/" style="font-size: 10px;">angular decorator</a> <a href="/tags/angular-filter/" style="font-size: 10px;">angular filter</a> <a href="/tags/angular-服务/" style="font-size: 10px;">angular 服务</a> <a href="/tags/angularjs/" style="font-size: 10px;">angularjs</a> <a href="/tags/angular、-http/" style="font-size: 10px;">angular、$http</a> <a href="/tags/angular、Karma/" style="font-size: 10px;">angular、Karma</a> <a href="/tags/angular、directive/" style="font-size: 10px;">angular、directive</a> <a href="/tags/angular、html5/" style="font-size: 10px;">angular、html5</a> <a href="/tags/angular、module、controller/" style="font-size: 10px;">angular、module、controller</a> <a href="/tags/angular、promise、-q、deferred/" style="font-size: 10px;">angular、promise、$q、deferred</a> <a href="/tags/angular、router/" style="font-size: 10px;">angular、router</a> <a href="/tags/angular、ui-router/" style="font-size: 10px;">angular、ui-router</a> <a href="/tags/angular、表达式、filter/" style="font-size: 10px;">angular、表达式、filter</a> <a href="/tags/app-跨平台/" style="font-size: 10px;">app,跨平台</a> <a href="/tags/aso/" style="font-size: 10px;">aso</a> <a href="/tags/blockchain/" style="font-size: 10px;">blockchain</a> <a href="/tags/css-1px/" style="font-size: 10px;">css 1px</a> <a href="/tags/debugger/" style="font-size: 10px;">debugger</a> <a href="/tags/es5-js/" style="font-size: 10px;">es5 js</a> <a href="/tags/fit/" style="font-size: 10px;">fit</a> <a href="/tags/flex-css/" style="font-size: 10px;">flex css</a> <a href="/tags/git-github/" style="font-size: 10px;">git github</a> <a href="/tags/h5-webworkers/" style="font-size: 10px;">h5 webworkers</a> <a href="/tags/iframe/" style="font-size: 10px;">iframe</a> <a href="/tags/javascript、object-oriented、继承/" style="font-size: 10px;">javascript、object-oriented、继承</a> <a href="/tags/jquery/" style="font-size: 10px;">jquery</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/js-Array/" style="font-size: 10px;">js Array</a> <a href="/tags/js-Higher-order-function/" style="font-size: 10px;">js Higher-order-function</a> <a href="/tags/js-closure/" style="font-size: 10px;">js closure</a> <a href="/tags/js-lodash/" style="font-size: 10px;">js lodash</a> <a href="/tags/js-object/" style="font-size: 10px;">js object</a> <a href="/tags/js-scope/" style="font-size: 10px;">js scope</a> <a href="/tags/js-sea-js-模块化/" style="font-size: 10px;">js sea.js 模块化</a> <a href="/tags/js-this/" style="font-size: 10px;">js this</a> <a href="/tags/js-性能调试/" style="font-size: 10px;">js 性能调试</a> <a href="/tags/js-柯里化/" style="font-size: 10px;">js 柯里化</a> <a href="/tags/js-纯函数/" style="font-size: 10px;">js 纯函数</a> <a href="/tags/js、变态题/" style="font-size: 10px;">js、变态题</a> <a href="/tags/js、设计模式/" style="font-size: 10px;">js、设计模式</a> <a href="/tags/js、跨域、document-domain/" style="font-size: 10px;">js、跨域、document.domain</a> <a href="/tags/js模块化、AMD、CMD、CommonJs/" style="font-size: 10px;">js模块化、AMD、CMD、CommonJs</a> <a href="/tags/js继承/" style="font-size: 10px;">js继承</a> <a href="/tags/life、意念/" style="font-size: 10px;">life、意念</a> <a href="/tags/lodash-chain/" style="font-size: 10px;">lodash chain</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mongoDB-数据库/" style="font-size: 10px;">mongoDB 数据库</a> <a href="/tags/mvp/" style="font-size: 10px;">mvp</a> <a href="/tags/node/" style="font-size: 12px;">node</a> <a href="/tags/node-debug/" style="font-size: 10px;">node debug</a> <a href="/tags/node-wechat/" style="font-size: 18px;">node wechat</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/promise、es6/" style="font-size: 10px;">promise、es6</a> <a href="/tags/rap/" style="font-size: 16px;">rap</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/react-ant-design/" style="font-size: 10px;">react ant-design</a> <a href="/tags/seo/" style="font-size: 18px;">seo</a> <a href="/tags/seo-新闻源/" style="font-size: 10px;">seo 新闻源</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/web-交互/" style="font-size: 10px;">web 交互</a> <a href="/tags/web、前端/" style="font-size: 10px;">web、前端</a> <a href="/tags/web、性能优化/" style="font-size: 10px;">web、性能优化</a> <a href="/tags/wechat/" style="font-size: 10px;">wechat</a> <a href="/tags/wechat-webstorm/" style="font-size: 10px;">wechat webstorm</a> <a href="/tags/win10、linux/" style="font-size: 10px;">win10、linux</a> <a href="/tags/window-history-html5/" style="font-size: 10px;">window.history html5</a> <a href="/tags/wxapp/" style="font-size: 14px;">wxapp</a> <a href="/tags/yarn-npm/" style="font-size: 10px;">yarn npm</a> <a href="/tags/人生/" style="font-size: 10px;">人生</a> <a href="/tags/前后端分享/" style="font-size: 10px;">前后端分享</a> <a href="/tags/前端脚手架/" style="font-size: 10px;">前端脚手架</a> <a href="/tags/占位以后改过来/" style="font-size: 10px;">占位以后改过来</a> <a href="/tags/建站-seo/" style="font-size: 10px;">建站 seo</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/我先占个地以后改/" style="font-size: 10px;">我先占个地以后改</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/生活/" style="font-size: 20px;">生活</a> <a href="/tags/移动端、fixed/" style="font-size: 10px;">移动端、fixed</a> <a href="/tags/解构赋值-es6/" style="font-size: 10px;">解构赋值 es6</a> <a href="/tags/跨域、postMessage、html5/" style="font-size: 10px;">跨域、postMessage、html5</a> <a href="/tags/路由-html5/" style="font-size: 10px;">路由 html5</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.webywx.com/">前端博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.yanwenxi.site/">web小站</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">前端在路上</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">前端在路上</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/about">关于我</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/yanwenxi" title="github">github</a>
			        
						<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="mail">mail</a>
			        
						<a class="qq" target="_blank" href="http://www.webywx.com" title="qq">qq</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-1px" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/10/15/1px/" class="article-date">
  	<time datetime="2018-10-15T06:12:39.000Z" itemprop="datePublished">2018-10-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/15/1px/">
        移动端1px细线解决方案总结
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="移动端1px变粗的原因"><a href="#移动端1px变粗的原因" class="headerlink" title="移动端1px变粗的原因"></a>移动端1px变粗的原因</h3><p>为什么移动端css里_面写了1px，实际看起来比1px粗，其实原因很好理解：这两个”px”的含义是不一样的,移动端html里的header里总会有一句:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>这句话定义了本页面的viewport的宽度为设备宽度，初始缩放值和最大缩放值都为1，并禁用了用户缩放，viewport通俗地讲是浏览器上可用来显示页面的区域，这个区域是可能比屏幕大的。</p>
<p> 手机存在一个能完美适配的理想viewport, 分辨率相差很大的手机的理想viewport的宽度可能是一样的, 这样做的目的是为了保证同样的css在不同屏幕下的显示效果是一致的, 上面的meta实际上是设置了ideal viewport的宽度.</p>
<p>以实际举例: iphone3和iphone4的屏幕宽度分别是320px,640px, 但是它们的ideal viewport的宽度都是320px, 设置了设备宽度后, 320px宽的元素都能100%的填充满屏幕宽. 不同手机的ideal viewport宽度是不一样的, 常见的有320px, 360px, 384px. iphone系列的这个值在6之前都是320px, 控制viewport的好处就在于一套css可以适配多个机型.</p>
<p>看懂的人应该已经明白 1px变粗的原因了, viewport的设置和屏幕物理分辨率是按比例而不是相同的. <strong>移动端window对象有个devicePixelRatio属性, 它表示设备物理像素和css像素的比例, 在retina屏的iphone手机上, 这个值为2或3, css里写的1px映射到物理像素上就有2px或3px那么粗.</strong></p>
<h3 id="1px解决方案"><a href="#1px解决方案" class="headerlink" title="1px解决方案"></a>1px解决方案</h3><h4 id="1、用小数来写px值"><a href="#1、用小数来写px值" class="headerlink" title="1、用小数来写px值"></a>1、用小数来写px值</h4><p>IOS8下已经支持带小数的px值, media query对应devicePixelRatio有个查询值-webkit-min-device-pixel-ratio, css可以写成这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.border &#123; border: 1px solid #999 &#125;</span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio: 2) &#123;</span><br><span class="line">    .border &#123; border: 0.5px solid #999 &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio: 3) &#123;</span><br><span class="line">    .border &#123; border: 0.333333px solid #999 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点: 安卓与低版本IOS不适用, 这个或许是未来的标准写法.</p>
<h4 id="2、scale缩放的方式"><a href="#2、scale缩放的方式" class="headerlink" title="2、scale缩放的方式"></a>2、scale缩放的方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.border-1px &#123;  </span><br><span class="line">            position: relative;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">.border-1px::after &#123;  </span><br><span class="line">            display: block;  </span><br><span class="line">            position: absolute;  </span><br><span class="line">            left: 0;  </span><br><span class="line">            bottom: 0;  </span><br><span class="line">            width: 100%;  </span><br><span class="line">            border-top: 1px solid red;  </span><br><span class="line">            content: &apos;  &apos;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line"> @media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio:1.5) &#123;  </span><br><span class="line"> 		.border-1px::after &#123;  </span><br><span class="line">		 -webkit-transform: scaleY(0.7);  </span><br><span class="line"> 		transform: scaleY(0.7)  </span><br><span class="line">            &#125;  </span><br><span class="line">       </span><br><span class="line">       @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio:2)       &#123;</span><br><span class="line">       .border-1px::after &#123;  </span><br><span class="line">       -webkit-transform: scaleY(0.5);  </span><br><span class="line">       transform: scaleY(0.5)  </span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、rem解决方案"><a href="#3、rem解决方案" class="headerlink" title="3、rem解决方案"></a>3、rem解决方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//根据屏幕大小及dpi调整缩放和大小  </span><br><span class="line">(function () &#123;</span><br><span class="line">        var scale = 1.0;</span><br><span class="line">        var ratio = 1;</span><br><span class="line">        if (window.devicePixelRatio &gt;= 2) &#123;</span><br><span class="line">            scale *= 0.5;</span><br><span class="line">            ratio *= 2;</span><br><span class="line">        &#125;</span><br><span class="line"> var text = &apos;&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=&apos; + scale + &apos;, maximum-scale=&apos; + scale + &apos;,&apos; + &apos; minimum-scale=&apos; + scale + &apos;, width=device-width,&apos; + &apos; user-scalable=no&quot; /&gt;&apos;;</span><br><span class="line">   document.write(text);</span><br><span class="line">   document.documentElement.style.fontSize = 50 * ratio + &quot;px&quot;;&#125;)();</span><br></pre></td></tr></table></figure>
<h4 id="4、其他方式"><a href="#4、其他方式" class="headerlink" title="4、其他方式"></a>4、其他方式</h4><p>比如：背景图图片、背景图渐变、js判断支持0.5px(和方案1类似)；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css-1px/">css 1px</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Promise" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/15/Promise/" class="article-date">
  	<time datetime="2018-05-15T06:12:39.000Z" itemprop="datePublished">2018-05-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/15/Promise/">
        promise学习笔记
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是promise"><a href="#什么是promise" class="headerlink" title="什么是promise"></a>什么是promise</h3><p>Promise 是异步编程的一种解决方案，它有三种状态，分别是pending(进行中)、</p>
<p>resolved(已完成)、rejected(已失败)。</p>
<p>当Promsie的状态由pending转变成resolved或rejected时，会执行相应的方法，并且状态一旦改变，就无法再次改变状态，这也是Promise-承诺名字的由来。</p>
<h3 id="ES6之前的promise"><a href="#ES6之前的promise" class="headerlink" title="ES6之前的promise"></a>ES6之前的promise</h3><p>使用较为成熟的第三方promise库—<a href="http://bluebirdjs.com/docs/getting-started.html" target="_blank" rel="noopener">Bluebird</a>,它是实现promise标准库功能最全、速度最快的一个库。</p>
<p>经典使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Promise = require(&apos;./bluebird&apos;);</span><br><span class="line"></span><br><span class="line">var readFile = Promise.promisify(require(&quot;fs&quot;).readFile);</span><br><span class="line">readFile(&quot;1.txt&quot;, &quot;utf8&quot;).then(function(contents) &#123;</span><br><span class="line">    console.log(contents);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var fs = Promise.promisifyAll(require(&quot;fs&quot;));</span><br><span class="line"></span><br><span class="line">fs.readFileAsync(&quot;1.txt&quot;, &quot;utf8&quot;).then(function (contents) &#123;</span><br><span class="line">    console.log(contents);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="ES6的promise-基本使用方法"><a href="#ES6的promise-基本使用方法" class="headerlink" title="ES6的promise 基本使用方法"></a>ES6的promise 基本使用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let promise=new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    if(success)&#123;</span><br><span class="line">        resolve(successData)//pending=&gt;resolved,参数传递给对应的回调方法</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        reject(failData) //pending=&gt;rejected,参数传递给对应的回调方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">注：实例化的Promsie对象会立即执行。</span><br></pre></td></tr></table></figure>
<h3 id="then-和catch-方法"><a href="#then-和catch-方法" class="headerlink" title="then()和catch()方法"></a>then()和catch()方法</h3><p>Promise.prototype.then()是Promise原型链上的方法，它有两个参数(都是函数)，分别对应resolved的回调和rejected的回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">    (successData) =&gt; &#123; console.log(&apos;我是成功的回调参数是successData&apos;) &#125;,</span><br><span class="line">    (failData) =&gt; &#123; console.log(&apos;我是失败的回调参数是failData&apos;) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>.catch()也是原型链上的方法，作用是捕获Promise的错误，与then()的rejected回调作用几乎一致。但是由于Promise的抛错具有冒泡性质，能够不断传递，这样就能够在下一个catch()中统一处理这些错误。同时catch()也能够捕获then()中抛出的错误，所以建议不要使用then()的rejected回调，而是统一使用catch()来处理错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">    () =&gt; &#123; console.log(&apos;this is success callback&apos;) &#125;</span><br><span class="line">).catch(</span><br><span class="line">    (err) =&gt; &#123; console.log(err) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>同样，catch()中也可以抛出错误，由于抛出的错误会在下一个catch中被捕获处理，因此可以再添加catch()；</p>
<p>当状态已经改变为resolved后，即使抛出错误，也不会触发then()的错误回调或者catch()方法；</p>
<p>then() 和 catch() 都会返回一个新的Promise对象，可以链式调用；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">    () =&gt; &#123; console.log(&apos;this is success callback&apos;) &#125;</span><br><span class="line">).catch(</span><br><span class="line">    (err) =&gt; &#123; console.log(err) &#125;</span><br><span class="line">).then(</span><br><span class="line">    ...</span><br><span class="line">).catch(</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="Promise实例的异步方法和then-中返回promise有什么区别？"><a href="#Promise实例的异步方法和then-中返回promise有什么区别？" class="headerlink" title="Promise实例的异步方法和then()中返回promise有什么区别？"></a>Promise实例的异步方法和then()中返回promise有什么区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// p1异步方法中返回p2</span><br><span class="line">let p1 = new Promise ( (resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(p2)</span><br><span class="line">&#125; )</span><br><span class="line">let p2 = new Promise ( ... )</span><br><span class="line"></span><br><span class="line">// then()中返回promise</span><br><span class="line">let p3 = new Promise ( (resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125; )</span><br><span class="line">let p4 = new Promise ( ... )</span><br><span class="line">p3.then(</span><br><span class="line">    () =&gt; return p4</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>p1异步方法中返回p2</strong></p>
<p>p1的状态取决于p2，如果p2为pending，p1将等待p2状态的改变，p2的状态一旦改变，p1将会立即执行自己对应的回调，即then()中的方法针对的依然是p1</p>
<p><strong>then()中返回promise</strong></p>
<p>由于then()本身就会返回一个新的promise，所以后一个then()针对的永远是一个新的promise，但是像上面代码中我们自己手动返回p4，那么我们就可以在返回的promise中再次通过 resolve() 和 reject() 来改变状态</p>
<h3 id="Promise-resolve-和Promise-reject"><a href="#Promise-resolve-和Promise-reject" class="headerlink" title="Promise.resolve()和Promise.reject()"></a>Promise.resolve()和Promise.reject()</h3><p>用来包装一个现有对象，将其转变为Promise对象，但Promise.resolve()会根据参数情况返回不同的Promise：</p>
<p><strong>参数是Promise</strong>：原样返回<br><strong>参数带有then方法</strong>：转换为Promise后立即执行then方法<br><strong>参数不带then方法、不是对象或没有参数</strong>：返回resolved状态的Promise</p>
<p>Promise.reject()会直接返回rejected状态的Promise;</p>
<h3 id="其他api"><a href="#其他api" class="headerlink" title="其他api"></a>其他api</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([promise1,promise2,promise3,promise4....])</span><br><span class="line">Promise.race([promise1,promise2,promise3,promise4....])</span><br><span class="line">Promise.done()/Promise.finally()</span><br><span class="line">//上述这几个api根据api名字自己脑补吧，娃哈哈。。。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//学完了练一练</span><br><span class="line">一、const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    resolve()</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(() =&gt; &#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">&#125;)</span><br><span class="line">    console.log(4)</span><br><span class="line">Promise构造函数里中的代码是同步执行的，但是then方法是异步方法，then方法需要等到resolve函数执行时才能执行，所以结果是1、2、4、3.</span><br><span class="line"></span><br><span class="line">二、Promise.resolve(1).then(res=&gt;&#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return 2;</span><br><span class="line">&#125;).catch(err=&gt;&#123;</span><br><span class="line">    return 3;</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">resolve(1)首先会执行第一个then函数，输出1.然后在函数中返回2，因为resolve是成功的状态，所以后面的catch不会执行，而是直接执行第二个then函数，输出2.所以结果是1、2.</span><br></pre></td></tr></table></figure>
<h3 id="Promise原理"><a href="#Promise原理" class="headerlink" title="Promise原理"></a>Promise原理</h3><p>在Promise的内部有一个状态管理器，它有三种状态：pending/fulfilled/rejected</p>
<p>1、promise对象初始化状态为pending。(new Promise时)</p>
<p>2、当调用resolve(data),状态pending=&gt;fulfilled</p>
<p>3、当调用resolve(err),状态pending=&gt;rejected</p>
<p>状态由pending变fulfilled/rejected时，一旦状态变了就不能再改变了。当状态变为fulfilled时，then的成功回调函数会被调用，并接收传来的参数data，进而进行操作，rejected则反之。promise.then方法每次执行完后，都会返回一个新的promise对象所以可以链式调用(不管是resolve还是reject).</p>
<p>举个例子来模拟Promise:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var fs=require(&apos;fs&apos;);</span><br><span class="line">var Promise = require(&apos;./Promise.js&apos;);</span><br><span class="line">var promise = new Promise(function (resolve,reject) &#123;</span><br><span class="line">    fs.readFile(&apos;1.txt&apos;,&apos;utf-8&apos;,function (err,data) &#123;</span><br><span class="line">        if(err)&#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(function (data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;,function (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>用es5来模拟Promise</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn) &#123;</span><br><span class="line">   fn((data)=&gt;&#123;</span><br><span class="line">       this._success(data);</span><br><span class="line">   &#125;,(error)=&gt;&#123;</span><br><span class="line">       this._error(error);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">Promise.prototype.then=function (onFul,onFail) &#123;</span><br><span class="line">    this._success=onFull;//</span><br><span class="line">    this._error=onFail;</span><br><span class="line">&#125;;</span><br><span class="line">Promise.prototype.resolve=function (data) &#123;</span><br><span class="line">    this._success(data);</span><br><span class="line">&#125;;</span><br><span class="line">Promise.prototype.reject=function (error) &#123;</span><br><span class="line">    this._error(error);</span><br><span class="line">&#125;;</span><br><span class="line">module.exports=Promise;</span><br></pre></td></tr></table></figure>
<p>es6来模拟Promise</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class promise &#123;</span><br><span class="line">    constructor(fn)&#123;</span><br><span class="line">        fn((data)=&gt;&#123;</span><br><span class="line">            this._success(data);</span><br><span class="line">        &#125;,(error)=&gt;&#123;</span><br><span class="line">            this._error(error);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(data)&#123;</span><br><span class="line">        this._success(data);</span><br><span class="line">    &#125;</span><br><span class="line">    reject(err)&#123;</span><br><span class="line">        this._error(err)</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFul,onFail)&#123;</span><br><span class="line">        this._success=onFul;</span><br><span class="line">        this._error=onFail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/promise、es6/">promise、es6</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Vue" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/04/15/Vue/" class="article-date">
  	<time datetime="2018-04-15T06:12:39.000Z" itemprop="datePublished">2018-04-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/15/Vue/">
        vue相关学习
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="查看vue-cli是否安装成功及版本号"><a href="#查看vue-cli是否安装成功及版本号" class="headerlink" title="查看vue-cli是否安装成功及版本号"></a>查看vue-cli是否安装成功及版本号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue -V //注意V要大写，如果有版本号了则说明vue-cli安装成功了。</span><br></pre></td></tr></table></figure>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>​    1、动态路由匹配（/goodlists/:id）</p>
<p>​    2、嵌套路由(children)</p>
<p>​    3、编程式路由（js控制路由的跳转 this.$router.push()）</p>
<p>​    4、命名路由和命名视图 </p>
<p>​    命名路由：给路由定义不同的名字，根据名字进行匹配 :to={name:xx}</p>
<p>​        命名视图：给不同的router-view定义名字，通过名字进行对应组件的渲                                                                            染。<router-view name="xx"></router-view></p>
<h3 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h3><p>路由是根据不同的url地址展示不同的内容或页面。</p>
<p>前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据url的不同返回不同的页面实现的。</p>
<p>什么时候用？在单页应用中，大部分页面结构不变，只改变部分内容的使用。</p>
<h3 id="前端路由的优缺点"><a href="#前端路由的优缺点" class="headerlink" title="前端路由的优缺点"></a>前端路由的优缺点</h3><p>优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户。</p>
<p>缺点：1、不利于seo。2、使用浏览器的前进，后退的时候会重新发送请求，没有合理地利用缓存。（正常的可利用浏览器的缓存机制直接前进后退而不用发送请求）</p>
<p>3、单页面无法记住之前滚动的位置，无法在前进、后退的时候记住滚动的位置。</p>
<h3 id="前端路由的两种实现原理"><a href="#前端路由的两种实现原理" class="headerlink" title="前端路由的两种实现原理"></a>前端路由的两种实现原理</h3><p>1、History Api</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">此功能其实是对bom对象的history属性的封装。history.go(0) //刷新当前页</span><br><span class="line">history.go(1) history.forward()//前进 </span><br><span class="line">history.go(-1) history.back()//后退</span><br><span class="line">history.pushState(state,title,url);</span><br></pre></td></tr></table></figure>
<p>2、hash</p>
<p>我们经常在 url 中看到 #，这个 # 有两种情况，一个是我们所谓的锚点，比如典型的回到顶部按钮原理、Github 上各个标题之间的跳转等，路由里的 # 不叫锚点，我们称之为 hash，大型框架的路由系统大多都是哈希实现的。</p>
<p>根据监听哈希变化触发的事件 —— hashchange 事件。</p>
<p>两种方案推荐 hash 方案，因照顾到低级浏览器，就是不美观（url中多了一个 #）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">    mode:&apos;history&apos;或&apos;hash&apos;, //vue中设置使用history还是hash的方法</span><br><span class="line">    routes:[]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="vue中的异步请求"><a href="#vue中的异步请求" class="headerlink" title="vue中的异步请求"></a>vue中的异步请求</h3><p>官方提供的vue-resource在vue2.0之后就不更新了，它提供了7个api和全局拦截器interceptors.不建议使用，流行使用地是扩展性比较好的axios，官方也推荐使用axios.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vue-Resource中全局拦截器interceptors的使用</span><br><span class="line">Vue.http.interceptors.push((request,next)=&gt;&#123;</span><br><span class="line">    //请求发送前的处理逻辑，比如判断是否登录</span><br><span class="line">    //............</span><br><span class="line">    next((response)=&gt;&#123;</span><br><span class="line">        //请求发送后的处理逻辑</span><br><span class="line">        //.........</span><br><span class="line">        //根据请求的状态，response参数会返回给successCallback或errorCallback</span><br><span class="line">        return response;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="axios的全局拦截器"><a href="#axios的全局拦截器" class="headerlink" title="axios的全局拦截器"></a>axios的全局拦截器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use((config)=&gt;&#123;</span><br><span class="line">    console.log(&quot;request init!所有的请求之前都会走这里&quot;)</span><br><span class="line">    return config;</span><br><span class="line">&#125;);</span><br><span class="line">axios.interceptors.response.use((response)=&gt;&#123;//拦截响应的请求</span><br><span class="line">    console.log(&quot;response init&quot;);//打印之后才会响应请求，才会获得请求的数据</span><br><span class="line">    return response;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-模块化开发" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/15/模块化开发/" class="article-date">
  	<time datetime="2018-02-15T06:12:39.000Z" itemprop="datePublished">2018-02-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/15/模块化开发/">
        AMD、CMD、CommonJs和ES6对比
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AMD是requireJs在推广过程中对模块定义的规范化产出，用法如下：</span><br><span class="line">define([&apos;package/lib&apos;],function(lib)&#123;</span><br><span class="line">    function foo()&#123;</span><br><span class="line">        lib.sun(1,2);</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        foo:foo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">依赖前置，由国外团队出口，知名度比较高，用的也相对较多。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CMD是SeaJs在推广过程中对模块定义的规范化产出，用法如下：</span><br><span class="line">//所有的模块都通过define来定义</span><br><span class="line">define(function(require,exports,module)&#123;</span><br><span class="line">    </span><br><span class="line">    //通过require引入依赖</span><br><span class="line">    var $=require(&apos;jquery&apos;);//用的时候才引入</span><br><span class="line">&#125;)</span><br><span class="line">就近依赖，由淘宝团队打造，用的相对较少</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CommonJs规范-module.exports</span><br><span class="line">exports.sum=function(a,b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ES6特性 export/import</span><br><span class="line">export default&#123;</span><br><span class="line">    a:1,</span><br><span class="line">    b:2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AMD/CMD/ES6都是在前端模块化中用到。CommonJS是服务端模块化中用到，比如node.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化/">模块化</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-测试2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/15/测试2/" class="article-date">
  	<time datetime="2017-10-15T07:12:39.000Z" itemprop="datePublished">2017-10-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/15/测试2/">
        我会被改的啊
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>js中常用的继承方式: 子类继承父类的方法：</p>
<h3 id="1、原型继承"><a href="#1、原型继承" class="headerlink" title="1、原型继承"></a>1、原型继承</h3><p>子类的原型指向父类的一个实例  父类的私有和公有方法都是子类的公有方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function A()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">    this.y = 100;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.getX = function ()&#123;&#125;</span><br><span class="line"></span><br><span class="line">function B()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype = new A(); //B的原型重新赋值A的实例==&gt;每个b实例都能通过自己的__proto__找到a上的所有的私有方法，并且还可以通过a.__proto__继续找到A.prototype上的所有属性 ==&gt; A这个类上的方法相对于B都是公有方法</span><br><span class="line">B.prototype.constructor = B; //由于重新修改了B的原型导致默认原型上的constructor丢失，我们需要自己添加上</span><br></pre></td></tr></table></figure></p>
<h3 id="2、call继承"><a href="#2、call继承" class="headerlink" title="2、call继承"></a>2、call继承</h3><p>在子类构造函数中 父类.call(this)  父类的私有变成子类的私有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function C()&#123;</span><br><span class="line">    this.x = 100; //d.x = 100</span><br><span class="line">&#125;</span><br><span class="line">C.prototype.getX = function ()&#123;&#125;;</span><br><span class="line">function D()&#123;</span><br><span class="line">    C.call(this); //构造函数中的this就是当前实例  this ==&gt; d     C.call(d);  ==&gt; 把C中的this修改成d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、冒充对象继承"><a href="#3、冒充对象继承" class="headerlink" title="3、冒充对象继承"></a>3、冒充对象继承</h3><p>循环遍历父类实例，然后父类实例的私有方法全部拿过来添加给子类实，如果不做hasOwnProperty判断那么就是把父类的公有的和私有的都拿过来当私有的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function E()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">    this.y = 200;</span><br><span class="line">&#125;</span><br><span class="line">E.prototype.getX = function ()&#123;&#125;</span><br><span class="line">function F()&#123;</span><br><span class="line">    var e = new E(); //e.x = 100;</span><br><span class="line">    for(var attr in e)&#123; //for in可以遍历到原型上的公有自定义属性</span><br><span class="line">        //attr = x</span><br><span class="line">        if(e.hasOwnProperty(attr))&#123; //如果这个判断不加，那么无论是公有的还是私有的都拿过来当私有的</span><br><span class="line">            this[attr] = e[attr];</span><br><span class="line">            //f[&apos;x&apos;] = e[&apos;x&apos;] ==&gt; f.x = 100;</span><br><span class="line">        &#125;</span><br><span class="line">        // e.propertyIsEnumerable() //可枚举属性  ==&gt; 简单理解：可以拿出来一一列举的属性</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-混合继承"><a href="#4-混合继承" class="headerlink" title="4 混合继承"></a>4 混合继承</h3><p>原型+call  ==&gt; 无论是私有的还是公有的都拿过来了 ==&gt; 子类的原型上的多了一套父类私有属但是不会产生问题。因为子类的私有属性也有一套相同的通过call继承拿过来的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function G()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">&#125;</span><br><span class="line">G.prototype.getX = function()&#123;&#125;;</span><br><span class="line">function H()&#123;</span><br><span class="line">    G.call(this);</span><br><span class="line">&#125;</span><br><span class="line">H.prototype = new G();</span><br><span class="line">H.prototype.constructor = H;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-中间件继承"><a href="#5-中间件继承" class="headerlink" title="5 中间件继承"></a>5 中间件继承</h3><p>M.prototype.<strong>proto</strong> = K.prototype;  把父类的公有的当作子类的公有的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function K()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">&#125;</span><br><span class="line">k.prototype.getX = function ()&#123;&#125;;</span><br><span class="line">function M()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">M.prototype.__proto__ = K.prototype; //本来应该是直接指向Object.prototype。从K的原型上的__proto__也可以到Object.prototype==&gt; 在K.prototype上停留了下，K.prototype就是一个中间件  父类的公有当作子类的公有</span><br></pre></td></tr></table></figure></p>
<h3 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6 寄生组合式继承"></a>6 寄生组合式继承</h3><p> Object.create(xx.prototype)方法  ==&gt; 是把xx.prototype当作别人家的原型  不兼容，只能找到父类原型的方法。父类的私有属性访问不到。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line">    this.name = &quot;ywx&quot;;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.eat = function () &#123;</span><br><span class="line">    console.log(123);</span><br><span class="line">&#125;;</span><br><span class="line">function Child() &#123;&#125;</span><br><span class="line">//寄生组合式继承实现方式如下：</span><br><span class="line">Child.prototype = Object.create(Parent.prototype);</span><br><span class="line">var child=new Child();</span><br><span class="line">console.log(child.eat());//只有找到父类原型上的方法</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/占位以后改过来/">占位以后改过来</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-测试的先占位" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/15/测试的先占位/" class="article-date">
  	<time datetime="2017-10-15T06:12:39.000Z" itemprop="datePublished">2017-10-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/15/测试的先占位/">
        我是测试的啊
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>js中常用的继承方式: 子类继承父类的方法：</p>
<h3 id="1、原型继承"><a href="#1、原型继承" class="headerlink" title="1、原型继承"></a>1、原型继承</h3><p>子类的原型指向父类的一个实例  父类的私有和公有方法都是子类的公有方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function A()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">    this.y = 100;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.getX = function ()&#123;&#125;</span><br><span class="line"></span><br><span class="line">function B()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype = new A(); //B的原型重新赋值A的实例==&gt;每个b实例都能通过自己的__proto__找到a上的所有的私有方法，并且还可以通过a.__proto__继续找到A.prototype上的所有属性 ==&gt; A这个类上的方法相对于B都是公有方法</span><br><span class="line">B.prototype.constructor = B; //由于重新修改了B的原型导致默认原型上的constructor丢失，我们需要自己添加上</span><br></pre></td></tr></table></figure></p>
<h3 id="2、call继承"><a href="#2、call继承" class="headerlink" title="2、call继承"></a>2、call继承</h3><p>在子类构造函数中 父类.call(this)  父类的私有变成子类的私有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function C()&#123;</span><br><span class="line">    this.x = 100; //d.x = 100</span><br><span class="line">&#125;</span><br><span class="line">C.prototype.getX = function ()&#123;&#125;;</span><br><span class="line">function D()&#123;</span><br><span class="line">    C.call(this); //构造函数中的this就是当前实例  this ==&gt; d     C.call(d);  ==&gt; 把C中的this修改成d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、冒充对象继承"><a href="#3、冒充对象继承" class="headerlink" title="3、冒充对象继承"></a>3、冒充对象继承</h3><p>循环遍历父类实例，然后父类实例的私有方法全部拿过来添加给子类实，如果不做hasOwnProperty判断那么就是把父类的公有的和私有的都拿过来当私有的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function E()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">    this.y = 200;</span><br><span class="line">&#125;</span><br><span class="line">E.prototype.getX = function ()&#123;&#125;</span><br><span class="line">function F()&#123;</span><br><span class="line">    var e = new E(); //e.x = 100;</span><br><span class="line">    for(var attr in e)&#123; //for in可以遍历到原型上的公有自定义属性</span><br><span class="line">        //attr = x</span><br><span class="line">        if(e.hasOwnProperty(attr))&#123; //如果这个判断不加，那么无论是公有的还是私有的都拿过来当私有的</span><br><span class="line">            this[attr] = e[attr];</span><br><span class="line">            //f[&apos;x&apos;] = e[&apos;x&apos;] ==&gt; f.x = 100;</span><br><span class="line">        &#125;</span><br><span class="line">        // e.propertyIsEnumerable() //可枚举属性  ==&gt; 简单理解：可以拿出来一一列举的属性</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-混合继承"><a href="#4-混合继承" class="headerlink" title="4 混合继承"></a>4 混合继承</h3><p>原型+call  ==&gt; 无论是私有的还是公有的都拿过来了 ==&gt; 子类的原型上的多了一套父类私有属但是不会产生问题。因为子类的私有属性也有一套相同的通过call继承拿过来的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function G()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">&#125;</span><br><span class="line">G.prototype.getX = function()&#123;&#125;;</span><br><span class="line">function H()&#123;</span><br><span class="line">    G.call(this);</span><br><span class="line">&#125;</span><br><span class="line">H.prototype = new G();</span><br><span class="line">H.prototype.constructor = H;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-中间件继承"><a href="#5-中间件继承" class="headerlink" title="5 中间件继承"></a>5 中间件继承</h3><p>M.prototype.<strong>proto</strong> = K.prototype;  把父类的公有的当作子类的公有的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function K()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">&#125;</span><br><span class="line">k.prototype.getX = function ()&#123;&#125;;</span><br><span class="line">function M()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">M.prototype.__proto__ = K.prototype; //本来应该是直接指向Object.prototype。从K的原型上的__proto__也可以到Object.prototype==&gt; 在K.prototype上停留了下，K.prototype就是一个中间件  父类的公有当作子类的公有</span><br></pre></td></tr></table></figure></p>
<h3 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6 寄生组合式继承"></a>6 寄生组合式继承</h3><p> Object.create(xx.prototype)方法  ==&gt; 是把xx.prototype当作别人家的原型  不兼容，只能找到父类原型的方法。父类的私有属性访问不到。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line">    this.name = &quot;ywx&quot;;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.eat = function () &#123;</span><br><span class="line">    console.log(123);</span><br><span class="line">&#125;;</span><br><span class="line">function Child() &#123;&#125;</span><br><span class="line">//寄生组合式继承实现方式如下：</span><br><span class="line">Child.prototype = Object.create(Parent.prototype);</span><br><span class="line">var child=new Child();</span><br><span class="line">console.log(child.eat());//只有找到父类原型上的方法</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/我先占个地以后改/">我先占个地以后改</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-rengemianju" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/19/rengemianju/" class="article-date">
  	<time datetime="2017-02-19T09:32:10.000Z" itemprop="datePublished">2017-02-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/19/rengemianju/">
        人格面具
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>村上春树在《海边的卡夫卡》里这样写道：“我相信所谓的命运不过是一个人的生理、心理、情感、性格等等因素所造成的一个人行动的最终结果。我也始终相信这些因素都是可以人为改变的。”</p>
<p>就像我们总是抱怨越长大越发现知人知面不知心，可当我们握着无数个面具在不同情境下快速扮演一个适宜的角色，把真实的自己隐藏在重重厚茧之下时，又有几点真实？</p>
<p>我们对生活展现的态度，也就是生活在我们身上映射的样子。</p>
<h4 id="人格面具"><a href="#人格面具" class="headerlink" title="人格面具"></a>人格面具</h4><p>之前又被吐槽高冷，已经习以为常，我曾经也琢磨过，我哪里高冷了？要不要改变一下显得更有亲和力？试图“矫正”过，不过最别扭的是自己，我是一个十分看重边界的人，确实没办法在不了解彼此的情况下“自来熟”般地表现热络和亲昵，索性作罢。</p>
<p>有人愿意给我贴上“高冷”标签，或者因此疏远，我也并不觉得可惜。别人对你有什么样的印象，并不都是准确的，而每个人看到的也未必都是一个人本来的样子。</p>
<p>这层表象，就是所谓的“人格面具”。我们并不总是时刻表现出真实的自我，有时囿于环境差异，有时囿于对象的不同。我们需要这层面具的保护，它带给我们游刃有余的安全感，让我们在不同情境下能更快适应和融入，并且感到舒服。</p>
<p>我们每个人都是这样，人前人后判若两人，把不适合展现于人前的东西妥善收好，在某个独自面对自己的时刻才肯摘掉面具，才肯让个性中被压抑的部分舒展和释放。</p>
<h4 id="你看到的未必就是真实，你以为的也不过就是你以为而已。"><a href="#你看到的未必就是真实，你以为的也不过就是你以为而已。" class="headerlink" title="你看到的未必就是真实，你以为的也不过就是你以为而已。"></a>你看到的未必就是真实，你以为的也不过就是你以为而已。</h4><p>而一旦人格面具戴久了，或许自己都不太习惯看见自己最真实的一面，我们越来越适应外部世界的各种情境。我们在人前越来越游刃有余地表演别人需要的样子，有时甚至把这层表象误以为是真正的自己，这是一种无奈。</p>
<p>更何况，人格面具从来不止一个。面对同事、家人、朋友、爱人、陌生人、敌人，面对工作、聚会、约会、谈判、交涉，每一个不同的人，每一个不同的场景，我们的内心都有一种预设，该表现怎么样的自我，该说怎样的话，都有它该匹配的剧本。就像不同场合适合不同着装一样，我们挑选着适合的衣服，也挑选着适合的人格面具，这是“社会化”的过程必不可少的一步。</p>
<p>人心是比宇宙还浩瀚的地方，而人的复杂性远超任何科学，它没有公式可以计算，也没有精确的工具可以测量。我们都是在一寸一寸地体验自己人格中的维度，比喻成盲人摸象也不为过，个性就是有很多面，它是立体的、富有弹性的、充满奥秘的。</p>
<h4 id="推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。"><a href="#推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。" class="headerlink" title="推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。"></a>推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。</h4><p>我经历过怒目相视的时刻，但想到这双眼或许对别人温柔如水过，刚要燃起的愤怒也就悄悄熄灭了；我也担心过疲惫困顿的身影，但我相信这只是一个停顿，总有些力量会支撑他走下去，所以会用鼓励替代心疼；而那些看似放荡不羁的灵魂，也总会有珍视和在意的人和事，便不再羡慕他那表面的轻松和无谓了。</p>
<p>我们体验到的只是对方转眼消失的一瞬，而对面的那个人却经历了无数个人生厚重的瞬间；我们看到的只是一个人的一面，而这个人其实跟自己一样，也不过是在诸多人格维度中展现了其中之一罢了。</p>
<p>人们总是习惯在不了解对方的时候，就用一些标签和自以为是的评价为对方打上一个烙印，还往往以为这就是确定的真实。用这种似是而非的“确定性”否定了所有的可能性，或许才是人与人相处的最大障碍。</p>
<p>有时候，不是命运缺少安排，也不是缘分太浅，只是你没有给别人时间和空间展示更丰富真实的自己，才同样让自己也错失了机会。又或者我们习惯了面具的存在，也快忘记了在别人靠近的时候，松动和敞开自己的内心，给他一个走进自己生活的机会。</p>
<p>原来，每个人都不是你看到的那个样子，原来，每个人都需要一个真正认识彼此的机会。——注：文章参考于网络，仅供个人学习</p>
<p>最后送大家一句话：真正支撑一个人活下去的不是安逸，而是对生活的不甘。我要经历一切，哪怕不完美！！！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生活/">生活</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-lovestart" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/14/lovestart/" class="article-date">
  	<time datetime="2017-02-14T09:15:48.000Z" itemprop="datePublished">2017-02-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/14/lovestart/">
        爱的开始
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <iframe style="margin:0 auto; display:block;" frameborder="no" border="0" marginwidth="0" marginheight="0" width="530" height="86" src="//music.163.com/outchain/player?type=2&id=27731261&auto=1&height=66"></iframe>

<p>2017年2月12日，在金莎鹿港小镇我们第一次相见。你迟到了（说好的11点，你临时修网线11点半多到的），按照国际惯例我应该是不耐烦了，因为我很讨厌迟到的人，除非是有不可控因素。一些可控因素的迟到在一定程序上说明没有引起对方足够的重视。但是那一刻我清楚地记得我很有耐心，说实话我都佩服我自己，我也不知道我哪来的耐心，大概是直觉告诉我你就是那个对的人。</p>
<p>饭前，我一个人在麦当劳静静地听着音乐，怀着一种期盼地心情等待你的出现。</p>
<p>饭间，通过简单地沟通我更加明确了方向，你就是我要等的那个人。吸引我的地方就是不但人美，而且还透露着一种独特的气质。此处应该有一个大写的表情：奸笑。</p>
<p>饭毕，我们去了八大处，说说笑笑走着上去的，安安静静地坐揽车下来的。期间，看到你儿童般地步伐、天真灿烂的笑容，我心里油然而生一种幸福感，仿佛回到了童年。</p>
<p>都说欣赏一个人，始于颜值，敬于才华，合于性格，久于善良，终于人品。我能告诉你们在这一天我用火眼金睛都看到了吗？答案是不能也得能。此刻让我想起来汪国真的一首诗：我不去想是否能够成功，既然选择了远方，便只顾风雨兼程！我不去想能否赢得爱情，既然钟情于玫瑰，就勇敢地吐露真诚。</p>
<p>爱不是交易，爱也不是要求，爱是不求回报地付出，爱是相互欣赏与理解对方。愿能用我的真心换来你的实意，你若不离，我定不弃。最后贴上一句我很喜欢的话：但行好事，莫问前程，欢迎你和我一起，成为很酷的年轻人。</p>
<h4 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h4><p>记得之前通话期间我问过你的生日，在此记录下来，阴历11月29，我想到时候应该会有一个惊喜。</p>
<p>17年2月 26日晚，我第一次认真地生气，是因为第一回打电话没人接，第二回打正在通话中，足足等了快一小时居然还没有回个电话，我本决定那天晚上不再给你打电话，但是我没有忍住，最终还是又打了。见了你之后对你就有一种说不出的感觉，那种感觉就像磁场，而磁场里只有你我共存。为了你我内心愿意放下从前的自己，对待你的态度和别人的就是不一样，这也不是我特意去做的，只是我内心的一种选择。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生活/">生活</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-web-workers" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/10/web-workers/" class="article-date">
  	<time datetime="2017-02-10T03:53:05.000Z" itemprop="datePublished">2017-02-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/10/web-workers/">
        程序性能之HTML5 Web Workers
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="什么是-Web-Worker？"><a href="#什么是-Web-Worker？" class="headerlink" title="什么是 Web Worker？"></a>什么是 Web Worker？</h4><p>当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。<br>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</p>
<p>大家都知道JavaScript是单线程运作的。但是，单线程并不是组织程序执行的唯一方式。可以设想一下，把你的程序分为两个部分： 一部分运行在主 UI 线程下， 另外一部分运行在另一个完全独立的线程中。<br>像浏览器这样的环境， 很容易提供多个 JavaScript 引擎实例， 各自运行在自己的线程上， 这样你可以在每个线程上运行不同的程序。 程序中每一个这样的独立的多线程部分被称为一个（ Web） Worker。 这种类型的并行化被称为任务并行 ，因为其重点在于把程序划分为多个块来并发运行。从 JavaScript 主程序（ 或另一个 Worker） 中， 可以这样实例化一个 Worker：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var w1 = new Worker( &quot;http://some.url.1/mycoolworker.js&quot; );</span><br></pre></td></tr></table></figure></p>
<p>这个 URL应该指向一个 JavaScript 文件的位置（ 而不是一个 HTML页面！ ） ， 这个文件将被加载到一个 Worker 中。 然后浏览器启动一个独立的线程， 让这个文件在这个线程中作为独立的程序运行。这种通过这样的 URL创建的 Worker 称为专用 Worker（ Dedicated Worker） 。 除了提供一个指向外部文件的 URL， 你还可以通过提供一个 Blob URL（ 另外一个 HTML5 特性） 创建一个在线 Worker（ Inline Worker)， 本质上就是一个存储在单个（ 二进制） 值中的在线文件。</p>
<p>Worker 之间以及它们和主程序之间， 不会共享任何作用域或资源，  而是通过一个基本的事件消息机制相互联系。<br>Worker w1 对象是一个事件侦听者和触发者， 可以通过订阅它来获得这个 Worker 发出的事件以及发送事件给这个 Worker。<br>以下是如何侦听事件（ 其实就是固定的 “message” 事件） ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w1.addEventListener( &quot;message&quot;, function(evt)&#123;</span><br><span class="line">// evt.data</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure></p>
<p>也可以发送 “message” 事件给这个 Worker：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w1.postMessage( &quot;something cool to say&quot; );</span><br></pre></td></tr></table></figure></p>
<p>在这个 Worker 内部， 收发消息是完全对称的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// &quot;mycoolworker.js&quot;</span><br><span class="line">addEventListener( &quot;message&quot;, function(evt)&#123;</span><br><span class="line">// evt.data</span><br><span class="line">&#125; );</span><br><span class="line">postMessage( &quot;a really cool reply&quot; );//postMessage() 方法 - 它用于向 HTML 页面传回一段消息。</span><br></pre></td></tr></table></figure></p>
<p>注意， 专用 Worker 和创建它的程序之间是一对一的关系。 也就是说， “message” 事件没有任何歧义需要消除， 因为我们确定它只能来自这个一对一的关系： 它要么来自这个 Worker， 要么来自主页面。<br>通常由主页面应用程序创建 Worker， 但若是需要的话， Worker 也可以实例化它自己的子 Worker， 称为 subworker。 有时候，把这样的细节委托给一个“主”Worker， 由它来创建其他 Worker 处理部分任务， 这样很有用。  要想使用subworker首先要确定浏览器是否支持。要在创建 Worker 的程序中终止 Worker， 可以调用 Worker 对象（ 就像前面代码中的 w1 ） 上的 terminate() 。 突然终止Worker 线程不会给它任何机会完成它的工作或者清理任何资源。 这就类似于通过关闭浏览器标签页来关闭页面。<br>如果浏览器中有两个或多个页面（ 或同一页上的多个 tab ！ ） 试图从同一个文件 URL创建 Worker， 那么最终得到的实际上是完全独立的 Worker。</p>
<h4 id="Web-Worker-通常应用于哪些方面呢？"><a href="#Web-Worker-通常应用于哪些方面呢？" class="headerlink" title="Web Worker 通常应用于哪些方面呢？"></a>Web Worker 通常应用于哪些方面呢？</h4><p>处理密集型数学计算<br>大数据集排序<br>数据处理（ 压缩、 音频分析、 图像处理等）<br>高流量网络通信<br>注释：web worker 通常不用于过于简单的脚本，而是用于更耗费 CPU 资源的任务。</p>
<h4 id="检测-Web-Worker-支持"><a href="#检测-Web-Worker-支持" class="headerlink" title="检测 Web Worker 支持"></a>检测 Web Worker 支持</h4><p>在创建 web worker 之前，请检测用户的浏览器是否支持它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(typeof(Worker)!==&quot;undefined&quot;)</span><br><span class="line">  &#123;</span><br><span class="line">  // Yes! Web worker support!</span><br><span class="line">  // Some code.....</span><br><span class="line">  &#125;</span><br><span class="line">else</span><br><span class="line">  &#123;</span><br><span class="line">  // Sorry! No Web Worker support..</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Worker环境"><a href="#Worker环境" class="headerlink" title="Worker环境"></a>Worker环境</h4><p>在 Worker 内部是无法访问主程序的任何资源的。 这意味着你不能访问它的任何全局变量， 也不能访问页面的 DOM 或者其他资源。 记住， 这是一个完全独立的线程。<br>但 是， 你可以执行网络操 作（ Ajax、 WebSockets） 以及设定定时 器。 还 有， Worker 可以访问几个重要的全局变量和功能的本地复本， 包括 navigator 、 location 、 JSON 和 applicationCache 。还可以通过 importScripts(..) 向 Worker 加载额外的 JavaScript 脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在Worker内部</span><br><span class="line">importScripts( &quot;foo.js&quot;, &quot;bar.js&quot; );</span><br></pre></td></tr></table></figure></p>
<p>这些脚本加载是同步的。 也就是说， importScripts(..) 调用会阻塞余下 Worker 的执行， 直到文件加载和执行完成。</p>
<h4 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h4><p>可能已经注意到这些应用中的大多数有一个共性， 就是需要在线程之间通过事件机制传递大量的信息， 可能是双向的。</p>
<p>如果要传递一个对象， 可以使用结构化克隆算法 （ structured clone algorithm） （ <a href="https://developer.mozilla.org/enUS/docs/Web/Guide/API/DOM/The_structured_clone_algorithm）" target="_blank" rel="noopener">https://developer.mozilla.org/enUS/docs/Web/Guide/API/DOM/The_structured_clone_algorithm）</a> 把这个对象复制到另一边。 这个算法非常高级， 甚至可以处理要复制的对象有循环引用的情况。这样就不用付出 to-string和 from-string的性能损失了， 但是这种方案还是要使用双倍的内存。IE10 及更高版本以及所有其他主流浏览器都支持这种方案。</p>
<p>还有一个更好的选择， 特别是对于大数据集而言， 就是使用 Transferable 对象 （ <a href="http://updates.html5rocks.com/2011/12/TransferableObjects-Lightning-Fast)这时发生的是对象所有权的转移，" target="_blank" rel="noopener">http://updates.html5rocks.com/2011/12/TransferableObjects-Lightning-Fast)这时发生的是对象所有权的转移，</a> 数据本身并没有移动。 一旦你把对象传递到一个 Worker 中， 在原来的位置上， 它就变为空的或者是不可访问的， 这样就消除了多线程编程作用域共享带来的混乱。当然，所有权传递是可以双向进行的。</p>
<p>如果选择 Transferable 对象的话， 其实不需要做什么。 任何实现了 Transferable 接口（ <a href="http://developer.mozilla.org/enUS/docs/Web/API/Transferable" target="_blank" rel="noopener">http://developer.mozilla.org/enUS/docs/Web/API/Transferable</a> ）的数据结构就自动按照这种方式传输（ Firefox和 Chrome 都支持） 。举例来说， 像 Uint8Array这样的带类型的数组 就是Transferable。 下面是如何使用 postMessage(..) 发送一个 Transferable 对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 比如foo是一个Uint8Array</span><br><span class="line">postMessage( foo.buffer, [ foo.buffer ] );</span><br></pre></td></tr></table></figure></p>
<p>第一个参数是一个原始缓冲区， 第二个是一个要传输的内容的列表。不支持 Transferable 对象的浏览器就降级到结构化克隆， 这会带来性能下降而不是彻底的功能失效。</p>
<h4 id="共享-Worker"><a href="#共享-Worker" class="headerlink" title="共享 Worker"></a>共享 Worker</h4><p>如果你的站点或 app 允许加载同一个页面的多个 tab（ 一个常见的功能） ， 那你可能非常希望通过防止重复专用 Worker 来降低系统的资源使用。 在这一方面最常见的有限资源就是 socket 网络连接， 因为浏览器限制了到同一个主机的同时连接数目。 当然， 限制来自于同一客户端的连接数也减轻了你的资源压力。<br>在这种情况下， 创建一个整个站点或 app 的所有页面实例都可以共享的中心 Worker 就非常有用了。<br>这称为 SharedWorker ， 可通过下面的方式创建（ 只有 Firefox和 Chrome 支持这一功能）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var w1 = new SharedWorker( &quot;http://some.url.1/mycoolworker.js&quot; );</span><br></pre></td></tr></table></figure></p>
<p>因为共享 Worker 可以与站点的多个程序实例或多个页面连接， 所以这个 Worker 需要通过某种方式来得知消息来自于哪个程序。 这个唯一标识符称为端口 （ port） ， 可以类比网络 socket 的端口。 因此， 调用程序必须使用 Worker 的 port 对象用于通信:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w1.port.addEventListener( &quot;message&quot;, handleMessages );</span><br><span class="line">// ..</span><br><span class="line">w1.port.postMessage( &quot;something cool&quot; );</span><br></pre></td></tr></table></figure></p>
<p>还有， 端口连接必须要初始化， 形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w1.port.start();</span><br></pre></td></tr></table></figure></p>
<p>在共享 Worker 内部， 必须要处理额外的一个事件： “connect” 。 这个事件为这个特定的连接提供了端口对象。 保持多个连接独立的最简单办法就是使用 port 上的闭包，就像下面的代码一样， 把这个链接上的事件侦听和传递定义在 “connect” 事件的处理函数内部：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在共享Worker内部</span><br><span class="line">addEventListener( &quot;connect&quot;, function(evt)&#123;</span><br><span class="line">// 这个连接分配的端口</span><br><span class="line">var port = evt.ports[0];</span><br><span class="line">port.addEventListener( &quot;message&quot;, function(evt)&#123;</span><br><span class="line">// ..</span><br><span class="line">port.postMessage( .. );</span><br><span class="line">// ..</span><br><span class="line">&#125; );</span><br><span class="line">// 初始化端口连接</span><br><span class="line">port.start();</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure></p>
<p>除了这个区别之外， 共享和专用 Worker 在功能和语义方面都是一样的.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/h5-webworkers/">h5 webworkers</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-codetest" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/10/codetest/" class="article-date">
  	<time datetime="2017-02-10T02:43:12.000Z" itemprop="datePublished">2017-02-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/10/codetest/">
        使用Benchmark.js和jsPerf分析代码性能
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>前端开发中，掌握好浏览器的特性进行有针对性的性能调优是一项基本工作，同时，比较不同代码的执行速度也是一项关键的工作。</p>
<p>比如，当我们想比较RegExp的test方法和String对象的indexOf方法查找字符串谁的速度更快的话，js代码在不同的浏览器，不同的操作系统环境运行的效率可能是不一样的，这就是为什么我们需要对其进行基准测试，在做基准测试方面，我们可以使用Benchmark.js和使用jsPerf（一个基于JSLitmus的基准测试库）。我们可以使用jsPerf来分享你的基准测试。</p>
<h4 id="Benchmark-js-的使用"><a href="#Benchmark-js-的使用" class="headerlink" title="Benchmark.js 的使用"></a>Benchmark.js 的使用</h4><p>其实在很多github 开源项目中，往往都能看到benchmark文件夹。使用方法如下：<br>首先在系统根目录下，通过npm intsall benchmark 来安装benchmark。该模块会被写入node_modules文件夹中，我们在test.js文件中通过require方法引入该模块。<br>将如下代码写入test.js文件，该文件置于系统根目录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var Benchmark = require(&apos;benchmark&apos;);</span><br><span class="line">var suite = new Benchmark.Suite;</span><br><span class="line"></span><br><span class="line">// 添加测试</span><br><span class="line">suite.add(&apos;RegExp#test&apos;, function() &#123;</span><br><span class="line">    /o/.test(&apos;Hello World!&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">    .add(&apos;String#indexOf&apos;, function() &#123;</span><br><span class="line">        &apos;Hello World!&apos;.indexOf(&apos;o&apos;) &gt; -1;</span><br><span class="line">    &#125;)</span><br><span class="line">// add listeners</span><br><span class="line">    .on(&apos;cycle&apos;, function(event) &#123;</span><br><span class="line">        console.log(String(event.target));</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(&apos;complete&apos;, function() &#123;</span><br><span class="line">        console.log(&apos;Fastest is &apos; + this.filter(&apos;fastest&apos;).pluck(&apos;name&apos;));</span><br><span class="line">    &#125;)</span><br><span class="line">// run async</span><br><span class="line">    .run(&#123; &apos;async&apos;: true &#125;);</span><br></pre></td></tr></table></figure></p>
<p>然后在控制台执行node test.js 可见输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ git:(master) ✗ node test.js</span><br><span class="line">RegExp#test x 9,847,928 ops/sec ±1.47% (83 runs sampled)</span><br><span class="line">String#indexOf x 23,366,017 ops/sec ±0.91% (96 runs sampled)</span><br><span class="line">Fastest is String#indexOf</span><br></pre></td></tr></table></figure></p>
<p>结果最快的就是String对象的indexOf方法，其中，Ops/sec 测试结果以每秒钟执行测试代码的次数（Ops/sec）显示，这个数值越大越好。除了这个结果外，同时会显示测试过程中的统计误差，以及相对最好的慢了多少（%）;</p>
<p><font color="red">call和apply的比较</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var Benchmark = require(&apos;benchmark&apos;);</span><br><span class="line">var suite = new Benchmark.Suite;</span><br><span class="line">var arr1 = function (str) &#123;</span><br><span class="line">    return [].slice.apply(str);</span><br><span class="line">&#125;;</span><br><span class="line">var str2 = function (str) &#123;</span><br><span class="line">    return [].slice.call(str);</span><br><span class="line">&#125;;</span><br><span class="line">// 添加测试</span><br><span class="line">suite.add(&apos;arr1&apos;, function() &#123;</span><br><span class="line">    arr1(&apos;test&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">    .add(&apos;str2&apos;, function() &#123;</span><br><span class="line">        str2(&apos;test&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">// add listeners</span><br><span class="line">    .on(&apos;cycle&apos;, function(event) &#123;</span><br><span class="line">        console.log(String(event.target));</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(&apos;complete&apos;, function() &#123;</span><br><span class="line">        console.log(&apos;Fastest is &apos; + this.filter(&apos;fastest&apos;).pluck(&apos;name&apos;));</span><br><span class="line">    &#125;)</span><br><span class="line">// run async</span><br><span class="line">    .run(&#123; &apos;async&apos;: true &#125;);</span><br></pre></td></tr></table></figure></p>
<p>输出如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr1 x 596,505 ops/sec ±1.14% (95 runs sampled)</span><br><span class="line">str2 x 627,822 ops/sec ±1.27% (92 runs sampled)</span><br><span class="line">Fastest is str2</span><br></pre></td></tr></table></figure></p>
<p><font color="red">本地的使用</font><br>本地使用Benchmark需要引入如下三个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;lodash.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;platform.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;benchmark.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="jsPerf-的使用"><a href="#jsPerf-的使用" class="headerlink" title="jsPerf 的使用"></a>jsPerf 的使用</h4><p>jsPerf 提供了一个简便的方式来创建和共享测试用例，并可以比较不同JavaScript代码段的性能。jsPerf也是基于Benchmark来运行的。<br>打开jsPerf站点：<a href="http://jsperf.com/，先将必填的项目填了。其中，slug是短名称，会生成一个网址，因此不可与别人的重复。然后在Code" target="_blank" rel="noopener">http://jsperf.com/，先将必填的项目填了。其中，slug是短名称，会生成一个网址，因此不可与别人的重复。然后在Code</a> snippets to compare 区域填入title和用于测试的code。最后点击save test case 完成验证即可。浏览器会自动跳转到测试页面.<br>Async选项框是用来测试一些异步调用的性能的，我们的代码没有使用异步方法，所以不必勾选。</p>
<p><font color="red">运行测试</font><br>点击“Run tests”按钮开始测试两种算法的性能。建议在运行性能测试之前，关闭无关的浏览器页面，关闭其他程序，退出不必要的后台进程，以保证结果不受其他环境的影响。你也可以通过点击个别测试用例的名字单独运行这个例子.<br>jsPerf还会统计所有运行过这个测试用例的浏览器的比较结果，显示在下方的Browserscope区域，可以通过它直观地看出各个版本浏览器的性能横向和纵向比较情况。</p>
<p><font color="red">查看别人的测试用例</font><br>我们可以通过 <a href="http://jsperf.com/browse" target="_blank" rel="noopener">http://jsperf.com/browse</a> 浏览最新提交的250项最新测试用例。我们也可以使用底部的Revisions来查看不同的版本，也就是不同浏览器的测试用例情况。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>John Resig 在其博文 JavaScript基准测试的质量中提到，应该尽量考虑到每个测试结果的误差并去减小它。扩大测试的样本值，健全的测试执行，都能够起到减少误差的作用。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Benchmark-jsPerf/">Benchmark jsPerf</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2018 前端在路上
      </div>
        <div class="footer-right">
          <a href="http://webywx.com/" target="_blank">webywx</a>  Theme <a href="https://yanwenxi.site" target="_blank">前端在路上</a> by Scorpio
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>