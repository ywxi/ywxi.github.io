<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>闫文喜的个人前端博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="闫文喜 前端博客 web前端博客  web前端开发">
<meta property="og:type" content="website">
<meta property="og:title" content="闫文喜的个人前端博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="闫文喜的个人前端博客">
<meta property="og:description" content="闫文喜 前端博客 web前端博客  web前端开发">
<meta property="og:locale" content="ch">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="闫文喜的个人前端博客">
<meta name="twitter:description" content="闫文喜 前端博客 web前端博客  web前端开发">
  
    <link rel="alternative" href="/atom.xml" title="闫文喜的个人前端博客" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">前端在路上</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/about">关于我</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/yanwenxi" title="github">github</a>
					        
								<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="mail">mail</a>
					        
								<a class="qq" target="_blank" href="http://www.webywx.com" title="qq">qq</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Benchmark-jsPerf/" style="font-size: 10px;">Benchmark jsPerf</a> <a href="/tags/ES6、promise/" style="font-size: 10px;">ES6、promise</a> <a href="/tags/GraphQL/" style="font-size: 10px;">GraphQL</a> <a href="/tags/H5-移动端优化/" style="font-size: 10px;">H5 移动端优化</a> <a href="/tags/H5、bug/" style="font-size: 10px;">H5、bug</a> <a href="/tags/JS设计模式-设计模式/" style="font-size: 10px;">JS设计模式 设计模式</a> <a href="/tags/Jenkins-CI/" style="font-size: 10px;">Jenkins CI</a> <a href="/tags/Lodash/" style="font-size: 10px;">Lodash</a> <a href="/tags/angular/" style="font-size: 10px;">angular</a> <a href="/tags/angular-http-q-promise/" style="font-size: 10px;">angular $http $q promise</a> <a href="/tags/angular-q-promise/" style="font-size: 10px;">angular $q promise</a> <a href="/tags/angular-decorator/" style="font-size: 10px;">angular decorator</a> <a href="/tags/angular-filter/" style="font-size: 10px;">angular filter</a> <a href="/tags/angular-服务/" style="font-size: 10px;">angular 服务</a> <a href="/tags/angularjs/" style="font-size: 10px;">angularjs</a> <a href="/tags/angular、-http/" style="font-size: 10px;">angular、$http</a> <a href="/tags/angular、Karma/" style="font-size: 10px;">angular、Karma</a> <a href="/tags/angular、directive/" style="font-size: 10px;">angular、directive</a> <a href="/tags/angular、html5/" style="font-size: 10px;">angular、html5</a> <a href="/tags/angular、module、controller/" style="font-size: 10px;">angular、module、controller</a> <a href="/tags/angular、promise、-q、deferred/" style="font-size: 10px;">angular、promise、$q、deferred</a> <a href="/tags/angular、router/" style="font-size: 10px;">angular、router</a> <a href="/tags/angular、ui-router/" style="font-size: 10px;">angular、ui-router</a> <a href="/tags/angular、表达式、filter/" style="font-size: 10px;">angular、表达式、filter</a> <a href="/tags/app-跨平台/" style="font-size: 10px;">app,跨平台</a> <a href="/tags/aso/" style="font-size: 10px;">aso</a> <a href="/tags/blockchain/" style="font-size: 10px;">blockchain</a> <a href="/tags/class/" style="font-size: 10px;">class</a> <a href="/tags/css-1px/" style="font-size: 10px;">css 1px</a> <a href="/tags/css3/" style="font-size: 10px;">css3</a> <a href="/tags/debugger/" style="font-size: 10px;">debugger</a> <a href="/tags/es5-js/" style="font-size: 10px;">es5 js</a> <a href="/tags/es6/" style="font-size: 10px;">es6</a> <a href="/tags/fit/" style="font-size: 10px;">fit</a> <a href="/tags/flex-css/" style="font-size: 10px;">flex css</a> <a href="/tags/flexbox/" style="font-size: 10px;">flexbox</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/git-github/" style="font-size: 10px;">git github</a> <a href="/tags/h5-webworkers/" style="font-size: 10px;">h5 webworkers</a> <a href="/tags/ifelse/" style="font-size: 10px;">ifelse</a> <a href="/tags/iframe/" style="font-size: 10px;">iframe</a> <a href="/tags/javascript、object-oriented、继承/" style="font-size: 10px;">javascript、object-oriented、继承</a> <a href="/tags/jest/" style="font-size: 10px;">jest</a> <a href="/tags/jquery/" style="font-size: 10px;">jquery</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/js-Array/" style="font-size: 10px;">js Array</a> <a href="/tags/js-Higher-order-function/" style="font-size: 10px;">js Higher-order-function</a> <a href="/tags/js-closure/" style="font-size: 10px;">js closure</a> <a href="/tags/js-lodash/" style="font-size: 10px;">js lodash</a> <a href="/tags/js-object/" style="font-size: 10px;">js object</a> <a href="/tags/js-scope/" style="font-size: 10px;">js scope</a> <a href="/tags/js-sea-js-模块化/" style="font-size: 10px;">js sea.js 模块化</a> <a href="/tags/js-this/" style="font-size: 10px;">js this</a> <a href="/tags/js-性能调试/" style="font-size: 10px;">js 性能调试</a> <a href="/tags/js-柯里化/" style="font-size: 10px;">js 柯里化</a> <a href="/tags/js-纯函数/" style="font-size: 10px;">js 纯函数</a> <a href="/tags/jsapi/" style="font-size: 10px;">jsapi</a> <a href="/tags/jsevent/" style="font-size: 10px;">jsevent</a> <a href="/tags/js、变态题/" style="font-size: 10px;">js、变态题</a> <a href="/tags/js、设计模式/" style="font-size: 10px;">js、设计模式</a> <a href="/tags/js、跨域、document-domain/" style="font-size: 10px;">js、跨域、document.domain</a> <a href="/tags/js异步编程/" style="font-size: 10px;">js异步编程</a> <a href="/tags/js模块化、AMD、CMD、CommonJs/" style="font-size: 10px;">js模块化、AMD、CMD、CommonJs</a> <a href="/tags/js继承/" style="font-size: 10px;">js继承</a> <a href="/tags/life、意念/" style="font-size: 10px;">life、意念</a> <a href="/tags/lodash-chain/" style="font-size: 10px;">lodash chain</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/maxhosts/" style="font-size: 10px;">maxhosts</a> <a href="/tags/mongoDB-数据库/" style="font-size: 10px;">mongoDB 数据库</a> <a href="/tags/mvp/" style="font-size: 10px;">mvp</a> <a href="/tags/mvvm/" style="font-size: 10px;">mvvm</a> <a href="/tags/node/" style="font-size: 12px;">node</a> <a href="/tags/node-debug/" style="font-size: 10px;">node debug</a> <a href="/tags/node-wechat/" style="font-size: 18px;">node wechat</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/node、enentLoop/" style="font-size: 10px;">node、enentLoop</a> <a href="/tags/promise、es6/" style="font-size: 10px;">promise、es6</a> <a href="/tags/rap/" style="font-size: 16px;">rap</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/react-ant-design/" style="font-size: 10px;">react ant-design</a> <a href="/tags/reflow、repaint/" style="font-size: 10px;">reflow、repaint</a> <a href="/tags/seo/" style="font-size: 18px;">seo</a> <a href="/tags/seo-新闻源/" style="font-size: 10px;">seo 新闻源</a> <a href="/tags/token、OAuth、鉴权/" style="font-size: 10px;">token、OAuth、鉴权</a> <a href="/tags/vh、vw、css3/" style="font-size: 10px;">vh、vw、css3</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/vuex/" style="font-size: 10px;">vuex</a> <a href="/tags/vue、多面应用/" style="font-size: 10px;">vue、多面应用</a> <a href="/tags/web/" style="font-size: 12px;">web</a> <a href="/tags/web-交互/" style="font-size: 10px;">web 交互</a> <a href="/tags/web、前端/" style="font-size: 10px;">web、前端</a> <a href="/tags/web、性能优化/" style="font-size: 10px;">web、性能优化</a> <a href="/tags/web缓存/" style="font-size: 10px;">web缓存</a> <a href="/tags/wechat/" style="font-size: 10px;">wechat</a> <a href="/tags/wechat-webstorm/" style="font-size: 10px;">wechat webstorm</a> <a href="/tags/win10、linux/" style="font-size: 10px;">win10、linux</a> <a href="/tags/window-history-html5/" style="font-size: 10px;">window.history html5</a> <a href="/tags/wxapp/" style="font-size: 14px;">wxapp</a> <a href="/tags/xss、csrf/" style="font-size: 10px;">xss、csrf</a> <a href="/tags/yarn-npm/" style="font-size: 10px;">yarn npm</a> <a href="/tags/人生/" style="font-size: 10px;">人生</a> <a href="/tags/前后端分享/" style="font-size: 10px;">前后端分享</a> <a href="/tags/前端脚手架/" style="font-size: 10px;">前端脚手架</a> <a href="/tags/埋点统计/" style="font-size: 10px;">埋点统计</a> <a href="/tags/建站-seo/" style="font-size: 10px;">建站 seo</a> <a href="/tags/性能、异常上报/" style="font-size: 10px;">性能、异常上报</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/生活/" style="font-size: 20px;">生活</a> <a href="/tags/移动端、fixed/" style="font-size: 10px;">移动端、fixed</a> <a href="/tags/统计、cloc/" style="font-size: 10px;">统计、cloc</a> <a href="/tags/解构赋值-es6/" style="font-size: 10px;">解构赋值 es6</a> <a href="/tags/跨域、postMessage、html5/" style="font-size: 10px;">跨域、postMessage、html5</a> <a href="/tags/路由-html5/" style="font-size: 10px;">路由 html5</a> <a href="/tags/防抖、节流/" style="font-size: 10px;">防抖、节流</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.webywx.com/">前端博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.yanwenxi.site/">web小站</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">前端在路上</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">前端在路上</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/about">关于我</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/yanwenxi" title="github">github</a>
			        
						<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="mail">mail</a>
			        
						<a class="qq" target="_blank" href="http://www.webywx.com" title="qq">qq</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-GraphQL" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/10/15/GraphQL/" class="article-date">
  	<time datetime="2018-10-15T06:12:39.000Z" itemprop="datePublished">2018-10-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/15/GraphQL/">
        学习GraphQL
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="REST将会过时，而GraphQL则会长存"><a href="#REST将会过时，而GraphQL则会长存" class="headerlink" title="REST将会过时，而GraphQL则会长存"></a>REST将会过时，而GraphQL则会长存</h4><h4 id="一、为何要使用GraphQL"><a href="#一、为何要使用GraphQL" class="headerlink" title="一、为何要使用GraphQL?"></a>一、为何要使用GraphQL?</h4><p>GraphQL 能够非常漂亮地解决三个重要的问题：</p>
<ul>
<li>为了得到视图所需的数据，需要进行多轮的网络调用：借助 GraphQL，要获取所有的初始化数据，我们仅需一次到服务器的网络调用。要在 REST API 中达到相同的目的，我们需要引入非结构化的参数和条件，这是很难管理和扩展的。</li>
<li>客户端对服务端的依赖：借助 GraphQL，客户端会使用一种请求语言，该语言：1）消除了服务器端硬编码数据形式或数量大小的必要性；2）将客户端与服务端解耦。这意味着我们能够独立于服务器端维护和改善客户端。</li>
<li>糟糕的前端开发体验：借助 GraphQL，开发人员只需使用一种声明式的语言表达用户的界面数据需求即可。他们所描述的是需要什么数据，而不是如何得到这些数据。在 GraphQL 中，UI 所需的数据以及开发人员描述数据的方式之间存在紧密的联系。</li>
</ul>
<h3 id="二、什么是GraphQL"><a href="#二、什么是GraphQL" class="headerlink" title="二、什么是GraphQL"></a>二、什么是GraphQL</h3><p>GraphQL 就是关于数据通信的。我们有客户端和服务器端，它们之间都需要进行对话。客户端需要告诉服务器端它需要什么数据，而服务器端要以实际的数据满足客户端的需求，GraphQL 就位于这种通信之间。</p>
<p>那为什么不能让客户端和服务器端直接通信呢？当然可以。</p>
<p>有多个原因促使我们在客户端和服务器端之间放置一个 GraphQL 层。其中有个原因，可能也是最常见的，那就是效率。客户端通常需要跟服务端要求多个资源，而服务端通常只能理解如何响应单个资源。所以，客户端需要发起多轮请求，这样才能收集到它需要的所有数据。</p>
<p>借助 GraphQL，我们可以将这种多请求的复杂性转移到服务端，让 GraphQL 层来对其进行处理。客户端对 GraphQL 层发起一个请求并且会得到一个响应，该响应中精确包含了客户端所需的内容。</p>
<p>使用 GraphQL 还会有很多收益，比如，另外一个收益就是与多个服务进行通信的时候。如果你有多个客户端要从多个服务请求数据的时候，位于中间的 GraphQL 层能够简化和标准化这种通信。尽管这并不是针对 REST API 的（因为它也能很容易地实现），但是 GraphQL 运行时提供了一个结构化和标准化的方式来实现这一点。</p>
<p>客户端不会与两个不同的数据服务直接交互，我们现在可以让客户端与 GraphQL 层进行通信。然后，GraphQL 层会与两个不同的数据服务进行通信。这样的话，GraphQL 首先能够将客户端进行隔离，这样它们就没有必要使用多种语言进行通信了，同时，GraphQL 还会将一个请求转换为针对不同服务的多个请求，这些不同的服务可能会使用不同的语言编写。</p>
<p><code>让我们假设有三个不同的人，他们使用不同的语言并且具备不同类型的知识。假设你有一个问题，该问题需要组合这三个人的知识才能给出答案。如果你有一个能够说这三门语言的翻译器，那么为你的问题给出答案就会变得很容易。这其实就是 GraphQL 运行时所做的事情。</code></p>
<p>我们需要在 GraphQL 运行时上定义模式，客户端会使用该模式。</p>
<p>基本上来讲，模式就是一个能力文档，它包含了客户端可以请求 GraphQL 层的所有问题的列表。在如何使用模式方面有一定的灵活性，因为我们在这里所讨论的是一个节点图。模式主要体现的是 GraphQL 层所能回答的问题都有哪些限制。</p>
<h4 id="三、REST-API-有什么问题呢？"><a href="#三、REST-API-有什么问题呢？" class="headerlink" title="三、REST API 有什么问题呢？"></a>三、REST API 有什么问题呢？</h4><p>REST API 最大的问题在于其多端点的特质。这需要客户端进行多轮请求才能获取到想要的数据。</p>
<p>REST API 通常是端点的集合，其中每个端点代表了一个资源。所以，当客户端需要来自多个资源的数据时，就需要针对 REST API 发起多轮请求，这样才能将客户端所需的数据组合完整。</p>
<p>在 REST API 中，没有客户端请求语言。客户端对服务端返回的数据没有控制权。在这方面，没有语言能够帮助它们实现这一点。更精确地说，客户端可用的语言非常有限。</p>
<p>例如，用来实现读取（READ）的 REST API 一般不外乎如下两种形式：</p>
<ul>
<li>GET <code>/ResouceName</code>：获取指定资源的所有记录的列表；</li>
<li>GET <code>/ResourceName/ResourceID</code>：根据 ID 获取单条记录。</li>
</ul>
<p>举例来说，客户端无法指定该选择记录中的哪个字段。这些信息位于 REST API 服务本身之中，不管客户端实际需要哪些字段，REST API 服务始终都会返回所有的字段。GraphQL 对该问题的描述术语是过度加载（over-fetching）不需要的信息。不管是对于客户端还是对于服务器端，这都是网络和内存资源的一种浪费。</p>
<p>REST API 的另外一个大问题是版本化。如果你需要支持多版本的话，通常意味着要有多个端点。在使用和维护这些端点的时候，这通常会导致更多的问题，而这也可能是服务端出现代码重复的原因所在。</p>
<p>上文所述的 REST API 的问题恰好是 GraphQL 所要致力解决的。上面所述的这些肯定不是 REST API 的所有问题，我也不想过多讨论 REST API 是什么，不是什么。我主要讲的是基于资源的 HTTP 端点 API。这些 API 最终都会变成常规 REST 端点和自定义专门端点的混合品，其中自定义的专门端点大多都是因为性能的原因而制作的。在这种情况下，GraphQL 能够提供好得多的方案。</p>
<h4 id="四、GraphQL的魔力是如何实现的"><a href="#四、GraphQL的魔力是如何实现的" class="headerlink" title="四、GraphQL的魔力是如何实现的"></a>四、GraphQL的魔力是如何实现的</h4><p>在 GraphQL 背后有着很多理念和设计决策，但是最为重要的包括：</p>
<ul>
<li>GraphQL 模式是强类型的模式。要创建 GraphQL 模式，我们需要按照类型来定义字段。这些类型可以是原始类型，也可以是自定义类型，模式中的任何内容都需要一个类型。这种丰富的类型系统允许实现丰富特性，比如具备内省功能的 API，以及为客户端和服务端构建强大的工具；</li>
<li>GraphQL 将数据以 Graph 的形式来进行表示，而数据很自然的表现形式就是图。如果想要表示任意的数据，那正确的结构就是图。GraphQL 运行时允许我们以图 API 的方式来表示数据，该 API 能够匹配数据的自然图形形状。</li>
<li>GraphQL 具有一个声明式的特质来表示数据需求。GraphQL 为客户端提供了一种声明式的语言，允许它们描述其数据需求。这种声明式的特质围绕 GraphQL 语言创建了心智模型，这与我们使用英语思考数据需求的方式非常接近，从而使得 GraphQL API 要比其他替代方案容易得多。</li>
</ul>
<p>这些都是高层级的理念，接下来让我们看一些细节。</p>
<p>为了解决多轮网络调用的问题，GraphQL 将响应服务器变成了只有一个端点。从根本上来讲，GraphQL 将自定义端点的思想发挥到了极致，将整个服务器变成了一个自定义的端点，使其能够应对所有的数据请求。</p>
<p>与这个单端点概念相关的另一个重要理念是富客户端请求语言（rich client request language），这是使用自定义端点所需的。如果没有客户端请求语言的话，单端点是没有什么用处的。它需要有一种语言来处理自定义的请求并为该请求响应数据。</p>
<p>具备客户端请求语言就意味着客户端将会是可控的。客户端能够确切地请求它们想要的内容，服务器端则能够确切地给出客户端想要的东西。这解决了过度加载的问题。</p>
<p>在版本化方面，GraphQL 有一种非常有趣的做法，能够彻底避免版本化的问题。从根本上来讲，我们可以添加新的字段，而不必移除旧的字段，因为我们有一个图，从而可以通过添加节点来灵活地扩展这个图。所以，我们可以为旧 API 继续保留其路径，并引入新的 API，而不必将其标记为新版本。API 只是不断增长而已。</p>
<p>这对于移动端尤为重要，因为我们无法控制它们使用哪个版本的 API。一旦安装之后，移动应用可能会多年一直使用相同版本的旧 API。在 Web 端，我们能够很容易地控制 API 的版本，我们只需推送并使用新的代码即可。对移动应用来说，这样做就有些困难了。</p>
<h4 id="五、RESTful-API-与-GraphQL-API-的样例"><a href="#五、RESTful-API-与-GraphQL-API-的样例" class="headerlink" title="五、RESTful API 与 GraphQL API 的样例"></a>五、RESTful API 与 GraphQL API 的样例</h4><p>假设我们是开发人员，负责构建一个崭新的用户界面，展现《星球大战》电影及其角色。</p>
<p>我们要构建的第一个 UI 界面很简单：显示每个《星球大战》人物信息的视图。例如，Darth Vader 以及他在哪些电影中出现过。这个视图将会展现人物的姓名、出生年份、星球名称以及他们所出现的电影的名字。</p>
<p>听起来非常简单，但实际上我们在处理三种不同类型的资源：人物（Person）、星球（Planet）以及电影（Film）。这些资源之间的关系很简单，任何人都可以猜测数据的形状。每个 Person 对象属于一个 Planet 对象，同时每个 Person 对象有一个或多个 Film 对象。</p>
<p>这个 UI 的 JSON 数据可能会如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;person&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Darth Vader&quot;,</span><br><span class="line">      &quot;birthYear&quot;: &quot;41.9BBY&quot;,</span><br><span class="line">      &quot;planet&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;Tatooine&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;films&quot;: [</span><br><span class="line">        &#123; &quot;title&quot;: &quot;A New Hope&quot; &#125;,</span><br><span class="line">        &#123; &quot;title&quot;: &quot;The Empire Strikes Back&quot; &#125;,</span><br><span class="line">        &#123; &quot;title&quot;: &quot;Return of the Jedi&quot; &#125;,</span><br><span class="line">        &#123; &quot;title&quot;: &quot;Revenge of the Sith&quot; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们看一下如何使用 RESTful API 请求该数据。</p>
<p>我们需要一个人的信息，假设我们知道人员的 ID，暴露该信息的 RESTful API 预期将会是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET - /people/&#123;id&#125;</span><br></pre></td></tr></table></figure>
<p>这个请求将会为我们提供该人员的姓名、生日和其他信息。一个好的 RESTful API 还会给我们提供该人员的星球 ID 以及这个人员所出现的所有电影的 ID 数组。</p>
<p>该请求的 JSON 响应可能会像如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Darth Vader&quot;,</span><br><span class="line">  &quot;birthYear&quot;: &quot;41.9BBY&quot;,</span><br><span class="line">  &quot;planetId&quot;: 1</span><br><span class="line">  &quot;filmIds&quot;: [1, 2, 3, 6],</span><br><span class="line">  *** 其他我们并不需要的信息 ***</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了读取星球的名称，我们需要调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET - /planets/1</span><br></pre></td></tr></table></figure>
<p>随后，为了读取电影的名称，我们还要调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET - /films/1</span><br><span class="line">GET - /films/2</span><br><span class="line">GET - /films/3</span><br><span class="line">GET - /films/6</span><br></pre></td></tr></table></figure>
<p>从服务器端得到这六个响应之后，我们就可以就可以将它们组合起来以满足视图的数据需求。</p>
<p>为了满足一个简单 UI 的数据需求，我们发起了六轮请求，除此之外，我们在这里的方式是命令式的。我们需要给出如何获取数据以及如何处理数据使其满足视图需求的指令。除此之外，在这个过程中还会过度加载视图并不需要的信息。</p>
<p>当然，这仅仅是该数据的一种 RESTful API 实现方式而已。我们可能还会有更好的实现方式，让视图编写起来更加容易。例如，如果 API 服务器的实现能够嵌套资源并理解人员和电影之间的关联关系，那么我们通过该 API 来读取电影数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET - /people/&#123;id&#125;/films</span><br></pre></td></tr></table></figure>
<p>但是，纯粹的 RESTful API 可能并不会实现这些，我们需要要求后端工程师为我们创建这个自定义的端点。这就是 RESTful API 进行扩展的现实：我们只能添加自定义端点来有效满足不断增长的客户端需求。管理这样的自定义端点是非常困难的。</p>
<p>现在，我们再来看一下 GraphQL 的方式。GraphQL 在服务端拥抱了自定义端点的理念，并将其发挥到了极致。服务器只有一个端点，至于通道则无关紧要。如果你通过 HTTP 来实现的话，HTTP 方法当前也是无关紧要的。我们假设有一个通过 HTTP 暴露的 GraphQL 端点，其地址为<code>/graphql</code>。</p>
<p>因为想要通过一轮请求就将数据获取到，所以需要有一种方式来向服务器表达完整的数据需求。我们通过一个 GraphQL 查询来实现这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET or POST - /graphql?query=&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>GraphQL 查询只是一个字符串，但是它需要包含我们所需数据的所有片段。此时，声明式的方式就能发挥作用了。</p>
<p>在中文中，会这样描述我们的数据需求：我们需要一个人员的姓名、出生年份、星球的名字以及所有相关电影的名称。在 GraphQL 中，这会翻译为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  person(ID: ...) &#123;</span><br><span class="line">    name,</span><br><span class="line">    birthYear,</span><br><span class="line">    planet &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;,</span><br><span class="line">    films &#123;</span><br><span class="line">      title</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次阅读一下使用中文表达的需求，然后将其与 GraphQL 查询进行对比。你会发现，它们非常接近。现在，对比一下这个 GraphQL 查询和我们开始时所见到的原始 JSON 数据。GraphQL 查询与 JSON 数据的格式完全相同，唯一的差异在于”值（value）“部分。如果我们将其想象为问题和答案的关系，所提出的问题就是将答案语句刨除了答案值。</p>
<p>如果答案语句是：</p>
<blockquote>
<p>距离太阳最近的行星是水星。</p>
</blockquote>
<p>对该问题进行表述时，一种非常好的方式就是将相同语句的答案部分刨除掉：</p>
<blockquote>
<p>距离太阳最近的行星是什么？</p>
</blockquote>
<p>同样的关系可以用到 GraphQL 查询中。以 JSON 响应为例，我们将其中的”答案“部分（也就是 JSON 中的值）移除掉，最终就能得到一个 GraphQL 查询，它能够非常恰当地表述 JSON 响应所对应的问题。</p>
<p>现在，对比一下 GraphQL 查询和我们为数据所定义的声明式 React UI。GraphQL 查询中的所有内容都用到了 UI 之中，而 UI 中用到的所有内容也都出现在了 GraphQL 查询中。</p>
<p>这是 GraphQL 非常强大的思想模型。UI 知道它所需要的确切数据，抽取需求相对是非常容易的。生成 GraphQL 是一项非常简单的任务，只需将 UI 所需的数据直接抽取为变量即可。</p>
<p>如果我们将这个模型反过来，它依然非常强大。有一个 GraphQL 查询之后，我们就能知道如何在 UI 中使用它的响应，这是因为查询与响应有着相同的”结构“。我们不需要探查响应就能知道如何使用它，我们甚至不需要任何关于该 API 的文档。它都是内置的。</p>
<p><a href="https://github.com/graphql/swapi-graphql" target="_blank" rel="noopener">https://github.com/graphql/swapi-graphql</a> 站点将《星球大战》的数据托管为 GraphQL API。你可以在这里进行尝试，构建我们的人员数据对象。这里有些小的差异，我们稍后会进行讨论，如下给出了一个官方的查询，我们可以基于该 API 读取视图所需的数据（以 Darth Vader 为例）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  person(personID: 4) &#123;</span><br><span class="line">    name,</span><br><span class="line">    birthYear,</span><br><span class="line">    homeworld &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;,</span><br><span class="line">    filmConnection &#123;</span><br><span class="line">      films &#123;</span><br><span class="line">        title</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个请求给出的响应结构非常类似于我们视图所使用的结构，需要记住的是，我们在一轮请求中就得到了所有的数据。</p>
<h4 id="六、GraphQL-灵活性的代价"><a href="#六、GraphQL-灵活性的代价" class="headerlink" title="六、GraphQL 灵活性的代价"></a>六、GraphQL 灵活性的代价</h4><p>完美的解决方案只可能出现在童话之中。GraphQL 带来了灵活性，同时也有一些值得关注的地方和问题。</p>
<p>GraphQL 所带来的一个非常重要的风险就是资源耗尽攻击（即拒绝服务攻击）。GraphQL 服务器可以通过过于复杂的查询来进行攻击，这种查询将会消耗尽服务器的所有资源。它也非常容易查询深层的嵌套关联关系（用户 -&gt;好友 -&gt;好友），或者使用字段别名多次查询相同的字段。资源耗尽攻击并不是 GraphQL 特有的，但是在使用 GraphQL 的时候，我们必须格外小心。</p>
<p>我们能够采取一些措施来缓解这种情况。我们可以在查询之前进行预先的成本分析，并限制人们可以消费的数据量。我们还可以实现超时功能，将消耗过长时间解析的请求杀掉。同时，因为 GraphQL 只是一个解析层，我们可以在 GraphQL 层之下，进行速度的限制。</p>
<p>如果我们试图保护的 GraphQL API 端点不是公开的，也就是只用于客户端（Web 或移动）的内部使用，那么可以使用白名单的方式，服务器只能执行预选得到许可的查询。客户端可以使用一个唯一的查询标识符，请求服务器执行预先许可的查询。Facebook 似乎采用了这种方式。</p>
<p>在使用 GraphQL 时，另外一个需要考虑的地方就是认证和授权。在 GraphQL 查询解析之前、之后或解析的过程中，我们需要在这方面进行处理吗？</p>
<p>要回答这个问题，我们可以将 GraphQL 视为你自己的后端数据获取逻辑之上的一个 DSL（领域特定语言）。它只是一个分层，我们可以将其放到客户端和实际的数据服务（或多个服务）之间。</p>
<p>我们将认证和授权视为另一个分层。GraphQL 并不会为实际的认证和授权逻辑提供帮助。它也不是做这个的。但是如果你想要将这些分层放到 GraphQL 之后的话，我们可以使用 GraphQL 在客户端和限制逻辑之间传输访问 token。这非常类似于在 RESTful API 认证和授权时，我们所采取的做法。</p>
<p>在客户端数据缓存方面，GraphQL 也面临着更多的挑战。RESTful API 由于其字典（dictionary）的特性，因此更容易进行缓存。对应的地址给出数据，因此我们可以使用这个地址本身作为缓存的 key。</p>
<p>在使用 GraphQL 的时候，我们可以采用类似的基本方法，使用查询的文本作为 key 来缓存它的响应。但是，这种方式是有一定限制的，效率不高，并且会导致数据一致性方面的问题。多个 GraphQL 查询的结果很容易出现重叠，这种基本的缓存机制不能解决重叠的问题。</p>
<p>但是，在这方面有一个很好的解决方案。图查询（Graph Query）意味着图缓存。如果我们将 GraphQL 查询的响应规范化为一个扁平的记录集合，为每条记录提供一个全局唯一的 ID，那么我们就可以缓存这些记录，而不是整个响应。</p>
<p>不过，这并不是一个简单的过程。记录会引用其他的记录，我们将会管理一个循环图。填充和读取缓存需要遍历查询。我们需要编码实现一个分层来处理缓存逻辑。但是，总体而言，这种方式要比基于响应的缓存高效得多。Relay.js 是采用该缓存策略的一个库，它会在内部进行自动管理。</p>
<p>关于 GraphQL，我们最需要关注的问题可能就是所谓的 N+1 SQL 查询。GraphQL 查询字段被设计为独立的函数，在数据库中为这些字段解析获取数据可能会导致每个字段都需要一个新的数据库请求。</p>
<p>对于简单的 RESTful API 端点，可以通过增强的结构化 SQL 查询来分析、检测和解决 N+1 查询问题。GraphQL 动态解析字段，因此并没有那么简单。幸好，Facebook 正在通过 DataLoader 方案来解决这个问题。</p>
<p>顾名思义，DataLoader 是一个工具，我们可以借助它从数据库中读取数据，并将其提供给 GraphQL 解析函数使用。我们可以使用 DataLoader 读取数据，避免直接使用 SQL 查询从数据库中进行查询，DataLoader 将会作为我们的代理，减少实际发往数据库中的 SQL 查询。</p>
<p>DataLoader 组合使用批处理和缓存来实现这一点。如果相同的客户端请求需要向数据库查询许多内容的话，DataLoader 能够合并这些问题，并从数据库中批量加载问题的答案。DataLoader 还会对答案进行缓存，后续的问题如果请求相同的资源的话，就可以使用缓存了。</p>
<p>参考链接：<a href="http://suo.im/5foXDV" target="_blank" rel="noopener">http://suo.im/5foXDV</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GraphQL/">GraphQL</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-authentication" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/10/15/authentication/" class="article-date">
  	<time datetime="2018-10-15T06:12:39.000Z" itemprop="datePublished">2018-10-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/15/authentication/">
        前后端常用的几种鉴权方式
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="神码是鉴权呢？"><a href="#神码是鉴权呢？" class="headerlink" title="神码是鉴权呢？"></a>神码是鉴权呢？</h4><p>鉴权（authentication）是指验证用户是否拥有访问系统的权利。</p>
<h4 id="目前常用的四种鉴权方式："><a href="#目前常用的四种鉴权方式：" class="headerlink" title="目前常用的四种鉴权方式："></a>目前常用的四种鉴权方式：</h4><p>1、HTTP Basic Authentication</p>
<p>2、session-cookie</p>
<p>3、token验证</p>
<p>4、OAuth(开放授权)</p>
<p>###1、HTTP Basic Authentication</p>
<p>这种授权方式是浏览器遵守http协议实现的基本授权方式,HTTP协议进行通信的过程中，HTTP协议定义了基本认证认证允许HTTP服务器对客户端进行用户身份证的方法。</p>
<ul>
<li>认证过程</li>
</ul>
<p>1． 客户端向服务器请求数据，请求的内容可能是一个网页或者是一个ajax异步请求，此时，假设客户端尚未被验证，则客户端提供如下请求至服务器:</p>
<p>  Get /index.html HTTP/1.0<br>  Host:www.google.com</p>
<p> 2． 服务器向客户端发送验证请求代码401,（WWW-Authenticate: Basic realm=”google.com”这句话是关键，如果没有客户端不会弹出用户名和密码输入界面）服务器返回的数据大抵如下：</p>
<p>  HTTP/1.0 401 Unauthorised<br>  Server: SokEvo/1.0<br>  WWW-Authenticate: Basic realm=”google.com”<br>  Content-Type: text/html<br>  Content-Length: xxx</p>
<p>  3． 当符合http1.0或1.1规范的客户端（如IE，FIREFOX）收到401返回值时，将自动弹出一个登录窗口，要求用户输入用户名和密码。（弹出框是浏览器默认的）</p>
<p> 4． 用户输入用户名和密码后，将用户名及密码以BASE64加密方式加密，并将密文放入前一条请求信息中，则客户端发送的第一条请求信息则变成如下内容：</p>
<p>  Get /index.html HTTP/1.0<br>  Host:www.google.com<br>  Authorization: Basic d2FuZzp3YW5n</p>
<p>注：d2FuZzp3YW5n表示加密后的用户名及密码（用户名：密码 然后通过base64加密，加密过程是浏览器默认的行为，不需要我们人为加密，我们只需要输入用户名密码即可）</p>
<p>  5． 服务器收到上述请求信息后，将Authorization字段后的用户信息取出、解密，将解密后的用户名及密码与用户数据库进行比较验证，如用户名及密码正确，服务器则根据请求，将所请求资源发送给客户端</p>
<p><strong>效果：</strong><br>  客户端未未认证的时候，会弹出用户名密码输入框，这个时候请求时属于pending状态，这个时候其实服务当用户输入用户名密码的时候客户端会再次发送带Authentication头的请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">server.js</span><br><span class="line">let express = require(&quot;express&quot;);</span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line">    app.use(express.static(__dirname+&apos;/public&apos;));</span><br><span class="line"></span><br><span class="line">    app.get(&quot;/Authentication_base&quot;,function(req,res)&#123;</span><br><span class="line">        console.log(&apos;req.headers.authorization:&apos;,req.headers)</span><br><span class="line">        if(!req.headers.authorization)&#123;</span><br><span class="line">            res.set(&#123;</span><br><span class="line">               &apos;WWW-Authenticate&apos;:&apos;Basic realm=&quot;wang&quot;&apos;</span><br><span class="line">            &#125;);</span><br><span class="line">            res.status(401).end();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            let base64 = req.headers.authorization.split(&quot; &quot;)[1];</span><br><span class="line">            let userPass = new Buffer(base64, &apos;base64&apos;).toString().split(&quot;:&quot;);</span><br><span class="line">            let user = userPass[0];</span><br><span class="line">            let pass = userPass[1];</span><br><span class="line">            if(user==&quot;wang&quot;&amp;&amp;pass=&quot;wang&quot;)&#123;</span><br><span class="line">                res.end(&quot;OK&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res.status(401).end();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    app.listen(9090)</span><br><span class="line">    </span><br><span class="line">index.html:</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(function()&#123;</span><br><span class="line">    send(&apos;./Authentication_base&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    var send = function(url)&#123;</span><br><span class="line">    $.ajax(&#123;  </span><br><span class="line">    url : url,  </span><br><span class="line">    method : &apos;GET&apos;,  </span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>当然有登陆就有注销，我们会发现当我们认证成功后每次请求请求头都会带上Authentication及里面的内容，那么如何做到让这次登陆失效的？</p>
<p>  网上查了半天，目前最有效的方式就是在注销操作的时候，专门在服务器设置一个专门的注销账号，当接收到的Authentication信息为注销用户名密码的时候就便注销成功了，而客户端在注销操作的时候，手动的的去修改请求头重的Authentication，将他设置未服务器默认的注销账号和密码。</p>
<p>  通过上面的简单讲解 其实我们已经可以返现这种验证方式的缺陷加密方式简单，仅仅是base64加密，这种加密方式是可逆的。同时在每个请求的头上都会附带上用户名和密码信息，这样在外网是很容易被嗅探器探测到的。</p>
<p><strong>总结:</strong></p>
<p>  正式因为这样，这种加密方式一般多被用在内部安全性要求不高的的系统上，只是相对的多，总的来说现在使用这种鉴权比较少了。如果项目需要部署在公网上，这种方式不推荐，当然你也可以和SSL来加密传输，这样会好一点.</p>
<h4 id="2、session-cookie"><a href="#2、session-cookie" class="headerlink" title="2、session-cookie"></a>2、session-cookie</h4><p>这种方式是利用服务器端的session（会话）和浏览器端的cookie来实现前后端的认证，由于http请求时是无状态的，服务器正常情况下是不知道当前请求之前有没有来过，这个时候我们如果要记录状态，就需要在服务器端创建一个会话(seesion),将同一个客户端的请求都维护在各自得会会话中，每当请求到达服务器端的时候，先去查一下该客户端有没有在服务器端创建seesion，如果有则已经认证成功了，否则就没有认证。<br><strong>session-cookie认证主要分四步：</strong> </p>
<p>  1、服务器在接受客户端首次访问时在服务器端创建seesion，然后保存seesion(我们可以将seesion保存在内存中，也可以保存在redis中，推荐使用后者)，然后给这个session生成一个唯一的标识字符串,然后在响应头中种下这个唯一标识字符串。<br> 2、签名。这一步只是对sid进行加密处理，服务端会根据这个secret密钥进行解密。（非必需步骤）<br>  3、浏览器中收到请求响应的时候会解析响应头，然后将sid保存在本地cookie中，浏览器在下次http请求的请求头中会带上该域名下的cookie信息，<br>   4、服务器在接受客户端请求时会去解析请求头cookie中的sid，然后根据这个sid去找服务器端保存的该客户端的session，然后判断该请求是否合法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server.js</span><br><span class="line">var express =require(&apos;express&apos;);</span><br><span class="line">var RedisStore = require(&apos;connect-redis&apos;)(express.session);</span><br><span class="line">var app =express();</span><br><span class="line">var secret = &apos;yanwenxi&apos;;</span><br><span class="line">//设置cookie</span><br><span class="line">app.use(express.cookieParser(secret));</span><br><span class="line">//设置session</span><br><span class="line">app.use(express.session(&#123;</span><br><span class="line">    store: new RedisStore(&#123;</span><br><span class="line">        host:&apos;127.0.0.1&apos;,</span><br><span class="line">        port:9999,</span><br><span class="line">        db:&apos;session_db&apos;</span><br><span class="line">    &#125;),</span><br><span class="line">    secret:secret</span><br><span class="line">&#125;))</span><br><span class="line">app.get(&apos;/&apos;,function(req,res)&#123;</span><br><span class="line">    var session = req.session;</span><br><span class="line">    session.time = session.time ||0;</span><br><span class="line">    var n= session.time++;</span><br><span class="line">    res.send(&apos;hello,session id:&apos;+session.id+&apos;count:&apos;+n);</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(9000);</span><br></pre></td></tr></table></figure>
<h4 id="3、token验证"><a href="#3、token验证" class="headerlink" title="3、token验证"></a>3、token验证</h4><p><strong>auth2.0流程分为六步：</strong></p>
<p>第一步. 向用户请求授权，现在很多的网站在登陆的时候都有第三方登陆的入口，当我们点击等第三方入口时，第三方授权服务会引导我们进入第三方登陆授权页面。</p>
<p>通过第三方请求授权页面的浏览器地址栏地址可以看出，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://graph.qq.com/oauth2.0/show?which=Login&amp;display=pc&amp;response_type=code&amp;client_id=100270989&amp;redirect_uri=https%3A%2F%2Fpassport.csdn.net%2Faccount%2Flogin%3Foauth_provider%3DQQProvider&amp;state=test1</span><br></pre></td></tr></table></figure>
<p>这里的地址里面的%是浏览器强制编码后的显示我们可以使用decodeURIComponent进行解码，解码后是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://graph.qq.com/oauth2.0/show?which=Login&amp;display=pc&amp;response_type=code&amp;client_id=100270989&amp;redirect_uri=https://passport.csdn.net/account/login?oauth_provider=QQProvider&amp;state=test1</span><br></pre></td></tr></table></figure>
<p>这个url地址我们可以看见Auth2.0常见的几个参数：<br>​      response_type，返回类型<br>​      client_id，第三方应用id,由授权服务器（qq）在第三方应用提交时颁发给第三方应用。<br>​      redirect_uri，登陆成功重定向页面<br>​      oauth_provider，第三方授权提供方<br>​      state，由第三方应用给出的随机码<br>第二步. 返回用户凭证（code），并返回一个凭证（code），当用户点击授权并登陆后，授权服务器将生成一个用户凭证（code）。这个用户凭证会附加在重定向的地址redirect_uri的后面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://passport.csdn.net/account/login?code=9e3efa6cea739f9aaab2&amp;state=XXX</span><br></pre></td></tr></table></figure>
<p>第3步. 请求授权服务器授权:</p>
<p>  经过第二部获取code后后面的工作就可以交给后台去处理的，和用户的交互就结束了。接下来我的需要获取Access Token，我们需要用他来向授权服务器获取用户信息等资源。<br>  第三方应用后台通过第二步的凭证（code）向授权服务器请求Access Token，这时候需要以下几个信息：</p>
<ul>
<li>client_id 标识第三方应用的id，由授权服务器（Github）在第三方应用提交时颁发给第三方应用</li>
<li>client_secret 第三方应用和授权服务器之间的安全凭证，由授权服务器（Github）在第三方应用提交时颁发给第三方应用</li>
<li>code 第一步中返回的用户凭证redirect_uri 第一步生成用户凭证后跳转到第二步时的地址</li>
<li>state 由第三方应用给出的随机码</li>
</ul>
<p>第四步. 授权服务器同意授权后，返回一个资源访问的凭证（Access Token）。</p>
<p>第五步. 第三方应用通过第四步的凭证（Access Token）向资源服务器请求相关资源。</p>
<p>第六步. 资源服务器验证凭证（Access Token）通过后，将第三方应用请求的资源返回。</p>
<p>从用户角度来说，第三方授权可以让我们快速的登陆应用，无需进行繁琐的注册,同时不用记住各种账号密码。只需要记住自己常用的几个账号就ok了。<br>从产品经理的角度来所，这种授权方式提高用户的体验满意度。另一方面可以获取更多的用户。</p>
<p>最后，授权方式多种多样，主要还是要取决于我们对于产品的定位。如果我们的产品只是在企业内部使用，token和session就可以满足我们的需求，如果是面向互联网的大众用户，那么第三方授权在用户体验度上会有一个很大的提升。</p>
<p>参考链接：<a href="https://blog.csdn.net/wang839305939/article/details/78713124/" target="_blank" rel="noopener">https://blog.csdn.net/wang839305939/article/details/78713124/</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/token、OAuth、鉴权/">token、OAuth、鉴权</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-1px" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/10/15/1px/" class="article-date">
  	<time datetime="2018-10-15T06:12:39.000Z" itemprop="datePublished">2018-10-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/15/1px/">
        移动端1px细线解决方案总结
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="移动端1px变粗的原因"><a href="#移动端1px变粗的原因" class="headerlink" title="移动端1px变粗的原因"></a>移动端1px变粗的原因</h3><p>为什么移动端css里_面写了1px，实际看起来比1px粗，其实原因很好理解：这两个”px”的含义是不一样的,移动端html里的header里总会有一句:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>这句话定义了本页面的viewport的宽度为设备宽度，初始缩放值和最大缩放值都为1，并禁用了用户缩放，viewport通俗地讲是浏览器上可用来显示页面的区域，这个区域是可能比屏幕大的。</p>
<p> 手机存在一个能完美适配的理想viewport, 分辨率相差很大的手机的理想viewport的宽度可能是一样的, 这样做的目的是为了保证同样的css在不同屏幕下的显示效果是一致的, 上面的meta实际上是设置了ideal viewport的宽度.</p>
<p>以实际举例: iphone3和iphone4的屏幕宽度分别是320px,640px, 但是它们的ideal viewport的宽度都是320px, 设置了设备宽度后, 320px宽的元素都能100%的填充满屏幕宽. 不同手机的ideal viewport宽度是不一样的, 常见的有320px, 360px, 384px. iphone系列的这个值在6之前都是320px, 控制viewport的好处就在于一套css可以适配多个机型.</p>
<p>看懂的人应该已经明白 1px变粗的原因了, viewport的设置和屏幕物理分辨率是按比例而不是相同的. <strong>移动端window对象有个devicePixelRatio属性, 它表示设备物理像素和css像素的比例, 在retina屏的iphone手机上, 这个值为2或3, css里写的1px映射到物理像素上就有2px或3px那么粗.</strong></p>
<h3 id="1px解决方案"><a href="#1px解决方案" class="headerlink" title="1px解决方案"></a>1px解决方案</h3><h4 id="1、用小数来写px值"><a href="#1、用小数来写px值" class="headerlink" title="1、用小数来写px值"></a>1、用小数来写px值</h4><p>IOS8下已经支持带小数的px值, media query对应devicePixelRatio有个查询值-webkit-min-device-pixel-ratio, css可以写成这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.border &#123; border: 1px solid #999 &#125;</span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio: 2) &#123;</span><br><span class="line">    .border &#123; border: 0.5px solid #999 &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio: 3) &#123;</span><br><span class="line">    .border &#123; border: 0.333333px solid #999 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点: 安卓与低版本IOS不适用, 这个或许是未来的标准写法.</p>
<h4 id="2、scale缩放的方式"><a href="#2、scale缩放的方式" class="headerlink" title="2、scale缩放的方式"></a>2、scale缩放的方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.border-1px &#123;  </span><br><span class="line">            position: relative;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">.border-1px::after &#123;  </span><br><span class="line">            display: block;  </span><br><span class="line">            position: absolute;  </span><br><span class="line">            left: 0;  </span><br><span class="line">            bottom: 0;  </span><br><span class="line">            width: 100%;  </span><br><span class="line">            border-top: 1px solid red;  </span><br><span class="line">            content: &apos;  &apos;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line"> @media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio:1.5) &#123;  </span><br><span class="line"> 		.border-1px::after &#123;  </span><br><span class="line">		 -webkit-transform: scaleY(0.7);  </span><br><span class="line"> 		transform: scaleY(0.7)  </span><br><span class="line">            &#125;  </span><br><span class="line">       </span><br><span class="line">       @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio:2)       &#123;</span><br><span class="line">       .border-1px::after &#123;  </span><br><span class="line">       -webkit-transform: scaleY(0.5);  </span><br><span class="line">       transform: scaleY(0.5)  </span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、rem解决方案"><a href="#3、rem解决方案" class="headerlink" title="3、rem解决方案"></a>3、rem解决方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//根据屏幕大小及dpi调整缩放和大小  </span><br><span class="line">(function () &#123;</span><br><span class="line">        var scale = 1.0;</span><br><span class="line">        var ratio = 1;</span><br><span class="line">        if (window.devicePixelRatio &gt;= 2) &#123;</span><br><span class="line">            scale *= 0.5;</span><br><span class="line">            ratio *= 2;</span><br><span class="line">        &#125;</span><br><span class="line"> var text = &apos;&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=&apos; + scale + &apos;, maximum-scale=&apos; + scale + &apos;,&apos; + &apos; minimum-scale=&apos; + scale + &apos;, width=device-width,&apos; + &apos; user-scalable=no&quot; /&gt;&apos;;</span><br><span class="line">   document.write(text);</span><br><span class="line">   document.documentElement.style.fontSize = 50 * ratio + &quot;px&quot;;&#125;)();</span><br></pre></td></tr></table></figure>
<h4 id="4、其他方式"><a href="#4、其他方式" class="headerlink" title="4、其他方式"></a>4、其他方式</h4><p>比如：背景图图片、背景图渐变、js判断支持0.5px(和方案1类似)；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css-1px/">css 1px</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-css3vwvh" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/09/15/css3vwvh/" class="article-date">
  	<time datetime="2018-09-15T06:12:39.000Z" itemprop="datePublished">2018-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/15/css3vwvh/">
        纯CSS3使用vw和vh视口单位实现移动端自适应
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在业界，极为推崇的一种理论是 Peter-Paul Koch (江湖人称“PPK大神”)提出的关于视口的解释——在桌面端，视口指的是在桌面端，指的是浏览器的可视区域；而在移动端较为复杂，它涉及到三个视口：分别是 Layout Viewport（布局视口）、 Visual Viewport（视觉视口）、Ideal Viewport。</p>
<p>而视口单位中的“视口”，在桌面端，毫无疑问指的就是浏览器的可视区域；但是在移动端，它指的则是三个 Viewport 中的 Layout Viewport 。</p>
<p>根据<a href="https://drafts.csswg.org/css-values-3/#viewport-relative-lengths" target="_blank" rel="noopener">CSS3规范</a>，视口单位主要包括以下4个：<a href="http://caibaojian.com/vw-vh.html" target="_blank" rel="noopener">·</a></p>
<ul>
<li>vw : 1vw 等于视口宽度的1%</li>
<li>vh : 1vh 等于视口高度的1%</li>
<li>vmin : 选取 vw 和 vh 中最小的那个</li>
<li>vmax : 选取 vw 和 vh 中最大的那个</li>
</ul>
<p>视口单位区别于%单位，视口单位是依赖于视口的尺寸，根据视口尺寸的百分比来定义的；而%单位则是依赖于元素的祖先元素。</p>
<p>例如，在桌面端浏览器视口尺寸为650px，那么 1vw = 650 * 1% = 6.5px（这是理论推算的出，如果浏览器不支持0.5px，那么实际渲染结果可能是7px）。整个视口的宽为100vw，即650px。</p>
<h3 id="postcss-px-to-viewport"><a href="#postcss-px-to-viewport" class="headerlink" title="postcss-px-to-viewport"></a>postcss-px-to-viewport</h3><p>可通过npm install 方式安装此插件，把px转化为viewport.用法可在github上搜</p>
<p>Postcss-px-to-viewport看官方文档。</p>
<p>PostCSS基于js插件去转换css的一个工具。这些插件支持变量，mixin，未来的css语法，在线图片甚至更多。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vh、vw、css3/">vh、vw、css3</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-cloc" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/09/15/cloc/" class="article-date">
  	<time datetime="2018-09-15T06:12:39.000Z" itemprop="datePublished">2018-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/15/cloc/">
        mac下统计任意文件夹中代码行数的工具—cloc
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-利用homebrew下载并安装cloc"><a href="#1-利用homebrew下载并安装cloc" class="headerlink" title="1.利用homebrew下载并安装cloc"></a>1.利用homebrew下载并安装cloc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install cloc</span><br></pre></td></tr></table></figure>
<h4 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2.基本用法"></a>2.基本用法</h4><p>统计当前文件夹代码行数（请先cd到目标目录）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloc ./</span><br></pre></td></tr></table></figure>
<p>如果想排除当前目录下的某个文件夹的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloc ./ --exclude-dir=xx   (xx为要排除的文件夹名字)</span><br></pre></td></tr></table></figure>
<h4 id="3-高级用法"><a href="#3-高级用法" class="headerlink" title="3.高级用法"></a>3.高级用法</h4><p>如果我们想要排除更多的文件夹该怎么处理呢？最好的方法就是查看cloc的使用文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloc --help</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloc ./ --exclude-dir=xx1,xx2    排除xx1和xx2两个文件夹</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/统计、cloc/">统计、cloc</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-node-eventLoop" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/27/node-eventLoop/" class="article-date">
  	<time datetime="2018-08-27T06:12:39.000Z" itemprop="datePublished">2018-08-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/27/node-eventLoop/">
        node中的事件循环机制
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>事件循环能让Node.js执行非阻塞I/O操作。尽管javascript事实上是单线程的，通过在可能的情况下把操作交给操作系统内核来实现。</p>
<p>由于大多数现代系统内核是多线程的，内核可以处理后台执行的多个操作，当其中一个操作完成的时候，内核会告诉nodejs，相应的回调就被添加到轮询队列（poll queue）并最终得到执行。</p>
<p>执行阶段总览：</p>
<p>1、定时器（timers）:本阶段执行setTimeout()和setInterval()计划的回调</p>
<p>2、I/O回调：例：readFile()在此执行。</p>
<p>3、空闲、预备（idle/prepare）:只内部使用</p>
<p>4、轮询（poll）:获取新的I/O事件，nodejs这时会适当进行阻塞</p>
<p>5、检查（check）:调用setImmediate()的回调</p>
<p>6、close callbacks:例如socket.on(‘close’,…..)</p>
<p>以上是事件循环的每一个阶段，第个阶段都有一个需要执行的回调函数的先入先出（FIFO）队列，基本上，当事件循环进行到某个阶段时，会执行该阶段特有的操作，然后执行该阶段队列中的回调，直到队列空了或者达到了执行次数限制，此时事件循环会进入下一个阶段，循环往复。</p>
<ul>
<li>setTimeout()           在某个时间值过后<strong>尽快</strong>执行回调函数；</li>
<li>setImmediate()       一旦<strong>轮询阶段完成</strong>就执行回调函数；</li>
<li><p>process.nextTick()   在<strong>当前调用栈结束</strong>后就立即处理，这时也必然是“事件循环继续进行之前” ；</p>
<p> 一般情况下：优先级顺序从高到低： process.nextTick() &gt; setImmediate() &gt; setTimeout()</p>
</li>
<li><p>宏任务macrotasks: setTimeout setInterval setImmediate I/O UI渲染</p>
</li>
<li>微任务microtasks: Promise process.nextTick Object.observe MutationObserver</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">const &#123;readFile&#125; = require(&apos;fs&apos;);</span><br><span class="line">const EventEmitter = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">class EE extends EventEmitter &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const yy = new EE();</span><br><span class="line">yy.on(&apos;event&apos;, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;出大事了啊&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;0毫秒后期执行的定时器函数&apos;);</span><br><span class="line">&#125;, 0)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;100毫秒后期执行的定时器函数&apos;);</span><br><span class="line">&#125;, 100)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;200毫秒后期执行的定时器函数&apos;);</span><br><span class="line">&#125;, 200)</span><br><span class="line">readFile(&apos;../package.json&apos;, &quot;utf-8&quot;, data =&gt; &#123;</span><br><span class="line">    console.log(&apos;完成文件1读操作的回调&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">readFile(&apos;../dev.sh&apos;, &apos;utf-8&apos;, data =&gt; &#123;</span><br><span class="line">    console.log(&apos;完成文件2的读操作回调&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;immediate 立即回调&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;process.nextTick 的回调&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    yy.emit(&apos;event&apos;);</span><br><span class="line">    process.nextTick(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;process.nextTick 的第2次回调&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(&apos;Promise的第1次回调&apos;);</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;Promise 的第2次回调&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">输出结果如下：</span><br><span class="line">process.nextTick 的回调</span><br><span class="line">出大事了啊</span><br><span class="line">Promise的第1次回调</span><br><span class="line">Promise 的第2次回调</span><br><span class="line">process.nextTick 的第2次回调</span><br><span class="line">0毫秒后期执行的定时器函数</span><br><span class="line">完成文件1读操作的回调</span><br><span class="line">完成文件2的读操作回调</span><br><span class="line">immediate 立即回调</span><br><span class="line">100毫秒后期执行的定时器函数</span><br><span class="line">200毫秒后期执行的定时器函数</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//setImmediate() 被设计成一旦轮询阶段完成就执行回调函数；setTimeout() 规划了在某个时间值过后执行回调函数；</span><br><span class="line">//setImmediate() 是nodejs中一个特殊的定时器，在事件循环中一个单独的阶段运行。它使用libuv的API 来使得回调函数在轮询阶段完成后执行</span><br><span class="line">//process.nextTick() 在事件循环的当前阶段回调执行完后立即生效；setImmediate() 生效是在接下来的迭代或者事件循环的下一次tick；process.nextTick() 比 setImmediate() 更“立刻”执行</span><br></pre></td></tr></table></figure>
<p>部分文章参考：<a href="https://www.cnblogs.com/jasonxuli/p/6074231.html" target="_blank" rel="noopener">https://www.cnblogs.com/jasonxuli/p/6074231.html</a></p>
<p>官方源码：<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/</a></p>
<p>编程中常用的阶段：1阶段、2阶段、5阶段。写代码测试这三个阶段得出的结论：</p>
<p>1、如果某个阶段队列的所有回调函数都执行完毕了，就会进入下一个阶段</p>
<p>2、无论在哪个阶段增加process.nextTick(),除非当前这个阶段的回调还没有执行完，那么在下一个阶段开始之前一定会执行process.nextTick；process.nextTick的优先级高于promise.</p>
<p>3、一旦有同步代码阻塞执行，这时候不会影响整个事件循环的秩序，先等到同步代码执行完后，再执行process.nextTick；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node、enentLoop/">node、enentLoop</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-toLocaleString" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/15/toLocaleString/" class="article-date">
  	<time datetime="2018-08-15T06:12:39.000Z" itemprop="datePublished">2018-08-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/15/toLocaleString/">
        toLocaleString()和toString()区别
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="toLocaleString-和toString-区别"><a href="#toLocaleString-和toString-区别" class="headerlink" title="toLocaleString()和toString()区别"></a>toLocaleString()和toString()区别</h3><p>《javascript高级程序设计》里解释道：</p>
<p>toLocaleString()返回对象的字符串表示，该字符串与执行环境的地区对应；</p>
<p>toString()返回对象的字符串表示。</p>
<p>听起来还是不太好理解，直接看例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数字：</span><br><span class="line">var a=55555;</span><br><span class="line">a.toLocaleString();//&apos;55,555&apos;</span><br><span class="line">a.toString();//&apos;55555&apos;</span><br></pre></td></tr></table></figure>
<p>当是数字时，可以看出：数字是三位以上时，toLocaleString会每三位出现一个分隔符。它可以用以实现数值的千分符。一般帐单中常用到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数组：</span><br><span class="line">var b=[1,2,3];</span><br><span class="line">b.toLocaleString();//&apos;1,2,3&apos;</span><br><span class="line">b.toString();//&apos;1,2,3&apos;</span><br></pre></td></tr></table></figure>
<p>可以看出数组调用时没啥区别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">日期：</span><br><span class="line">var c=new Date();</span><br><span class="line">console.log(c.toLocaleString());//&quot;2018/8/2 下午4:50:26&quot;</span><br><span class="line">console.log(c.toString());//&quot;Thu Aug 02 2018 16:50:26 GMT+0800 (中国标准时间)&quot;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>1、toLocaleString()会根据你的机器的本地环境来返回字符串，它和toString()返回的值在不同的本地环境下使用的符号可能变化；用数字的toLocaleString方法可以很方便地实现千分位。</p>
<p>2、使用toString()是保险的方法，它不会因为本地环境（例如国家）改变而改变。</p>
<p>3、为了返回时间类型的值的话，使用toLocaleString();</p>
<h4 id="toLocaleString-好玩的地方："><a href="#toLocaleString-好玩的地方：" class="headerlink" title="toLocaleString()好玩的地方："></a>toLocaleString()好玩的地方：</h4><p>1、console.log(1234567890..toLocaleString(“zh-CN-u-nu-hanidec”,{useGrouping:false}))；//一二三四五六七八九〇</p>
<p>注意：数字加上两个点可以直接调用toLocaleString(),若写一个点需对数字加上括号。等价于上面的结果：console.log((1234567890).toLocaleString(“zh-CN-u-nu-hanidec”,{useGrouping:false}))</p>
<p>2、console.log(1234567890..toLocaleString(“zh-CN-u-nu-hanidec”,{useGrouping:true}))</p>
<p>结果：一,二三四,五六七,八九〇</p>
<p>3、document.write(new Date().toLocaleString(“zh-CN-u-nu-hanidec”))</p>
<p>结果：二〇一六/四/二一 上午一〇:三八:三七</p>
<p>useGrouping 的值对结果无影响</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jsapi/">jsapi</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-xssAndCsrf" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/15/xssAndCsrf/" class="article-date">
  	<time datetime="2018-06-15T06:12:39.000Z" itemprop="datePublished">2018-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/15/xssAndCsrf/">
        前端领域中常用的两种攻击xss和csrf
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在web安全领域中，xss和csrf是最常见的攻击方式。下文将简单介绍xss和csrf的攻防问题。</p>
<h4 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h4><p>Xss:中文译为跨站脚本攻击。</p>
<p>xss攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。</p>
<p>XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。</p>
<h4 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h4><p>反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">比如点击恶意链接发起一个请求，此请求返回一段可执行的脚本。</span><br><span class="line">function handleReequest(req, res) &#123;</span><br><span class="line"></span><br><span class="line">    res.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;);</span><br><span class="line"></span><br><span class="line">    res.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/html; charset=UTF-8&apos;&#125;);</span><br><span class="line"></span><br><span class="line">    res.write(&apos;&lt;script&gt;alert(&quot;反射型 XSS 攻击&quot;)&lt;/script&gt;&apos;);</span><br><span class="line"></span><br><span class="line">    res.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>攻击者可以注入任意的恶意脚本进行攻击，可能注入恶作剧脚本，或者注入能获取用户隐私数据(如cookie)的脚本，这取决于攻击者的目的。</p>
<h4 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a><strong>存储型</strong></h4><p>存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。</p>
<p>比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。</p>
<p>当用户点击提交按钮将输入恶意脚本信息提交到服务端时，服务端通过 userInput 变量保存了输入内容。当其他用户访问时，服务端会返回对应的内容，恶意脚本就会在浏览器端执行。</p>
<p><strong>基于DOM</strong></p>
<p>基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。</p>
<p>###<strong>XSS 攻击的防范</strong></p>
<p>现在主流的浏览器内置了防范 XSS 的措施，例如 CSP。但对于开发者来说，也应该寻找可靠的解决方案来防止 XSS 攻击。</p>
<p><strong>HttpOnly 防止劫取 Cookie</strong></p>
<p>HttpOnly 最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。</p>
<p>上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。</p>
<p><strong>输入检查</strong></p>
<p>不要相信用户的任何输入。 对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。</p>
<p>在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 &lt;，&gt; 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。</p>
<p>而在一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 &lt;，&gt;，script，防止 XSS 攻击：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// vuejs 中的 decodingMap</span><br><span class="line">// 在 vuejs 中，如果输入带 script 标签的内容，会直接过滤掉</span><br><span class="line">const decodingMap = &#123;</span><br><span class="line">  &apos;&amp;lt;&apos;: &apos;&lt;&apos;,</span><br><span class="line">  &apos;&amp;gt;&apos;: &apos;&gt;&apos;,</span><br><span class="line">  &apos;&amp;quot;&apos;: &apos;&quot;&apos;,</span><br><span class="line">  &apos;&amp;amp;&apos;: &apos;&amp;&apos;,</span><br><span class="line">  &apos;&apos;: &apos;\n&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出检查</strong></p>
<hr>
<p>用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。</p>
<h3 id="csrf"><a href="#csrf" class="headerlink" title="csrf"></a>csrf</h3><p>CSRF，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。</p>
<p>通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。Cookie 主要用于以下方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
</ul>
<p>而浏览器所持有的 Cookie 分为两种：</p>
<ul>
<li>Session Cookie(会话期 Cookie)：会话期 Cookie 是最简单的Cookie，它不需要指定过期时间（Expires）或者有效期（Max-Age），它仅在会话期内有效，浏览器关闭之后它会被自动删除。</li>
<li>Permanent Cookie(持久性 Cookie)：与会话期 Cookie 不同的是，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。</li>
</ul>
<blockquote>
<p>res.setHeader(‘Set-Cookie’, [‘mycookie=222’, ‘test=3333; expires=Sat, 21 Jul 2018 00:00:00 GMT;’]);</p>
</blockquote>
<p>上述代码创建了两个 Cookie：mycookie 和 test，前者属于会话期 Cookie，后者则属于持久性 Cookie。当我们去查看 Cookie 相关的属性时，不同的浏览器对会话期 Cookie 的 Expires 属性值会不一样：</p>
<p>此外，每个 Cookie 都会有与之关联的域，这个域的范围一般通过 donmain 属性指定。如果 Cookie 的域和页面的域相同，那么我们称这个 Cookie 为第一方 Cookie（first-party cookie），如果 Cookie 的域和页面的域不同，则称之为第三方 Cookie（third-party cookie）。一个页面包含图片或存放在其他域上的资源（如图片）时，第一方的 Cookie 也只会发送给设置它们的服务器。</p>
<p><strong>通过 Cookie 进行 CSRF 攻击</strong></p>
<p>假设有一个 bbs 站点：<a href="http://www.c.com，当登录后的用户发起如下" target="_blank" rel="noopener">http://www.c.com，当登录后的用户发起如下</a> GET 请求时，会删除 ID 指定的帖子：</p>
<blockquote>
<p><a href="http://www.c.com:8002/content/delete/:id" target="_blank" rel="noopener">http://www.c.com:8002/content/delete/:id</a></p>
</blockquote>
<p>如发起 <a href="http://www.c.com:8002/content/delete/87343" target="_blank" rel="noopener">http://www.c.com:8002/content/delete/87343</a> 请求时，会删除 id 为 87343 的帖子。当用户登录之后，会设置如下 cookie：</p>
<blockquote>
<p>res.setHeader(‘Set-Cookie’, [‘user=22333; expires=Sat, 21 Jul 2018 00:00:00 GMT;’]);</p>
</blockquote>
<p>user 对应的值是用户 ID。然后构造一个页面 A：</p>
<p>CSRF 攻击者准备的网站：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;CSRF 攻击者准备的网站：&lt;/p&gt;</span><br><span class="line">&lt;img src=&quot;http://www.c.com:8002/content/delete/87343&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>页面 A 使用了一个 img 标签，其地址指向了删除用户帖子的链接：</p>
<p>可以看到，当登录用户访问攻击者的网站时，会向 www.c.com 发起一个删除用户帖子的请求。此时若用户在切换到 www.c.com 的帖子页面刷新，会发现ID 为 87343 的帖子已经被删除。</p>
<p>由于 Cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起 CSRF 攻击。在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。因此，攻击者无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。</p>
<p>但若 CSRF 攻击的目标并不需要使用 Cookie，则也不必顾虑浏览器的 Cookie 策略了。</p>
<p><strong>CSRF 攻击的防范</strong></p>
<hr>
<p>当前，对 CSRF 攻击的防范措施主要有如下几种方式。</p>
<p><strong>验证码</strong></p>
<p>验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。</p>
<p>从上述示例中可以看出，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。</p>
<p>但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。</p>
<p><strong>Referer Check</strong></p>
<p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的”源”。</p>
<p>比如，如果用户要删除自己的帖子，那么先要登录 www.c.com，然后找到对应的页面，发起删除帖子的请求。此时，Referer 的值是 <a href="http://www.c.com；当请求是从" target="_blank" rel="noopener">http://www.c.com；当请求是从</a> www.a.com 发起时，Referer 的值是 <a href="http://www.a.com" target="_blank" rel="noopener">http://www.a.com</a> 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 www.c.com 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。</p>
<p>针对上文的例子，可以在服务端增加如下代码：</p>
<blockquote>
<p>if (req.headers.referer !== ‘<a href="http://www.c.com:8002/" target="_blank" rel="noopener">http://www.c.com:8002/</a>‘) {</p>
<p>​    res.write(‘csrf 攻击’);</p>
<p>​    return;</p>
<p>}</p>
</blockquote>
<p>Referer Check 不仅能防范 CSRF 攻击，另一个应用场景是 “防止图片盗链”。</p>
<p><strong>添加 token 验证</strong></p>
<hr>
<p>CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<p><strong>总结</strong></p>
<hr>
<p>本文主要介绍了 XSS 和 CSRF 的攻击原理和防御措施。当然，在 Web 安全领域，除了这两种常见的攻击方式，也存在这 SQL 注入等其它攻击方式，如果你对其感兴趣，可以阅读SQL注入技术专题的专栏详细了解相关信息。最后，总结一下 XSS 攻击和 CSRF 攻击的常见防御措施：</p>
<ol>
<li><p>防御 XSS 攻击</p>
</li>
<li><ol>
<li>HttpOnly 防止劫取 Cookie</li>
<li>用户的输入检查</li>
<li>服务端的输出检查</li>
</ol>
</li>
<li><p>防御 CSRF 攻击</p>
</li>
<li><ol>
<li>验证码</li>
<li>Referer Check</li>
<li>Token 验证</li>
</ol>
</li>
</ol>
<p>参考链接：<a href="https://github.com/dwqs/blog/issues/68" target="_blank" rel="noopener">https://github.com/dwqs/blog/issues/68</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/xss、csrf/">xss、csrf</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-jest-chuji" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/15/jest-chuji/" class="article-date">
  	<time datetime="2018-06-15T06:12:39.000Z" itemprop="datePublished">2018-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/15/jest-chuji/">
        jest单元测试学习记录
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://jestjs.io/docs/zh-Hans/getting-started" target="_blank" rel="noopener">jest</a>是Facebook开发的一个对javascript进行单元测试的工具，使用了大家熟知的expect(value).toBe(xx)这种断言格式</p>
<h3 id="GET-START"><a href="#GET-START" class="headerlink" title="GET START"></a>GET START</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过 npm 安装</span><br><span class="line">npm install jest --save-dev</span><br></pre></td></tr></table></figure>
<p>编写一个待测试的sum.test.js文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function sum(a,b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = sum;</span><br><span class="line">//注意测试文件后缀名需要为xx.test.js</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const sum=require(&apos;./sum&apos;)</span><br><span class="line">test(&apos;1加2等于3&apos;，()=&gt;&#123;</span><br><span class="line">    expect(sum(1,2).toBe(3));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>接下来在package.json文件里添加测试脚本命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts:&quot;&#123;</span><br><span class="line">    &quot;test&quot;:&quot;jest&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后运行npm test 命令后jest将会打印通过还是没有通过，还有具体的执行时间，是不是很简单哈。</p>
<h3 id="Using-Matchers"><a href="#Using-Matchers" class="headerlink" title="Using Matchers"></a>Using Matchers</h3><p>Jest 使用matchers来使用不同的方式测试你的结果</p>
<h3 id="Common-Matchers"><a href="#Common-Matchers" class="headerlink" title="Common Matchers"></a>Common Matchers</h3><p><code>toBe</code>使用 <code>===</code> 来测试全等于，如果我们想检查一个对象<code>object</code>中的值，使用<code>toEqual</code>来替代，<code>toEqual</code>递归遍历检查对象或数组里的每一个领域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(&apos;object assigenment&apos;, ()=&gt; &#123;</span><br><span class="line">    let data = &#123; one: 1&#125;;</span><br><span class="line">    data[&apos;two&apos;] = 2;</span><br><span class="line">    expect(data).toEqual(&#123; one: 1, two: 2 &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用<code>not</code>可以测试一个<code>matchers</code>的反向规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(&apos;this number is not zero&apos;,()=&gt;&#123;</span><br><span class="line">    for(let a=1;a&lt;10;a++)&#123;</span><br><span class="line">        expect(a+2).not.toBe(0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Truthiness"><a href="#Truthiness" class="headerlink" title="Truthiness"></a>Truthiness</h3><p>测试的时候，有时候需要对undefined/null/false进行区别，jest的使用方法如下：</p>
<ul>
<li><code>toBeNull</code> 检查是否为null</li>
<li><code>toBeUndefined</code> 检查是否为undefined</li>
<li><code>toBeDefined</code> 与<code>toBeUndefined</code>的相反</li>
<li><code>toBeTruthy</code> 检查任何通过<code>if</code>显示转换是否为true</li>
<li><code>toBeFalsy</code> 检查任何通过<code>if</code>显示转换是否为false</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">test(&apos;null&apos;, () =&gt; &#123;</span><br><span class="line">    let n = null;</span><br><span class="line">      expect(n).toBeNull();</span><br><span class="line">      expect(n).toBeDefined();</span><br><span class="line">      expect(n).not.toBeUndefined();</span><br><span class="line">      expect(n).not.toBeTruthy();</span><br><span class="line">      expect(n).toBeFalsy();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(&apos;zero&apos;, () =&gt; &#123;</span><br><span class="line">      let z = 0;</span><br><span class="line">      expect(z).not.toBeNull();</span><br><span class="line">      expect(z).toBeDefined();</span><br><span class="line">      expect(z).not.toBeUndefined();</span><br><span class="line">      expect(z).not.toBeTruthy();</span><br><span class="line">      expect(z).toBeFalsy();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>比较数字的大多数方法都有其对应的matchers</p>
<ul>
<li><code>toBeGreaterThan</code> 大于</li>
<li><code>toBeGreaterThanOrEqual</code> 大于等于</li>
<li><code>toBeLessThan</code> 小于</li>
<li><code>toBeLessThanOrEqual</code> 小于等于</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test(&apos;two plus two&apos;, () =&gt; &#123;</span><br><span class="line">    let value = 2 + 2;</span><br><span class="line">    expect(value).toBeGreaterThan(3);</span><br><span class="line">    expect(value).toBeGreaterThanOrEqual(3.5);</span><br><span class="line">    expect(value).toBeLessThan(5);</span><br><span class="line">    expect(value).toBeLessThanOrEqual(4.5);</span><br><span class="line"></span><br><span class="line">    // toBe and toEqual 对于number类型作用是一样的</span><br><span class="line">    expect(value).toBe(4);</span><br><span class="line">    expect(value).toEqual(4);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>对于浮点数的测试，使用<code>toBeCloseTo</code>来替代<code>toEqual</code>，因为我们不会让一个测试依赖于一个微小的舍入型错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(&apos;adding floating point numbers&apos;, () =&gt; &#123;</span><br><span class="line">    let value = 0.1 + 0.2;</span><br><span class="line">    expect(value).not.toBe(0.3);    // error</span><br><span class="line">    expect(value).toBeCloseTo(0.3); // correct</span><br><span class="line">&#125;);</span><br><span class="line">//说明：js中对浮点数的加减乘除计算都不准确，大家注意哦。</span><br></pre></td></tr></table></figure>
<h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><p>使用<code>toMatch</code>对字符串进行正则表达式匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test(&apos;there is no I in team&apos;, () =&gt; &#123;</span><br><span class="line">    expect(&apos;team&apos;).not.toMatch(/I/);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(&apos;but there is a &quot;stop&quot; in Christoph&apos;, () =&gt; &#123;</span><br><span class="line">    expect(&apos;Christoph&apos;).toMatch(/stop/);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>使用<code>toContain</code>对数组内的特定项进行匹配测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let shoppingList = [&apos;diapers&apos;, &apos;kleenex&apos;, &apos;trash bags&apos;, &apos;paper towels&apos;, &apos;beer&apos;];</span><br><span class="line"></span><br><span class="line">test(&apos;the shopping list has beer on it&apos;, () =&gt; &#123;</span><br><span class="line">    expect(shoppingList).toContain(&apos;beer&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h3><p>使用<code>toThrow</code>对一个特定函数调用时候抛出的错误进行测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function compileAndroidCode() &#123;</span><br><span class="line">    throw new ConfigError(&apos;you are using the wrong JDK&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(&apos;compiling android goes as expected&apos;, () =&gt; &#123;</span><br><span class="line">    expect(compileAndroidCode).toThrow();</span><br><span class="line">    expect(compileAndroidCode).toThrow(ConfigError);</span><br><span class="line"></span><br><span class="line">    // You can also use the exact error message or a regexp</span><br><span class="line">    expect(compileAndroidCode).toThrow(&apos;you are using the wrong JDK&apos;);</span><br><span class="line">    expect(compileAndroidCode).toThrow(/JDK/);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Testing-Asynchronous-Code"><a href="#Testing-Asynchronous-Code" class="headerlink" title="Testing Asynchronous Code"></a>Testing Asynchronous Code</h2><p>在javascript程序中，会经常见到一些异步执行的代码，当我们有这些异步执行的代码时，<strong>Jest</strong>需要知道当前这个代码测试是否已经完成，然后才能转向另一个测试。<strong>Jest</strong>提供了一些方法来处理这种问题。</p>
<h3 id="Callbacks"><a href="#Callbacks" class="headerlink" title="Callbacks"></a>Callbacks</h3><p>最常用的异步测试模式便是<strong>callbacks</strong></p>
<p>列如，我们有一个<code>fetchData(callback)</code>方法，当<code>callback(data)</code>方法调用的时候，我们会获取一些<code>data</code>数据，并且想测试返回的数据是否只是一个字符串<code>ywx</code>。</p>
<p>默认情况下下，<strong>Jest</strong>在所有的代码执行完之后便会完成测试，这意味这些测试不再会按计划的工作下去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// error</span><br><span class="line">test(&apos;the data is ywx&apos;, () =&gt; &#123;</span><br><span class="line">    function callback(data) &#123;</span><br><span class="line">        expect(data).toBe(&apos;ywx&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    fetchData(callback);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>问题是，测试希望一旦<code>fatchData</code>成功后才能完成，并在其之前调用回调。</p>
<p>这里有另一种形式修复这个测试的问题，在这个测试方法里使用一个参数为<code>done</code>的回调参数，而不是放置一个空参数，<strong>Jest</strong>要等到<code>done</code>被调用后才会结束此次测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(&apos;the data is ywx&apos;, done =&gt; &#123;</span><br><span class="line">    function callback(data) &#123;</span><br><span class="line">        expect(data).toBe(&apos;ywx&apos;);</span><br><span class="line">        done();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fetchData(callback);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果<code>done()</code>没被调用，测试即失败了，这时候我们也会得到我们想要的错误结果了。</p>
<h3 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h3><p>如果我们的代码中使用到了<code>Promises</code>，这里有一个简单的异步测试处理方法。只是我们的测试中返回一个<code>promise</code>，并且<strong>Jest</strong>会等待这个promise解析完成，如果rejected了，这个测试便会自动视为失败。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(&apos;the data is ywx&apos;, () =&gt; &#123;</span><br><span class="line">    return fetchData().then(data =&gt; &#123;//一定要return</span><br><span class="line">        expect(data).toBe(&apos;ywx&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">注：一定要确保返回了Promise，如果省略了这步，你的测试将会在fetchData完成之前首先结束掉。</span><br></pre></td></tr></table></figure>
<h3 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h3><p>如果代码中使用到<code>async</code>和<code>await</code>，可以这样做。编写一个异步测试，仅需要在测试方法前面使用<code>async</code>关键词，然后传递给测试函数即可。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(&apos;the data is ywx&apos;, async () =&gt; &#123;</span><br><span class="line">    const data = await fetchData();</span><br><span class="line">    expect(data).toBe(&apos;ywx&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">//async和await等同于promises方法的一种语法糖实现方式。</span><br></pre></td></tr></table></figure>
<h3 id="测试的生命周期"><a href="#测试的生命周期" class="headerlink" title="测试的生命周期"></a>测试的生命周期</h3><p>jest 测试提供了一些测试的生命周期 API，可以辅助我们在每个 case 的开始和结束做一些处理。 这样，在进行一些和数据相关的测试时，可以在测试前准备一些数据，在测试后，清理测试数据。</p>
<p>4 个主要的生命周期函数：</p>
<ul>
<li>afterAll(fn, timeout): 当前文件中的所有测试执行完成后执行 fn, 如果 fn 是 promise，jest 会等待 timeout 毫秒，默认 5000</li>
<li>afterEach(fn, timeout): 每个 test 执行完后执行 fn，timeout 含义同上</li>
<li>beforeAll(fn, timeout): 同 afterAll，不同之处在于在所有测试开始前执行</li>
<li>beforeEach(fn, timeout): 同 afterEach，不同之处在于在每个测试开始前执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BeforeAll(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;before all tests to excute !&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">BeforeEach(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;before each test !&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">AfterAll(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;after all tests to excute !&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">AfterEach(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;after each test !&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Test(&apos;test add1&apos;, () =&gt; &#123;</span><br><span class="line">  expect(1 + 2).toBe(3)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Test(&apos;test add2&apos;, () =&gt; &#123;</span><br><span class="line">  expect(2 + 2).toBe(4)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>jest除了能测试js，还能测试react component,强大功能后续补充。。。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jest/">jest</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Promise" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/15/Promise/" class="article-date">
  	<time datetime="2018-05-15T06:12:39.000Z" itemprop="datePublished">2018-05-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/15/Promise/">
        promise学习笔记
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是promise"><a href="#什么是promise" class="headerlink" title="什么是promise"></a>什么是promise</h3><p>Promise 是异步编程的一种解决方案，它有三种状态，分别是pending(进行中)、</p>
<p>resolved(已完成)、rejected(已失败)。</p>
<p>当Promsie的状态由pending转变成resolved或rejected时，会执行相应的方法，并且状态一旦改变，就无法再次改变状态，这也是Promise-承诺名字的由来。</p>
<h3 id="ES6之前的promise"><a href="#ES6之前的promise" class="headerlink" title="ES6之前的promise"></a>ES6之前的promise</h3><p>使用较为成熟的第三方promise库—<a href="http://bluebirdjs.com/docs/getting-started.html" target="_blank" rel="noopener">Bluebird</a>,它是实现promise标准库功能最全、速度最快的一个库。</p>
<p>经典使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Promise = require(&apos;./bluebird&apos;);</span><br><span class="line"></span><br><span class="line">var readFile = Promise.promisify(require(&quot;fs&quot;).readFile);</span><br><span class="line">readFile(&quot;1.txt&quot;, &quot;utf8&quot;).then(function(contents) &#123;</span><br><span class="line">    console.log(contents);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var fs = Promise.promisifyAll(require(&quot;fs&quot;));</span><br><span class="line"></span><br><span class="line">fs.readFileAsync(&quot;1.txt&quot;, &quot;utf8&quot;).then(function (contents) &#123;</span><br><span class="line">    console.log(contents);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="ES6的promise-基本使用方法"><a href="#ES6的promise-基本使用方法" class="headerlink" title="ES6的promise 基本使用方法"></a>ES6的promise 基本使用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let promise=new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    if(success)&#123;</span><br><span class="line">        resolve(successData)//pending=&gt;resolved,参数传递给对应的回调方法</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        reject(failData) //pending=&gt;rejected,参数传递给对应的回调方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">注：实例化的Promsie对象会立即执行。</span><br></pre></td></tr></table></figure>
<h3 id="then-和catch-方法"><a href="#then-和catch-方法" class="headerlink" title="then()和catch()方法"></a>then()和catch()方法</h3><p>Promise.prototype.then()是Promise原型链上的方法，它有两个参数(都是函数)，分别对应resolved的回调和rejected的回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">    (successData) =&gt; &#123; console.log(&apos;我是成功的回调参数是successData&apos;) &#125;,</span><br><span class="line">    (failData) =&gt; &#123; console.log(&apos;我是失败的回调参数是failData&apos;) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>.catch()也是原型链上的方法，作用是捕获Promise的错误，与then()的rejected回调作用几乎一致。但是由于Promise的抛错具有冒泡性质，能够不断传递，这样就能够在下一个catch()中统一处理这些错误。同时catch()也能够捕获then()中抛出的错误，所以建议不要使用then()的rejected回调，而是统一使用catch()来处理错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">    () =&gt; &#123; console.log(&apos;this is success callback&apos;) &#125;</span><br><span class="line">).catch(</span><br><span class="line">    (err) =&gt; &#123; console.log(err) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>同样，catch()中也可以抛出错误，由于抛出的错误会在下一个catch中被捕获处理，因此可以再添加catch()；</p>
<p>当状态已经改变为resolved后，即使抛出错误，也不会触发then()的错误回调或者catch()方法；</p>
<p>then() 和 catch() 都会返回一个新的Promise对象，可以链式调用；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">    () =&gt; &#123; console.log(&apos;this is success callback&apos;) &#125;</span><br><span class="line">).catch(</span><br><span class="line">    (err) =&gt; &#123; console.log(err) &#125;</span><br><span class="line">).then(</span><br><span class="line">    ...</span><br><span class="line">).catch(</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="Promise实例的异步方法和then-中返回promise有什么区别？"><a href="#Promise实例的异步方法和then-中返回promise有什么区别？" class="headerlink" title="Promise实例的异步方法和then()中返回promise有什么区别？"></a>Promise实例的异步方法和then()中返回promise有什么区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// p1异步方法中返回p2</span><br><span class="line">let p1 = new Promise ( (resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(p2)</span><br><span class="line">&#125; )</span><br><span class="line">let p2 = new Promise ( ... )</span><br><span class="line"></span><br><span class="line">// then()中返回promise</span><br><span class="line">let p3 = new Promise ( (resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125; )</span><br><span class="line">let p4 = new Promise ( ... )</span><br><span class="line">p3.then(</span><br><span class="line">    () =&gt; return p4</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>p1异步方法中返回p2</strong></p>
<p>p1的状态取决于p2，如果p2为pending，p1将等待p2状态的改变，p2的状态一旦改变，p1将会立即执行自己对应的回调，即then()中的方法针对的依然是p1</p>
<p><strong>then()中返回promise</strong></p>
<p>由于then()本身就会返回一个新的promise，所以后一个then()针对的永远是一个新的promise，但是像上面代码中我们自己手动返回p4，那么我们就可以在返回的promise中再次通过 resolve() 和 reject() 来改变状态</p>
<h3 id="Promise-resolve-和Promise-reject"><a href="#Promise-resolve-和Promise-reject" class="headerlink" title="Promise.resolve()和Promise.reject()"></a>Promise.resolve()和Promise.reject()</h3><p>用来包装一个现有对象，将其转变为Promise对象，但Promise.resolve()会根据参数情况返回不同的Promise：</p>
<p><strong>参数是Promise</strong>：原样返回<br><strong>参数带有then方法</strong>：转换为Promise后立即执行then方法<br><strong>参数不带then方法、不是对象或没有参数</strong>：返回resolved状态的Promise</p>
<p>Promise.reject()会直接返回rejected状态的Promise;</p>
<h3 id="其他api"><a href="#其他api" class="headerlink" title="其他api"></a>其他api</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([promise1,promise2,promise3,promise4....])</span><br><span class="line">Promise.race([promise1,promise2,promise3,promise4....])</span><br><span class="line">Promise.done()/Promise.finally()</span><br><span class="line">//上述这几个api根据api名字自己脑补吧，娃哈哈。。。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//学完了练一练</span><br><span class="line">一、const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    resolve()</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(() =&gt; &#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">&#125;)</span><br><span class="line">    console.log(4)</span><br><span class="line">Promise构造函数里中的代码是同步执行的，但是then方法是异步方法，then方法需要等到resolve函数执行时才能执行，所以结果是1、2、4、3.</span><br><span class="line"></span><br><span class="line">二、Promise.resolve(1).then(res=&gt;&#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return 2;</span><br><span class="line">&#125;).catch(err=&gt;&#123;</span><br><span class="line">    return 3;</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">resolve(1)首先会执行第一个then函数，输出1.然后在函数中返回2，因为resolve是成功的状态，所以后面的catch不会执行，而是直接执行第二个then函数，输出2.所以结果是1、2.</span><br></pre></td></tr></table></figure>
<h3 id="Promise原理"><a href="#Promise原理" class="headerlink" title="Promise原理"></a>Promise原理</h3><p>在Promise的内部有一个状态管理器，它有三种状态：pending/fulfilled/rejected</p>
<p>1、promise对象初始化状态为pending。(new Promise时)</p>
<p>2、当调用resolve(data),状态pending=&gt;fulfilled</p>
<p>3、当调用resolve(err),状态pending=&gt;rejected</p>
<p>状态由pending变fulfilled/rejected时，一旦状态变了就不能再改变了。当状态变为fulfilled时，then的成功回调函数会被调用，并接收传来的参数data，进而进行操作，rejected则反之。promise.then方法每次执行完后，都会返回一个新的promise对象所以可以链式调用(不管是resolve还是reject).</p>
<p>举个例子来模拟Promise:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var fs=require(&apos;fs&apos;);</span><br><span class="line">var Promise = require(&apos;./Promise.js&apos;);</span><br><span class="line">var promise = new Promise(function (resolve,reject) &#123;</span><br><span class="line">    fs.readFile(&apos;1.txt&apos;,&apos;utf-8&apos;,function (err,data) &#123;</span><br><span class="line">        if(err)&#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(function (data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;,function (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>用es5来模拟Promise</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn) &#123;</span><br><span class="line">   fn((data)=&gt;&#123;</span><br><span class="line">       this._success(data);</span><br><span class="line">   &#125;,(error)=&gt;&#123;</span><br><span class="line">       this._error(error);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">Promise.prototype.then=function (onFul,onFail) &#123;</span><br><span class="line">    this._success=onFull;//</span><br><span class="line">    this._error=onFail;</span><br><span class="line">&#125;;</span><br><span class="line">Promise.prototype.resolve=function (data) &#123;</span><br><span class="line">    this._success(data);</span><br><span class="line">&#125;;</span><br><span class="line">Promise.prototype.reject=function (error) &#123;</span><br><span class="line">    this._error(error);</span><br><span class="line">&#125;;</span><br><span class="line">module.exports=Promise;</span><br></pre></td></tr></table></figure>
<p>es6来模拟Promise</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class promise &#123;</span><br><span class="line">    constructor(fn)&#123;</span><br><span class="line">        fn((data)=&gt;&#123;</span><br><span class="line">            this._success(data);</span><br><span class="line">        &#125;,(error)=&gt;&#123;</span><br><span class="line">            this._error(error);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(data)&#123;</span><br><span class="line">        this._success(data);</span><br><span class="line">    &#125;</span><br><span class="line">    reject(err)&#123;</span><br><span class="line">        this._error(err)</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFul,onFail)&#123;</span><br><span class="line">        this._success=onFul;</span><br><span class="line">        this._error=onFail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/promise、es6/">promise、es6</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2018 前端在路上
      </div>
        <div class="footer-right">
          <a href="http://webywx.com/" target="_blank">webywx</a>  Theme <a href="https://yanwenxi.site" target="_blank">前端在路上</a> by Scorpio
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>